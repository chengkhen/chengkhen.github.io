<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关系代数</title>
    <link href="/2023/03/07/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    <url>/2023/03/07/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<ul><li>关系代数是一种抽象的查询语言，是对关系的运算来表达查询</li><li>关系代数的运算对象是关系，运算结果也是关系</li><li>关系代数按运算符的不同可分为传统的集合运算和专门的关系运算两类</li><li>集合运算是从关系的水平方向即行的角度进行</li><li>专门的关系运算不仅涉及行还涉及列</li></ul><p>集合运算有：并、交、差、笛卡尔积</p><p>专门的关系运算有：选择、投影、连接、除</p><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ul><li><p>交、并、差，运算的条件是：两个关系具有相同的目n（即两个关系都有n个属性），相应的属性取自同一个域</p></li><li><p>笛卡尔积</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303072240800.png" alt="image-20230307224035710"></p><h2 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h2><h3 id="相关记号说明"><a href="#相关记号说明" class="headerlink" title="相关记号说明"></a>相关记号说明</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303072245600.png" alt="image-20230307224533403"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303072249953.png" alt="image-20230307224922886"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303072251143.png" alt="image-20230307225127084"></p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303072254823.png" alt="image-20230307225410768"></p><p>其中$&#x2F;theta$表示比较运算符，可以是大于、小于等等，X1,Y1是属性名或为常量或为简单函数</p>]]></content>
    
    
    <categories>
      
      <category>关系数据库</category>
      
      <category>数据库系统概论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统概论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统概述复习</title>
    <link href="/2023/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="#%E7%AC%AC1%E7%AB%A0%20%E6%A6%82%E8%BF%B0">第1章 概述</a></p><p><a href="#1.1%20DBS%E6%A6%82%E8%BF%B0">1.1 DBS概述</a></p><p><a href="#1.1.1%20%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.1.1 四个基本概念</a></p><p><a href="#1.1.2%20%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5">1.1.1 1.1.2 数据管理的三个阶段</a></p><p><a href="#1.1.3%20DBS%E7%9A%84%E7%89%B9%E7%82%B9">1.1.3 DBS的特点</a></p><p><a href="#1.2%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2 数据模型</a></p><p><a href="#1.2.1%20%E4%B8%A4%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2.1 两类数据模型</a></p><p><a href="#1.2.2%20%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B">1.2.2 概念模型</a></p><p><a href="#1.2.3%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0">1.2.3 数据模型的组成要素</a></p><p><a href="#1.2.4%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2.4 常用的数据模型</a></p><p><a href="#1.2.7%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B">1.2.7 关系模型</a></p><p><a href="#1.3%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84">1.3 数据库系统的结构</a></p><p><a href="#1.3.1%20DBS%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5">1.3.1 DBS模式的概念</a></p><p><a href="#1.3.2%20DBS%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84">1.3.2 DBS的三级模式结构</a></p><p><a href="#1.3.3%20DB%E7%9A%84%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%83%8F%E5%8A%9F%E8%83%BD%E5%92%8C%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7">1.3.3 DB的二级映像功能和数据独立性</a></p><p><a href="#%E7%AC%AC2%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">第2章 关系数据库</a></p><p><a href="#2.1%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89">2.1 关系数据结构及形式化定义</a></p><p><a href="#2.1.1%20%E5%85%B3%E7%B3%BB">2.1.1 关系</a></p><p><a href="#2.1.2%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F">2.1.2 关系模式</a></p><p><a href="#2.2%20%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C">2.2 关系操作</a></p><p><a href="#2.3%20%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">2.3 关系的完整性</a></p><p><a href="#2.3.1%20%E5%AE%9E%E4%BD%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.1 实体的完整性</a></p><p><a href="#2.3.2%20%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.2 参照完整性</a></p><p><a href="#2.3.3%20%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.3 用户定义完整性</a></p><p><a href="#2.4%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0">2.4 关系代数</a></p><p><a href="#2.4.1%20%E4%BC%A0%E7%BB%9F%E7%9A%84%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97">2.4.1 传统的集合运算</a></p><p><a href="#2.4.2%20%E4%B8%93%E9%97%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97">2.4.2 专门的关系运算</a></p><p><a href="#%E7%AC%AC3%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL">第3章 关系型数据库标准语言SQL</a></p><p><a href="#3.1%20SQL%E6%A6%82%E8%BF%B0">3.1 SQL概述</a></p><p><a href="#3.1.3%20SQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5P78">3.1.3 SQL的基本概念P78</a></p><p><a href="#3.3%20%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89">3.3 数据定义</a></p><p><a href="#3.3.1%20%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%A0%E9%99%A4">3.3.1 模式的定义和删除</a></p><p><a href="#3.3.2%20%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9">3.3.2 基本表的定义、删除与修改</a></p><p><a href="#3.3.3%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E5%88%A0%E9%99%A4">3.3.3 索引的建立与删除</a></p><p><a href="#3.4%20%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2">3.4 数据查询</a></p><p><a href="#3.4.1%20%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2">3.4.1 单表查询</a></p><p><a href="#3.4.2%20%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2">3.4.2 连接查询</a></p><p><a href="#3.4.3%20%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2">3.4.3 嵌套查询（nested query）凸显结构化</a></p><p><a href="#3.4.4%20%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2">3.4.4 集合查询</a></p><p><a href="#3.4.5%20%E5%9F%BA%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2">3.4.5 基于派生表的查询</a></p><p><a href="#3.4.6%20select%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F">3.4.6 select语句的一般格式</a></p><p><a href="#3.5%20%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0">3.5 数据更新</a></p><p><a href="#3.5.1%20%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">3.5.1 插入数据</a></p><p><a href="#3.5.2%20%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE">3.5.2 修改数据</a></p><p><a href="#3.5.3%20%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">3.5.3 删除数据</a></p><p><a href="#3.6%20%E7%A9%BA%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86">3.6 空值的处理</a></p><p><a href="#3.7%20%E8%A7%86%E5%9B%BE">3.7 视图</a></p><p><a href="#3.7.1%20%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE">3.7.1 定义视图</a></p><p><a href="#3.7.2%20%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE">3.7.2 查询视图</a></p><p><a href="#3.7.3%20%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE">3.7.3 更新视图</a></p><p><a href="#3.7.4%20%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8">3.7.4 视图的作用</a></p><p><a href="#%E7%AC%AC4%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7">第4章 数据库安全性</a></p><p><a href="#4.2%20DB%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6">4.2 DB安全性控制</a></p><p><a href="#4.2.1%20%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E5%88%AB">4.2.1 用户身份鉴别</a></p><p><a href="#4.2.2%20%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">4.2.2 存取控制</a></p><p><a href="#4.2.3%20%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95">4.2.3 自主存取控制方法</a></p><p><a href="#4.2.4%20%E6%8E%88%E6%9D%83%EF%BC%9A%E6%8E%88%E4%BA%88%E4%B8%8E%E6%94%B6%E5%9B%9E">4.2.4 授权：授予与收回</a></p><p><a href="#%E7%AC%AC5%E7%AB%A0">第5章</a></p><p><a href="#5.3%20%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">5.3 用户定义的完整性</a></p><p><a href="#5.3.1%20%E5%B1%9E%E6%80%A7%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6(P163)">5.3.1 属性上的约束条件(P163)</a></p><p><a href="#5.3.2%20%E5%85%83%E7%BB%84%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89">5.3.2 元组上的约束条件的定义</a></p><p><a href="#%E7%AC%AC7%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1">第7章 数据库设计</a></p><p><a href="#7.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0">7.1 数据库设计概述</a></p><p><a href="#7.1.3%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">7.1.3 数据库设计基本步骤</a></p><p><a href="#7.3%20%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">7.3 概念结构设计</a></p><p><a href="#7.4%20%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">7.4 逻辑结构设计</a></p><p><a href="#7.4.1%20ER%E5%9B%BE%E5%90%91%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2">7.4.1 ER图向关系模型的转换</a></p><p><a href="#7.6%20DB%E7%9A%84%E5%AE%9E%E6%96%BD%E5%92%8C%E7%BB%B4%E6%8A%A4">7.6 DB的实施和维护</a></p><p><a href="#7.6.1%20%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E8%AF%95">7.6.1 数据载入和应用程序的调试</a></p><p><a href="#%E7%AC%AC9%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">第9章 关系查询处理和查询优化</a></p><p><a href="#9.1%20%E5%85%B3%E7%B3%BBDBS%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86">9.1 关系DBS的查询处理</a></p><p><a href="#1.%20%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90">1. 查询分析</a></p><p><a href="#2.%20%E6%9F%A5%E8%AF%A2%E6%A3%80%E6%9F%A5">2. 查询检查</a></p><p><a href="#3.%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">3. 查询优化</a></p><p><a href="#4.%20%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C">4. 查询执行</a></p><p><a href="#9.2%20%E5%85%B3%E7%B3%BBDBS%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">9.2 关系DBS的查询优化</a></p><p><a href="#9.2.1%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0">9.2.1 查询优化概述</a></p><p><a href="#9.3%20%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96">9.3 代数优化</a></p><p><a href="#9.3.2%20%E6%9F%A5%E8%AF%A2%E6%A0%91%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E4%BC%98%E5%8C%96">9.3.2 查询树的启发式优化</a></p><p><a href="#%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF">第10章 数据库恢复技术</a></p><p><a href="#10.1%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">10.1 事务的基本概念</a></p><p><a href="#1.%E4%BA%8B%E5%8A%A1">1.事务</a></p><p><a href="#2.%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7">2.事务的ACID特性</a></p><p><a href="#10.3%20%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB">10.3 故障的种类</a></p><p><a href="#1.%20%E4%BA%8B%E5%8A%A1%E5%86%85%E9%83%A8%E7%9A%84%E6%95%85%E9%9A%9C">1. 事务内部的故障</a></p><p><a href="#2.%20%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C">2. 系统故障</a></p><p><a href="#3.%20%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C">3. 介质故障</a></p><p><a href="#4.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">4. 计算机病毒</a></p><p><a href="#10.4%20%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF">10.4 恢复的实现技术</a></p><p><a href="#10.4.2%20%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">10.4.2 日志文件</a></p><p><a href="#%E8%AF%95%E9%A2%98:">试题:</a></p><hr><h1 id="第1章 概述">第1章 概述</h1><h2 id="1.1 DBS概述">1.1 DBS概述</h2><h3 id="1.1.1 四个基本概念">1.1.1 四个基本概念</h3><p>数据data：描述事物的<strong>符号记录</strong>。<br>数据库DB：长期存储在计算机内的、有组织的、可共享的大量数据集合。<br>数据库管理系统DBMS：是位于用户与操作系统之间的具有数据定义、数据操纵、数据库的运行管理、数据库的建立和维护功能的一层数据管理软件。<br>数据库系统DBS：在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员<strong>DBA</strong>和用户构成。<br>DDL：数据定义语言(Data Definition Launguage)。<br>DML：数据操纵语言(Data Manipulation Launguage)。  </p><h3 id="1.1.2 数据管理的三个阶段">1.1.2 数据管理的三个阶段</h3><table><thead><tr><th></th><th>人工管理阶段</th><th>文件系统阶段</th><th>数据库系统阶段</th></tr></thead><tbody><tr><td>处理方式</td><td>批处理</td><td>联机实时处理，批处理</td><td>有数据库管理系统</td></tr><tr><td>面向对象</td><td>某一个应用程序</td><td>某一个应用</td><td>现实世界</td></tr><tr><td>数据共享程度</td><td>无共享，冗余度极大</td><td>共享性差，冗余度大</td><td>共享性高，冗余度小</td></tr><tr><td>独立性</td><td>不独立，完全依赖程序</td><td>独立性差</td><td>具有高度的物理独立性和一定的逻辑独立性</td></tr></tbody></table><h3 id="1.1.3 DBS的特点">1.1.3 DBS的特点</h3><p>1. <strong>数据结构化</strong></p><p>2. 数据<strong>共享性高</strong>、冗余度低<strong>且易扩充</strong></p><p>3. 数据独立性高</p><blockquote><p>物理独立性：应用程序与数据库中<strong>数据的物理存储</strong>是相互独立的</p><p>逻辑独立性：应用程序与<strong>数据库的逻辑结构</strong>是相互独立的，数据的逻辑结构改变时用户程序可以不变  </p><p>数据的独立性是由<strong>二级映像决定的</strong></p></blockquote><p>4. 数据由DBMS统一管理和控制</p><h2 id="1.2 数据模型">1.2 数据模型</h2><h3 id="1.2.1 两类数据模型">1.2.1 两类数据模型</h3><blockquote><p>1. 概念模型（信息模型） 按用户的观点对数据和信息建模，用于DB设计</p><p>2. 逻辑和物理模型  逻辑模型用于DBMS的实现 物理模型是对底层的抽象</p></blockquote><h3 id="1.2.2 概念模型">1.2.2 概念模型</h3><p>1. 实体：客观存在并可相互区别的事物</p><p>2. 属性：实体所具有的某一特性称为属性</p><p>3. 码：唯一标识实体的属性集</p><p>4. 实体型：同类实体，比如学生</p><p>5. 实体集：同一类型的集合，比如全体学生</p><p>6. 联系：实体内部联系，或者实体之间的联系，如一对一，一对多和多对多</p><p>ER图：概念模型的表示方法</p><h3 id="1.2.3 数据模型的组成要素">1.2.3 数据模型的组成要素</h3><p>1. 数据结构（静态特性）</p><p>2. 数据操作（动态特性）</p><p>3. 数据的完整性约束条件</p><h3 id="1.2.4 常用的数据模型">1.2.4 常用的数据模型</h3><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li><li>面向对象数据模型</li><li>对象关系数据模型</li><li>半结构化数据模型</li></ul><h3 id="1.2.7 关系模型">1.2.7 关系模型</h3><p>1. 关系模型的数据结构</p><blockquote><ol><li>关系：二维表</li><li>元组：行</li><li>属性：列</li><li>码：表里的某个属性组，它可以唯一确定一个元组</li><li>域：一组具有相同数据类型的集合</li><li>分量：行中的某个值</li><li>关系模式：对关系的描述</li></ol></blockquote><p><strong>关系的每一个分量必须是一个不可分的数据项，即不允许表里有表</strong></p><p>2. 数据操纵和完整性约束</p><p>3. 优缺点</p><blockquote><ol><li>具有严谨的数学基础</li><li>概念单一，数据结构简单、清晰，用户易懂</li><li>数据独立性、安全保密性、简化开发工作</li><li>缺点：查询效率不如格式化数据模型，需要查询优化</li></ol></blockquote><h2 id="1.3 数据库系统的结构">1.3 数据库系统的结构</h2><h3 id="1.3.1 DBS模式的概念">1.3.1 DBS模式的概念</h3><blockquote><p>模式是DB中<strong>全体数据</strong>的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值（实例），模式是相对稳定的，而实例是相对变动的，模式反映的是数据的结构和联系，实例反映的是DB某一时刻的状态</p></blockquote><h3 id="1.3.2 DBS的三级模式结构">1.3.2 DBS的三级模式结构</h3><p>1. 外模式（external schema，用户模式）：用户能看到、使用的<strong>局部</strong>数据的<strong>逻辑结构和特征的描述</strong>，是DB用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式是模式的子集，<strong>根据用户的不同而不同</strong>，一个DB可以有多个外模式。外模式是保障DB安全的有利措施，每个用户只能访问对应外模式中的数据，其余不可见。</p><p>2. 模式（逻辑模式）：DB中<strong>全体数据</strong>的<strong>逻辑结构和特征的描述</strong>，是所有用户的<strong>公共数据视图</strong>；是DB模式结构的<strong>中间层</strong>，不涉及物理存储，与应用程序也无关。<strong>一个DB只有一个模式</strong>。</p><p>3. 内模式（internal schema，存储模式）：一个DB只有一个内模式，是物理结构</p><p><strong>注：</strong></p><blockquote><p>一个关系型DBMS的实例（instance）中可建立多个数据库，<strong>一个DB中可建立多个模式（包括不同级的模式）</strong>，一个模式下通常包括多个table、视图、索引等数据库对象。</p><p>DBMS提供<strong>模式DDL</strong>来定义模式，<strong>外模式DDL</strong>来定义外模式</p></blockquote><h3 id="1.3.3 DB的二级映像功能和数据独立性">1.3.3 DB的二级映像功能和数据独立性</h3><p>为了实现三种模式的联系和转换，DBMS提供了两层映像，正因如此，保证了DBS中的数据有较高的独立性</p><p>1. 外模式&#x2F;模式映像</p><p>对于每一个外模式，DBS都有一个外模式&#x2F;模式映像，它定义了该外模式和模式之间的对应关系，这些映像通常包含在各自外模式的描述中。<strong>当模式改变时</strong>，由数据库管理员对映像做相应改变，可使外模式保持不变，而应用程序是根据外模式编写的，所以也不用改，从而保证了数据和程序的逻辑独立性。</p><p>2. 模式&#x2F;内模式映像</p><p>DB中只有一个模式和一个内模式，所以模式&#x2F;内模式映像是<strong>唯一的。定义了数据全局逻辑结构二号存储结构之间的对应关系。当存储结构改变时</strong>，由数据库管理员对映像做相应改变，可使模式保持不变，从而应用程序不用改，从而保证了数据和程序的物理独立性。</p><p>注：</p><blockquote><p>设计DB模式结构时应首先确定数据库的全局逻辑结构，即模式（P30）</p><p>设计外模式时应充分考虑应用的扩充性（P30）</p></blockquote><h1 id="第2章 关系数据库">第2章 关系数据库</h1><h2 id="2.1 关系数据结构及形式化定义"> 2.1 关系数据结构及形式化定义</h2><h3 id="2.1.1 关系">2.1.1 关系</h3><p>1. 域：一组具有相同数据类型的值的集合； 一个域允许的不同取值的个数成为基数</p><p>2. 笛卡儿积：每个域的基数相乘&#x3D;行数,一行&#x3D;元组，元组每一个值叫分量</p><p>3. 关系：笛卡儿积的<strong>有限集合</strong>，就是一张二维表，<strong>关系&#x3D;表</strong></p><blockquote><ol><li>候选码：每一个属性组的值能够唯一标识一个元组，而子集不行。候选码的诸属性为主属性。若有多个候选码，选其中一个作为主码</li><li>全码，所有属性全是该关系模式的候选码</li><li>关系有三种类型：基本关系（实际存在，实际数据的逻辑表示）、视图表（虚表）、查询表</li></ol></blockquote><p>基本关系具有6条性质：</p><blockquote><p>1. 列是同质的，每个元组的某个分量属于同一个域</p></blockquote><blockquote><p>2. 不同的列可能出自同一域，每一列称为属性，属性必须是不同的属性名</p></blockquote><blockquote><p>3. 列顺序无所谓</p></blockquote><blockquote><p>4. 任意元组候选码不能取相同值</p></blockquote><blockquote><p>5. 行顺序无所谓</p></blockquote><blockquote><p>6. 分量原子值，即不能表中有表</p></blockquote><h3 id="2.1.2 关系模式">2.1.2 关系模式</h3><p>关系模式：关系的描述，应当要刻划出完整性的约束条件</p><p>形式化表示：</p><blockquote><p>R(U,D,DOM,F)</p></blockquote><p><strong>关系实际上就是关系模式在某一时刻的状态或内容。也就是说，关系模式是型，关系是它的值。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。</strong></p><h2 id="2.2 关系操作">2.2 关系操作</h2><p>增删改查</p><p>查又分为：</p><p>基本操作是：选择、投影、并、差、笛卡儿积</p><h2 id="2.3 关系的完整性">2.3 关系的完整性</h2><h3 id="2.3.1 实体的完整性">2.3.1 实体的完整性</h3><p>主码不能为空，若主码有多个，则都不能空</p><h3 id="2.3.2 参照完整性">2.3.2 参照完整性</h3><p>外码</p><p>参照关系(有外码)</p><p>被参照关系（被引用的主码）</p><p>参照和被参照关系可以是同一个</p><p>外码不一定要与相应的主码同名</p><p>对于有F(外码)的R的元组，要么取空（不存在），要么取S（被参照关系）的主码</p><h3 id="2.3.3 用户定义完整性">2.3.3 用户定义完整性</h3><h2 id="2.4 关系代数">2.4 关系代数</h2><table><thead><tr><th></th><th>并</th><th>差</th><th>交</th><th>笛卡儿积</th><th>选择</th><th>投影</th><th>连接</th><th>除</th></tr></thead><tbody><tr><td>符号</td><td>∪</td><td>-</td><td>∩</td><td>x</td><td>σ</td><td>Π</td><td>⋈</td><td>÷</td></tr></tbody></table><h3 id="2.4.1 传统的集合运算">2.4.1 传统的集合运算</h3><blockquote><p>基于行的，和集合运算无区别</p></blockquote><p>1. 并</p><p>2. 差</p><p>3. 交</p><p>4. 笛卡儿积（用R X S表示）</p><h3 id="2.4.2 专门的关系运算">2.4.2 专门的关系运算</h3><p>1. 选择  针对行</p><p>2. 投影  针对列，也可能取消某些行，避免重复</p><p>3. 连接</p><blockquote><p>等值连接：从广义笛卡儿积中选取A、B<strong>属性值</strong>相等的元组（注意相等的不能合并）</p><p>自然连接：特殊的等值连接，将相等的合并了（它要求两个关系中进行比较的<strong>分量</strong>必须是相同的属性组，并且要在结果中把重复的属性去掉）</p><p>非等值连接：从广义笛卡儿积中选择符合条件的</p><p>在连接中被舍弃的元组为悬浮元组</p><p>若不舍弃，则为外连接</p><p>不舍弃左边关系中的，就叫左外连接</p></blockquote><p>4. 除</p><blockquote><p>象集：R中属性组X上的x值的诸元组在Z上分量的集合</p><p>R(X,Y),S(Y,Z),Y属于同一域<br>除的定义：元组在<strong>X</strong>上 分量值 <strong>x</strong> 的象集 <strong>Yx</strong> 包含 <strong>S</strong> 在 <strong>Y</strong> 上投影 的集合</p></blockquote><h1 id="第3章-关系型数据库标准语言SQL"><a href="#第3章-关系型数据库标准语言SQL" class="headerlink" title="第3章 关系型数据库标准语言SQL"></a>第3章 关系型数据库标准语言SQL</h1><h2 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h2><h3 id="3-1-3-SQL的基本概念P78"><a href="#3-1-3-SQL的基本概念P78" class="headerlink" title="3.1.3 SQL的基本概念P78"></a>3.1.3 SQL的基本概念P78</h3><blockquote><p>外模式：包括若干视图和部分基本表，基本表是本身独立存在的表，一个关系就对应一个基本表，一个或多个基本表对应一个存储文件；视图是从一个或多个基本表导出的表，本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放其数据，数据仍存在基本表中，因此视图是虚表，视图上可以再定义视图。</p><p>模式：包括若干基本表</p><p>内模式：包含若干存储文件，<strong>存储文件的逻辑结构组成了关系数据库的内模式</strong>，存储文件的物理结构对用户是隐蔽的</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">首先进入mysql文件夹下的bin目录，然后输入MySQL -u+用户名 -p然后输入密码，AC  musk  spacexjack  密码忘了Yang  。。。 <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> 用户名 identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span>; 授予权限： <span class="hljs-keyword">grant</span> <span class="hljs-keyword">insert</span>,<span class="hljs-keyword">update</span>,<span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> student_course <span class="hljs-keyword">to</span> musk; 撤回权限： <span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> student <span class="hljs-keyword">from</span> musk;//mysql只能一次撤一个对象<br></code></pre></td></tr></table></figure><h2 id="3-3-数据定义"><a href="#3-3-数据定义" class="headerlink" title="3.3 数据定义"></a>3.3 数据定义</h2><h3 id="3-3-1-模式的定义和删除"><a href="#3-3-1-模式的定义和删除" class="headerlink" title="3.3.1 模式的定义和删除"></a>3.3.1 模式的定义和删除</h3><h3 id="3-3-2-基本表的定义、删除与修改"><a href="#3-3-2-基本表的定义、删除与修改" class="headerlink" title="3.3.2 基本表的定义、删除与修改"></a>3.3.2 基本表的定义、删除与修改</h3><p>1. 定义基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(sno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">primary</span>, sname <span class="hljs-type">char</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">unique</span>, <span class="hljs-keyword">foreign</span> key(Cno) <span class="hljs-keyword">references</span> Course(Cno)); 跟在列名后面的是列级完整性约束 单独定义的是表级   <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(<span class="hljs-keyword">primary</span> key(Sno, Cno), Cno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>), Sno <span class="hljs-type">char</span>(<span class="hljs-number">3</span>), grade <span class="hljs-type">smallint</span>); 如果完整性约束条件涉及多个属性列，则必须定义在表级，如上所示<br></code></pre></td></tr></table></figure><p>2. 数据类型</p><p>3. 模式与表</p><p><strong>4. 修改基本表*************************************</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 删除列alter table 表名 drop column 属性名 cascade/restrict    <span class="hljs-comment">//column是列的意思注：后面的条件可不写，默认restrict；restrict是指删除是有条件的，所删除的属性不能被其他表的约束所引用，不能有视图、触发器、存储过程或函数； cascade是指删除没有条件，删除的同时，所有相关的对象都将删除 2. 增加列alter table 表名 add column 属性名 数据类型;如：alter table student add column Sname char(6);//mqsql里column可不写 修改列的数据类型//主码好像改不了,外码似乎也是alter table 表名 change 原列名 现列名 数据类型; 3. 删除主键约束alter table student drop primary key;4. 增加主键约束alter table student add primary key(sno);//注意：mysql一张表里只能有一个主键 5. 设置唯一性约束alter table student add unique（sname）;//注意：主键本身就是唯一的 6.设置外键约束（注意外键一定要是所参考的表（student）的主键，不然报错）alter table student_course add foreign key(sno) references student(sno);  7. 元组上的约束条件 P164    a. 检查约束check //mysql不支持检查约束，但写上不会报错    alter table student_course add constraint check(score &gt;= 0 and score &lt;= 100); 8. 设置默认约束alter table 表名 change 原列名 现列名 数据类型 default 默认值;如：alter table student change entime entime date default &#x27;2002-09-01&#x27;;  9. 删除表drop table stu cascade/restrict;  </span><br></code></pre></td></tr></table></figure><h3 id="3-3-3-索引的建立与删除"><a href="#3-3-3-索引的建立与删除" class="headerlink" title="3.3.3 索引的建立与删除"></a>3.3.3 索引的建立与删除</h3><h2 id="3-4-数据查询"><a href="#3-4-数据查询" class="headerlink" title="3.4 数据查询"></a>3.4 数据查询</h2><p>数据查询是数据库的核心操作</p><h3 id="3-4-1-单表查询"><a href="#3-4-1-单表查询" class="headerlink" title="3.4.1 单表查询"></a>3.4.1 单表查询</h3><p>1. 选择表中的若干列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 查询指定列select 属性列,属性列,··· from 表名;<span class="hljs-comment">//各列的顺序可以和原表不一样2. 查询所有列select * from 表名;3. 查询经过计算的值select Sname,2014-Sage from 表名; 属性列还可以是算术表达式、字符串常量、函数等。如：select sname,&#x27;year of birth&#x27;,2014-sage,LOWER(sdept) from student;//小写字母表示系名 还可以通过指定别名来改变查询结果的列标题，例如有些含有算术表达式、函数、常量的列名就可指定别名如：select sname NAME,&#x27;yaer of birth&#x27; BIRTH,2014-sage BIRTHDAY from student;</span><br></code></pre></td></tr></table></figure><p>2. 选择表中的若干元组（行）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 消除取值重复的行（两个不相同的元组投影到指定列后，可能会变成相同的行）使用distinct消除:select distinct sno from sc; <span class="hljs-number">2.</span> 查询满足条件的元组     a. 比较大小    b. 确定范围    c. 确定集合    d. 字符匹配        select * from student where Sno like <span class="hljs-string">&#x27;12313&#x27;</span>;<span class="hljs-comment">//like等价于=        //如果like后面的匹配串中不含通配符(%和_)，则可用=取代like，用!=或&lt;&gt;取代not like        select * from student where Sname like &#x27;刘%&#x27;;//有通配符必须用like        //通配符%代表任意长度（包括0）的字符串，_表示任意单个字符        select * from student where Sname like &#x27;欧阳_&#x27;;        select * from student where Sname like &#x27;_阳%&#x27;;//第二个字为阳的        select * from student where Sname not like &#x27;杨%&#x27;;                //如果要查询的字符串本身有通配符，要用escape转义符        select Cno,Credit from Course where Cname like &#x27;DB\_Design&#x27; escape&#x27;\&#x27;;        //escape\表示\为换码字符，这样跟在\后面的字符不再具有通配符的含义    e. 涉及空值的查询    f. 多重条件查询</span><br></code></pre></td></tr></table></figure><p>3. order by 子句（排序用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">select Sno,Grade from SC where Cno = <span class="hljs-string">&#x27;3&#x27;</span> order by Grade desc;desc: 降序asc: 升序<br></code></pre></td></tr></table></figure><p>4. 聚集函数</p><blockquote><ol><li>count(*)&#x2F;&#x2F;统计元组个数</li><li>count(distinct 列名)&#x2F;&#x2F;统计一列中值的个数，取消重复值</li><li>sum(distinct 列名)&#x2F;&#x2F;计算一列值的总和</li><li>max(distinct 列名)&#x2F;&#x2F;计算一列中的最大值</li><li>avg(列名)&#x2F;&#x2F;平均值</li></ol><p>当聚集函数遇到空值时，除count(*)，都跳过空值</p><p>where 子句中不能用聚集函数</p></blockquote><p>5. group by子句（分组用）</p><blockquote><p>将查询结果按某一列或多列的值分组，值相等的一组</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-number">1.</span>求各个课程号及相应的选课人数select Cno,count(Sno) from sc group by Cno;  如果分组后还要筛选，用having语句select Cno,count(Sno) from sc group by Cnohaving count(*) &gt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><blockquote><p>where语句和having语句的区别：</p><p>where语句不能用聚集函数，作用于基本表或视图；having短语作用于组，也就是group</p></blockquote><h3 id="3-4-2-连接查询"><a href="#3-4-2-连接查询" class="headerlink" title="3.4.2 连接查询"></a>3.4.2 连接查询</h3><p>1. 等值与非等值连接查询</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">select stu.sno, snamefrom stu,scwhere stu.sno = sc.sno and sc.cno<span class="hljs-string">&#x27;2&#x27;</span>; <span class="hljs-regexp">//</span>sno在两个表都有，所以要加前缀<br></code></pre></td></tr></table></figure><p>2. 自身连接</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">查询每一门课的间接先修课（先修课的先修课）<br></code></pre></td></tr></table></figure><p>3. 外连接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">左外连接<span class="hljs-keyword">select</span> student.sno, sname, ssex, sage, sdept, cno, gradefrom student <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> (student.sno = sc.sno);<br></code></pre></td></tr></table></figure><p>4**. 多表连接**</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">查询每个学生的学号、姓名、选修的课程名、成绩select student.sno, Sname, Cname, Gradefrom student, <span class="hljs-keyword">sc, </span>coursewhere student.sno = <span class="hljs-keyword">sc.sno </span><span class="hljs-keyword">AND </span><span class="hljs-keyword">sc.cno </span>= course.cno;<br></code></pre></td></tr></table></figure><h3 id="3-4-3-嵌套查询（nested-query）凸显结构化"><a href="#3-4-3-嵌套查询（nested-query）凸显结构化" class="headerlink" title="3.4.3 嵌套查询（nested query）凸显结构化"></a>3.4.3 嵌套查询（nested query）凸显结构化</h3><blockquote><p>子查询的select语句不能用order by子句，order by只能对最终查询结果排序</p></blockquote><p>1. <strong>带有IN谓词的子查询</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">查询和刘成在同一个系学习的学生<span class="hljs-keyword">SELECT</span> sname,sno,sdept <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> sdept <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">select</span> sdept <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> sname = <span class="hljs-string">&#x27;刘成&#x27;</span>);  在此例中，IN可以用=替换<br></code></pre></td></tr></table></figure><p>子查询的条件不依赖与父查询，称不相关子查询(相关子查询（相关嵌套查询）反之)</p><p><strong>2. 带有比较运算符的子查询</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">找出每个学生超过他自己选秀课程平均成绩的课程号 <span class="hljs-keyword">SELECT</span> Sno,Cno <span class="hljs-keyword">FROM</span> SC xWHERE Grade &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(Grade)                <span class="hljs-keyword">FROM</span>                <span class="hljs-keyword">WHERE</span> y.Sno = x.Sno);<br></code></pre></td></tr></table></figure><p><strong>3.带有any（some）或all谓词的子查询</strong></p><p><strong>4. 带有exists谓词的子查询</strong></p><h3 id="3-4-4-集合查询"><a href="#3-4-4-集合查询" class="headerlink" title="3.4.4 集合查询"></a>3.4.4 集合查询</h3><h3 id="3-4-5-基于派生表的查询"><a href="#3-4-5-基于派生表的查询" class="headerlink" title="3.4.5 基于派生表的查询"></a>3.4.5 基于派生表的查询</h3><h3 id="3-4-6-select语句的一般格式"><a href="#3-4-6-select语句的一般格式" class="headerlink" title="3.4.6 select语句的一般格式"></a>3.4.6 select语句的一般格式</h3><h2 id="3-5-数据更新"><a href="#3-5-数据更新" class="headerlink" title="3.5 数据更新"></a>3.5 数据更新</h2><h3 id="3-5-1-插入数据"><a href="#3-5-1-插入数据" class="headerlink" title="3.5.1 插入数据"></a>3.5.1 插入数据</h3><p><strong>1. 插入元组</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名（属性列，···，···） <span class="hljs-keyword">values</span>（对应的值，···，···）； 注意：<span class="hljs-number">1.</span> 没有出现的属性列，将自动取空值；但说明了<span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> 的属性列不能取空值，否则出错      <span class="hljs-number">2.</span> 如果没有指明任何属性列， 则新插入的必须在每个属性列上都有值（如果为<span class="hljs-literal">null</span>要显式给出），且顺序要和表的属性列顺序一样      <span class="hljs-number">3.</span>值如果为字符串常数，要用单引号括起来，数字不用      <span class="hljs-number">4.</span> 可以把属性列显式的置为<span class="hljs-literal">NULL</span> 例：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student（Sno，Sname，Ssex） <span class="hljs-keyword">values</span>（<span class="hljs-string">&#x27;29193&#x27;</span>,<span class="hljs-string">&#x27;李明&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>）;   一次同时插入多条数据：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名（属性列，···，···） <span class="hljs-keyword">values</span>（对应的值，···，···），（对应的值<span class="hljs-number">2</span>，···，···），（对应的值<span class="hljs-number">3</span>，···，···），···；<br></code></pre></td></tr></table></figure><p><strong>2. <strong>插</strong>入子查询结果</strong></p><blockquote><p>子查询既可以嵌套在select语句中，也可以用在insert语句中用以生成要插入的数据</p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept_age(sdept, avg_age) <span class="hljs-keyword">select</span> sdept, <span class="hljs-built_in">avg</span>(sage) <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sdept;<br></code></pre></td></tr></table></figure><h3 id="3-5-2-修改数据"><a href="#3-5-2-修改数据" class="headerlink" title="3.5.2 修改数据"></a>3.5.2 修改数据</h3><p>1. 修改某一个元组的值</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">where</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span>；如：<span class="hljs-keyword">update</span> student <span class="hljs-keyword">set</span> Sage = <span class="hljs-number">16</span> <span class="hljs-keyword">where</span> Sno = <span class="hljs-string">&#x27;201215121&#x27;</span>；<br></code></pre></td></tr></table></figure><p>2. 修改多个元组的值</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">update 表名 <span class="hljs-keyword">set</span> Sage <span class="hljs-comment">= Sage + 1</span>；<br></code></pre></td></tr></table></figure><p>3. 带子查询的修改语句</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">update SC <span class="hljs-keyword">set</span> Grade = <span class="hljs-number">0</span> <span class="hljs-function"><span class="hljs-keyword">where</span> Sno <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> Sno <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">where</span> Sdept <span class="hljs-string">&#x27;CS&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-删除数据"><a href="#3-5-3-删除数据" class="headerlink" title="3.5.3 删除数据"></a>3.5.3 删除数据</h3><p>1. 删除一个元组</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span>；<br></code></pre></td></tr></table></figure><p>2. 删除多个元组</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Delphi">delete from 表名；<span class="hljs-comment">//删除所有，该表成为空表</span><br></code></pre></td></tr></table></figure><p>3. 带子查询的删除语句</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">delete <span class="hljs-keyword">from</span> SC <span class="hljs-keyword">where</span> Sno <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> Sno <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">where</span> Sdept = <span class="hljs-string">&#x27;CS&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="3-6-空值的处理"><a href="#3-6-空值的处理" class="headerlink" title="3.6 空值的处理"></a>3.6 空值的处理</h2><h2 id="3-7-视图"><a href="#3-7-视图" class="headerlink" title="3.7 视图"></a>3.7 视图</h2><h3 id="3-7-1-定义视图"><a href="#3-7-1-定义视图" class="headerlink" title="3.7.1 定义视图"></a>3.7.1 定义视图</h3><p>1. 建立视图</p><blockquote><p>with check option 表示对视图操作时要满足视图定义中的条件(比如下例中的sdept&#x3D;’IS‘)</p><p>组成视图的列名要么全部省略，要么全部指定</p><p>以下三种情况必须全部指定：</p><ol><li>某个目标列是函数表达式</li><li>有同名列</li><li>需要更合适的名字</li></ol></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">create view <span class="hljs-constructor">IS_student(<span class="hljs-params">sno</span>,<span class="hljs-params">sname</span>,<span class="hljs-params">sage</span>)</span>asselect sno,sname,sagefrom studentwhere sdept = &#x27;IS&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>若一个视图是从单个基本表导出，且只去掉了某些行列，但保留了主码，称这类视图为行列子集视图</p><p>带虚拟列（派生属性，在基本表中不存在）的视图称为带表达式的视图</p><p>带有聚集函数和group by 子句的查询来定义的视图称为分组视图</p></blockquote><p>2. 删除视图</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> IS_stu <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></table></figure><blockquote><p>cascade表示把由该视图导出的所有视图都删除</p><p>当基本表删除后，视图的定义还在，必须用删除视图语句显式删除</p></blockquote><h3 id="3-7-2-查询视图"><a href="#3-7-2-查询视图" class="headerlink" title="3.7.2 查询视图"></a>3.7.2 查询视图</h3><blockquote><p>视图消解：把视图的查询转换为对基本表的查询</p></blockquote><h3 id="3-7-3-更新视图"><a href="#3-7-3-更新视图" class="headerlink" title="3.7.3 更新视图"></a>3.7.3 更新视图</h3><h3 id="3-7-4-视图的作用"><a href="#3-7-4-视图的作用" class="headerlink" title="3.7.4 视图的作用"></a>3.7.4 视图的作用</h3><h1 id="第4章-数据库安全性"><a href="#第4章-数据库安全性" class="headerlink" title="第4章 数据库安全性"></a>第4章 数据库安全性</h1><h2 id="4-2-DB安全性控制"><a href="#4-2-DB安全性控制" class="headerlink" title="4.2 DB安全性控制"></a>4.2 DB安全性控制</h2><h3 id="4-2-1-用户身份鉴别"><a href="#4-2-1-用户身份鉴别" class="headerlink" title="4.2.1 用户身份鉴别"></a>4.2.1 用户身份鉴别</h3><ol><li>静态口令鉴别   密码</li><li>动态口令鉴别   每次鉴别时都需使用动态产生的新口令登陆</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ol><h3 id="4-2-2-存取控制"><a href="#4-2-2-存取控制" class="headerlink" title="4.2.2 存取控制"></a>4.2.2 存取控制</h3><ol><li>自主存取控制</li><li>强制存取控制  每个数据库对象被标以一定的密级</li></ol><h3 id="4-2-3-自主存取控制方法"><a href="#4-2-3-自主存取控制方法" class="headerlink" title="4.2.3 自主存取控制方法"></a>4.2.3 自主存取控制方法</h3><blockquote><p>用户权限由 数据库对象和操作类型 组成</p></blockquote><h3 id="4-2-4-授权：授予与收回"><a href="#4-2-4-授权：授予与收回" class="headerlink" title="4.2.4 授权：授予与收回"></a>4.2.4 授权：授予与收回</h3><p><strong>1. grant</strong></p><blockquote><p>一些权限：</p><p>基本表和视图：select, insert, update, delete references, all privileges</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">to</span> u1 <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span>;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student,course <span class="hljs-keyword">to</span> u2,u3;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">to</span> <span class="hljs-built_in">public</span>;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">update</span>(Sno),<span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">to</span> u4;<br></code></pre></td></tr></table></figure><p><strong>2. revoke</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">update</span>(Sno) <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">from</span> u4;<span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc <span class="hljs-keyword">from</span> <span class="hljs-built_in">public</span>;<span class="hljs-keyword">revoke</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc <span class="hljs-keyword">from</span> u5 <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></table></figure><h1 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h1><h2 id="5-3-用户定义的完整性"><a href="#5-3-用户定义的完整性" class="headerlink" title="5.3 用户定义的完整性"></a>5.3 用户定义的完整性</h2><h3 id="5-3-1-属性上的约束条件-P163"><a href="#5-3-1-属性上的约束条件-P163" class="headerlink" title="5.3.1 属性上的约束条件(P163)"></a>5.3.1 属性上的约束条件(P163)</h3><p>1. 属性上约束条件的定义</p><blockquote><p>包括：</p><p>1. not null</p><p>2. unique</p><p>3. check</p></blockquote><h3 id="5-3-2-元组上的约束条件的定义"><a href="#5-3-2-元组上的约束条件的定义" class="headerlink" title="5.3.2 元组上的约束条件的定义"></a>5.3.2 元组上的约束条件的定义</h3><p>在创建表时可用check短语定义</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(sno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">primary</span>, sname <span class="hljs-type">char</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">unique</span>, sex <span class="hljs-type">char</span>(<span class="hljs-number">2</span>),<span class="hljs-keyword">foreign key</span>(Cno) <span class="hljs-keyword">references</span> Course(Cno),<span class="hljs-keyword">check</span>(sex = <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">OR</span> Sname <span class="hljs-keyword">not</span> lik<span class="hljs-string">e&#x27;Ms.%&#x27;</span>)); 男性名字不能以Ms.开头<br></code></pre></td></tr></table></figure><h1 id="第7章-数据库设计"><a href="#第7章-数据库设计" class="headerlink" title="第7章 数据库设计"></a>第7章 数据库设计</h1><h2 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h2><h3 id="7-1-3-数据库设计基本步骤"><a href="#7-1-3-数据库设计基本步骤" class="headerlink" title="7.1.3 数据库设计基本步骤"></a>7.1.3 数据库设计基本步骤</h3><p> 需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护</p><h2 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h2><h2 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h2><h3 id="7-4-1-ER图向关系模型的转换"><a href="#7-4-1-ER图向关系模型的转换" class="headerlink" title="7.4.1 ER图向关系模型的转换"></a>7.4.1 ER图向关系模型的转换</h3><h2 id="7-6-DB的实施和维护"><a href="#7-6-DB的实施和维护" class="headerlink" title="7.6 DB的实施和维护"></a>7.6 DB的实施和维护</h2><h3 id="7-6-1-数据载入和应用程序的调试"><a href="#7-6-1-数据载入和应用程序的调试" class="headerlink" title="7.6.1 数据载入和应用程序的调试"></a>7.6.1 数据载入和应用程序的调试</h3><h1 id="第9章-关系查询处理和查询优化"><a href="#第9章-关系查询处理和查询优化" class="headerlink" title="第9章 关系查询处理和查询优化"></a>第9章 关系查询处理和查询优化</h1><h2 id="9-1-关系DBS的查询处理"><a href="#9-1-关系DBS的查询处理" class="headerlink" title="9.1 关系DBS的查询处理"></a>9.1 关系DBS的查询处理</h2><h3 id="1-查询分析"><a href="#1-查询分析" class="headerlink" title="1. 查询分析"></a>1. 查询分析</h3><h3 id="2-查询检查"><a href="#2-查询检查" class="headerlink" title="2. 查询检查"></a>2. 查询检查</h3><h3 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3. 查询优化"></a>3. 查询优化</h3><h3 id="4-查询执行"><a href="#4-查询执行" class="headerlink" title="4. 查询执行"></a>4. 查询执行</h3><h2 id="9-2-关系DBS的查询优化"><a href="#9-2-关系DBS的查询优化" class="headerlink" title="9.2 关系DBS的查询优化"></a>9.2 关系DBS的查询优化</h2><h3 id="9-2-1-查询优化概述"><a href="#9-2-1-查询优化概述" class="headerlink" title="9.2.1 查询优化概述"></a>9.2.1 查询优化概述</h3><blockquote><p>查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较高的效率，而且在于系统能比用户程序的“优化”做的更好，这是因为：</p><p>1. </p></blockquote><h2 id="9-3-代数优化"><a href="#9-3-代数优化" class="headerlink" title="9.3 代数优化"></a>9.3 代数优化</h2><h2 id="9-3-2-查询树的启发式优化"><a href="#9-3-2-查询树的启发式优化" class="headerlink" title="9.3.2 查询树的启发式优化"></a>9.3.2 查询树的启发式优化</h2><blockquote><p>风格恢复</p></blockquote><h1 id="第10章-数据库恢复技术"><a href="#第10章-数据库恢复技术" class="headerlink" title="第10章 数据库恢复技术"></a>第10章 数据库恢复技术</h1><h2 id="10-1-事务的基本概念"><a href="#10-1-事务的基本概念" class="headerlink" title="10.1 事务的基本概念"></a>10.1 事务的基本概念</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h3><blockquote><p>事务：是用户定义的数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</p></blockquote><p>在sql中，定义事务的语句有三条：</p><ol><li>begin transaction 表示开始</li><li>commit 提交</li><li>rollback 撤销</li></ol><h3 id="2-事务的ACID特性"><a href="#2-事务的ACID特性" class="headerlink" title="2.事务的ACID特性"></a>2.事务的ACID特性</h3><ol><li>原子性 atomicity</li><li>一致性 consistency 和原子性密切相关   一致性状态（正常）   中断（不一致） 所以要保证原子性</li><li>隔离性 isolation 并发执行的各个事务之间不能干扰</li><li>持续性 durability 永久性 事务一旦提交，改变就是永久性的，其他操作不能影响其结果</li></ol><blockquote><p>ACID特性可能遭到破坏的因素：</p><p>1. 多个事务并行运行，不同事务的操作交叉执行；</p><p>2. 事务在运行过程中被强行停止。</p></blockquote><h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a>10.3 故障的种类</h2><h3 id="1-事务内部的故障"><a href="#1-事务内部的故障" class="headerlink" title="1. 事务内部的故障"></a>1. 事务内部的故障</h3><p>非预期的，不能有由应用程序处理</p><p>发生后需要  事务撤销</p><h3 id="2-系统故障"><a href="#2-系统故障" class="headerlink" title="2. 系统故障"></a>2. 系统故障</h3><p>断电、死机</p><p>系统重启后，不仅要撤销所有未完成的事务，还要重做所有已提交的事务</p><h3 id="3-介质故障"><a href="#3-介质故障" class="headerlink" title="3. 介质故障"></a>3. 介质故障</h3><p>硬故障 磁盘损坏、磁头碰撞、瞬间强磁场干扰</p><h3 id="4-计算机病毒"><a href="#4-计算机病毒" class="headerlink" title="4. 计算机病毒"></a>4. 计算机病毒</h3><blockquote><p>总结，各类故障对DB的影响有两种：</p><p>1. 数据库本身被破坏</p><p>2. 没破坏，但数据不对了</p><p>恢复的原理：冗余</p></blockquote><h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a>10.4 恢复的实现技术</h2><h3 id="10-4-2-日志文件"><a href="#10-4-2-日志文件" class="headerlink" title="10.4.2 日志文件"></a>10.4.2 日志文件</h3><blockquote><p>用来记录事务对数据库的更新操作的文件</p><p>日志文件的作用：P299</p><p>1. </p></blockquote><p>两种：</p><p>1. 以记录为单位的</p><p>需要记录：</p><blockquote><p>1. 各个事务的开始</p><p>2. ················结束</p><p>3. ················所有更新操作</p><p>一个事务就是一个日志记录</p><p>每个日志记录包括：</p><ol><li></li></ol></blockquote><p>2. 以数据块为单位的</p><h1 id="试题"><a href="#试题" class="headerlink" title="试题:"></a>试题:</h1><p><strong>什么是数据库的再组织和重构造？为什么要进行数据库的再组织和重构造？</strong><br>[参考答案 ] 答：数据库的再组织是指：按原设计要求重新安排存储位置、回收垃圾、减少指针链等， 以提高系统性能。 数据库的重构造则是指部分修改数据库的模式和内模式， 即修改原设计的逻辑和物理结构。数据库的再组织是不修改数<br>据库的模式和内模式的。 进行数据库的再组织和重构造的原因： 数据库运行一段时间后，由于记录不断 增、删、改，会使数据库的物理存储情况变坏，降低了数 据 的 存 取 效 率 ，数 据库 性能 下 降 ， 这 时 DBA 就 要 对 数 据库 进行 重组织。 DBMS一般都提供用于数据重组织的实用程序。数据库应用环境常常发生变化，如增加新的应用或新的实体， 取消了某些应用， 有的实体与实体间的联系也发生了变化等， 使原有的数据库设计不能满足新的需求，需要调整数据库的模式和内模式。这就要进行数据库重构造</p><p><strong>什么是检查点记录？</strong><br>答：检查点记录是一类<strong>新的日志记录</strong>。它的内容包括：（1）<strong>建立检查点时刻</strong>所有正在执行的事务清单；（2）这些事务的<strong>最近</strong>一个<strong>日志</strong>记录的地址。</p><p><strong>关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别进行处理的？</strong><br>答:<br>对于违反实体完整性和用户定义的完整性的操作一般都采用<strong>拒绝执行</strong>的方式进行处理。而对于违反参照完整性的操作，并不都是简单地拒绝执行，有时要根据应用语义执行<strong>一些附加的</strong>操作，以保证数据库的正确性。</p><p><strong>什么是数据库的审计功能，为什么要提供审计功能？</strong><br>答：审计功能是指 DBMS 的<strong>审计模块</strong>在用户对数据库执行操作的同时把所有操作自动记录到系统的审计日志中。因为任何系统的安全保护措施都不是完美无缺的，蓄意盗窃破坏数据的人总可能存在。利用数据库的审计功能， <strong>DBA</strong> 可以<strong>根据审计跟踪的信息</strong>，重现导致数据库现有状况的一系列事件，<strong>找出非法存取数据的</strong>人、时间和内容等。</p><p><strong>哪类视图是可以更新的？哪类视图是不可更新的？各举一例说明。</strong><br>答：基本表的<strong>行列子集视图</strong>一般是可更新的。若视图的属性来自集合函数、表达式，则该视图<strong>肯定是</strong>不可以更新的。</p><p><strong>什么是基本表？什么是视图？两者的区别和联系是什么？</strong><br>答：基本表是本身独立存在的表， 在 sQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图<strong>本身不独立存储在数据库中</strong>，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，<strong>这些数据</strong>仍存放在导出视图的基本表中。 视图在概念上与基本表等同， 用户可以如同基本表那样使用视图，可以在视图上再定义视图</p><p><strong>假设有下面两个关系模式：</strong></p><p>职工（职工号，姓名，年龄，职务，工资，部门号） ，其中职工号为主码；</p><p>部门（部门号，名称，经理名，电话） ，其中部门号为主码。</p><p>用 sQL 语言定义这两个关系模式，要求在模式中完成以下完整性约束条件的定义：</p><p>定义每个模式的<strong>主码</strong>；</p><p>定义<strong>参照完整性</strong>； 定义职工年龄不得超过 60岁。<br>答<br>CREATE TABLE DEPT<br>(Deptno NUMBER(2) <strong>PRIMARY KEY,</strong><br>Deptname VARCHAR(10),<br>Manager VARCHAR(10),<br>PhoneNumber Char(12)<br>);</p><p>CREATE TABLE EMP<br>(Empno NUMBER(4) <strong>PRIMARY KEY,</strong><br>Ename VARCHAR(10),<br>Age NUMBER(2),<br>CHECK ( Aage&lt;&#x3D;60),<br>Job VARCHAR(9),<br>Sal <strong>FLOAT</strong>(6),<br>Deptno NUMBER(2),<br><strong>FOREIGN KEY(Deptno)  REFERENCES DEPT(Deptno));</strong></p><p><strong>什么是数据库中的自主存取控制方法和强制存取控制方法？</strong><br>答：<br>自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。<br>强制存取控制方法：每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。</p><p><strong>试述实现数据库安全性控制的常用方法和技术。</strong><br>答：实现数据库安全性控制的常用方法和技术有：<br>( l  ）<strong>用户标识和鉴别</strong>：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权。<br>( 2 ）<strong>存取控制</strong>：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。例如 CZ 级中的自主存取控制 ( DAC ) , Bl  级中的强制存取控制（ MAC ）。<br>( 3 ）<strong>视图机制</strong>：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。<br>( 4 ）<strong>审计</strong>：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中， DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。<br>( 5 ）<strong>数据加密</strong>：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。</p><blockquote><ol><li>DB具有数据独立性的原因：三级模式结构</li><li>逻辑数据和物理数据的转换由DBMS负责</li><li>在嵌入式 SQL 中，当 SQL 语句中引用宿主语言的程序变量时，程序变量应加前缀：</li><li>在关系代数表达式的查询优化中，不正确的叙述是 尽可能早地执行连接</li><li>下列哪类不属于计算机系统的安全问题 政策安全类</li><li>数据库设计人员和用户之间沟通信息的桥梁是 实体联系图</li><li>并行数据库系统研究一直以三种并行计算结构为基础，分别是 <strong>共享内存结构、共享磁盘结构、无共享资源结构</strong></li><li>RDBMS查询处理可以分为四个阶段，包括 <strong>查询分析、检查、优化、执行</strong></li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构附录</title>
    <link href="/2023/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%99%84%E5%BD%95/"/>
    <url>/2023/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%99%84%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h2><blockquote><p>指针</p></blockquote><ul><li>定义指针时，* 号前面的数据类型，表示的是你所定义的指针要指向的数据类型</li></ul><blockquote><p>顺序表</p></blockquote><ul><li><p>逻辑结构与存储元素的物理结构一致</p></li><li><p>占用一片连续的存储空间，访问顺序表示，可快速算出任何一个元素的存储地址（即找到那个元素），可粗略认为访问每个元素所花费的时间相等（<strong>这种存取元素的方法称为随机存取法</strong>）</p></li><li><p>时间复杂度：查找、插入、删除算法的平均时间复杂度均为O(n)</p></li><li><p>存储密度大，等于1（存储密度&#x3D;结点本身所占存储量&#x2F;结点结构所占存储量）</p></li><li><p>可随机存取表中任一元素</p></li></ul><blockquote><p>链表</p></blockquote><ul><li><p>单链表由头指针唯一确定，因此单链表可用头指针的名字来命名</p></li><li><p>头指针：是指向链表中第一个结点的指针，即指向头结点</p></li><li><p>首元结点：是指链表中存储第一个数据元素的结点</p></li><li><p>头结点：附设在链表寿元结点之前的一个结点，是链表的第一个结点，头指针指向头结点</p></li><li><p>如何表示空表？</p><ul><li>无头结点时，头指针为空时表示空表</li><li>有头结点时，头结点的指针域为空时表示空表</li></ul></li><li><p>设置头结点有什么好处？</p><ul><li><p>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无序进行特殊处理</p></li><li><p>便于空表和非空表的统一处理：在有头结点的情况下，无论链表是否为空，头指针都是指向头结点的非空指针，因此你空表和非空表的处理也就统一</p></li></ul></li><li><p>头结点的数据域放些什么？</p><ul><li>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但是此结点不能计入链表长度值，即计算表长时不能算头结点</li></ul></li><li><p>访问链表时，只能通过头指针进入链表，并且通过每个结点的指针域一次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不相同</p></li><li><p>链表时顺序存取的，顺序表是随机存取的</p></li><li><p>在看到如下代码时，怎么理解？(见注释)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">s-&gt;next = p-&gt;next;<span class="hljs-comment">//把p的指针域的指针（原本指向p后面一个结点的指针）赋值给s的指针域里的指针</span><br>p-&gt;next = s;<span class="hljs-comment">//把指向s结点的指针赋值给p的指针域里的指针</span><br></code></pre></td></tr></table></figure></li><li><p>单链表的查找、插入、删除算法时间效率分析</p><ul><li><p>因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为O(n)</p></li><li><p>插入和删除：因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为O(1)。但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)</p></li><li><p>头插法的时间复杂度是O(n)</p></li><li><p>尾插法的时间复杂度是O(n)</p></li></ul></li></ul><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ul><li><p>typedef</p><ul><li>是C语言关键字，是声明，用来给类型起别名</li><li>格式为：typedef   你要给起别名的数据类型    别名</li></ul></li><li><p>在头文件stdlib.h中</p><ul><li><p>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址</p></li><li><p>sizeof(x)运算，计算变量x的长度</p></li><li><p>free（p）函数，释放指针p所指变量的存储空间，即彻底删除一个变量</p></li></ul></li><li><p>new 类型名 T （初值列表） </p><ul><li>功能： 申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值 </li><li>结果值： <ul><li>成功：T类型的指针，指向新分配的内存 </li><li>失败：0（NULL)</li></ul></li><li>例如：int * p1 &#x3D; new int;或int * p1 &#x3D; new int(10); </li><li>注意：new出来的空间的返回值是一个地址所以只能赋值给指针</li></ul></li><li><p>delete 指针p </p><ul><li>功能： 释放指针p所指向的内存。p必须是new操作的返回值</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库绪论</title>
    <link href="/2023/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/01/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h1><h2 id="数据、数据库、数据库管理系统、数据库系统"><a href="#数据、数据库、数据库管理系统、数据库系统" class="headerlink" title="数据、数据库、数据库管理系统、数据库系统"></a>数据、数据库、数据库管理系统、数据库系统</h2><blockquote><p>数据（Data）</p></blockquote><ul><li>数据库中存储的基本对象</li><li>描述事物的符号记录称为数据</li></ul><blockquote><p>数据库（DataBase 简称DB）</p></blockquote><ul><li>数据库是长期储存在计算机内、有组织、可共享的大量数据的结合</li><li>数据库数据具有永久存储、有组织和可共享三个基本特点 </li><li>有组织是说数据库里面的数据是有一定结构的</li><li>可共享是说数据库里的数据可以被不同的软件访问和使用</li></ul><blockquote><p>数据库管理系统（DataBase Mangement System  简称DBMS）</p></blockquote><p><strong>数据库管理系统的主要功能包括：</strong></p><ul><li>数据定义功能</li></ul><p>DBMS提供数据定义语言（Data Definition Language 简称DDL），用户通过它可以方便地对数据库中的数据对象进行定义 </p><ul><li>数据组织、存储和管理</li></ul><p>DBMS要分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等</p><ul><li>数据操纵功能</li></ul><p>DBMS提供数据操纵语言（Data Manipulation Language 简称DML），用户可以使用DML操纵数据，实现对数据库的基本操作，查询、插入、删除、修改等</p><ul><li>数据库的事务管理和运行管理</li></ul><p>数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制，以保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复</p><ul><li>数据库的建立和维护功能</li></ul><p>数据库初始数据的输入、转换功能、数据库的转储、恢复功能、数据库的重组织功能、性能监视、分析功能等</p><blockquote><p>数据库系统（DataBase System 坚持DBS）</p></blockquote><ul><li>数据库系统一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员构成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303061554773.png" alt="image-20230306155400705"></p><h2 id="数据管理技术的产生和反展"><a href="#数据管理技术的产生和反展" class="headerlink" title="数据管理技术的产生和反展"></a>数据管理技术的产生和反展</h2><p>数据管理技术经历了人工管理、文件系统、数据库系统三个阶段</p><blockquote><p>人工管理阶段</p></blockquote><p><strong>人工管理数据有如下特点：</strong></p><ul><li>数据不保存</li><li>应用程序管理数据</li><li>数据不共享</li><li>数据不具有独立性（数据和程序绑定在一起）</li></ul><p><strong>缺点：</strong>数据的逻辑结构或物理结构发生变化后，必须对应用程序做相应的修改，这就加重了程序员的负担</p><blockquote><p>文件系统阶段</p></blockquote><p><strong>用文件系统管理数据具有如下特点：</strong></p><ul><li>数据可以长期保存</li><li>有文件系统管理数据</li></ul><p><strong>缺点：</strong></p><ul><li>数据共享性差，冗余度大</li><li>数据独立性差</li></ul><blockquote><p>数据库系统阶段</p></blockquote><p><strong>用数据库系统管理数据具有如下特点：</strong></p><ul><li>数据结构化</li><li>数据的共享性高、冗余度低、易扩充</li><li>数据独立性高</li><li>数据由DBMS统一管理和控制</li></ul><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><ul><li>数据模型也是一种模型，它是对显示世界数据特征的抽象。数据模型就是现实世界的模拟</li></ul><h2 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h2><p><strong>数据模型应满足三方面要求：</strong></p><ul><li>能比较真实地模拟现实世界</li><li>容易为人所理解</li><li>便于在计算机上实现</li></ul><h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><p>也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计</p><h4 id="逻辑模型和物理模型"><a href="#逻辑模型和物理模型" class="headerlink" title="逻辑模型和物理模型"></a>逻辑模型和物理模型</h4><blockquote><p>逻辑模型</p></blockquote><p>主要包括层次模型、网状模型、关系模型、面向对象模型、对象关系模型。它是按计算机系统的观点对数据建模，主要用于DBMS的实现</p><blockquote><p>物理模型</p></blockquote><p>对数据最低层的抽象，它描述数据再系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的 </p><h2 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h2><p><strong>数据模型通常由数据结构、数据操作和完整性约束三部分组成</strong></p><blockquote><p>数据结构</p></blockquote><blockquote><p>数据操作</p></blockquote><blockquote><p>完整性约束</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库系统概论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统概论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基本概念</title>
    <link href="/2023/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/01/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul><li><p>信息</p></li><li><p>数据</p></li><li><p>数据与信息的联系</p></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301051429474.png"></p><blockquote><p>数据库</p></blockquote><ul><li><p>Database（DB），长期存储在计算机内、有组织的、可共享的数据集合</p></li><li><p>特征</p><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301051417497.png"></p><blockquote><p>数据库管理系统</p></blockquote><ul><li><p>简称DBMS，位于用户与操作系统之家的一层数据管理软件</p></li><li><p>主要功能</p><ul><li><p>数据定义</p><ul><li>提供数据定义语言(DDL)，用于定义数据库中的数据对象</li></ul></li><li><p>数据操纵</p><ul><li>提供数据操纵语言(DML)，用于操纵数据实现对数据库的基本操作（查询、插入、删除、和修改）</li></ul></li><li><p>数据库的运行管理</p><ul><li>保证数据的安全性、完整性、多用户对数据的并发使用以及发生故障后的系统恢复</li></ul></li><li><p>数据库的建立和维护功能</p><ul><li>提供使用程序，完成数据库数据批量装载，数据库转储，介质故障恢复，数据库的重组织和性能监视等</li></ul></li></ul></li></ul><blockquote><p>数据库系统</p></blockquote><ul><li><p>简称DBS，指在计算机系统中引入数据库后的系统构成</p></li><li><p>数据库系统的构成</p><ul><li>数据库</li><li>数据库管理系统</li><li>应用系统（及其开发工具）</li><li>相关人员（数据库管理员、应用系统开发人员、用户）</li></ul></li></ul><blockquote><p>数据库管理员</p></blockquote><ul><li><p>简称DBA，负责全面管理和控制数据库系统，是数据库系统中最重要的人员</p></li><li><p>DBA的主要职责</p><ul><li>设计和定义数据库系统</li><li>帮助最终用户使用数据库系统</li><li>监督与控制数据库系统的使用和运行</li><li>改进和充足数据库系统</li><li>调优数据库系统的性能</li><li>转储和恢复数据库</li><li>重构数据库</li></ul></li></ul><h2 id="数据库系统的体系结构"><a href="#数据库系统的体系结构" class="headerlink" title="数据库系统的体系结构"></a>数据库系统的体系结构</h2><p><strong>三级模式两级映像</strong><br>三层模式是对数据的三个抽象级别<br>二级映像在DBMS内部实现这三个抽象层次的联系和转换</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301051717632.png"></p><blockquote><p>逻辑模式（也称模式）（Schema）</p></blockquote><ul><li><p>数据库中<strong>全体数据</strong>的逻辑结构和特征的描述</p></li><li><p>是综合了<strong>所有用户</strong>需求的<strong>公共</strong>数据视图</p></li></ul><p>对于所有用户，比如教务管理系统，用户不仅有学生、还有老师，设计的逻辑模式应把这些不同用户的需求都满足</p><ul><li><p>一个数据库只有一个逻辑模式</p></li><li><p>逻辑模式的地位：是数据库系统模式结构的中间层</p><ul><li><p>与数据的物理存储细节和硬件环境无关</p></li><li><p>与具体的应用程序、开发工具以及高级程序设计语言无关</p></li></ul></li><li><p>逻辑模式定义的内容</p><ul><li><p>数据的逻辑结构（数据项的名字、类型、取值范围等等）。比如，学生，要有学号、姓名、性别、电话号码</p></li><li><p>数据之间的联系</p></li><li><p>数据有关的安全性、完整性要求</p></li></ul></li></ul><blockquote><p>外模式（也称子模式或用户模式）（External Schema）</p></blockquote><ul><li><p>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述</p></li><li><p>数据库用户的数据视图，是某一应用有关的数据的逻辑表示</p></li><li><p>外模式的地位：介于模式与应用之间</p><ul><li><p>逻辑模式与外模式的关系：一对多</p></li><li><p>外模式通常是逻辑模式的子集</p></li></ul></li><li><p>外模式与应用的关系：一对多</p></li><li><p>外模式的用途</p><ul><li><p>保证数据库的安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据</p></li><li><p>保证数据独立性的一个有力措施</p></li></ul></li></ul><blockquote><p>内模式（也称物理模式或者存储模式）（Internal Schema）</p></blockquote><ul><li>直接面向数据库，对其中的数据进行各种管理</li></ul><blockquote><p>外模式&#x2F;模式映像</p></blockquote><ul><li><p>定义外模式与逻辑模式之间的对应关系</p></li><li><p>每个外模式都对应一个外模式&#x2F;模式映像</p></li><li><p>映像定义通常包含在各自外模式的描述中</p></li></ul><blockquote><p>逻辑模式&#x2F;内模式映像</p></blockquote><ul><li><p>逻辑模式&#x2F;内模式映像定义了数据全局逻辑结构与存储结构之间的对应关系</p><ul><li>例如：说明逻辑记录和字段在内存是如何表示的</li></ul></li><li><p>数据库中模式&#x2F;内模式映像是唯一的</p></li><li><p>该映像定义通常包含在逻辑模式描述中</p></li></ul><p><strong>三级模式两级映像的作用是什么捏？</strong><br>答：保证了数据的独立性，应用程序和数据之间相互独立！</p><p><strong>什么是数据独立性捏？</strong><br>答：外部应用程序和内部数据相互独立的，内部数据发生改变，外部应用程序不用改变。</p><p>数据独立性又分为逻辑独立性和物理独立性</p><ul><li><p>逻辑独立性</p><ul><li><p>指用户的应用程序与数据库的逻级结构是相互独立的，数据的逻级结构改变了，应用程序也可以不变</p></li><li><p>外模式&#x2F;模式映像保证了数据的逻辑独立性</p><ul><li><p>模式改变时，数据管理员修改有关的外模式&#x2F;模式映像，使外模式保持不变</p></li><li><p>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据域程序的独立性</p></li></ul></li></ul></li><li><p>物理独立性</p><ul><li>指的是用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的。当数据的物理存储改变了，应用程序不用改变</li><li>模式&#x2F;内模式映像的用途是保证数据的物理独立性<ul><li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式&#x2F;内模式映像，是模式保持不变</li><li>应用程序不受影响，保证了数据域程序的物理独立性</li></ul></li></ul></li></ul><p><strong>怎么做到保证数据的独立性捏？</strong><br>答：因为有三级模式两级映像这种分层的结构，内部数据改变时，可以通过改变对应的映像来使对应的模式不改变，从而外部应用程序也就不受影响了</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><blockquote><p>数据模型三要素</p></blockquote><ul><li><p>数据结构</p><ul><li>用于描述静态特性</li></ul></li><li><p>数据操作</p><ul><li>用于描述动态特性</li></ul></li><li><p>数据的约束条件</p><ul><li>是一组完整性规则的集合</li></ul></li></ul><blockquote><p>数据模型的分类</p></blockquote><ul><li><p>关系模型</p></li><li><p>半结构化的数据模型</p><ul><li>网状模型</li><li>层次模型</li><li>XML</li><li>JSON<br>  网状模型和层次模型是早期的<br>  XML和JSON是这两种经常在网络使用的数据表示格式</li></ul></li></ul><p><strong>这些数据模型的根本区别在与数据结构不同</strong><br><strong>现在也诞生出新的数据模型</strong></p><blockquote><p>关系模型</p></blockquote><ul><li>数据结构——表<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301071424658.png"></li></ul><blockquote><p>XML</p></blockquote><ul><li>XML是可扩展标记语言(eXtensible Markup Languange)的缩写</li><li>常用于传输和存储数据</li><li>它是一种数据表示格式，可以描述非常复杂的数据结构</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301071426336.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301071426906.png"></p><ul><li>XML有几个特点<ul><li>纯文本，默认使用UTF-8编码</li><li>可嵌套，适合表示结构化数据</li></ul></li></ul><blockquote><p>JSON</p></blockquote><p>XML的特点是功能全面，但标签繁琐，格式复杂。在Web上使用XML越来越少，取而代之的是JSON<br>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript的执行代码，只保留JS的对象格式</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301071430764.png"></p><ul><li>JSON作为数据传输的格式，有几个显著优点：</li><li>只允许使用UTF-8编码，不存在编码问题</li><li>格式简单，浏览器内置JSON支持，如果把数据用JSON发给浏览器，可以用JS直接处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成与设计</title>
    <link href="/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>查找——王卓</title>
    <link href="/2022/10/13/%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第7章-查找"><a href="#第7章-查找" class="headerlink" title="第7章 查找"></a>第7章 查找</h1><h2 id="7-1-查找的基本概念"><a href="#7-1-查找的基本概念" class="headerlink" title="7.1 查找的基本概念"></a>7.1 查找的基本概念</h2><p><strong>查找表</strong>是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着<strong>松散的关系</strong>，因此查找表是一种应用灵便的结构。</p><p><strong>查找</strong>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）</p><ul><li><p><strong>关键字</strong>：用来标识一个数据元素（或记录）的某个数据项的值</p><ul><li><p><strong>主关键字</strong>：可唯一地标识一个记录的关键字是主关键字；</p></li><li><p><strong>次关键字</strong>：反之，用以识别若干记录的关键字是次关键字。</p></li></ul></li></ul><ol><li><p>查找的目的：</p><ul><li><p>查询某个“特定的”数据元素是否在查找表中；</p></li><li><p>检索某个“特定的“数据元素的各种属性；</p></li><li><p>在查找表中插入一个数据元素；</p></li><li><p>删除查找表中的某个数据元素。</p></li></ul></li><li><p>查找的分类</p><ul><li><p><strong>静态查找表</strong>：仅作“查询”（检索）操作的查找表</p></li><li><p><strong>动态查找表</strong>：作“插入”和“删除”操作的查找表</p></li></ul></li><li><p>如何评价查找算法</p><ul><li><p>查找算法的评价指标“：关键字的平均比较次数，也称为<strong>平均查找长度</strong>，（ASL, Average Search Length）。</p></li><li><p>平均查找长度定义</p></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131110029.png"></p><p>4.查找的过程中我们要研究什么？</p><p>查找的方法取决于查找表的结构，即表中数据元素是依何种关系组织在一起的。</p><p>由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时，若无规律可循，只能对集合中的元素一一加以辨认直至找到为止。而这样的“查询”或“检索”是任何计算机应用系统中使用频度都很高的操作，因此设法提高查找表的查找效率，是本章讨论问题的出发点。</p><p>为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的约束关系。</p><h2 id="7-2-线性表的查找"><a href="#7-2-线性表的查找" class="headerlink" title="7.2 线性表的查找"></a>7.2 线性表的查找</h2><h3 id="7-2-1-顺序查找（线性查找）"><a href="#7-2-1-顺序查找（线性查找）" class="headerlink" title="7.2.1 顺序查找（线性查找）"></a>7.2.1 顺序查找（线性查找）</h3><p>应用范围：顺序表或线性链表表示的<strong>静态查找表</strong>；表内元素之间无序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 若成功返回其位置信息，否则返回0</span><br>    <span class="hljs-keyword">for</span>(i = ST.length; i &gt;= <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ST.R[i].key == key) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进：把待查关键字key存入表头（“哨兵”、”监视哨”），从后往前逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    ST.R[<span class="hljs-number">0</span>].key = key;<br>    <span class="hljs-keyword">for</span>(i = ST.length; ST.R[i].key != key; i--);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>当ST.length较大时，此改进能使进行一次查找所需的平均时间几乎减少一半。</p><ul><li><p>时间复杂度：O(n)，查找成功时的平均查找长度为：<code>ASL(n) = (1+2+...+n)/n = (n+1)/2</code>。</p></li><li><p>空间复杂度：一个辅助空间，O(1)。</p></li></ul><p>讨论：</p><ol><li><p>记录的查找概率不相等时如何提高查找效率？</p><p> 查找表存储记录原则按查找概率高低存储：</p><ol><li><p>查找概率越高，比较次数越少；</p></li><li><p>查找概率越低，比较次数较多。</p></li></ol></li><li><p>记录的查找概率无法测定时如何提高查找效率？</p><p> 方法——按查找概率<strong>动态调整</strong>记录顺序：</p><ol><li><p>在每个记录中设一个访问频度域；</p></li><li><p>始终保持记录按非递增有序的次序排列；</p></li><li><p>每次查找后均将刚查到的记录直接移至表头。</p></li></ol></li></ol><p>优点：算法简单，逻辑次序无要求，且不同存储结构均适用。</p><p>缺点：ASL太长，时间效率太低</p><h3 id="7-2-2-折半查找（二分或对分查找）"><a href="#7-2-2-折半查找（二分或对分查找）" class="headerlink" title="7.2.2 折半查找（二分或对分查找）"></a>7.2.2 折半查找（二分或对分查找）</h3><p><strong>折半查找</strong>：每次将待查记录所在区间缩小一半。</p><ul><li><p>折半查找算法：（非递归算法）</p><ul><li><p>设表长为n，low、high和mid分别指向待查元素所在区间的上界、下界和中点，key为给定的要查找的值；</p></li><li><p>初始时，令low&#x3D;1，high&#x3D;n，mid&#x3D;floar((low+high)&#x2F;2)</p></li><li><p>让k与mid指向的记录比较</p><ul><li>若key&#x3D;&#x3D;R[mid].key，查找成功；</li><li>若key&lt;R[mid].key，high&#x3D;mid-1；</li><li>若key&gt;R[mid].key，low&#x3D;mid+1；</li></ul></li><li><p>重复上述操作，直至low&gt;high时，查找失败</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    low = <span class="hljs-number">1</span>; high = ST.length;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)<br>    &#123;<br>        mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(ST.R[mid].key == key) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; ST.R[mid].key)<br>            high = mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>            low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, KeyTable key, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    mid = (low + high) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(key == ST.elem[mid].key) <span class="hljs-keyword">return</span> mid;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; ST.elem[mid].key)<br>        <span class="hljs-built_in">Search_Bin</span>(ST,key, mid<span class="hljs-number">-1</span>, high);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">Search_Bin</span>(ST,key, low, mid+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>假定每个元素的查找概率相等，查找成功时的平均查找长度（ASL），设表长n&#x3D;2^h-1，则h&#x3D;log2(n+1)，查找概率相等为：1&#x2F;n，<code>ASL≈log2(n+1)-1    (n&gt;50)</code>。</p><p>优点：效率比顺序查找高</p><p>缺点：只适用于<strong>有序表</strong>，且限于<strong>顺序存储结构</strong>（对线性链表无效）。</p><h3 id="7-2-3-分块查找（索引顺序查找）"><a href="#7-2-3-分块查找（索引顺序查找）" class="headerlink" title="7.2.3 分块查找（索引顺序查找）"></a>7.2.3 分块查找（索引顺序查找）</h3><p>分块查找条件基础：</p><ol><li><p>将表分成几块，且表有序或者分块有序。若i &lt; j，则第j块中所有记录的关键字均大于第i块中的最大关键字。</p></li><li><p>建立”索引表“（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）。</p></li></ol><p>查找过程：先确定待查记录所在块（顺序或折半查找），再在块内查找（顺序查找）。</p><p>查找效率：ASL &#x3D; LB + LW；即对索引表查找的ASL加上对块内查找的ASL</p><ul><li>图2：分块查找效率<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131111682.png"></li></ul><p>优点：插入和删除较容易，无需进行大量移动</p><p>缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算</p><p>适用情况：如果线性表既要<strong>快速查找</strong>又经常<strong>动态变化</strong>，则可采用分块查找。</p><ul><li>图3：查找方法比较<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131111925.png"></li></ul><h2 id="7-3-树表的查找"><a href="#7-3-树表的查找" class="headerlink" title="7.3 树表的查找"></a>7.3 树表的查找</h2><h3 id="7-3-1-二叉排序树"><a href="#7-3-1-二叉排序树" class="headerlink" title="7.3.1 二叉排序树"></a>7.3.1 二叉排序树</h3><p><strong>二叉排序树</strong>（Binary Sort Tree）又称为二叉搜索树、二叉查找树。</p><ol><li><p>二叉排序树定义：</p><p> 二叉排序树或是空树，或是满足如下性质的二叉树：</p><ol><li><p>若其左子树非空，则左子树上所有结点的值均小于根结点的值；</p></li><li><p>若其右子树非空，则右子树上所有结点的值均大于等于根结点的值；</p></li><li><p>其左右子树本身又各是一棵二叉排序树</p></li></ol></li><li><p>二叉排序树的性质：</p><p> 中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的<strong>递增有序</strong>序列。</p></li><li><p>二叉排序树的操作——查找</p><ul><li><p>若查找的关键字等于根节点，成功。</p></li><li><p>否则：</p><ul><li><p>若小于根节点，查其左子树</p></li><li><p>若大于根节点，查找右子树</p></li></ul></li><li><p>在左右子树上的操作类似</p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-comment">// 二叉排序树的存储结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ElemType</span><br>&#123;<br>    KeyType key;    <span class="hljs-comment">// 关键字项</span><br>    InfoType otherInfo; <span class="hljs-comment">// 其他数据项</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span><br>&#123;<br>    ElemType data;      <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> *lchild, *rchild;        <span class="hljs-comment">// 左右孩子指针</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> BSTNode* BSTree;<br><br><span class="hljs-comment">// 递归查找</span><br><span class="hljs-function">BSTree <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree T, KeyType key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T || key == T-&gt;data.key) <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; T-&gt;data.key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild, key);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>二叉排序树的查找分析</p><p> 二叉排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。</p><p> 比较的关键字次数 &#x3D; 此结点所在层次数；最多的比较次数 &#x3D; 树的深度</p><p> 对于含有n个结点的二叉排序树的平均查找长度和树的形状有关。</p><pre><code class="hljs"> - 最好情况：与折半查找中的判定树相同，O(log2n)； - 最坏情况：退化为单支树（类似于线性列表），树深度为n，ASL = (n+1)/2，O(n)；</code></pre><p> 为了提高形态不均衡的二叉排序树的查找效率，应当进行“平衡化”处理（即<strong>平衡二叉树</strong>），尽量使二叉树的形状均衡！</p></li><li><p>二叉排序树的操作——插入</p><ul><li><p>若二叉排序树为空，则插入结点作为根结点插入到空树中</p></li><li><p>否则，继续在其左、右子树上查找</p><ul><li><p>树中已有，不再插入</p></li><li><p>树中没有</p><ul><li>查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子</li></ul></li></ul></li></ul><p> <strong>插入的元素一定是叶子节点</strong>。</p></li><li><p>二叉排序树的操作——生成</p><p> 从空树出发，经过一系列的查找、插入操作之后，可生成一颗二叉排序树。</p><p> 一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。</p><p> 插入的结点均为叶子结点，故无需移动其他结点。相当于在有序序列上插入记录而无需移动其他记录。但是，<strong>关键字的输入顺序不同，建立的二叉排序树也不同</strong>。</p></li><li><p>二叉排序树的操作——删除</p><p> 从二叉排序树中删除一个结点，不能把以该结点为根的子树者都删除，只能删掉该结点，并且<strong>还应保证删除后所得的二叉树仍然满足二叉排序树的性质不变</strong>。</p><p> 由于中序遍历二叉排序树可以得到一个递增有序的序列。那么，在二叉排序树中删去一个结点相当于删去有序序列中的一个结点。</p><pre><code class="hljs"> - 将因删除结点而断开的二叉链表重新链接起来 - 防止重新链接后树的高度增加</code></pre><ol><li><p>如果删除的结点是叶子结点：直接删除该结点。</p></li><li><p>被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它（结点替换）。</p></li><li><p>本删除的结点既有左子树，也有右子树：可以用其中序的前驱结点替换，然后删除该前驱结点（前驱结点是左子树中最大的结点）；也可以用中序的后继结点，然后删除该后继结点（后继是右子树中最小的结点）。</p></li></ol></li></ol><h3 id="7-3-2-平衡二叉树"><a href="#7-3-2-平衡二叉树" class="headerlink" title="7.3.2 平衡二叉树"></a>7.3.2 平衡二叉树</h3><ol><li><p>平衡二叉树的定义</p><p> <strong>平衡二叉树</strong>（balanced binary tree），又称为AVL树（Adelson-Velskii and Landis）。</p><p> 一棵平衡二叉树或者是空树，或者是具有以下性质的<strong>二叉排序树</strong>：</p><ul><li><p>左子树与右子树的高度之差的绝对值小于等于1；</p></li><li><p>左子树和右子树也是<strong>平衡二叉排序树</strong>。</p></li></ul><p> 左子树与右子树的高度差又称为结点的平衡因子（BF），<code>平衡因子=结点左子树的高度-结点右子树的高度</code>。根据平衡二叉树的定义，平衡二又树上所有结点的平衡因子只能是-1、0，或1。</p></li></ol><p>对于一棵有n个结点的AVL树，其高度保持在O(log2n)数量级，ASL也保持在O(log2n)量级。</p><ol start="2"><li><p>失衡二叉排序树的分析与调整</p><p>当我们在一个平衡二叉排序树上插入一个结点时，有可能导致<strong>失衡</strong>，即出现平衡因子绝对值大于1的结点。</p><p>如果在一个AVL树中插入一个新结点后造成失衡，则必须<strong>重新调整树的结构</strong>，使之回复平衡。</p></li></ol><p>平衡调整的四种类型：LL型、LR型、RL型和RR型</p><ul><li><p>图4：平衡调整的四种类型示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131112212.png"></p></li><li><p>图5：平衡调整的四种类型调整后示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131113075.png"></p></li></ul><p>平衡调整的原则：1）降低高度；2）保持二叉排序树性质</p><ol><li>LL型调整</li></ol><ul><li><p>图6：LL型调整前-后对比示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131113389.png"></p></li><li><p>B结点带左子树一起上升</p></li><li><p>A结点成为B的右孩子</p></li><li><p>原来B结点的右子树作为A的左子树</p></li><li><p>图7：LL型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131114924.png"></p></li></ul><ol start="2"><li>RR型调整</li></ol><ul><li><p>图8：RR型调整前-后对比示意图<br>  <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131115509.png"></p></li><li><p>B结点带右节点一起上升</p></li><li><p>A结点成为B结点的左孩子</p></li><li><p>原来B结点的左子树作为A的右子树</p></li><li><p>图9：RR型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131116899.png"></p></li></ul><ol start="3"><li>LR型调整</li></ol><ul><li><p>图10：LR型调整前-后对比示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131117344.png"></p></li><li><p>C结点穿过A、B结点上升</p></li><li><p>B结点成为C的左孩子，A结点成为C的右孩子</p></li><li><p>原来C结点的左子树作为B的右子树，原来C结点的右子树作为A的左子树</p></li><li><p>图11：LR型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131118813.png"></p></li></ul><ol start="4"><li>RL型调整</li></ol><ul><li><p>图12：RL型调整前示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131118548.png"></p></li><li><p>图13：RL型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131119631.png"></p></li></ul><h2 id="7-4-哈希表的查找（散列表的查找）"><a href="#7-4-哈希表的查找（散列表的查找）" class="headerlink" title="7.4 哈希表的查找（散列表的查找）"></a>7.4 哈希表的查找（散列表的查找）</h2><h3 id="7-4-1-散列表的基本概念"><a href="#7-4-1-散列表的基本概念" class="headerlink" title="7.4.1 散列表的基本概念"></a>7.4.1 散列表的基本概念</h3><p>基本思想：<strong>记录的存储位置与关键字之间的存在对应关系</strong>，对应关系常成为hash函数。</p><p><strong>优点：查找效率高；缺点：空间效率低！</strong></p><p><strong>散列方法（杂凑法）</strong>：选取某个函数，依该函数按关键字<strong>计算元素的存储位置</strong>，并按此存放。查找时，<strong>由同一个函数对给定值k计算地址</strong>，将k与地址单元中元素关键码进行对比，确定查找是否成功。</p><p><strong>散列函数（杂凑函数）</strong>：散列方法中适用的<strong>转换函数</strong>。</p><p><strong>冲突</strong>：不同的关键码映射到同一个散列地址，则称为冲突。</p><h3 id="7-4-2-散列函数的构造方法"><a href="#7-4-2-散列函数的构造方法" class="headerlink" title="7.4.2 散列函数的构造方法"></a>7.4.2 散列函数的构造方法</h3><p>在散列查找方法中，冲突是不可避免的，只能尽可能避免。使用散列表要解决的两个主要为题包括：</p><ol><li><p>构造好的散列函数</p><ul><li><p>所选函数尽可能简单，以便提高转换速度；</p></li><li><p>所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。</p></li></ul></li><li><p>制定一个好的解决冲突的方案</p><ul><li>查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。</li></ul></li></ol><p>构造散列函数考虑的因素：执行速度、关键字的长度、散列表的大小、关键字的分布情况、查找频率。</p><p>根据元素集合的特性构造，<strong>要求一</strong>：n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的<strong>地址空间尽量小</strong>。<strong>要求二</strong>：无论用什么方法存储，目的都是尽量<strong>均匀</strong>地存放元素，以避免冲突。</p><p>常见构造方法包括有：直接定址法、数字分析法、平方取中法、折叠法、<strong>除留余数法</strong>、随机数法。</p><p><strong>直接定址法</strong>：以关键码key的某个线性函数值为散列地址，不会产生冲突。但是要占用连续地址空间，空间效率低。</p><p><strong>除留余数法</strong>：<code>Hash(key) = key mod p(其中p是一个整数)</code>，常见p值取小于表长的质数。</p><h3 id="7-4-3-处理冲突的方法"><a href="#7-4-3-处理冲突的方法" class="headerlink" title="7.4.3 处理冲突的方法"></a>7.4.3 处理冲突的方法</h3><ol><li><p>开放地址法（开地址法）</p><p> 当有冲突时就去寻找<strong>下一个</strong>空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。常见方法包括：<strong>线性探测法</strong>、<strong>二次探测法</strong>、<strong>伪随机探测法</strong>。<code>Hi = (Hash(key) + di) mod m, m是散列表长度, di是增量序列</code></p><p> 线性探测法：<code>di为1, 2, ..., m-1线性序列</code>，一旦冲突，就找下一个地址，直到找到空地址存入。</p><p> 二次探测法：<code>di为1^2, -1^2, 2^2, -2^2， ..., q^2二次序列</code>。</p><p> 伪随机探测法：<code>di为伪随机数序列</code>。</p></li><li><p>链地址法（拉链法）</p><p> 将相同散列地址的记录链成一个单链表，<strong>m个散列地址就设m个单链表</strong>，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。</p><p> 链地址法建立散列表步骤：</p><ol><li><p>取数据元素的关键字key，计算其散列函数值（地址）。若该地址对应的链表为空，则将该元素插入此链表；否则执行步骤2解决冲突。</p></li><li><p>根据选择的冲突处理方法，计算关键字key的下一个存储地址。若该地址对应的链表为不为空，则利用链表的前插法或后插法将该元素插入此链表。</p></li></ol><p> 连地址法的优点：非同义词<strong>不会冲突</strong>，无聚集现象；链表上结点空间动态申请，更适合于表长不确定的情况；</p></li><li><p>再散列法（双散列函数法）</p></li><li><p>建立一个公共溢出区</p></li></ol><h3 id="7-4-4-散列表的查找及性能分析"><a href="#7-4-4-散列表的查找及性能分析" class="headerlink" title="7.4.4 散列表的查找及性能分析"></a>7.4.4 散列表的查找及性能分析</h3><ul><li>图14：散列表查找流程图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131119199.png"></li></ul><p>散列表的查找效率，如果使用平均查找长度ASL来衡量，则ASL取决于：散列函数、处理冲突的方法、散列表的<strong>装填因子</strong>α（<code>α=表中填入的记录数/哈希表的长度</code>）。</p><p>其中，α越大，表中记录的数据越多，说明表装填的越满，发生冲突的可能性越大，查找时比较次数就越多。</p><p>ASL与装填因子α有关，既不是严格的O(1)，也不是O(n)。</p><p><code>ASL≈1+α/2(拉链法);ASL≈1/2*(1+(1/(1-α)))(线性探测法);ASL≈-(1/α)*ln(1-α)(随机探测法)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图——王卓</title>
    <link href="/2022/10/13/%E5%9B%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E5%9B%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第6章-图"><a href="#第6章-图" class="headerlink" title="第6章 图"></a>第6章 图</h1><p>图是一种比线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层中的多个元素（即其孩子结点）相关，但只能和上一层中一个元素（即其双亲结点）相关；而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。在数据结构中，应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构，以及若于图的操作的实现。</p><h2 id="6-1-图的定义和基本术语"><a href="#6-1-图的定义和基本术语" class="headerlink" title="6.1 图的定义和基本术语"></a>6.1 图的定义和基本术语</h2><h3 id="6-1-1-图的定义"><a href="#6-1-1-图的定义" class="headerlink" title="6.1.1 图的定义"></a>6.1.1 图的定义</h3><p>图(Graph)G由两个集合V和E组成，记为G&#x3D;(V,E)：</p><ul><li><p>V(vertex)是顶点的<strong>有穷非空集合</strong>;</p></li><li><p>E(Edge)是V中顶点偶对的<strong>有穷集合</strong>，这些顶点偶对称为<strong>边</strong>。</p></li></ul><p>V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。</p><p>对于图G，若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。</p><p>对于图G，若图中任意两个点之间都有一条边相连，则称为<strong>完全图</strong>。对于n个顶点，则无向完全图有n(n-1)&#x2F;2条边，有向完全图有n(n-1)条边。</p><h3 id="6-1-2-图的基本术语"><a href="#6-1-2-图的基本术语" class="headerlink" title="6.1.2 图的基本术语"></a>6.1.2 图的基本术语</h3><p>用n表示图中顶点数目，用e表示边的数目，下面介绍图结构中的一些基本术语。</p><ol><li><p><strong>无向完全图</strong>和<strong>有向完全图</strong>：对于无向图，若具有n(n- 1)&#x2F;2条边，则称为无向完全图。对于有向图，若具有n(n-1)条弧，则称为有向完全图。</p></li><li><p><strong>稀疏图</strong>和<strong>稠密图</strong>：有很少条边或弧(如e &lt; nlogn)的图称为稀疏图，反之称为稠密图。</p></li><li><p><strong>权</strong>和<strong>网</strong>：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。<strong>这种带权的图通常称为网</strong>。</p></li><li><p><strong>邻接</strong>：描述图中两个顶点之间的关系，有边&#x2F;弧相连的两个顶点，称为两顶点邻接。</p></li><li><p><strong>邻接点</strong>：对于无向图G，如果图的边(v, v’)∈E，则称顶点v和v’互为邻接点，即v和v’相邻接。边(v, v’)<strong>依附于</strong>顶点v和v’，或者说边(v, v’)与顶点v和v’<strong>相关联</strong>。在有向图中，存在<code>&lt;v, v&#39;&gt;</code>，则称<strong>v邻接到v’，v’邻接于v</strong>。</p></li><li><p><strong>度</strong>、<strong>入度</strong>和<strong>出度</strong>：顶点的度是指和v<strong>相关联的边的数目</strong>，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v),顶点v的度为TD(v) &#x3D; ID(v) + OD(v)。</p></li><li><p><strong>路径</strong>和<strong>路径长度</strong>：接续的边构成的顶点序列。在无向图G中，从顶点v到顶点v’的路径是一个顶点序列。如果G是有向图，则路径也是有向的。路径长度是一条路径上经过的边或弧的数目或权值之和。</p></li><li><p><strong>回路</strong>或<strong>环</strong>：第一个顶点和最后一个顶点相同的路径称为回路或环。</p></li><li><p><strong>简单路径</strong>、<strong>简单回路</strong>或<strong>简单环</strong>：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p></li><li><p><strong>连通</strong>、<strong>连通图</strong>和<strong>连通分量</strong>：在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点Vi、Vj，Vi和Vj都是连通的，则称G是连通图。所谓连通分量，指的是无向图中的极大连通子图。其中极大连通子图意思是：<strong>该子图是连通子图，将G的任何不在该子图中的顶点加入，子图不再连通</strong>。</p></li><li><p><strong>强连通图</strong>和<strong>强连通分量</strong>：在有向图G中，如果对于每一对Vi, Vj，从Vi到Vj和从Vj到Vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。</p></li><li><p>极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，该子图不再连通。</p></li><li><p><strong>连通图的生成树</strong>：包含无向图G所有顶点的极小连通图；一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边，这样的连通子图称为连通图的生成树。</p></li><li><p><strong>有向树</strong>和<strong>生成森林</strong>：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p></li></ol><h2 id="6-2-案例引入"><a href="#6-2-案例引入" class="headerlink" title="6.2 案例引入"></a>6.2 案例引入</h2><h2 id="6-3-图的类型定义"><a href="#6-3-图的类型定义" class="headerlink" title="6.3 图的类型定义"></a>6.3 图的类型定义</h2><p>图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。抽象数据类型图的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADTGraph&#123;<br>    数据对象： V是具有相同特性的数据元素的集合，称为顶点集。<br>数据关系：<br>    R = &#123;VR&#125;<br>    VR = &#123;&lt;v, w&gt;|v, w属于V，且<span class="hljs-built_in">P</span>(v, w) &lt;v, w&gt;表示从v到w的弧，谓词<span class="hljs-built_in">P</span>(v, w)定义了弧&lt;v, w&gt;的意义或信息&#125;<br>基本操作：<br>    图的创建、增删改查等。其中重要的包括有构造图、深度优先搜索、广度优先搜索。<br></code></pre></td></tr></table></figure><h2 id="6-4-图的存储结构"><a href="#6-4-图的存储结构" class="headerlink" title="6.4 图的存储结构"></a>6.4 图的存储结构</h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但<strong>可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法（数组表示法）</strong>。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有<strong>邻接表</strong>、<strong>十字链表</strong>和<strong>邻接多重表</strong>，应根据实际需要的不同选择不同的存储结构。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121945.png"></p><h3 id="6-4-1-邻接矩阵"><a href="#6-4-1-邻接矩阵" class="headerlink" title="6.4.1 邻接矩阵"></a>6.4.1 邻接矩阵</h3><ol><li><p>邻接矩阵表示法</p><p> 建立一个<strong>顶点表</strong>(记录哥各个顶点信息)和一个<strong>邻接矩阵</strong>(表示各个顶点之间关系)。</p><p> <strong>邻接矩阵</strong>(<strong>Adjacency Matrix</strong>)是表示顶点之间相邻关系的矩阵。设G(V, E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">A[i][j] = <span class="hljs-number">1</span>; 若&lt;i, j&gt;∈E或者(i, j)∈E<br>A[i][j] = <span class="hljs-number">0</span>; 否则<br></code></pre></td></tr></table></figure><ul><li>分析1：无向图的邻接矩阵是对阵的；</li><li>分析2：顶点i的度&#x3D;第i行(列)中的1的个数；</li><li>分析3：完全图的邻接矩阵中，对焦元素为0，其余为1。</li></ul><p> 有向图的邻接矩阵需考虑边的方向。</p><ul><li>分析1：有向图的邻接矩阵可能是不对称的；</li><li>分析2：顶点的出度&#x3D;第i行元素之和，顶点的入度&#x3D;第i列元素之和，顶点的度&#x3D;第i行元素之和+第i列元素之和。</li></ul><p> 网(即有权图)的邻接矩阵表示法：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">A[i][j] = Wij; 若&lt;vi, vj&gt;或(vi, vj)∈VR<br>A[i][j] = ∞; 无边(弧)<br>其中，Wij表示边上的权值；∞表示计算机允许的、大于所有边上权值的数。<br></code></pre></td></tr></table></figure><p> 用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。其形式说明如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//-----图的邻接矩阵存储表示－－－－－</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt  32767</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum   100         <span class="hljs-comment">// 最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;    <span class="hljs-comment">// 设顶点的数据类型为字符型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;        <span class="hljs-comment">// 假设边的权值类型为整型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    VerTexType  vexs[MVNum];    <span class="hljs-comment">// 顶点表</span><br>    ArcType     arcs[MVNum][MVNum]; <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum; <span class="hljs-comment">// 图的当前点数和边数</span><br>&#125;AMGraph;<br></code></pre></td></tr></table></figure></li><li><p>采用邻接矩阵表示法创建无向网</p><p> 已知一个图的点和边，使用邻接矩阵表示法来创建此图的方法比较简单，下面以一个无向网为例来说明创建图的算法。</p><p> 算法步骤：</p><ol><li>输入总顶点数和总边数。</li><li>依次输入点的信息存入顶点表中。</li><li>初始化邻接矩阵，使每个权值初始化为极大值。</li><li>构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。</li></ol><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(AMGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接矩阵表示法，创建无向网G</span><br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;        <span class="hljs-comment">// 输入总顶点数，总边数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-comment">// 依次输入顶点信息</span><br>        cin &gt;&gt; G.vexs[i];<br>    &#125;<br>    <span class="hljs-comment">// 初始化邻接矩阵，边的权值均置为极大值MaxInt</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; i &lt; G.vexnum; j++)<br>        &#123;<br>            G.arcs[i][j] = MaxInt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 构造邻接矩阵</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++)<br>    &#123;<br>        <span class="hljs-comment">// 输人一条边依附的顶点及权值</span><br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<br>        <span class="hljs-comment">// 确定v1和v2在G中的位置，即顶点数组的下标</span><br>        i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-comment">// 边&lt;v1,v2&gt;的权值为w</span><br>        G.arcs[i][j] = w;<br>        G.arcs[j][i] = G.arcs[i][j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocatVex</span><span class="hljs-params">(AMGraph G, VerTexType u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(u == G.vexs[i])<br>        &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 该算法的时间复杂度是0(n^2)。</p><p> 若要建立无向图，只需对上述算法做两处小的改动：<strong>一是初始化邻接矩阵时，将边的权值均初始化为0；二是构造邻接矩阵时，将权值w改为常量值1即可</strong>。同样，将该算法稍做修改即可建立一个有向网或有向图，即邻接矩阵为非对称矩阵。</p></li><li><p>邻接矩阵表示法的优缺点</p><blockquote><p>优点</p></blockquote><ol><li><p>便于判断两个顶点之间是否有边，即根据A[i][j] &#x3D; 0或1来判断。</p></li><li><p>方便找任意顶点的所有邻接点；</p></li><li><p>便于计算各个顶点的度。对于无向图，邻接矩阵第i行元素之和就是顶点i的度；对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。</p></li></ol><blockquote><p>缺点</p></blockquote><ol><li><p>不便于增加和删除顶点。</p></li><li><p>不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2)</p></li><li><p>空间复杂度高。如果是有向图，n个顶点需要n^2个单元存储边。</p><p> 如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要n(n-1)&#x2F;2个单元即可。</p></li></ol></li></ol><h3 id="6-4-2-邻接表"><a href="#6-4-2-邻接表" class="headerlink" title="6.4.2 邻接表"></a>6.4.2 邻接表</h3><ol><li><p>邻接表表示法</p><p> <strong>邻接表</strong>(<strong>Adjacency List</strong>)是图的一种链式存储结构。在邻接表中，对图中每个顶点vi建立一个单链表，把与vi相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：<strong>表头结点表</strong>和<strong>边表</strong>。</p><ol><li><p><strong>表头结点表</strong>：由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。表头结点包括数据域(data)和链域(firstarc)两部分。其中，数据域用于存储顶点vi的名称或其他有关信息；链域用于指向链表中第一个结点（即与顶点vi邻接的第一个邻接点）。</p></li><li><p><strong>边表</strong>：由表示图中顶点间关系的2n个边链表组成。边链表中边结点包括<strong>邻接点域(adjvex)、数据域(info)和链域(nextarc)三部分</strong>。其中，邻接点域指示与顶点vi邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点vi邻接的下一条边的结点。</p></li></ol><p> 特点：</p><ul><li>邻接表不唯一；</li><li>若<strong>无向图</strong>中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适合存储稀疏图；</li><li><strong>无向图</strong>中顶点vi的度为第i个单链表中的结点数。</li></ul><p> 有向图的邻接表特点：</p><ul><li>顶点vi的出度为第i个单链表中的结点个数</li><li>顶点vi的入读为整个单链表中邻接点域值是i-1的结点个数。</li></ul><p> 反之，逆邻接表记录的是入度，所以找入度易，找出度难。</p><p> <strong>当邻接表的存储结构形成后，图便惟一确定</strong>。</p><p> 根据上述讨论，要定义一个邻接表，需要先定义其存放顶点的头结点和表示边的边结点。图的邻接表存储结构说明如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100           <span class="hljs-comment">// 最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>      <span class="hljs-comment">// 边结点</span><br>&#123;<br>    <span class="hljs-type">int</span> adjvex;             <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>    ArcNode* nextarc;       <span class="hljs-comment">// 指向下一条边的指针</span><br>    OtherInfo info;         <span class="hljs-comment">// 和边相关的信息</span><br>&#125;ArcNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span>        <span class="hljs-comment">// 顶点信息</span><br>&#123;<br>    VerTexType data;<br>    ArcNode *firstarc;      <span class="hljs-comment">// 指向第一条依附于该顶点的边的指针</span><br>&#125;VNode, AdjList[MVNum];     <span class="hljs-comment">// AdjList表示邻接表类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ALGraph</span><br>&#123;<br>    AdjList vertices;       <span class="hljs-comment">// 邻接表数组</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;     <span class="hljs-comment">// 图的当前定点数和边数</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>采用邻接表表示法创建无向图</p><p> 算法思想:</p><ol><li>输入总顶点数和总边数。</li><li>依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。</li><li>创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj对应的两个边链表的头部。</li></ol><blockquote><p>算法实现</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 采用邻接表表示法，创建无向图G</span><br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    <span class="hljs-comment">// 输入总顶点数，总边数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<span class="hljs-comment">// 输入各点，构造表头结点表</span><br>        cin &gt;&gt; G.vertices[i].data;  <span class="hljs-comment">// 输入顶点值</span><br>        G.vertices[i].firstarc = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 初始化各表头结点的指针域为NULL</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++)<br>    &#123;<span class="hljs-comment">// 输入各边，构造邻接表</span><br>        cin &gt;&gt; v1 &gt;&gt; v2;<br>        <span class="hljs-comment">// 确定v1和v2在G中的位置，即顶点在G.vertices中的序号</span><br>        i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        p1 = <span class="hljs-keyword">new</span> ArcNode;   <span class="hljs-comment">// 生成一个新的边结点</span><br>        p1-&gt;adjvex = j;     <span class="hljs-comment">// 邻接点序号为j</span><br>        <span class="hljs-comment">// 将新结点p1插入顶点vi的边表头部</span><br>        p1-&gt;nextarc = G.vertices[i].firstarc;<br>        G.vertices[i].firstarc = p1;<br>        p2 = <span class="hljs-keyword">new</span> ArcNode;   <span class="hljs-comment">// 生成另一个对称的新的边结点</span><br>        p2-&gt;adjvex = i;<br>        <span class="hljs-comment">// 将新结点p2插入顶点vj的边表头部</span><br>        p2-&gt;nextarc = G.vertices[j].firstarc;<br>        G.vertices[j].firstarc = p2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p> 该算法的时间复杂度是O(n + e)。</p><p> 建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号&lt;i,j&gt;，仅需生成一个邻接点序号为j的边表结点，并将其插入到vi；的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。</p></li><li><p>邻接表表示法的优缺点</p><p> 优点：</p><ol><li>便于增加和删除顶点。</li><li>便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n + e)。</li><li>空间效率高。对于一个具有n个顶点e条边的图G，若G是无向图，则在其邻接表表示中有n个顶点表结点和2e个边表结点；若G是有向图，则在它的邻接表表示或逆邻接表表示中均有n个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为O(n + e),适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。</li></ol><p> 缺点：</p><ol><li>不便于判断顶点之间是否有边，要判定vi和vj之间是否有边，就需扫描第i个边表，最坏情况下要耗费O(n)时间。</li><li>不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点vi的度是第i个边表中的结点个数。在有向图的邻接表中，第i个边表上的结点个数是顶点vi的出度，但求vi的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。</li></ol></li><li><p>邻接矩阵与邻接表示法的关系</p><ol><li><p><strong>联系</strong>：邻接表中每个链表对应邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p></li><li><p><strong>区别</strong>：</p><ul><li><p>对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。</p></li><li><p>邻接矩阵的空间复杂度为O(n^2)，而领接表的空间复杂度为O(n+e)；</p></li></ul></li><li><p><strong>用途</strong>：邻接矩阵多用于稠密图；而邻接表多用于稀疏图。</p></li></ol></li></ol><h3 id="6-4-3-十字链表"><a href="#6-4-3-十字链表" class="headerlink" title="6.4.3 十字链表"></a>6.4.3 十字链表</h3><p><strong>十字链表</strong>(<strong>Orthogonal List</strong>)是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。</p><p><strong>有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点</strong>。</p><p>在弧结点中有5个域：其中尾域(tailvex)和头域(headvex)分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink指向弧尾相同的下一条弧，info域指向该弧的相关信息。</p><p>头结点即顶点结点，它由3个域组成：其中data域存储和顶点相关的信息，如顶点的名称等；firstin和firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。</p><h3 id="6-4-4-邻接多重表"><a href="#6-4-4-邻接多重表" class="headerlink" title="6.4.4 邻接多重表"></a>6.4.4 邻接多重表</h3><p><strong>邻接多重表</strong>(<strong>Adjacency Multilist</strong>)是无向图的另一种链式存储结构。</p><p>邻接多重表的结构和十字链表类似。在邻接多重表中，每一条边用一个结点表示。其中，mark为标志域，可用以标记该条边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域。</p><p>每一个顶点也用一个结点表示，其中，data域存储和该顶点相关的信息，firstedge域指示第一条依附于该顶点的边。</p><h2 id="6-5-图的遍历"><a href="#6-5-图的遍历" class="headerlink" title="6.5 图的遍历"></a>6.5 图的遍历</h2><p>和树的遍历类似，图的遍历也是从图中某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。</p><p>为避免重复访问，可设置辅助数组visited[n]，用来标记每个被访问过的顶点。</p><ul><li>初始状态visited[i]为0；</li><li>顶点i被访问，改visited[i]为1，防止被多次访问</li></ul><p>根据搜索路径的方向，通常有两条遍历图的路径：深度优先搜索和广度优先搜索。它们对无向图和有向图都适用。</p><h3 id="6-5-1-深度优先搜索"><a href="#6-5-1-深度优先搜索" class="headerlink" title="6.5.1 深度优先搜索"></a>6.5.1 深度优先搜索</h3><ol><li><p>深度优先搜索遍历的过程</p><p> <strong>深度优先搜索</strong>(<strong>DepthFirst Search, DFS</strong>)遍历类似于树的先序遍历，是树的先序遍历的推广。对于一个连通图，深度优先搜索遍历的过程如下：</p><ol><li><p>从图中某个顶点v出发，访问v。</p></li><li><p>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。</p></li><li><p>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</p></li><li><p>重复步骤(2)和(3),直至图中所有顶点都被访问过，搜索结束。</p></li></ol></li><li><p>深度优先搜索遍历的算法实现</p><p> 显然，深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为”false，一旦某个顶点被访问，则其相应的分量置为”true”。</p><p> 算法6.3 深度优先搜索遍历连通图</p><p> 算法步骤：</p><ol><li><p>从图中某个顶点v出发，访问v，并置visited[v]的值为true。</p></li><li><p>依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历，直到图中所有顶点都被访问过。</p></li></ol> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> visited[MVNum];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(w = <span class="hljs-built_in">FitstAdjVex</span>(G, v); w &gt;= <span class="hljs-number">0</span>; w = <span class="hljs-built_in">NextAdjVex</span>(G, v, w))<br>        <span class="hljs-keyword">if</span>(!visited[w])<br>            <span class="hljs-built_in">DFS</span>(G, w);<br>&#125;<br></code></pre></td></tr></table></figure><p> 算法6.4 深度优先搜索遍历非连通图</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFSTracerse</span><span class="hljs-params">(Graph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v &lt; G.vexnum; ++v)<br>    &#123;<br>        visited[v] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v &lt; G.vexnum; ++v)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!visited[v])<br>            <span class="hljs-built_in">DFS</span>(G, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 算法6.5 采用邻接矩阵表示图的深度优先搜索遍历</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFs</span><span class="hljs-params">(AMGraph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>; w &lt; G.vexnum; w++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((G.arcs[v][w] != <span class="hljs-number">0</span>) &amp;&amp; (!visited[w]))<br>        &#123;<br>            <span class="hljs-built_in">DFS</span>(G, w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在的行，时间复杂度为O(n^2)。</p><p> 算法6.6 采用邻接表表示图的深度优先搜索遍历</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS_AL</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 图G为邻接表类型，从第v个顶点出发深度优先搜索遍历图G</span><br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    p = G.vertices[v].firstarc;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        w = p-&gt;adjvex;      <span class="hljs-comment">// 表示w是v的邻接点</span><br>        <span class="hljs-keyword">if</span>(!visited[w])<br>            <span class="hljs-built_in">DFS</span>(G,w);<br>        p = p-&gt;nextarc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问个头结点的时间，时间复杂度为O(n+e)。</p><p> 因此，<strong>稠密图适于在邻接矩阵上进行深度遍历</strong>，<strong>稀疏图适于在邻接表上进行深度遍历</strong>。</p></li></ol><h3 id="6-5-2-广度优先搜索"><a href="#6-5-2-广度优先搜索" class="headerlink" title="6.5.2 广度优先搜索"></a>6.5.2 广度优先搜索</h3><ol><li><p>广度优先搜索遍历的过程</p><p> <strong>广度优先搜索</strong>(<strong>Breadth First Search, BFS</strong>)遍历类似于树的按层次遍历的过程。广度优先搜索遍历的过程如下：</p><ol><li><p>从图中某个顶点v出发，访问v。</p></li><li><p>依次访问v的各个未曾访问过的邻接点。</p></li><li><p>分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤(3)，直至图中所有已被访问的顶点的邻接点都被访问到。</p></li></ol></li><li><p>广度优先搜索遍历的算法实现</p><p> 算法6.7 广度优先搜索遍历连通图</p><p> 算法步骤：</p><ol><li><p>从图中某个顶点v出发，访问v，并置visited[v]的值为true，然后将v进队。</p></li><li><p>只要队列不空，则重复下述操作：</p><ul><li><p>队头顶点u出队；</p></li><li><p>依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。</p></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">InitQueue</span>(Q);<br>    <span class="hljs-built_in">EnQueue</span>(Q, v);  <span class="hljs-comment">//v入队</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(Q))<br>    &#123;<br>        <span class="hljs-built_in">DeQueue</span>(Q, u);  <span class="hljs-comment">// 队首元素出队并置为u</span><br>        <span class="hljs-keyword">for</span>(w = <span class="hljs-built_in">FirstAdjVex</span>(G, u); w &gt;= <span class="hljs-number">0</span>; <span class="hljs-built_in">NextAdjVex</span>(G, u, w))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[w])<br>            &#123;<br>                cout &lt;&lt; w;<br>                visited[w] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">EnQueue</span>(Q, w);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 遍历图的过程实质上是通过边找邻接点的过程，因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，即当用邻接矩阵存储时，时间复杂度为O(n^2)；用邻接表存储时，时间复杂度为O(n+e)。</p></li></ol><h3 id="6-5-3-DFS与BFS算法效率比较"><a href="#6-5-3-DFS与BFS算法效率比较" class="headerlink" title="6.5.3 DFS与BFS算法效率比较"></a>6.5.3 DFS与BFS算法效率比较</h3><ul><li><p>空间复杂度相同，都是O(n)（借用了堆栈或队列）；</p></li><li><p>时间复杂度只与存储结构、（邻接矩阵或邻接表）有关，而与搜索路径无关。</p></li></ul><h2 id="6-6-图的应用"><a href="#6-6-图的应用" class="headerlink" title="6.6 图的应用"></a>6.6 图的应用</h2><h3 id="6-6-1-最小生成树"><a href="#6-6-1-最小生成树" class="headerlink" title="6.6.1 最小生成树"></a>6.6.1 最小生成树</h3><p>生成树的共同特点：</p><ul><li><p>顶点个数与图的顶点个数相同；</p></li><li><p>是图的极小连通子图，去掉一条边则非连通；</p></li><li><p>一个有n个顶点的连通图的生成树有n-1条边；</p></li><li><p><strong>在生成树中再加一条边必然形成回路</strong>；</p></li><li><p>生成树中的任意两个顶点间的路径是惟一的。</p></li></ul><p>在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的<strong>最小代价生成树</strong>(<strong>Minimum Cost Spanning Tree</strong>)，简称为<strong>最小生成树</strong>。</p><p>构造最小生成树有多种算法，其中多数算法利用了最小生成树的下列一种简称为MST的性质：假设N&#x3D;(V, E)是一个连通网，U是顶点集V的一个非空子集。若(u, v)是一条具有最小权值（代价）的边，其中u∈U，v∈V-U，则必存在一棵包含边(u, v)的最小生成树。</p><p>MST性质解释：</p><p>在生成树的构造过程中，图中n个顶点分属两个集合：</p><ul><li><p>已落在生成树上的顶点集：U</p></li><li><p>尚未落在生成树上的顶点集：V-U</p></li></ul><p>接下来则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。</p><p>普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法是两个利用MST性质构造最小生成树的算法。下面先介绍普里姆算法。</p><ol><li><p>普里姆算法</p><p> 普里姆算法的构造过程：</p><p> 假设N&#x3D;(V,E)是连通网，TE是N上最小生成树中边的集合。</p><ol><li><p>U &#x3D; {u0}(u0∈V), TE &#x3D; {}。</p></li><li><p>在所有u∈U, v∈V- U的边(u,v)∈E中找一条权值最小的边(u0,v0)并入集合TE，同时v0并入U。</p></li><li><p>重复步骤2，直至U &#x3D; V为止。</p></li></ol><p> 此时TE中必有n-1条边，则T&#x3D; (V, TE)为N的最小生成树。</p><p> 普里姆算法的算法实现：</p><p> 假设一个无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，要求输出T的各条边。为实现这个算法需附设一个辅助数组closedge，以记录从U到V-U具有最小权值的边。对每个顶点vi∈V- U，在辅助数组中存在一个相应分量closedge[i-1], 它包括两个域：lowcost和adjvex，其中Iowcost存储最小边上的权值，adjvex存储最小边在U中的那个顶点。显然，closedge[i-1].lowcost &#x3D; Min{ cost(u, vi)|u∈U}，其中cost(u,v)表示赋于边(u,v)的权。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边</span><br><br><span class="hljs-keyword">struct</span><br>&#123;<br>    VerTexType adjvex;      <span class="hljs-comment">// 最小边在U中的那个顶点</span><br>    ArcType lowcost;        <span class="hljs-comment">// 最小边上的权值</span><br>&#125;closedge[MVNum];<br></code></pre></td></tr></table></figure><p> 算法6.8 普里姆算法</p><ol><li><p>首先将初始顶点u加入U中，对其余的每一个顶点Vj，将closedge[j]均初始化为到u的边息。</p></li><li><p>循环n - 1次，做如下处理：</p><ul><li><p>从各组边closedge中选出最小边closedge[k]，输出此边；</p></li><li><p>将k加入U中；</p></li><li><p>更新剩余的每组最小边信息closedge[j]，对于V-U中的边，新增加了一条从k到j的边，如果新边的权值比closedge[i].lowcost小，则将closedge[j].lowcost 更新为新边的权值。</p></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree_Prim</span><span class="hljs-params">(AMGraph G, VerTexType u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边</span><br>    k = <span class="hljs-built_in">LocateVex</span>(G, u);        <span class="hljs-comment">// k为顶点u的下标</span><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(j != k) closedge[j] = &#123;u, G.arcs[k][j]&#125;;<br>        closedge[k].lowcost = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 初始，U=&#123;u&#125;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.vexnum; ++i)<br>        &#123;<br>            <span class="hljs-comment">// 求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边</span><br>            u0 = closedge[k].adjvex;    <span class="hljs-comment">// u0为最小边的一个顶点</span><br>            v0 = G.vexs[k];             <span class="hljs-comment">// v0为最小边的另一个顶点</span><br>            cout &lt;&lt; u0 &lt;&lt; v0;<br>            closedge[k].lowcost = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(G.arcs[k][j] &lt; closedge[j].lowcost)<br>                &#123;<br>                    closedge[j] = &#123;G.vexs[k], G.arcs[k][j]&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>克鲁斯卡尔算法</p><p> 算法步骤：</p><ol><li><p>将数组Edge中的元素按权值从小到大排序。</p></li><li><p>依次查看数组Edge中的边，循环执行以下操作：</p><ul><li><p>依次从排好序的数组Edge中选出一条边(U1,U2)；</p></li><li><p>在Vexset中分别查找V1和V2所在的连通分量vs1和vs2，进行判断：</p><ul><li><p>如果vs1和vs2不等，表明所选的两个顶点分属不同的连通分量，输出此边，并合并vs1和vs2两个连通分量；</p></li><li><p>如果vs1和vs2相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。</p></li></ul></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree_Kruskal</span><span class="hljs-params">(AMGraph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Sort</span>(Edge); <span class="hljs-comment">// 将数组Edge中的元素按权值从小到大排序</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; G.arcnum; i++)<br>    &#123;<br>        v1 = <span class="hljs-built_in">LocateVex</span>(G, Edge[i].Head);    <span class="hljs-comment">// v1为边的始点Head的下标</span><br>        v2 = <span class="hljs-built_in">LocateVex</span>(G, Edge[i].Tail);    <span class="hljs-comment">// v2为边的始点Head的下标</span><br>        vs1 = Vexset[v1];   <span class="hljs-comment">// 获取边Edge[i]的始点所在的连通分量vs1</span><br>        vs2 = Vexset[v2];   <span class="hljs-comment">// 获取边Edge[i]的始点所在的连通分量vs2</span><br>        <span class="hljs-keyword">if</span>(vs1 != vs2)<br>        &#123;<br>            cout &lt;&lt; Edge[i].Head &lt;&lt; Edge[i].Tail;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(Vexset[j] == vs2)<br>                    Vexset[j] = vsl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302141915180.png"></p><h3 id="6-6-2-最短路径"><a href="#6-6-2-最短路径" class="headerlink" title="6.6.2 最短路径"></a>6.6.2 最短路径</h3><p>问题抽象：在有向网中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。</p><p>在带权有向网中，习惯上称路径上的第一个顶点为源点(Source)，最后一个顶点为终点(Destination)。</p><p>针对单源最短路径一用Dijkstra(迪杰断特拉)算法；针对所有顶点间的最短路径一用Floyd(弗洛伊德)算法。</p><ol><li><p>Dijistra算法</p><ol><li><p>初始化：先找出从源点v0到各终点vk的直达路径(v0,vk)，即通过一条弧到达的路径；</p></li><li><p>选择：从这些路径中找出一条长度最短的路径(v0,u)；</p></li><li><p>更新：然后对其余各条路径进行适当调整：</p><p> 若在图中存在弧(u,vk)，且(v0,u)+(u,vk)&lt;(v0,vk)，则以路径(v0,u，vk)代替(v0,vk)。</p></li></ol><p> 在调整后的各条路径中，再找长度最短的路径，依此类推。</p><p> <strong>Dijistra算法：按照长度递增次序产生最短路径。</strong></p><ol><li><p>把V分成两组：</p><p> (1) S：已求出最短路径的顶点的集合；</p><p> (2)T&#x3D;V - S：尚未确定最短路径的顶点解和。</p></li><li><p>将T中顶点按最短路径递增的次序加入到S中</p><p> 保证：a. 从源点v0到S中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。</p><p> b. 每个顶点对应一个距离值：S中顶点：从v0到此顶点的最短路径；T中顶点：从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。</p></li></ol></li><li><p>Floyd算法</p><ol><li><p>初始时设置一个n阶方阵，令其对角线元素为0，若存在弧&lt;vi, vj&gt;，则对应元素为全职，否则为正无穷。</p></li><li><p>逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之；否则，维持原值。所有顶点试探完毕，算法结束。</p></li></ol></li></ol><h3 id="6-6-3-拓扑排序"><a href="#6-6-3-拓扑排序" class="headerlink" title="6.6.3 拓扑排序"></a>6.6.3 拓扑排序</h3><p>拓扑排序针对有向无环图。<strong>有向无环图</strong>：无环的有向图，简称DAG图（Directed Acycline Graph）。</p><p>有向无环图常用来描述一个工程或系统的进行过程。（通常把计划、施工、生产、程序流程等当成是一个工程）一个工程可以分为若干个子工程，只要完成了这些子工程（活动），就可以导致整个工程的完成。</p><p><strong>AOV网</strong>（拓扑排序）：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以<strong>顶点表示活动</strong>，<strong>弧表示活动之间的优先制约关系</strong>，称这种有向图为<strong>顶点表示活动的网</strong>，简称AOV网（Activity On Vertex network）。</p><p><strong>AOE网</strong>（关键路径）：用一个有向图表示一个工程的各子工程及其相互制约的关系，<strong>以弧表示活动</strong>，<strong>以顶点表示活动的开始或结束事件</strong>，称这种有向图为<strong>边表示活动的网</strong>，简称为AOE网（Activity On Edge）。</p><ol><li><p>AOV网的特点</p><ul><li><p>若从i到j有一条有向路径，则i是j的前驱，j是i的后继；</p></li><li><p>若&lt;i, j&gt;是网中有向边，则i是j的直接前驱，j是i的直接后继；</p></li><li><p>AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。</p></li></ul></li><li><p>拓扑排序</p><p> 在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧&lt;i, j&gt;存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为<strong>拓扑有序序列</strong>，相应的拓扑有序排序的算法称为<strong>拓扑排序</strong>。</p><p> 拓扑排序方法：</p><ul><li><p>在有向图中选一个没有前驱的顶点且输出之；</p></li><li><p>从图中删除该顶点和所有以它为尾的弧；</p></li><li><p>重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止。</p></li></ul><p> 检测AOV网中是否存在环：对有向图构造其顶点得拓扑有序序列，若网中所有顶点都在它得拓扑有序序列中，则该AOV网必定不存在环。</p></li><li><p>关键路径</p><p> 把工程计划表示为<strong>边表示活动的网络</strong>，即<strong>AOE网</strong>，用<strong>顶点表示事件</strong>，<strong>弧表示活动</strong>，<strong>弧的权表示活动持续时间</strong>。</p><p> 针对AOE网，主要关心两方面问题：完成整项工程至少需要多少时间；哪些活动是影响工程进度的关键。</p><p> 确定关键路径的4个描述量：ve(vj)表示事件vj的最早发生时间；vl(vj)表示事件vj的最晚发生时间；e(i)表示活动ai的最早开始时间；l(i)表示活动ai的最迟开始时间，则l(i)-e(i)表示完成活动ai的时间余量。</p><p> <strong>关键活动</strong>：关键路径上的活动，即l(i)&#x3D;&#x3D;e(i)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树——王卓</title>
    <link href="/2022/10/13/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第5章-树和二叉树"><a href="#第5章-树和二叉树" class="headerlink" title="第5章 树和二叉树"></a>第5章 树和二叉树</h1><h2 id="5-1-树与二叉树的定义"><a href="#5-1-树与二叉树的定义" class="headerlink" title="5.1 树与二叉树的定义"></a>5.1 树与二叉树的定义</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><p>树(非线性结构)是以分支关系定义的层次结构：结点之间有分支、具有层次关系。</p><blockquote><p>树的定义</p></blockquote><p>树(Tree)是n(n≥0)个结点的<strong>有限集</strong>。</p><ul><li><p>若n&#x3D;0，称为空树；</p><ul><li>若n&gt;0，则它满足如下两个条件：</li></ul><ol><li><p><strong>有且仅有一个</strong>特定的称为根(Root)的结点；</p></li><li><p><strong>其余结点</strong>可分m(m≥0)个互不相交的有限集T1，T2，T3…Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)。</p></li></ol></li></ul><p>树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还可有其他的表示形式：嵌套集合表示<br>（即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）；广义表的形式表示，根作为由子树森林组成的表的名字写在表的左边；凹入表示法（类似书的编目）。</p><h3 id="5-1-2-树的基本术语"><a href="#5-1-2-树的基本术语" class="headerlink" title="5.1.2 树的基本术语"></a>5.1.2 树的基本术语</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121460.png"></p><ol><li><p><strong>根节点</strong>：非空树中无前驱结点的结点；</p></li><li><p><strong>结点</strong>：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支，如图中的A 、B 、C 、D等。</p></li><li><p><strong>结点的度</strong>：结点拥有的子树数称为结点的度。例如，A的度为3，C的度为1，F的度为0。</p></li><li><p><strong>树的度</strong>：树的度是树内各结点度的最大值。图中所示的树的度为3。</p></li><li><p><strong>叶子</strong>：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。</p></li><li><p><strong>非终端结点</strong>：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。</p></li><li><p><strong>父亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的父亲。例如，B的双亲为A，B的孩子有E和F。</p></li><li><p><strong>兄弟</strong>：同一个父亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。</p></li><li><p><strong>祖先</strong>：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。</p></li><li><p><strong>子孙</strong>：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。</p></li><li><p><strong>层次</strong>：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其父亲结点的层次加1。</p></li><li><p><strong>堂兄弟</strong>：父亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。</p></li><li><p><strong>树的深度</strong>：树中结点的最大层次称为<strong>树的深度或高度</strong>。图中所示的树的深度为4。</p></li><li><p><strong>有序树和无序树</strong>：如果将树中结点的各子树从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</p></li><li><p><strong>森林</strong>：是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。</p></li></ol><blockquote><p>树结构和线性结构的比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131122180.png"></p><h3 id="5-1-3-二叉树的定义"><a href="#5-1-3-二叉树的定义" class="headerlink" title="5.1.3 二叉树的定义"></a>5.1.3 二叉树的定义</h3><p>引入二叉树的原因：</p><ul><li><p>二叉树的结构最简单，规律性最强；</p></li><li><p>可以证明，所有树都能转为唯一对应的二叉树，不失一般性。</p></li></ul><p>二叉树是n(n≥0)个结点的有限集，它或者是空集(n&#x3D;0)，或者由一个根结点及<strong>两棵互不相交</strong>的分别称作这个根的左子树和右子树的二又树组成。</p><ol><li><p>每个结点最多有俩孩子，二叉树中不存在度大于2的结点。</p></li><li><p>子树有左右之分，其次序不能颠倒。</p></li><li><p>二叉树可以是空集合，根可以有空的左子树或空的右子树。</p></li></ol><p>二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。</p><p>需要注意的是：<strong>二叉树不是树的特殊情况，与树是两个概念</strong>。</p><p>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要区分，说明它是左子树，还是右子树。</p><p>树中当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</p><p>因此，考虑到二叉树的特点，思考：具有三个结点的二叉树可能有几种不同形态？普通树有几种不同形态？</p><p>二叉树有五种形态；树有两种形态：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123376.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123841.png"></p><blockquote><p>二叉树的5种基本形态</p></blockquote><p>二叉树的5种基本形态包括有：空二叉树、根和空的左右子树、根和左子树、根和右子树、根和左右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131124877.png"></p><p>似于二叉树，因此可以利用二叉树来表示表达式。</p><h2 id="5-3-树和二叉树的抽象数据类型定义"><a href="#5-3-树和二叉树的抽象数据类型定义" class="headerlink" title="5.3 树和二叉树的抽象数据类型定义"></a>5.3 树和二叉树的抽象数据类型定义</h2><p>根据树的结构定义，加上树的一组基本操作就构成了树的抽象数据类型定义。</p><pre><code class="hljs">ADT BinaryTree&#123;    // 数据对象D：    // 数据关系R：    // 基本操作P：&#125;ADT BinaryTree;</code></pre><h2 id="5-4-二叉树的性质和存储结构"><a href="#5-4-二叉树的性质和存储结构" class="headerlink" title="5.4 二叉树的性质和存储结构"></a>5.4 二叉树的性质和存储结构</h2><h3 id="5-4-1-二叉树的性质"><a href="#5-4-1-二叉树的性质" class="headerlink" title="5.4.1 二叉树的性质"></a>5.4.1 二叉树的性质</h3><p>性质1：在二叉树的第i层上至多有2^(i-1)个结点(i≥1)</p><p>性质2：深度为k的二叉树一共至多有2^k-1 个结点(k≥1)</p><p>性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 &#x3D; n2+1。即叶子结点的数目等于度为2的结点数为n2，再加1。</p><blockquote><p>两种特殊形式的二叉树</p></blockquote><ol><li><p>满二叉树</p><p> 满二叉树：深度为k且含有2^k-1个结点的二叉树。</p><p> 特点：</p><ul><li><p>每一层上的结点数都是最大结点数（即每层都满）</p></li><li><p>叶子节点全部在最底层。</p></li></ul><p> 对满二叉树结点位置进行编号，按照从根结点开始，自<strong>上而下，自左而右</strong>进行编号，可以发现每一结点位置都有元素。</p><p> 满二叉树在同样深度的二叉树中<strong>结点个数最多</strong>。</p><p> 满二叉树在同样深度的二叉树中<strong>叶子结点个数最多</strong>。</p></li><li><p>完全二叉树</p><p> 完全二叉树：深度为k的，有n个结点的二叉树，当且仅当其<strong>每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时</strong>，称之为完全二叉树。</p><p> 同理，在满二叉树中，从最后一个结点开始，<strong>连续去掉任意</strong>个结点，即是一棵完全二叉树。</p><p> 完全二叉树的特点是：</p><ul><li><p>叶子结点只可能在层次最大的两层上出现；</p></li><li><p>对任一结点，若其右分支下的子孙(即右子树)的最大层次为i，则其左分支下的子孙(左子树)的最大层次必为i或i+1。</p></li></ul></li></ol><p>性质4：具有n个结点的完全二叉树的深度为⌊log2n⌋ + 1。<br>注：⌊x⌋ 称作x的底，表示不大于x的最大整数</p><p>性质5：如果对一棵有n个结点的完全二叉树(其深度为⌊log2n⌋+ 1)的结点按层序编号(从第1层到第⌊log2n⌋+1层，每层从左到右)，则对任一结点i(1≤i≤n)，有：</p><ol><li><p>如果i&#x3D;1，则结点1是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点⌊i&#x2F;2⌋。</p></li><li><p>如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i。</p></li><li><p>如果2i+1&gt;n，则结点无右孩子；否则其右孩子是结点2i+1。</p></li></ol><p>性质5表明了完全二叉树中<strong>双亲结点编号与孩子结点编号</strong>之间的关系。</p><h3 id="5-4-2-二叉树的存储结构"><a href="#5-4-2-二叉树的存储结构" class="headerlink" title="5.4.2 二叉树的存储结构"></a>5.4.2 二叉树的存储结构</h3><p>二叉树的存储结构主要有顺序存储结构和链式存储结构，其中链式存储结构又分为二叉链表和三叉链表。</p><p>二叉树的顺序存储实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树顺序存储表示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br>Typedef TElemType SqBiTree[MAXSIZE];<br>SqBiTree bt;<br></code></pre></td></tr></table></figure><p>二叉树的顺序存储缺点：存储密度低，适合存储满二叉树和完全二叉树。</p><blockquote><p>二叉树的链式存储结构</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span>&#123;<br>    TElemType data;<br>    BiNode *lchild, *rchild;<br>&#125;BiNode, *BiTree;<br></code></pre></td></tr></table></figure><p>在n个结点的二叉表中，有n+1个空指针域。</p><p>三叉链表即在二叉链表的基础上增加一个指向父节点的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriNode</span>&#123;<br>    TElemType data;<br>    TriNode *lchild, *parent, *rchild;<br>&#125;TriNode, *TriTree;<br></code></pre></td></tr></table></figure><h2 id="5-5-遍历二叉树和线索二叉树"><a href="#5-5-遍历二叉树和线索二叉树" class="headerlink" title="5.5 遍历二叉树和线索二叉树"></a>5.5 遍历二叉树和线索二叉树</h2><h3 id="5-5-1-遍历二叉树"><a href="#5-5-1-遍历二叉树" class="headerlink" title="5.5.1 遍历二叉树"></a>5.5.1 遍历二叉树</h3><ul><li><p>遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。</p></li><li><p>遍历目的：得到树中所有结点的一个线性排列。</p></li><li><p>遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p></li><li><p>遍历方法：规定在先左后右的情况下，主要遍历方法有三种：先序遍历、中序遍历、后序遍历。</p></li></ul><ol><li>三种遍历方法描述如下：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131125028.png"></p><ol><li><p>先序遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>访问根节点；</p></li><li><p>先续遍历左子树；</p></li><li><p>先续遍历右子树。</p></li></ol></li><li><p>中序遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>中序遍历左子树；</p></li><li><p>访问根结点；</p></li><li><p>中序遍历右子树。</p></li></ol></li><li><p>后续遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>后续遍历左子树；</p></li><li><p>后续遍历右子树；</p></li><li><p>访问根结点。</p></li></ol></li><li><p>根据遍历顺序确定二叉树</p><ul><li><p>若二叉树中各结点的值均不同，则二叉树结点的先序序列、中序序列、后序列都是唯一的。</p></li><li><p>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树（一定要有中序序列）</p></li></ul><p> 例题：已知二叉树的先序和中序序列，构造出相应的二叉树：<strong>可以先由先序序列确定根，由中序确定左右子树</strong>。</p><p> 已知中序序列和后序序列，<strong>由后序遍历可知，根结点必在后续序列尾部</strong>。</p></li><li><p>遍历的算法实现——先序遍历</p><p> 二叉树先续遍历算法（递归）</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历算法实现——中序遍历</p><p> 二叉树中序遍历算法（递归）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>遍历算法实现——后序遍历</p><p> 二叉树后序遍历算法（递归）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li><p>遍历算法分析</p><ul><li><p>如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。</p></li><li><p>时间效率：O(n)；每个结点只访问一次</p></li><li><p>空间效率：O(n)；栈占用的最大辅助空间</p></li></ul></li><li><p>遍历二叉树的非递归算法</p><p> 中序遍历非递归算法：二叉树中序遍历的非递归算法的关键在于：<strong>在中序遍历过某节点的整个左子树后，如何找到该接点的根以及右子树</strong>。</p><p> 基本思想：</p><ul><li><p>建立一个空栈S，指针p指向根结点</p></li><li><p>申请一个结点空间q，用来存放栈顶弹出的元素。</p></li><li><p>当p非空或者栈S非空时，循环执行以下操作：</p><ul><li><p>如果p非空，则将p进栈，p指向该结点的左孩子；</p></li><li><p>如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。</p></li></ul></li></ul><p> 中序遍历非递归算法实现：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    BiTree p; <span class="hljs-built_in">InitStack</span>(S); p = T;<br>    <span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 不为空</span><br>            <span class="hljs-built_in">Push</span>(S, p);<br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">Pop</span>(S, q);<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%c&quot;</span>, q-&gt;data);<br>            p = q-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。</code></pre><ol start="8"><li><p>二叉树的层次遍历</p><p> 对于一颗二叉树，从根结点开始，按<strong>从上到下、从左到右</strong>的顺序访问每一个结点。每一个结点仅仅访问一次。</p><p> 算法思路：</p><ul><li><p>将根结点入队；</p></li><li><p>队不为空时循环：从队列中出列一个结点*p，访问它：</p><ul><li><p>若它右左孩子结点，将左孩子结点入队；</p></li><li><p>若它有右孩子结点，将右孩子结点入队。</p></li></ul></li></ul><p> 二叉树层次遍历算法实现：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    BTNode data[MaxSize];   <span class="hljs-comment">// 存放队中元素</span><br>    <span class="hljs-type">int</span> front, rear;        <span class="hljs-comment">// 队头和队尾指针</span><br>&#125;SqQueue;   <span class="hljs-comment">// 顺序循环队列类型</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BTNode *b)</span></span>&#123;<br>    BTNode* p;<br>    SqQueue* qu;<br>    <span class="hljs-built_in">InitQueue</span>(sqQueue); <span class="hljs-comment">// 初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(qu, b);     <span class="hljs-comment">// 根结点指针入队</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;<br>        <span class="hljs-comment">// 队不为空，则循环</span><br>        <span class="hljs-built_in">deQueue</span>(qu, p); <span class="hljs-comment">// 出队结点p</span><br>        cout &lt;&lt; p-&gt;data;<br>        <span class="hljs-keyword">if</span>(p-&gt;lchild != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 有左孩子时将其入队</span><br>            <span class="hljs-built_in">enQueue</span>(qu, p-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;rchild != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 有右孩子时将其入队</span><br>            <span class="hljs-built_in">enQueue</span>(qi, p-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li><p>二叉树遍历算法的应用——二叉树的建立(算法5.3)</p><p> 按照先续遍历序列建立二叉树的二叉链表</p><p> 算法步骤：</p><ul><li><p>扫描字符序列，读入字符，建立二叉树的存储结构；</p></li><li><p>如果ch是一个”#”字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：在建立二叉树的过程中按照二叉树先序方式建立：</p><ul><li><p>申请一个结点空间T；</p></li><li><p>将ch赋给T-&gt;data；</p></li><li><p>递归创建T的左子树</p></li><li><p>递归创建T的右子树</p></li></ul></li></ul><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree&amp; T)</span></span>&#123;<br>    <span class="hljs-comment">// 按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span><br>    cin &gt;&gt; ch;<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&quot;#&quot;</span>) T = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 递归结束，建空树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 递归创建二叉树</span><br>        T = <span class="hljs-keyword">new</span> BiTree; <span class="hljs-comment">// 生成根结点</span><br>        T-&gt;data = ch;   <span class="hljs-comment">// 根结点数据域置为ch</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<span class="hljs-comment">// 递归创建左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<span class="hljs-comment">// 递归创建右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——复制二叉树(算法5.4)</p><p>算法步骤：</p><p>如果是空树，递归结束，否则执行以下操作：</p><ul><li><p>申请一个新结点空间， 复制根结点；</p></li><li><p>递归复制左子树；</p></li><li><p>递归复制右子树。</p></li></ul><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Copy</span><span class="hljs-params">(BiTree T, BiTree&amp; NewT)</span></span>&#123;<br>    <span class="hljs-comment">// 复制一棵和T完全相同的二叉树</span><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 如果是空树，递归结束</span><br>        newT = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        newT = <span class="hljs-keyword">new</span> BoTree;<br>        newT-&gt;data = T-&gt;data;<span class="hljs-comment">// 复制根结点</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;lchild, newT-&gt;lchild);<span class="hljs-comment">// 递归复制左子树</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;rchild, newT-&gt;rchild);<span class="hljs-comment">// 递归复制左子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——计算二叉树的深度(算法5.5)</p><p>如果是空树，递归结束，深度为0，否则执行以下操作：</p><ul><li><p>递归计算左子树的深度记为m；</p></li><li><p>递归计算右子树的深度记为n;</p></li><li><p>如果m大于n，二叉树的深度为m+1，否则为n+1。</p></li></ul><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-comment">// 计算二叉树T的深度</span><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m = <span class="hljs-built_in">Depth</span>(T-&gt;lchild);   <span class="hljs-comment">// 递归计算左子树的深度记为m</span><br>        n = <span class="hljs-built_in">Depth</span>(T-&gt;rchild);   <span class="hljs-comment">// 递归计算右子树的深度记为n</span><br>        <span class="hljs-keyword">if</span>(m &gt; n) <span class="hljs-keyword">return</span>(m+<span class="hljs-number">1</span>);  <span class="hljs-comment">// 二叉树深度为m与n的较大者加1</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">return</span> (n+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。</p></li><li><p>二叉树遍历算法的应用——统计二叉树结点的个数(算法5.6)</p><p>如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上1。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NodeCount</span>(T-&gt;lchild) + <span class="hljs-built_in">NodeCount</span>(T-&gt;rchild) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——统计二叉树叶子结点的个数(补充算法)</p><p>如果是空树，则结点个数为0；否则，结点个数为左子树的叶子结点个数加上右子树的叶子结点个数再加上1。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeafCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-comment">// 如果是叶子节点返回1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCount</span>(T-&gt;lchild) + <span class="hljs-built_in">LeafCount</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-2-线索二叉树"><a href="#5-5-2-线索二叉树" class="headerlink" title="5.5.2 线索二叉树"></a>5.5.2 线索二叉树</h3><ol><li><p>线索二叉树的基本概念</p><p> 遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。</p><p> 但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点<strong>在任一序列中的前驱和后继信息</strong>，这种信息只有在遍历的动态过程中才能得到，为此<strong>引入线索二叉树来保存这些在动态过程中得到的（任一序列中的）有关前驱和后继的信息</strong>。</p><p> 由于有n个结点的二叉链表中必定存在n+1个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息。可做如下规定：若结点有左子树，则其lchild域指示其左孩子，<strong>否则令lchild域指示其前驱</strong>；若结点有右子树，则其rchild域指示其右孩子，<strong>否则令rchild域指示其后继</strong>。同时，为了避免混淆，尚需改变结点结构，增加两个标志域：LTag和RTag，其中标志位为0表示存储的为左&#x2F;右孩子，为1表示存储的为前驱&#x2F;后继。</p><p> 这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树(Threaded Binary Tree)，对二叉树按某种遍历次序使其变为线索二叉树的过程叫<strong>线索化</strong>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树的二叉线索存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span><br>&#123;<br>    TElemType data;<br>    BiThrNode *lchild, *rchild;<br>    <span class="hljs-type">int</span> LTag, RTag;<br>&#125;BiThrNode, *BiThrTree;<br></code></pre></td></tr></table></figure><p> 以下为先序线索二叉树、中序线索二叉树、后序线索二叉树示意图。</p></li></ol><ul><li><p>先序线索二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131126344.png"></p></li><li><p>中序线索二叉树</p></li><li><p>后序线索二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127045.png"></p></li></ul><p>为了方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其<strong>lchild域的指针指向二叉树的根结点</strong>，其<strong>rchild域的指针指向遍历遍历时访问的最后一个结点</strong>；同时，<strong>令二叉树遍历序列中第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点</strong>。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。</p><pre><code class="hljs">即其中LTag = 0，lchild指向根结点；RTag = 1，rchild指向遍历序列中最后一个结点。</code></pre><ol start="2"><li><p>构造线索二叉树</p><p> TODO</p></li></ol><h2 id="5-6-树和森林"><a href="#5-6-树和森林" class="headerlink" title="5.6 树和森林"></a>5.6 树和森林</h2><p>树(Tree)是n(n≥0)个结点的有限集。若n&#x3D;0，称为空树。</p><p>若n&gt;0，当有且仅有一个特定的称为根(root)的结点；其余结点可分为m(m≥0)个互不相交的有限集T1，T2，T3，…，Tm</p><p>森林是m(m≥0)个互不相交的树的集合。</p><h3 id="5-6-1-树的存储结构"><a href="#5-6-1-树的存储结构" class="headerlink" title="5.6.1 树的存储结构"></a>5.6.1 树的存储结构</h3><ol><li><p>双亲表示法</p><p> 这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。</p></li></ol><ul><li>树的双亲表示法<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127885.png"></li></ul><p>双亲表示法特点：找双亲结点容易，找孩子结点难。</p><p>类型描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>    TElemType data;<br>    <span class="hljs-type">int</span> parent; <span class="hljs-comment">// parent结点位置</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTree</span>&#123;<br>    PTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> r, n;   <span class="hljs-comment">// 根结点的位置和节点个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>孩子表示法</p><p> 把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。</p><p> 特点：找孩子容易，找双亲难。</p><p> 类型描述：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 孩子结点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    CTNode* next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> CTNode *ChildPtr;<br><span class="hljs-comment">// 双亲结点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTBox</span>&#123;<br>    TElemType data;<br>    ChildPtr firstChild;    <span class="hljs-comment">// 孩子链表头指针</span><br>&#125;<br><span class="hljs-comment">// 树结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTree</span>&#123;<br>    CTBox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> n, r;<br>&#125;;<br></code></pre></td></tr></table></figure><pre><code class="hljs">可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起，称为带双亲的孩子链表。</code></pre><ol start="3"><li><p>孩子兄弟表示法(二叉树表示法、二叉链表表示法)</p><p> 又称二叉树表示法，或<strong>二叉链表表示法</strong>，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的<strong>第一个孩子结点</strong>和<strong>下一个兄弟结点</strong>，分别命名为firstchild域和nextsibling域。</p><p>  类型描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>&#123;<br>    ElemType data;<br>    CSNode *firstChild, *nextsibling;<br>&#125;;<br><span class="hljs-keyword">typedef</span> CSNode *CSTree;<br></code></pre></td></tr></table></figure><p> 这种存储结构的优点是它和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树的算法来实现对树的操作。因此孩子兄弟表示法是应用较为普遍的一种树的存储表示方法。</p></li></ol><h3 id="5-6-2-森林与二叉树的转换"><a href="#5-6-2-森林与二叉树的转换" class="headerlink" title="5.6.2 森林与二叉树的转换"></a>5.6.2 森林与二叉树的转换</h3><ul><li><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操T。</p></li><li><p>由于树和二叉树都可以用二叉链表作存储结构，则<strong>以二叉链表作媒介</strong>可以导出树与二叉树之间的一个对应关系。</p></li></ul><p>给定一棵树，可以找到唯一的以可二叉树与之对应。这个一一对应的关系说明<strong>森林或树与二叉树可以相互转换</strong>。</p><ol><li><p>将树转换为二叉树</p><ol><li><p>加线：在兄弟之间加一连线；</p></li><li><p>抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系；</p></li><li><p>旋转：以树的根结点为轴心，将整树顺时针转45°</p></li></ol><p> 树变二叉树：<strong>兄弟相连留长子</strong></p></li><li><p>将二叉树转换为树</p><ol><li><p>加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子……沿分支找到的所有右孩子，都p的双亲用线连起来；</p></li><li><p>抹线：抹掉原二叉树中双亲与右孩子之间的连线；</p></li><li><p>调整：将结点按层次排列，形成树结构</p></li></ol><p> 二叉树变树：<strong>左孩右右连双亲，去掉原来右孩线</strong></p></li><li><p>森林转换称二叉树</p><ol><li><p>将各棵树分别转换成二叉树</p></li><li><p>将每棵树的根结点用线相连</p></li><li><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p></li></ol><p> 森林变二叉树：<strong>树变二叉根相连</strong></p></li><li><p>二叉树转换成森林</p><ol><li><p>抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树；</p></li><li><p>还原：将孤立的二叉树还原成树</p></li></ol><p> 二叉树变森林：<strong>去掉全部右孩线，孤立二叉再还原</strong>。</p></li></ol><h3 id="5-6-3-树和森林的遍历"><a href="#5-6-3-树和森林的遍历" class="headerlink" title="5.6.3 树和森林的遍历"></a>5.6.3 树和森林的遍历</h3><ol><li><p>树的遍历（三种方式）</p><ol><li><p>先根(次序)遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。</p></li><li><p>后根(次序)遍历：若树不空，则先依次后根遍历各棵子树，然后再访问根结点。</p></li><li><p>层次遍历：若树不空，则自上而下自左至右访问树中每个结点。</p></li></ol></li><li><p>森林的遍历</p><p> 将森林看作由三部分构成：1、森林中第一棵树的根结点；2.森林中第一棵树的子树森林；3.森林中其它树构成的森林。</p><ol><li><p>先序遍历</p><p> 若森林不为空，则</p><ol><li><p><strong>访问森林中第一棵树的根结点</strong>；</p></li><li><p>先序遍历森林中第一棵树的子树森林；</p></li><li><p>先序遍历森林中（除第一棵树之外）其余树构成的森林。</p></li></ol></li><li><p>中序遍历</p><p> 若森林不为空，则</p><ol><li><p>中序遍历森林中第一棵树的子树森林；</p></li><li><p>访问森林中第一棵树的根结点；</p></li><li><p>中序遍历森林中（除第一棵树之外）其余树构成的森林。</p></li></ol></li></ol></li></ol><h2 id="5-7-哈夫曼树及其应用"><a href="#5-7-哈夫曼树及其应用" class="headerlink" title="5.7 哈夫曼树及其应用"></a>5.7 哈夫曼树及其应用</h2><h3 id="5-7-1-哈夫曼树的基本概念"><a href="#5-7-1-哈夫曼树的基本概念" class="headerlink" title="5.7.1 哈夫曼树的基本概念"></a>5.7.1 哈夫曼树的基本概念</h3><p>哈夫曼(Huffman)树又称<strong>最优树，是一类带权路径长度最短的树</strong>，哈夫曼树的定义，涉及路径、路径长度、权等概念。</p><ul><li><p><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。</p></li><li><p><strong>路径长度</strong>：路径上的<strong>分支数目</strong>称作路径长度。</p></li><li><p><strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。</p><p>  在结点数目相同的二叉树中，<strong>完全二叉树的路径长度最短的二叉树</strong>。但路径长度最短的二叉树不一定就是完全二叉树。</p></li><li><p><strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有<strong>结点权和边权</strong>。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。</p></li><li><p><strong>结点的带权路径长度</strong>：从该结点到树 根之间的<strong>路径长度与结点上权的乘积</strong>。</p></li><li><p><strong>树的带权路径长度</strong>：树中所有<strong>叶子结点</strong>的带权路径长度之和，通常记作WPL。</p></li><li><p><strong>哈夫曼树</strong>：假设有m个权值{w1, W2,…,Wm}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为W；则其中<strong>带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树</strong>。</p></li></ul><p>带权路径最短的树，比较的前提是所有树的度相同，即树的各结点度的最大值，即结点拥有的子树数。</p><p><strong>满二叉树不一定是曼哈夫树</strong>，哈夫曼树中权越大的叶子离根越近，具有相同带权结点的哈夫曼树不唯一。</p><h3 id="5-7-2-哈夫曼树的构造算法"><a href="#5-7-2-哈夫曼树的构造算法" class="headerlink" title="5.7.2 哈夫曼树的构造算法"></a>5.7.2 哈夫曼树的构造算法</h3><ol><li><p>哈夫曼树的构造过程</p><p> 在构造哈夫曼树时，<strong>首先选择权小的</strong>，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的<strong>贪心法</strong>。</p><ol><li><p>根据给定的n个权值{W1, W2, …, Wn}，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。<strong>构造森林全是根</strong>。</p></li><li><p>在森林F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。<strong>选用两小造新树</strong>。</p></li><li><p>在森林F中删除这两棵树，同时将新得到的二叉树加入F中。<strong>删除两小添新人</strong>。</p></li><li><p>重复（2）和（3），直到F只含一棵树为止。这棵树便是哈夫曼树。<strong>重复2、3剩单根</strong>。</p></li></ol><p> 特点：</p><p> 包含n棵树的森林要经过n-1次合并才能形成哈去曼树，共产生n-1新结点，且这n-1个新结点都是具有两个孩子的分支结点。。</p><ul><li><p><strong>包含n个叶子结点的哈夫曼树中共有2n-1个结点</strong>。</p></li><li><p><strong>哈夫曼树的结点的度数为0或2，没有度为1的结点</strong>。</p></li></ul></li><li><p>哈夫曼算法的实现</p><p> 哈夫曼树是一种二叉树，由于哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n-1个结点，可以存储在一个大小为2n-1的一维数组中。树中每个结点还要包含其<strong>双亲信息</strong>和<strong>孩子结点的信息</strong>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> parent, lch, rch;<br>&#125;HTNode, *HuffmanTree;<br></code></pre></td></tr></table></figure><p> 哈夫曼树中共有2n-1个结点不使用0下标，数组大小为2n。将叶子结点集中存储在前面部分1~n个位置，而后面的n-1个位置存储其余非叶子结点。</p><blockquote><p>构造哈夫曼树——算法5.10</p></blockquote><p> 构造哈夫曼树算法的实现可以分成两大部分。</p><ol><li><p>初始化：首先动态申请2n个单元；然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0；最后再循环n次，输入前n个单元中叶子结点的权值。</p></li><li><p>创建树：循环n-1次，通过n-1次的选择、删除与合并来创建哈夫曼树。</p><ul><li><p>选择是从当前森林中选择双亲为0且权值最小的两个树根结点s1和s2；</p></li><li><p>删除是指将结点s1和s2的双亲改为非0；</p></li><li><p>合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个新结点左孩子的下标为s1，右孩子的下标为s2。</p></li></ul></li></ol><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanTree</span><span class="hljs-params">(HuffmanTree HT, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;<br>    HT = <span class="hljs-keyword">new</span> HTNode[m+<span class="hljs-number">1</span>];   <span class="hljs-comment">// 0号单元未用，</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-comment">// 将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0</span><br>        HT[i].lch = <span class="hljs-number">0</span>;<br>        HT[i].rch = <span class="hljs-number">0</span>;<br>        HT[i].parent = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-comment">// 输入前n个元素的weight值</span><br>        cin &gt;&gt; HT[i].weight;<br>    &#125;<br>    <span class="hljs-comment">/*－初始化工作结束，下面开始创建哈夫曼树－*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n+<span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-built_in">Select</span>(HT, i<span class="hljs-number">-1</span>, s1, s2);<br>        <span class="hljs-comment">// 在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点，并返回它们在HT中的序号s1和s2</span><br>        HT[s1].parent = i;<br>        HT[s2].parent = i;<br>        <span class="hljs-comment">// 得到新结点i，从森林中删除s1和s2，将s1和s2的双亲域由0改为i</span><br>        HT[i].lch = s1;<br>        HT[i].rch = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-7-3-哈夫曼编码"><a href="#5-7-3-哈夫曼编码" class="headerlink" title="5.7.3 哈夫曼编码"></a>5.7.3 哈夫曼编码</h3><p>在进行数据压缩时，为了使压缩后的数据文件尽可能短，可采用不定长编码。其基本思想是：为出现次数较多的字符编以较短的编码。为确保对数据文件进行有效的压缩和对压缩文件进行正确的解码，可以利用哈夫曼树来设计二进制编码。</p><p>关键：要设计长度不等的编码，则必须使<strong>任一字符的编码都不是另一个字符的编码的前缀</strong>。上述编码方式又称为前缀编码。</p><p>前缀编码：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。</p><p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p><p>哈夫曼编码的性质：</p><ol><li><p><strong>哈夫曼编码是前缀编码</strong>。</p></li><li><p><strong>哈夫曼编码是最优前缀编码</strong>。</p></li></ol><p>哈夫曼编码实现方法：</p><ol><li><p>统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）。</p></li><li><p>利用哈夫曼树的特点：权越大的叶子离根越近；<strong>将每个字符的概率值作为权值，构造哈夫曼树</strong>。则概率越大的结点，路径越短。</p></li><li><p>在哈夫曼树的每个分支上标上0或1：</p><ul><li><p>结点的左分支标0，右分支标1</p></li><li><p>把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。</p></li></ul></li></ol><p>两个问题：</p><ol><li><p>为什么哈夫曼编码能够保证是前缀编码？。</p><p> 因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p></li><li><p>为什么哈夫曼编码能够保证字符编码总长最短？</p><p> 因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</p></li></ol><blockquote><p>哈夫曼编码的算法实现</p></blockquote><p>在构造哈夫曼树之后，求哈夫曼编码的主要思想是：<strong>依次以叶子为出发点，向上回溯至根结点为止</strong>。回溯时走左分支则生成代码0，走右分支则生成代码1。</p><p>算法步骤：</p><ol><li><p>分配存储n个字符编码的编码表空间HC，长度为n+1；分配临时存储每个字符编码的动态数组空间cd，cd[n-1]置为’\0’。</p></li><li><p>逐个求解n个字符的编码，循环n次，执行以下操作：</p><ul><li><p>设置变量start用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置n-1;</p></li><li><p>设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f用于记录i的双亲结点的下标；</p></li><li><p>从叶子结点向上回溯至根结点，求得字符i的编码，当f没有到达根结点时，循环执行以下操作：</p><ul><li><p>回溯一次start向前指一个位置，即–start;</p></li><li><p>若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在cd[start]中；</p></li><li><p>继续向上回溯，改变c和f的值。</p></li></ul></li><li><p>根据数组cd的字符串长度为第i个字符编码分配空间HC[i]，然后将数组cd中的编码复制到HC[i]中。</p></li></ul></li><li><p>释放临时空间cd。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanCode</span><span class="hljs-params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span><br>    HC = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>*[n+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 分配存储n个字符编码的编码表空间</span><br>    cd = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];           <span class="hljs-comment">// 分配临时存放每个字符编码的动态数组空间</span><br>    cd[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;             <span class="hljs-comment">// 编码结束符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 逐个字符求哈夫曼编码</span><br>    &#123;<br>        start = n<span class="hljs-number">-1</span>;            <span class="hljs-comment">// start开始时指向最后，即编码结束符位置</span><br>        c = i;<br>        f = HT[i].parent;       <span class="hljs-comment">// f指向结点c的双亲结点</span><br>        <span class="hljs-keyword">while</span>(f != <span class="hljs-number">0</span>)           <span class="hljs-comment">// 从叶子节点开始向上回溯，知道根结点</span><br>        &#123;<br>            --start;            <span class="hljs-comment">// 回溯一次start位置向前指一个位置</span><br>            <span class="hljs-keyword">if</span>(HT[f].lch == c)  <span class="hljs-comment">// 结点c是f的左孩子，则生成代码0</span><br>            &#123;<br>                cd[start] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// 结点c是f的右孩子，则生成代码1</span><br>            &#123;<br>                cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            &#125;<br>            c = f;<br>            f = HT[f].parent;   <span class="hljs-comment">// 继续向上回溯</span><br>        &#125;                       <span class="hljs-comment">// 求出第i个字符的编码</span><br>        HC[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n-start];  <span class="hljs-comment">// 为第i个字符编码分配空间</span><br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);<br>    &#125;<br>    <span class="hljs-keyword">delete</span> cd;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>文件的编码和译码</p></blockquote><ol><li><p>编码</p><p> 有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符c，在哈夫曼编码表HC中找到此字符，将字符c转换为编码表中存放的编码串。</p></li><li><p>译码</p><p> 对编码后的文件进行译码的过程必须借助于哈夫曼树。具体过程是：依次读入文件的二进制码，从哈夫曼树的根结点（即HT[m])出发，若当前读入0，则走向左孩子，否则走向右孩子。一旦到达某一叶子HT[i]时便译出相应的字符编码HC[i]。然后重新从根出发继续译码，直至文件结束。</p></li></ol><h2 id="5-8-案例分析与实现"><a href="#5-8-案例分析与实现" class="headerlink" title="5.8 案例分析与实现"></a>5.8 案例分析与实现</h2><h2 id="5-9-习题"><a href="#5-9-习题" class="headerlink" title="5.9 习题"></a>5.9 习题</h2><ol><li><p>利用二叉链表存储树， 则根结点的右指针()。</p><p> A. 指向最左孩子 B. 指向最右孩子 C. 为空 D. 非空</p><p> 解答：C，利用二叉链表存储树时，右指针指向兄弟结点，因为根节点没有兄弟结点，故根结点的右指针为空</p></li><li><p>一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足()。</p><p> A. 所有的结点均无左孩子 B. 所有的结点均无右孩子 C. 只有一个叶子结点 D. 是任意一棵二叉树</p><p> 解答：因为先序遍历结果是“中左右”， 序遍历结果是“左右中”，当没有左子树时，就是“中右”和“右中”；当没有右子树时，就是“中左”和“左中”。则所有的结点均无左孩子或所有的结点均无右孩子均可，所以A、B不能选，又所有的结点均无左孩子与所有的结点均无右孩子时，均只有一个叶子结点，故选C。</p></li><li><p>在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是( )</p><p> A．41 B．82 C．113 D．122</p><p> 解答：考查树结点数的特性。设树中度为i(i&#x3D;0，1，2，3，4)的结点数分别为Ni，树中结点总数为N，则树中各结点的度之和等于N-1，即N&#x3D;1+N1+2N2+3N3+4N4&#x3D;N0+N1+N2+N3+N4。根据题设中的数据，即可得到N0&#x3D;82，即树T的叶结点的个数是82。</p></li></ol><p>算法设计题：</p><ol><li><p>统计二叉树的叶结点个数。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>判别两棵树是否相等。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>交换二叉树每个结点的左孩子和右孩子。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>设计二叉树的双序遍历算法（双序遍历是指对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe4.cpp">算法设计题4</a></p></li><li><p>计算二叉树最大的宽度（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>用按层次顺序遍历二叉树的方法，统计树中度为1的结点数目。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li><li><p>求任意二叉树中第一条最长的路径长度，并输出此路径上各结点的值。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe7.cpp">算法设计题7</a></p></li><li><p>输出二叉树中从每个叶子结点到根结点的路径。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe8.cpp">算法设计题8</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串、数组和广义表——王卓</title>
    <link href="/2022/10/13/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-串、数组和广义表"><a href="#第4章-串、数组和广义表" class="headerlink" title="第4章 串、数组和广义表"></a>第4章 串、数组和广义表</h1><p>字符串一般简称为串。串是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说，<strong>串是一种内容受限的线性表</strong>。</p><p>本章后两部分讨论的多维数组和广义表可以看成是线性表的一种扩充，即线性表的数据元素自身又是一个数据结构。高级语言都支持数组，但在高级语言中，重点介绍数组的使用，而本章重点介绍数组的内部实现，并介绍对于一些特殊的二维数组如何实现压缩存储。最后介绍广义表的基本概念和存储结构。</p><h2 id="4-1-串的定义"><a href="#4-1-串的定义" class="headerlink" title="4.1 串的定义"></a>4.1 串的定义</h2><p><strong>串</strong>(string)(或字符串)是由零个或多个字符组成的有限序列，一般记为：s &#x3D; “a1a2 … an”。</p><p>其中，s是串的名，用双引号括起来的字符序列是串的值；ai(1≤i≤n)可以是字母、数字或其他字符；串中字符的数目n称为串的长度。零个字符的串称为<strong>空串</strong>(null string)，其长度为零。</p><blockquote><p>相关术语</p></blockquote><ul><li><p><strong>子串</strong>：一个串中任意个连续的字符组成的子序列(含空串)称为该串的子串。</p></li><li><p><strong>主串</strong>：包含子串的串相应地称为主串。</p></li><li><p><strong>字符位置</strong>：通常称字符在序列中的序号为该字符在串中的位置。</p></li><li><p><strong>子串的位置</strong>：子串的第一个字符在主串中的位置。</p></li><li><p><strong>空格串</strong>：一个或多个空格组成的串，与空串不同。</p></li><li><p><strong>串相等</strong>：当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。</p></li><li><p>所有的空串都是相等的。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301301652448.png"><br>最后一个位b在d中位置</p><h2 id="4-2-案例的引入"><a href="#4-2-案例的引入" class="headerlink" title="4.2 案例的引入"></a>4.2 案例的引入</h2><h2 id="4-3-串的类型定义、存储结构及其运算"><a href="#4-3-串的类型定义、存储结构及其运算" class="headerlink" title="4.3 串的类型定义、存储结构及其运算"></a>4.3 串的类型定义、存储结构及其运算</h2><h3 id="4-3-1-串的抽象类型定义"><a href="#4-3-1-串的抽象类型定义" class="headerlink" title="4.3.1 串的抽象类型定义"></a>4.3.1 串的抽象类型定义</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301301700866.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT string&#123;<br>    数据对象：<br>    数据关系：<br>    基本操作：<br>        <span class="hljs-number">1.</span> <span class="hljs-built_in">StrAssign</span>(&amp;T, chars);    <span class="hljs-comment">// 串赋值</span><br>        <span class="hljs-number">2.</span> <span class="hljs-built_in">StrCompare</span>(S, T);        <span class="hljs-comment">// 串比较</span><br>        <span class="hljs-number">3.</span> <span class="hljs-built_in">StrLenght</span>(S);            <span class="hljs-comment">// 求串长</span><br>        <span class="hljs-number">4.</span> <span class="hljs-built_in">Concat</span>(&amp;T, S1, S2);      <span class="hljs-comment">// 串连结</span><br>        <span class="hljs-number">5.</span> <span class="hljs-built_in">SubString</span>(&amp;Sub, S, pos, len);    <span class="hljs-comment">// 求子串</span><br>        <span class="hljs-number">6.</span> <span class="hljs-built_in">StrCopy</span>(&amp;T, S);          <span class="hljs-comment">// 串拷贝</span><br>        <span class="hljs-number">7.</span> <span class="hljs-built_in">StrEmpty</span>(S);             <span class="hljs-comment">// 串判空</span><br>        <span class="hljs-number">8.</span> <span class="hljs-built_in">ClearString</span>(&amp;S);         <span class="hljs-comment">// 清空串</span><br>        <span class="hljs-number">9.</span> <span class="hljs-built_in">Index</span>(S, T, pos);        <span class="hljs-comment">// 子串的位置</span><br>        <span class="hljs-number">10.</span> <span class="hljs-built_in">Replace</span>(&amp;S, T, V);      <span class="hljs-comment">// 串替换</span><br>        <span class="hljs-number">11.</span> <span class="hljs-built_in">StrInsert</span>(&amp;S, pos, T);  <span class="hljs-comment">// 子串插入</span><br>        <span class="hljs-number">12.</span> <span class="hljs-built_in">StrDelete</span>(&amp;S, pos, len);    <span class="hljs-comment">// 子串删除</span><br>        <span class="hljs-number">13.</span> <span class="hljs-built_in">DestoryString</span>(&amp;S);      <span class="hljs-comment">// 串销毁</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-串的存储结构"><a href="#4-3-2-串的存储结构" class="headerlink" title="4.3.2 串的存储结构"></a>4.3.2 串的存储结构</h3><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构：<strong>顺序存储和链式存储</strong>。</p><ol><li><p>串的顺序存储结构</p><p> 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SString</span>&#123;<br>    <span class="hljs-type">char</span> ch[MAXLEN+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length;<br>&#125;;<br></code></pre></td></tr></table></figure><p> 其中，MAXLEN表示串的最大长度，ch是存储字符串的一维数组，每个分量存储一个字符，length表示字符串的当前长度。其中，后面算法描述当中所用到的顺序存储的字符串都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用。</p></li><li><p>串的链式存储结构</p><p> 顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。</p></li></ol><ul><li>串值的链表存储方式<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131129962.png"></li></ul><p>如图(a)中所示，结点大小为4，图(b)，结点大小为1。</p><ul><li><p>串的链式存储结构——块链结构</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80    <span class="hljs-comment">// 块的大小可自由定义</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span>&#123;<br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    Chunk* next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LString</span>&#123;<br>    Chunk *head, *tail; <span class="hljs-comment">// 串的头指针和尾指针</span><br>    <span class="hljs-type">int</span> curlen; <span class="hljs-comment">// 串当前的长度</span><br>&#125;;  <span class="hljs-comment">// 字符串的块链结构</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-3-串的模式匹配算法"><a href="#4-3-3-串的模式匹配算法" class="headerlink" title="4.3.3 串的模式匹配算法"></a>4.3.3 串的模式匹配算法</h3><p>子串的定位运算通常称为串的<strong>模式匹配</strong>或<strong>串匹配</strong>。即算法目的：确定主串中所含子串（模式串）第一次出现得位置。</p><p>串的模式匹配设有两个字符串S和T，设S为主串，也称正文串；设T为子串，也称为模式。在主串S中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置。</p><p>算法种类包括有：BF算法、KMP算法。</p><ol><li><p>BF算法</p><p> Brute-Force简称BF算法，亦称简单匹配算法，采用穷举法的思路：从S的每一个字符开始依次与T的字符进行匹配。</p><blockquote><p>算法设计思想</p></blockquote><p> Index(S, T, pos)</p><ol><li><p>将主串的第pos个字符和模式串的第一个字符比较，</p><ul><li><p>若相等，继续逐个比较后续字符；</p></li><li><p>若不等，从主串的下一字符起，重新与模式串的第一个字符比较。</p></li></ul></li><li><p>直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。</p></li><li><p>否则，匹配失败，返回值0</p></li></ol><blockquote><p>算法4.1——BF算法描述</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString S, SString T)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= S.lenght &amp;&amp; j &lt;= T.length)&#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            ++j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 主串、子串指针回溯重新开始下一次匹配</span><br>            i = i - j + <span class="hljs-number">2</span>;<span class="hljs-comment">//可以看成（i-j+1）+1，i-j+1是把i退回到原来的位置，再加一移到后一个位置</span><br>            j = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt;= T.lenght) <span class="hljs-keyword">return</span> i - T.lenght;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 当m远小于n时，算法复杂度为O(n*m)，平均复杂度为O(nm&#x2F;2)。</p></li><li><p>KMP算法</p><p> KMP算法，利用已经部分匹配的结果而加快模式串的滑动速度，且主串S的指针i<strong>不必回溯</strong>！可提速到O(n+m)</p><p> 重点在于定义<code>next[j]</code>函数，表明当模式中第j个字符与主串中相应字符失配时，在模式中需要重新和主串中该字符进行比较的字符的位置。</p></li></ol><ul><li><p>next_j<br>  <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131135247.png"></p><blockquote><p>KMP算法</p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_KMP</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = pos, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; S.length &amp;&amp; j &lt; T.length)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || S.ch[i] == T.ch[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];    <span class="hljs-comment">// i不变，j后退</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt; T.length) <span class="hljs-keyword">return</span> i - T.length;   <span class="hljs-comment">// 匹配成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span>&amp; next[])</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; T.length)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || T.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            next[i] = j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>next计算</p></blockquote><p>  Next值就是字符串s的最长相同前缀和后缀子字符串的长度。</p><p>  默认第一个和第二个字符的next值为0、1。那么从第三个开始依次执行如下操作：</p><p>  找到<strong>当前要求next字符的前一个</strong>（称为这个字符），以它为标准，找到其next对应下标的字符（称为现在字符），<strong>和这个字符做比较</strong>。若相等，那么当前字符的next值就位此字符next<strong>加1</strong>；若不等，继续找现在字符next所指的下一个字符，还是和之前的字符比较，直到找到第一个位置为止，那么next为1。</p><blockquote><p>nextVal计算</p></blockquote><p>  NextVal值就是字符串s的的最长相同且满足后续字符不同的前缀和后缀子字符串的长度。</p><p>  在求出next的值的基础上，求nextval的方法其实很简单。默认第一个nextval的值是0，第二个字符如果和第一个字符相等，那么它的nextval的值就为0，不等就为1。之后遵循如下方法：</p><p>  <strong>找到当前要求nextval值的字符，看它的[next值]下标所指向的字符是否和它相等，相等那么nextval为当前所指下标的nextval值，不相等nextval的值就为本身字符的next值。</strong></p><p>  对next进行修正，改进：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_nextval</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span>&amp; nextval[])</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, nextval[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; T.lenght)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || T.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            ++j;<br>            <span class="hljs-keyword">if</span>(T.ch[i] != T.ch[j]) nextval[i] = j;<br>            <span class="hljs-keyword">else</span> nextval[i] = nextval[j];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = nextval[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-4-数组"><a href="#4-4-数组" class="headerlink" title="4.4 数组"></a>4.4 数组</h2><h3 id="4-4-1-数组定义和特点"><a href="#4-4-1-数组定义和特点" class="headerlink" title="4.4.1 数组定义和特点"></a>4.4.1 数组定义和特点</h3><p>数组：按一定格式排列起来的具有相同类型的数据元素的集合。</p><blockquote><p>一维数组</p></blockquote><p>一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。</p><p>一维数组的逻辑结构：线性结构。定长的线性表。</p><p>声明格式：<code>数据类型 变量名称[长度]</code>；</p><blockquote><p>二维数组</p></blockquote><p>二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组。</p><p>二维数组的逻辑结构：</p><ul><li><p>非线性结构：每一个数据元素既在一个行表中，又在一个列表中。</p></li><li><p>线性结构定长的线性表：该线性表的每个数据元素也是一个定长的线性表。</p></li></ul><p>声明格式：<code>数据类型 变量名称[行数][列数]</code>；</p><blockquote><p>多维数组</p></blockquote><p>三维数组：若二维数组中的元素又是一个一维数组，则称作三维数组。</p><p>n维数组：若n-1维数组中的元素又是一个一维数组结构，则称作n维数组。</p><p>结论：线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。</p><p>数组特点：<strong>结构固定</strong>，定义后，维数和维界不再改变。</p><p>数组基本操作：除了结构的初始化和销毁之外，只有<strong>取元素</strong>和<strong>修改元素值</strong>的操作。</p><h3 id="4-4-2-数组的抽象数据类型定义"><a href="#4-4-2-数组的抽象数据类型定义" class="headerlink" title="4.4.2 数组的抽象数据类型定义"></a>4.4.2 数组的抽象数据类型定义</h3><p>以二维数组为例，二维数组的抽象数据类型的数据对象和数据关系的定义：</p><p>n&#x3D;2（维数为2，二维数组）</p><p>b1：第1维长度（行数）</p><p>b2：第2维长度（列数）</p><p>aj1j2：第1维下标为j1，第2维下标为j2</p><h3 id="4-4-3-数组的顺序存储"><a href="#4-4-3-数组的顺序存储" class="headerlink" title="4.4.3 数组的顺序存储"></a>4.4.3 数组的顺序存储</h3><p>在数组存储过程中，数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。</p><p>针对二维数组，可以以行序为主序(C、PASCAL、JAVA、Basic)；也可以是列序为主序(FORTRAN)。</p><ul><li>n维数组元素地址<br> <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131133589.png"></li></ul><h3 id="4-4-4-特殊矩阵的压缩存储"><a href="#4-4-4-特殊矩阵的压缩存储" class="headerlink" title="4.4.4 特殊矩阵的压缩存储"></a>4.4.4 特殊矩阵的压缩存储</h3><p>矩阵的常规存储：将矩阵描述为一个二维数组。</p><p>矩阵的常规存储的特点：可以对其元素进行随机存取；矩阵运算非常简单；存储的密度为1。</p><p>但是对于不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多。特殊矩阵主要包括<strong>对称矩阵、三角矩阵和对角矩阵</strong>等，以及稀疏矩阵：矩阵中非零元素的个数较少（一般小于5%）</p><p>因此可以采用矩阵压缩存储：为多个相同的非零元素只分配一个存储空间，对零元素不分配空间。</p><ol><li><p>对称矩阵：</p><p> 特点：在nxn的矩阵a中，满足aij &#x3D; aji</p><p> 存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)&#x2F;2个元素空间。</p><p> 对称矩阵可以以行序为主序将元素存放在一个一维数组<code>sa[n(n+1)/2]</code>中，其中aij存放在(i*(i-1)&#x2F;2)+(j-1)位置。</p></li><li><p>三角矩阵</p><p> 特点：特点对角线以下（或者以上）的数据元素（不包括对角线全部为常数c。</p><p> 存储方法：重复元素c共享一个元素存储空间，共占用n(n+1)&#x2F;2+1个元素空间。</p></li><li><p>对角矩阵</p><p> 特点：在nxn的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p><p> 存储方法：可按某个原则（或以行为主，或以对角线的顺序）将其压缩存储到一维数组上。</p></li><li><p>稀疏矩阵存储</p><p> 稀疏矩阵：在mxn的矩阵中，有超过95%的元素位零，非零元素仅不到5%。</p><ul><li><p>三元组法：</p><p>  三元组顺序表，又称为<strong>有序的双下标法</strong></p><p>  压缩存储原则：可通过三元组法来表示稀疏矩阵，三元组：(i, j, aij)。即存各非零元素的值、行列位置和矩阵的行列数。</p><p>  其中，为更为可靠描述，通常会加上总体的描述信息：总行数、总列数、非零元素总个数。</p><p>  优点：非零元在表中按行序有序存储，因此<strong>便于进行依行顺序处理的矩阵运算</strong>。</p><p>  缺点：<strong>不能随机存取</strong>。若按行号存取某一行中的非零元，则需从头开始进行查找。</p></li><li><p>十字链表法</p><p>  稀疏矩阵的链式存储结构：</p><p>  优点：它能够<strong>灵活地插入</strong>因运算而产生的新的非零元素，<strong>删除</strong>因运算而产生的新的零元素，实现矩阵的各种运算。</p><p>  在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了(row, col, value)以外，还要有两个域：</p><ul><li><p>right：用于链接同一行中的下一个非零元素；</p></li><li><p>down：用以链接同一列中的下一个非零元素。</p></li></ul><p>  同时，为了方便元素查找，可为每一行、每一列添加头指针结点。</p></li></ul></li></ol><h2 id="4-5-广义表"><a href="#4-5-广义表" class="headerlink" title="4.5 广义表"></a>4.5 广义表</h2><h3 id="4-5-1-广义表的定义"><a href="#4-5-1-广义表的定义" class="headerlink" title="4.5.1 广义表的定义"></a>4.5.1 广义表的定义</h3><p>广义表是线性表的推广，也称为列表。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。</p><p>广义表(又称列表Lists)是n≥0个元素a0, a1, a2, …, an-1的有限序列，其中每一个ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。</p><p>广义表通常记作：LS&#x3D;(a1, a2, …, an)，其中：LS为表名，n为表的长度，每一个元素ai为表的元素。</p><p>习惯上，一般用大写字母表示广义表，小写字母表示原子。</p><p>表头：若LS非空，则第一个元素a1就是表头，记作head(LS)&#x3D;a1。其中，表头可以是原子，也可以是子表。</p><p>表尾：除表头外的其他元素组成的表。记作tail(LS) &#x3D; (a2,…,an)。其中表尾不是一个元素，而实一个子表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">A = ()  <span class="hljs-comment">// 空表，长度为零</span><br>B = (())    <span class="hljs-comment">// 长度为1，表头、表尾均为()</span><br>C = (a, (b, c)) <span class="hljs-comment">// 长度为2，由原子a和子表(b,c)构成，表头为a；表尾为((b, c))</span><br>D = (x, y, z)   <span class="hljs-comment">// 长度为3，每一项都是原子，表头为x，表尾为(y, z)</span><br>E = (C, D)  <span class="hljs-comment">// 长度为2，每一项都是子表，表头为C，表尾为(D)</span><br>F = (a, F)  <span class="hljs-comment">// 长度为2，第一项为原子，第二项为本身。表头为a；表尾为(F)</span><br></code></pre></td></tr></table></figure><blockquote><p>广义表的性质</p></blockquote><ol><li><p>广义表中的数据元素有相对次序；一个直接前驱和一个直接后继</p></li><li><p><strong>广义表的长度</strong>:定义为最外层所包含元素的个数；</p></li><li><p><strong>广义表的深度</strong>:定义为该广义表展开后所含括号的重数；其中，原子的深度为0，空表的深度为1。A&#x3D;(b,c)的深度为1，B&#x3D;(A,d)的深度为2，C&#x3D;（f，b，h）的深度为3</p></li><li><p>广义表可以为其他广义表共享；</p></li><li><p>广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302011349375.png"></p></li><li><p>广义表是一个多层次的结构，可以用图形象地表示。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302011350760.png"></p></li></ol><blockquote><p>广义表与线性表的区别</p></blockquote><p><strong>广义表可以看成是线性表的推广，线性表是广义表的特例</strong>。</p><p>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</p><p><strong>当二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表</strong>。</p><p>另外，树和有向图也可以用广义表来表示。由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。</p><blockquote><p>广义表的运算</p></blockquote><ol><li><p>取表头GetHead(LS): 取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表。</p></li><li><p>取表尾GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。即<strong>表尾一定是一个广义表</strong>。</p></li></ol><h3 id="4-5-2-广义表的存储"><a href="#4-5-2-广义表的存储" class="headerlink" title="4.5.2 广义表的存储"></a>4.5.2 广义表的存储</h3><p>由 于广义表中的数据元素可以有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构。常用的链式存储结构有两种，<strong>头尾链表的存储结构</strong>和<strong>扩展线性链表的存储结构</strong>。</p><h2 id="4-6-案例分析与实现"><a href="#4-6-案例分析与实现" class="headerlink" title="4.6 案例分析与实现"></a>4.6 案例分析与实现</h2><h2 id="4-7-习题"><a href="#4-7-习题" class="headerlink" title="4.7 习题"></a>4.7 习题</h2><blockquote><p>算法设计题</p></blockquote><ol><li><p>写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符为A<del>Z这26个字母和0</del>9这10个数字）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>写一个递归算法来实现字符串逆序存储，要求不另设串存储空间。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>编写算法，实现下面函数的功能。函数<code>void insert(char*s, char* t, int pos)</code>将字符串t插入到字符串s中，插入位置为pos。假设分配给字符串s的空间足够让字符串t插入。（说明：不得使用任何库函数）</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>已知字符串S1中存放一段英文，写出算法format(s1, s2, s3, n)，将其按给定的长度n格式化成两端对齐的字符串S2，其多余的字符送S3。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe4.cpp">算法设计题4</a></p></li><li><p>设二维数组a[1…m, l…n]含有m x n个整数。</p><ol><li><p>写一个算法判断a中所有元素是否互不相同？输出相关信息(yes&#x2F;no);</p></li><li><p>试分析算法的时间复杂度。</p></li></ol><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>设任意n个整数存放于数组A[1..n]中，试编写算法，将所有正数排在所有负数前面(要求：算法时间复杂度为O(n))。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列——王卓</title>
    <link href="/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><p>栈和队列是两种重要的线性结构。从数据结构角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为<strong>限定性的数据结构</strong>。但从数据类型角度看，它们是和线性表不相同的两类重要的抽象数据类型。</p><h2 id="3-1-栈和队列的定义和特点"><a href="#3-1-栈和队列的定义和特点" class="headerlink" title="3.1 栈和队列的定义和特点"></a>3.1 栈和队列的定义和特点</h2><h3 id="3-1-1-栈的定义和特点"><a href="#3-1-1-栈的定义和特点" class="headerlink" title="3.1.1 栈的定义和特点"></a>3.1.1 栈的定义和特点</h3><p><strong>栈</strong>(<strong>stack</strong>)是限定仅在<strong>表尾进行插入或删除</strong>操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为<strong>栈顶</strong>(<strong>top</strong>)，相应地，表头端称为<strong>栈底</strong>(<strong>bottom</strong>)。不含元素的空表称为<strong>空栈</strong>。</p><p>栈的修改是按后进先出的原则进行的，因此，栈又称为<strong>后进先出</strong>(Last In First Out, LIFO)的线性表。</p><blockquote><p>栈与一般线性表的区别</p></blockquote><p>栈与一般线性表的区别：<strong>仅存在运算规则不同</strong>。</p><p>|一般线性表|栈|<br>|:—|:—:|:—:|<br>|逻辑结构|一对一|一对一|<br>|存储结构|顺序表、链表|顺序表、链表|<br>|运算规则|随机存取|后进先出(LIFO)|</p><h3 id="3-1-2-队列的定义和特点"><a href="#3-1-2-队列的定义和特点" class="headerlink" title="3.1.2 队列的定义和特点"></a>3.1.2 队列的定义和特点</h3><p><strong>队列</strong>(<strong>queue</strong>)是一种<strong>先进先出</strong>(<strong>First In First Out, FIFO</strong>)的线性表。它只允许在表的一端进行插入，而在另一端删除元素。</p><p>在队列中，允许插入的一端称为<strong>队尾</strong>(<strong>rear</strong>)，允许删除的一端则称为<strong>队头</strong>(<strong>front</strong>)。</p><h2 id="3-2-案例引入"><a href="#3-2-案例引入" class="headerlink" title="3.2 案例引入"></a>3.2 案例引入</h2><h3 id="案例3-1-进制转换"><a href="#案例3-1-进制转换" class="headerlink" title="案例3.1 进制转换"></a>案例3.1 进制转换</h3><ul><li>进制转换</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131135382.png"></p><h3 id="案例3-2-括号匹配的检验"><a href="#案例3-2-括号匹配的检验" class="headerlink" title="案例3.2 括号匹配的检验"></a>案例3.2 括号匹配的检验</h3><ul><li><p>假设表达式中允许包含两种括号：圆括号和方括号</p></li><li><p>其嵌套的顺序随意，即：</p><ol><li><p>([ ] ( ))或[ ( [ ] [ ] ) ]为正确格式；</p></li><li><p>[ ( ] )为错误格式；</p></li><li><p>( [ () )或(()])为错误格式。</p></li></ol></li><li><p>括号匹配<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131136898.png"></p></li></ul><h3 id="案例3-3-表达式求值"><a href="#案例3-3-表达式求值" class="headerlink" title="案例3.3 表达式求值"></a>案例3.3 表达式求值</h3><ul><li><p>表达式求值是程序设计语言编译中一个最基本的问题，它的实现需要运用栈。</p></li><li><p>这里介绍的算法是由运算符优先级确定运算顺序的对表达式求值算法——算符优先算法。</p></li><li><p>表达式的组成</p><ul><li><p>操作数(operand)：常数、变量。</p></li><li><p>运算符(operator)：算术运算符、关系运算符和逻辑运算符。</p></li><li><p>界限符(delimiter)：左右括弧和表达式结束符。</p></li></ul></li><li><p>任何一个算术表达式都由<strong>操作数</strong>(常数、变量)、算术<strong>运算符</strong>(+、-、* 、&#x2F;)和界限符(括号、表达式结束符’#’、虚设的表达式起始符’#’)组成。后两者统称为算符。</p></li><li><p>为了实现表达式求值。需要设置两个栈：</p><p>  一个是算符栈OPTR，用于寄存运算符。</p><p>  另一个称为操作数栈OPND，用于寄存运算数和运算结果。</p></li><li><p>求值的处理过程是自左至右扫描表达式的每一个字符</p><ul><li><p>当扫描到的是运算数，则将其压入栈OPND，</p></li><li><p>当扫描到的是运算符时</p><ul><li><p>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTR，继续向后处理</p></li><li><p>若这个运算符比OPTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从栈OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND。</p></li></ul></li><li><p>继续处理当前字符，直到遇到结束符为止。</p></li></ul></li></ul><h3 id="案例3-4-舞伴问题"><a href="#案例3-4-舞伴问题" class="headerlink" title="案例3.4 舞伴问题"></a>案例3.4 舞伴问题</h3><p>假设在舞会上，男士和女士各自排成一队。舞会开始时，依次从男队和女队的队买务出一人配成舞伴。如果两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一算法模拟上述舞伴配对问题。</p><p>显然，先入队的男士或女士先出队配成舞。因此该问题具有典型的先进先出特性，可以用队列作为算法的数据结构。</p><ul><li><p>首先构造两个队列</p></li><li><p>依次将从男元素出队配成舞伴</p></li><li><p>某队为空，则另外一队等待着则是下一舞曲第一个可获得舞伴的人。</p></li></ul><h2 id="3-3-栈的表示和操作的实现"><a href="#3-3-栈的表示和操作的实现" class="headerlink" title="3.3 栈的表示和操作的实现"></a>3.3 栈的表示和操作的实现</h2><h3 id="3-3-1-栈的抽象数据类型的类型定义"><a href="#3-3-1-栈的抽象数据类型的类型定义" class="headerlink" title="3.3.1 栈的抽象数据类型的类型定义"></a>3.3.1 栈的抽象数据类型的类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT Stack&#123;<br>数据对象：<br>    D = &#123;ai | ai ∈ ElemSet, i = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n, n≥<span class="hljs-number">0</span>&#125;<br>数据关系：<br>    R1 = &#123;&lt;ai<span class="hljs-number">-1</span>, ai&gt; | ai<span class="hljs-number">-1</span>, ai∈D, i = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n&#125;<br>    约定an端为栈顶，a1端为栈底<br>基本操作：<br>    初始化、进栈、出栈、取栈顶元素等<br>&#125;ADT Stack<br></code></pre></td></tr></table></figure><ul><li>栈的基本操作<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131137111.png"></li></ul><h3 id="3-3-2-顺序栈的表示和实现"><a href="#3-3-2-顺序栈的表示和实现" class="headerlink" title="3.3.2 顺序栈的表示和实现"></a>3.3.2 顺序栈的表示和实现</h3><p>存储方式：同一般线性表的顺序存储结构完全相同，<strong>利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素</strong>。栈底一般在低地址端。</p><ul><li><p>附设<strong>top指针</strong>，指示栈顶元素在顺序栈中的位置。</p></li><li><p>另设<strong>base指针</strong>，指示栈底元素在顺序栈中的位置。</p></li><li><p>用stacksize表示栈可使用的最大容量。</p></li></ul><p>但是，为了方便操作，通常top指示真正的<strong>栈顶元素之上</strong>的下标地址。</p><p>空栈：base &#x3D;&#x3D; top是栈空标志</p><p>栈满：top - base &#x3D;&#x3D; stacksize</p><ul><li><p>栈满时的处理方法：</p><ol><li><p>报错，返回操作系统</p></li><li><p>分配更大的空间，作为栈的存储空间，将原栈的内容移入新栈</p></li></ol></li></ul><p>使用数组作为顺序栈存储方式的特点：简单、方便、但易产生溢出（数组大小固定）</p><ul><li><p>上溢(overflow)：栈已经满，又要压入元素</p></li><li><p>下溢(underflow)：栈已经空，还要弹出元素</p></li></ul><p>注：上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题处理结束。</p><blockquote><p>顺序栈的表示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqStack</span>&#123;<br>    SElemType *base;    <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;     <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;      <span class="hljs-comment">// 栈可用最大容量</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.1 顺序栈的初始化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造一个空栈</span><br><span class="hljs-function">State <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    S.base = <span class="hljs-keyword">new</span> SElemType[MAXSIZE];<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>    S.top = S.base; <span class="hljs-comment">// 栈顶指针等于栈底指针</span><br>    S.stacksize = MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1 判断顺序栈是否为空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 若栈为空，返回TRUE；否则返回FALSE</span><br><span class="hljs-function">State <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == S.base)<br>        <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法2 求顺序栈的长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> S.top - S.base;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3 清空顺序栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base) S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法4 销毁顺序栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base)&#123;<br>        <span class="hljs-keyword">delete</span> S.base;<br>        S.stacksize = <span class="hljs-number">0</span>;<br>        S.base = S.top = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.2 顺序栈的入栈</p></blockquote><ul><li><p>步骤：</p><ol><li><p>判断是否栈满，若满则出错</p></li><li><p>元素e压入栈顶</p></li><li><p>栈顶指针加1</p></li></ol></li></ul><p><strong>先压入元素，再移动栈顶指针，为什么？</strong><br>我的理解是，你得先通过top指针找到你要把元素压入哪个位置，然后再把top指针上移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top - S.base == S.stacksize)   <span class="hljs-comment">// 栈满</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    *S.top = e;<br>    S.top++;<br>    <span class="hljs-comment">// 两步加起来等同于</span><br>    <span class="hljs-comment">// *S.top++ = e;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.3 顺序栈的出栈</p></blockquote><ul><li><p>步骤：</p><ol><li><p>判断是否栈空，若空则出错</p></li><li><p>获取栈顶元素e</p></li><li><p>栈顶指针减1</p></li></ol></li></ul><p><strong>先移动栈底指针，再取出元素，为什么？</strong><br>我的理解是，你得先移动栈顶指针，才能找到你要取出的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top  == S.base) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//判断是否栈空，若空则出错（下溢）</span><br>    S.top--;<br>    e = *S.top;<br><span class="hljs-comment">// 等同于e = *--S.top;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-链栈的表示和实现"><a href="#3-3-3-链栈的表示和实现" class="headerlink" title="3.3.3 链栈的表示和实现"></a>3.3.3 链栈的表示和实现</h3><p>链栈是运算受限的单链表，只能在链表头部进行操作。定义链栈的结构类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span>&#123;<br>    SElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> *next;<br>&#125;StackNode， *LinkStack;<br>Link Stack S;<span class="hljs-comment">//创建栈S</span><br></code></pre></td></tr></table></figure><p><strong>注意：链栈中指针的方向</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211515685.png"></p><ul><li><p>链表的头指针就是栈顶</p></li><li><p>不需要头结点</p></li><li><p>基本不存在栈满的情况</p></li><li><p>空栈相当于，栈指针指向空</p></li><li><p>插入和删除仅在栈顶处执行</p></li></ul><blockquote><p>算法3.5 链栈的初始化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span></span>&#123;<br>    <span class="hljs-comment">// 构造一个空栈，栈顶指针置为空</span><br>    S = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1 判断链栈是否位空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(LinkList S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE;<br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p>算法3.6 链栈的入栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack &amp;S, SElemType e)</span></span>&#123;<br>    p = <span class="hljs-keyword">new</span> StackNode;  <span class="hljs-comment">// 生成新结点p</span><br>    p-&gt;data = e;    <span class="hljs-comment">// 将新结点数据域置为e</span><br>    p-&gt;next = S;    <span class="hljs-comment">// 将新结点插入栈顶</span><br>    S = p;          <span class="hljs-comment">// 修改栈顶指针</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.7 链栈的出栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    e = S-&gt;data;把数据用e存储<br>    p = S;  <span class="hljs-comment">//存储原来的栈顶指针</span><br>    S = S-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211531419.png"><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211531360.png"></p><blockquote><p>算法3.8 取栈顶的元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> S-&gt;data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-栈与递归"><a href="#3-4-栈与递归" class="headerlink" title="3.4 栈与递归"></a>3.4 栈与递归</h2><ul><li><p>递归的定义</p><ul><li><p>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的；</p></li><li><p>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。</p></li></ul></li><li><p>常用到递归方法的三种情况：</p><ul><li><p>递归定义的数学函数</p></li><li><p>具有递归特性的数据结构</p><ul><li><p>二叉树</p></li><li><p>广义表</p></li></ul></li><li><p>可递归求解的问题</p><ul><li><p>迷宫问题</p></li><li><p>汉诺塔问题</p></li></ul></li></ul></li><li><p>递归问题——用分治法求解</p><ul><li><p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p></li><li><p>用分治法必备的三个条件</p><ol><li><p>能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</p></li><li><p>可以通过上述转换而使得问题简化</p></li><li><p>必须有一个明确的递归出口，或称递归边界</p></li></ol></li><li><p>分治法求解递归问题算法的一般形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">(参数表)</span></span>&#123;<br>    <span class="hljs-comment">// 基本项</span><br>    <span class="hljs-keyword">if</span>(递归结束条件) 可直接求解步骤; <span class="hljs-comment">// 递归边界</span><br>    <span class="hljs-comment">// 归纳项</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">p</span>(较小的参数);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">例如：<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">Fact</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//基本项</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">Fact</span>(n<span class="hljs-number">-1</span>);  <span class="hljs-comment">//归纳项</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>函数调用过程</p><ul><li><p>调用前，系统完成</p><ul><li><p>将实参、返回地址等传递给被调函数</p></li><li><p>为被调函数的局部变量分配存储区</p></li><li><p>将控制转移到被调函数的入口</p></li></ul></li><li><p>调用后，系统完成：</p><ul><li><p>保存被调函数的计算结果</p></li><li><p>释放被调函数的数据区</p></li><li><p>依照被调函数保存的返回地址将控制转移到被调函数</p></li></ul></li></ul></li><li><p>当多个函数构成嵌套调用时</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211610264.png"><br><strong>遵循后调用的先返回</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211630096.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211633233.png"><br>工作记录包括实参，局部变量，返回地址<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211635394.png"></p><ul><li><p>递归的优缺点</p><ul><li><p>优点：结构清晰，程序易读</p></li><li><p>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</p></li></ul></li><li><p>实现递归转非递归</p><ul><li><p>方法1：尾递归、单向递归变为循环结构</p></li><li><p>方法2：自用栈模拟系统的运行时栈</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211642768.png"></p><h2 id="3-5-队列的表示和操作的实现"><a href="#3-5-队列的表示和操作的实现" class="headerlink" title="3.5 队列的表示和操作的实现"></a>3.5 队列的表示和操作的实现</h2><ul><li><p>队列描述</p><ul><li><p><strong>队列</strong>(<strong>Queue</strong>)是仅在表尾进行插入操作，在表头进行删除操作的线性表。</p></li><li><p>表尾即an端，称为队尾；表头即a1端，称为队头；</p></li><li><p>它是一种先进先出(FIFO)的线性表</p></li></ul></li><li><p>队列的常见应用</p><ul><li><p>脱机打印输出：按申请的先后顺序依次输出</p></li><li><p>多用户系统中，多个用户排成队，分时地循坏使用CPU和主存</p></li><li><p>按用户的优先级排成多个队，每个优先级一个队列</p></li><li><p>实时控制系统中，信号俺接受的先后顺序依次处理</p></li></ul></li></ul><h3 id="3-5-1-队列的抽象数据类型定义"><a href="#3-5-1-队列的抽象数据类型定义" class="headerlink" title="3.5.1 队列的抽象数据类型定义"></a>3.5.1 队列的抽象数据类型定义</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211647621.png"></p><h3 id="3-5-2-队列的顺序表示和实现"><a href="#3-5-2-队列的顺序表示和实现" class="headerlink" title="3.5.2 队列的顺序表示和实现"></a>3.5.2 队列的顺序表示和实现</h3><p>队列的物理存储可以用顺序存储结构，也可用链式存储结构。相应地队列的存储方式也分为两种，即<strong>顺序队列</strong>和<strong>链式队列</strong>。</p><p>队列的顺序表示——用一维数组<code>base[MAXQSIZE]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QElemType *base;    <span class="hljs-comment">// 初始化的动态分配存储空间</span><br>    <span class="hljs-type">int</span> front;  <span class="hljs-comment">// 头指针，即队头下标</span><br>    <span class="hljs-type">int</span> rear;   <span class="hljs-comment">// 尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211700806.png"></p><blockquote><p>顺序队列存在的问题</p></blockquote><p>顺序队列的真溢出问题：即front&#x3D;0，rear&#x3D;MAXQSIZE时，队列中存满，为真溢出；</p><p>而当入队、出队操作之后，随着front和rear移动，出现front!&#x3D;0，rear&#x3D;MAXQSIZE时，为假溢出。</p><blockquote><p>顺序队列假上溢解决办法</p></blockquote><ul><li><p>解决假上溢的方法 </p><ol><li><p>将队中元素依次向队头方向移动。缺点：浪费时间。每移动一次，队中元素都要移动。</p></li><li><p>将队空间设想成一个循环的表，即分配给队列的m个存储单元可以循环使用，当rear为maxqsize时，若向量的开始端空着，又可从头使用空着的空间。当front为maxqsize时，也是一样。</p></li></ol></li><li><p>引入循环队列——解决假上溢的问题</p><p>  <code>base[0]</code>接在<code>base[MAXQSIZE-1]</code>之后，若rear+1 &#x3D;&#x3D; M，则rear&#x3D;0；</p><p>  实现方法：利用模运算(mod, %)</p><p>  入队：(尾指针后移一位)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Q.base[Q.rear] = x;<br>Q.rear = (Q.rear+<span class="hljs-number">1</span>) % MAXQSIZE;<br></code></pre></td></tr></table></figure><p>  出队：(头指针后移一位)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">x = Q.base[Q.front];<br>Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE;<br></code></pre></td></tr></table></figure><p>  针对循环队列，判断队空、队满时，front都与rear相等，因此可解决的方案有：</p><ol><li><p>另外设一个标态以区别队空和队满</p></li><li><p>另设一个变量，记录循环队列中当前元素个数</p></li><li><p>少用一个元素空间</p></li></ol></li><li><p>循环队列解决队满时判断方法——少用一个元素空间</p><p>  队空时：front &#x3D;&#x3D; rear</p><p>  队满时：(rear+1)% MAXQSIZE &#x3D;&#x3D; front（为什么判断队满时还要取余，考虑尾指针再加一归零的情况）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211913147.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301231508757.png"></p><blockquote><p>循环队列的类型定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QElemType *base;    <span class="hljs-comment">// 初始化的动态分配存储空间</span><br>    <span class="hljs-type">int</span> front;  <span class="hljs-comment">// 头指针，若队列不为空，指向队列头元素</span><br>    <span class="hljs-type">int</span> rear;   <span class="hljs-comment">// 尾指针，若队列不为空，指向队尾元素的下一个位置</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——队列的初始化(算法3.11)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.base = <span class="hljs-keyword">new</span> QElemType[MAXQSIZE]; <span class="hljs-comment">//分配数组空间</span><br>    <span class="hljs-comment">//等同于Q.base=(QElemType*)malloc(MAXQSIZE*sizeof(QElemType));</span><br>    <span class="hljs-keyword">if</span>(!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>    Q.front = Q.rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——求队列的长度(算法3.12)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>队列中的元素个数&#x3D;(Q.rear - Q.front + MAXQSIZE) % MAXQSIZE</strong></p><blockquote><p>循环队列的操作——循环队列入队(算法3.13)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE == Q.front) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队满</span><br>    Q.base[Q.rear] = e; <span class="hljs-comment">// 新元素加入队尾</span><br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE;   <span class="hljs-comment">// 队尾指针+1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——循环队列出队(算法3.14)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队空</span><br>    e = Q.base[Q.front];    <span class="hljs-comment">// 保存队头元素</span><br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE; <span class="hljs-comment">// 队头指针+1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——取循环队列队头元素(算法3.15)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear != Q.front)&#123; <span class="hljs-comment">// 不为空</span><br>        <span class="hljs-keyword">return</span> Q.base[Q.front]; <span class="hljs-comment">// 返回队头指针元素的值，队头指针不变</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-链队——队列的链式表示和实现"><a href="#3-5-3-链队——队列的链式表示和实现" class="headerlink" title="3.5.3 链队——队列的链式表示和实现"></a>3.5.3 链队——队列的链式表示和实现</h3><p>若用户无法估计所用队列的长度，则宜采用链队列。</p><blockquote><p>链式队列的类型定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span>&#123;<br>    QElemType data;<br>    Qnode *next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> Qnode *QueuePtr;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkQueue</span>&#123;<br>    QueuePtr front; <span class="hljs-comment">// 队头指针</span><br>    QueuePtr rear;  <span class="hljs-comment">// 队尾指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——链队列的初始化(算法3.16)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueuePtr</span>();<br>    Q.rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueuePtr</span>();<br>    Q.front-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——销毁链队列(补充)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(Q.front)&#123;<br>        p = Q.front-&gt;next;<br>        <span class="hljs-built_in">delete</span> (Q.front);<br>        Q.front = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——将元素e入队(算法3.17)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;<br>    p = <span class="hljs-keyword">new</span> QueuePtr;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-built_in">exit</span>(OVERFLOW);  <span class="hljs-comment">// 存储分配失败</span><br>    p-&gt;data = e;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next = p;<br>    Q.rear = p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——链队列的出队(算法3.18)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队空</span><br>    p = Q.front-&gt;next;<br>    e = p-&gt;data;<br>    Q.front-&gt;next = p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear == p) Q.rear = Q.front;<span class="hljs-comment">//此情况为删除的就是尾结点，此时队列为空，所以要使队尾指针等于队头指针</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——求链队列的队头元素(算法3.19)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    e = Q.front-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-习题"><a href="#3-6-习题" class="headerlink" title="3.6 习题"></a>3.6 习题</h2><blockquote><p>选择题</p></blockquote><ol><li><p>设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5和e6依次进入栈s，一个元素出栈后即进入Q，若6个元素出队的序列是e2、e4、e3、e6、e5和e1，则栈S的容量至少应该是()</p><p> A. 2  <strong>B. 3</strong>  C. 4  D. 6</p></li><li><p>若一个栈以向量<code>V[1...n]</code>存储，初始栈顶指针top设为n+1，则元素x进栈的正确操作是()。</p><p> A. <code>top++; V[top]=x;</code> B. <code>V[top]=x; top++;</code> <strong>C.</strong> <code>top--; V[top]= x;</code> D. <code>V[top]=x; top--;</code></p><p> 答案：C；解释：初始栈顶指针top为n+1，说明元素从数组向量的高端地址进栈，又因为元素存储在向量空间<code>V[1...n]</code>中，所以进栈时top指针先下移变为n，之后将元素x存储在<code>V[n]</code>。</p></li></ol><blockquote><p>算法设计题</p></blockquote><ol><li><p>将编号为0和1的两个栈存放于一个数组空间<code>V[m]</code>中，栈底分别处于数组的两端。当第0号栈的栈顶指针<code>top[0]</code>等于-1时该栈为空；当第1号栈的栈顶指针<code>top[1]</code>等于m时，该栈为空。两个栈均从两端向中间增长(见图)。试编写双栈初始化，判断栈空、栈满、进栈和出栈等算法的函数。双栈数据结构的定义如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DblStack</span>&#123;<br>    <span class="hljs-type">int</span> top[<span class="hljs-number">2</span>], bot[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 栈顶和栈底指针</span><br>    SElemType* V;       <span class="hljs-comment">// 栈数组</span><br>    <span class="hljs-type">int</span> m;              <span class="hljs-comment">// 栈最大可容纳元素个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> <img src="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/%E5%8F%8C%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="双栈结构的表示"></p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。试写一个算法判定给定的字符序列是否为回文。（提示：将一半字符入栈）</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>设从键盘输入一整数的序列：a1, a2, a3,…, an，试编写算法实现：用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai &#x3D; -1时，输出栈顶整数并出栈。算法应对异常情况(入栈满等)给出相应的信息。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>从键盘上输入一个后缀表达式，试编写算法计算表达式的值。规定：逆波兰表达式的长度不超过一行，以”$”作为输入结束，操作数之间用空格分隔，操作符只可能有+、-、<em>、／四种运算。例如： 23434 + 2</em>$。</p></li><li><p>假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，称可以操作的序列为合法序列，否则称为非法序列。</p><ul><li>下面所示的序列中哪些是合法的？</li></ul><p> A. IOIIOIOO B. IOOIOIIO C. IIIOIOIO D. IIIOOIOO</p><ul><li>通过对上述的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false(假定被判定的操作序列已存入一维数组中)。</li></ul><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意：不设头指针），试编写相应的置空队列、判断队列是否为空、入队和出队等算法。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li><li><p>假设以数组<code>Q[m]</code>存放循环队列中的元素，同时设置一个标志tag，以tag &#x3D; 0和tag &#x3D; 1来区别在队头指针(front)和队尾指针(rear)相等时，队列状态为“空”还是“满”。试编写与此结构相应的插入(enqueue)和删除(dequeue)算法。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe7.cpp">算法设计题7</a></p></li><li><p>如果允许在循环队列的两端都可以进行插入和删除操作。要求：</p><ul><li><p>写出循环队列的类型定义；</p></li><li><p>写出“从队尾删除”和“从队头插入”的算法。</p></li></ul><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe8.cpp">算法设计题8</a></p></li><li><p>已知Ackermann函数定义如下：Ack(m, n) &#x3D;</p><ul><li><p>n + 1, 当m &#x3D; 0时</p></li><li><p>Ack(m-1, 1), 当m≠0, n&#x3D;0时</p></li><li><p>Ack(m-1, Ack(m, n-1)), 当m≠0, n≠0时</p></li></ul><ol><li><p>写出计算Ack(m, n)的递归算法，并根据此算法给出Ack(2, 1)的计算过程。</p></li><li><p>写出计算Ack(m,n)的非递归算法。</p></li></ol><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe9.cpp">算法设计题9</a></p></li><li><p>已知f为单链表的表头指针，链表中存储的都是整型数据，试写出实现下列运算的递归算法：</p><ol><li><p>求链表中的最大整数；</p></li><li><p>求链表的结点个数；</p></li><li><p>求所有整数的平均值。</p></li></ol><p><a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe10.cpp">算法设计题10</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和特点"><a href="#2-1-线性表的定义和特点" class="headerlink" title="2.1 线性表的定义和特点"></a>2.1 线性表的定义和特点</h2><p><strong>线性表是具有相同特性的数据元素的一个有限序列</strong>。</p><blockquote><p>线性表(Linear List)：</p></blockquote><p>由n(n ≥ 0)个数据元素（结点）a1, a2, … an组成的<strong>有限序列</strong>。</p><ul><li><p>其中数据元素的个数n定义为表的<strong>长度</strong></p></li><li><p>当n&#x3D;0时称为<strong>空表</strong></p></li><li><p>将非空的线性表(n&gt;0)记作：(a1, az, … an)</p></li><li><p>这里的数据元素ai(1≤i≤n)只是一个抽象的符号，其具体含义在不同的情况下可以不同。</p></li></ul><blockquote><p>线性表的逻辑特征</p></blockquote><ul><li><p>在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2；</p></li><li><p>有且仅有一个终端结点an，它没有直接后继，而仅有一个直接前趋an-1；</p></li><li><p>其余的内部结点ai(2≤i≤n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1。</p></li></ul><h2 id="2-2-案例引入"><a href="#2-2-案例引入" class="headerlink" title="2.2 案例引入"></a>2.2 案例引入</h2><blockquote><p>顺序存储结构存在问题</p></blockquote><ul><li><p>存储空间分配不灵活</p></li><li><p>运算的空间复杂度高</p></li></ul><blockquote><p>总结</p></blockquote><ul><li><p>线性表中的数据元素的类型可以为<strong>简单类型</strong>，也可以为<strong>复杂类型</strong></p></li><li><p>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序</p></li><li><p>从具体应用中抽象出共性的<strong>逻辑结构和基本操作</strong>（抽象数据类型），然后实现其<strong>存储结构和基本操作</strong></p></li></ul><h2 id="2-3-线性表的定义"><a href="#2-3-线性表的定义" class="headerlink" title="2.3 线性表的定义"></a>2.3 线性表的定义</h2><blockquote><p>基本操作</p></blockquote><ul><li><p>InitList(&amp;L)</p><ul><li>操作结果：构造一个空的线性表L</li></ul></li><li><p>DestoryList(&amp;L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：销毁线性表L</p></li></ul></li><li><p>ClearList(&amp;L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：将线性表L重置为空表</p></li></ul></li><li><p>ListEmpty(L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若线性表L空表则返回TURE；否则返回FALSE。</p></li></ul></li><li><p>ListLength(L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：返回线性表L中的数据元素个数。</p></li></ul></li><li><p>GetElem(L, i, &amp;e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</p></li><li><p>操作结果：用e返回线性表L中第个数据元素的值。</p></li></ul></li><li><p>LocateElem(L, e, compare())</p><ul><li><p>初始条件：线性表L已存在，compare()是数据元素判定函数</p></li><li><p>操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。</p></li></ul></li><li><p>PriorElem(L, cur_e, &amp;pre_e)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义。</p></li></ul></li><li><p>NextElem(L, cur_e, &amp;next_e)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若cur_e是L的数据元素，且不是第最后个，则用next_e返回它的后继，否则操作失败，next_e无意义。</p></li></ul></li><li><p>ListInsert(&amp;L, i, e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)+1</p></li><li><p>操作结果：在L的第i个位置<strong>之前</strong>插入新的数据元素e，L的长度加一。</p></li></ul></li><li><p>ListDelete(&amp;L, i, &amp;e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</p></li><li><p>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一。</p></li></ul></li><li><p>ListTraverse(&amp;L, visited())   &#x2F;&#x2F; 遍历</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：依次对线性表中每个元素调用visited()。</p></li></ul></li></ul><h2 id="2-4-线性表的顺序表示和实现"><a href="#2-4-线性表的顺序表示和实现" class="headerlink" title="2.4 线性表的顺序表示和实现"></a>2.4 线性表的顺序表示和实现</h2><h3 id="2-4-1-线性表的顺序存储表示"><a href="#2-4-1-线性表的顺序存储表示" class="headerlink" title="2.4.1 线性表的顺序存储表示"></a>2.4.1 线性表的顺序存储表示</h3><p>线性表的顺序表示又称为<strong>顺序存储结构</strong>或<strong>顺序映像</strong>。</p><p>顺序存储定义：把<strong>逻辑上相邻的数据元素</strong>存储在<strong>物理上相邻的存储单元</strong>中的存储结构。</p><p>线形表顺序存储结构占用<strong>一片续的存储空间</strong>。知道某个元素的存储位置就可以计算其他元素的存储位置。</p><blockquote><p>数组静态分配</p></blockquote><p>这段代码就相当于一个模板<br>typedef是用来给数据类型起一个新的名字<br>ElemType是数组的数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 100  <span class="hljs-comment">//线性表存储空间初始分配量</span></span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType data[MaxSize];<br>    <span class="hljs-type">int</span> length;  <span class="hljs-comment">//线性表当前长度</span><br>  &#125; SqList; <span class="hljs-comment">// 顺序表类型</span><br></code></pre></td></tr></table></figure><p>数组存放的是第一个元素的地址，因此也可以写成以下动态分配形式，用指针代替第一个元素地址。</p><blockquote><p>数组动态分配</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 1000  <span class="hljs-comment">//线性表存储空间</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>  ElemType *data;  <span class="hljs-comment">//存储空间的基地址</span><br>  <span class="hljs-type">int</span> length;<br>&#125; SqList; <span class="hljs-comment">// 定义顺序表类型</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">SqList L;  <span class="hljs-comment">//定义变量L，L是SqList这种类型的，L是个线性表</span><br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ElemType) * MaxSize);<br></code></pre></td></tr></table></figure><p>（ElemType*）表示强制类型转换</p><p>在头文件stdlib.h中：</p><p>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址。</p><p>size of(x)运算，计算变量x的长度</p><p>free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量。</p><blockquote><p>补充：C++的动态存储分配</p></blockquote><p>new 类型名T （初值列表）<br>    功能：<br>        申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值<br>    结果值：<br>        成功：T类型的指针，指向新分配的内存<br>        失败：0（NULL)<br>例如：int * p1 &#x3D; new int;或int * p1 &#x3D; new int(10);<br>注意：new出来的空间是一个地址所以只能赋值给指针。</p><p>delete 指针p<br>    功能：<br>        释放指针p所指向的内存。p必须是new操作的返回值</p><blockquote><p>补充：C++的参数传递</p></blockquote><ul><li><p>函数调用时传送给形参表的实参必须与形参三个一致</p><ul><li>类型、个数、顺序</li></ul></li><li><p>参数传递有两种方式</p><ul><li>传值方式</li><li>传地址<ul><li>参数为指针变量</li><li>参数为引用类型</li><li>参数为数组名</li></ul></li></ul></li><li><p>传地址方式–引用类型作参数<br>什么是引用？？？<br>引用：它用来给一个对象提供一个替代的名字</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp;j=i;<br>i=<span class="hljs-number">7</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j;<br>&#125;  <span class="hljs-comment">//j是一个引用类型，代表i的一个替代名i值改变时，j值也跟着改变，所以会输出i=7 j=7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210192252376.png"></p><p>m是对a的引用，n是对b的引用，通过引用变量直接操作实参</p><p>可以这样理解：m和a用的是同一个地址，他们共用同一块空间</p><ul><li>引用类型作形参的三点说明<ul><li>传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化</li><li>引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作，而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值时实参变量的副本。因此当参数传递的<strong>数据量比较大</strong>时，用引用比用一般变量传递参数的时间和空间效率都好</li><li>指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“* 指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用的点出，必须用变量的地址作为实参</li></ul></li></ul><h3 id="2-4-2-顺序表基本操作的实现"><a href="#2-4-2-顺序表基本操作的实现" class="headerlink" title="2.4.2 顺序表基本操作的实现"></a>2.4.2 顺序表基本操作的实现</h3><blockquote><p>线性表L的初始化</p></blockquote><p>Status 是函数的类型，其值是函数结果状态代码，在本例中为int的别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<span class="hljs-comment">// 构造一个空的顺序表L   </span><br>L.elem=<span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">// 为顺序表分配空间</span><br><span class="hljs-keyword">if</span>(!L.elem) <br>    <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 空表长度为0</span><br><span class="hljs-keyword">return</span> OK；<br></code></pre></td></tr></table></figure><blockquote><p>销毁线性表L</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestoryList</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(L.elem) <br>      <span class="hljs-keyword">delete</span> L.elem; <span class="hljs-comment">// 释放存储空间</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>清空线性表L</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 将线性表的长度置为0</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>求线性表的长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> L.length;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>判断线性表是否为空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>顺序表的取值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 取物理位置第i个元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt;= L.length) <span class="hljs-keyword">return</span> ERROR;<br><br>  e = L.elem[i<span class="hljs-number">-1</span>];<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是在主函数定义了变量e，并且通过引用的方式把值已经传给e了，所以不用return e，这样写代码是为了获取状态代码，判断此操作中传入的i值是否可在线性表中取到</p><blockquote><p>顺序表按值查找(顺序查找)</p></blockquote><ul><li><p>在线性表L中查找与指定值e相同的数据元素的位置</p></li><li><p>从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//顺序表的查找（按值查找）</span><br><span class="hljs-comment">//暂且先用最简单的查找方法，从表的一端开始，逐个进行记录的关键字和给定值比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在线性表L中查找值为e的元素，返回其序号（是第几个元素）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;  <span class="hljs-comment">//查找成功，返回序号</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//查找失败，返回0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>平均查找长度ASL(Average Search Length):</p><ul><li><p>为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的<strong>平均查找长度</strong>。</p></li><li><p><strong>数学期望&#x3D;平均查找长度</strong></p></li></ul><blockquote><p>顺序表插入</p></blockquote><p>插入不同位置的算法演示：插入位置在最后、插入位置在中间、插入位置在最前面</p><p>算法思想：</p><ol><li><p>判断插入位置i是否合理</p></li><li><p>判断顺序表的存储空间是否已满，若已满返回ERROR</p></li><li><p>将第n至第i位的元素一次向后移动一个位置，空出第i个位置</p></li><li><p>将要插入的新元素e放入第i个位置</p></li><li><p>表长加1，返回插入成功。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ListInsert_Sq</span>(SqList&amp; L, <span class="hljs-type">int</span> i, ElemType e)<br>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// i值不合法</span><br>  <span class="hljs-keyword">if</span>(L.length == MAXSIZE) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 当前存储已满</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = L.length<span class="hljs-number">-1</span>; j &gt;= i; j--)&#123;<br>    L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<br>  &#125;  <span class="hljs-comment">//把位置i后的元素都后移一个位置</span><br>  L.elem[i<span class="hljs-number">-1</span>] = e;<br>  L.length++;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表插入算法的平均时间复杂度为O(n)。</p><blockquote><p>顺序表的删除算法</p></blockquote><p>算法思想：</p><ol><li><p>判断删除位置i是否合法</p></li><li><p>将欲删除的元素保留在e中</p></li><li><p>将第i+1至第n位的元素依次向前移动一个位置</p></li><li><p>表长减1，删除成功返回OK</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ListInsert_Sq</span>(SqList&amp; L, <span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// i值不合法</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= L.length<span class="hljs-number">-1</span>; j++)&#123;<br>    L.elem[j<span class="hljs-number">-1</span>] = L.elem[j];<br>  &#125;<br>  L.length--;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125; <br><span class="hljs-comment">//注意算法里面的i是位置不是数组下标</span><br></code></pre></td></tr></table></figure><p>顺序表删除算法的平均时间复杂度为O(n)。</p><h3 id="2-4-3-顺序表小结"><a href="#2-4-3-顺序表小结" class="headerlink" title="2.4.3 顺序表小结"></a>2.4.3 顺序表小结</h3><ol><li><p>利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致</p></li><li><p>在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等</p><ul><li>这种存取元素的方法被称为<strong>随机存取法</strong></li></ul></li></ol><blockquote><p>顺序表的操作算法分析</p></blockquote><ul><li><p>时间复杂度</p><ul><li>查找、插入、删除算法的平均时间复杂度为O(n)</li></ul></li><li><p>空间复杂度</p><ul><li>顺序表操作算法的空间复杂度S(n) &#x3D; O(1)，没有占用辅助空间</li></ul></li></ul><blockquote><p>顺序表的优缺点</p></blockquote><ol><li><p>优点</p><ul><li><p>存储密度大（结点本身所占存储量&#x2F;结点结构所占存储量）</p></li><li><p>可以随机存取表中任一元素</p></li></ul></li><li><p>缺点</p><ul><li><p>在插入、删除某一元素时，需要移动大量元素</p></li><li><p>浪费存储空间</p></li><li><p>属于静态存储形式，数据元素的个数不能自由扩充</p></li></ul></li></ol><h2 id="2-5-线性表的链式表示和实现"><a href="#2-5-线性表的链式表示和实现" class="headerlink" title="2.5 线性表的链式表示和实现"></a>2.5 线性表的链式表示和实现</h2><ul><li><p>链式存储结构</p><ul><li>节点在存储器中的位置是任意的，即逻辑上相邻的数据在物理上不一定相邻</li></ul></li><li><p>线性表的链式表示又称为非顺序映像或链式映像。</p></li><li><p>用一组<strong>物理位置任意的存储单元</strong>来存放线性表的数据元素。</p></li></ul><p>单链表由头指针惟一确定，因此单链表可以用头指针的名字来命名。</p><p>各结点由两个域组成：</p><ul><li><p>数据域：存储元素数值数据</p></li><li><p>指针域：存储直接后继结点的存储位置</p></li></ul><blockquote><p>链式存储有关的术语</p></blockquote><ol><li><p>结点：数据元素的存储映像。由数据域和指针域两部分组成</p></li><li><p>链表：n个结点由<strong>指针链</strong>链接而成的一个链表</p></li><li><p>链表类型</p><p> 单链表：结点只有一个指针域的链表；</p><p> 双链表：结点有两个指针域的链表；</p><p> 循环链表：首尾相接的链表；</p></li><li><p>头指针、头结点和首元结点：</p><p> 头指针：是指向链表中第一个结点的指针，即指向头结点</p><p> 首元结点：是指链表中存储第一个数据元素a1的结点</p><p> 头结点：是在链表的首元结点之前附设的一个结点，一个附加结点。</p></li></ol><p><strong>以上三个概念一定要区分好</strong></p><blockquote><p>讨论1：如何表示空表</p></blockquote><ul><li><p>若无头结点时，头指针为空时表示空表</p></li><li><p>有头结点时，当头结点的指针域位空时表示空表</p></li></ul><blockquote><p>讨论2：在链表中设置头结点有什么好处？</p></blockquote><ol><li><p>便于首元结点的处理</p><p> 首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理</p></li><li><p>便于空表和非空表的统一处理</p><p> 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</p></li></ol><blockquote><p>讨论3：头结点的数据域内装的是什么？</p></blockquote><p>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</p><blockquote><p>链表的特点：</p></blockquote><ol><li><p>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻</p></li><li><p>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间<strong>不相同</strong></p></li><li><p><strong>链表是顺序存取的，顺序表是随机存取的</strong></p></li></ol><h3 id="2-5-1-单链表的定义和表示"><a href="#2-5-1-单链表的定义和表示" class="headerlink" title="2.5.1 单链表的定义和表示"></a>2.5.1 单链表的定义和表示</h3><blockquote><p>带头结点的单链表</p></blockquote><p>单链表是由<strong>表头</strong>唯一确定，因此单链表可以用头指针的名字来命名若头指针名是L，则把链表称为表L</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123; <span class="hljs-comment">// 声明结点的类型和指向结点的指针类型</span><br>  ElemType data;  <span class="hljs-comment">// 结点的数据域</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next;    <span class="hljs-comment">// 结点的指针域</span><br>&#125; Lnode, *LinkList; <span class="hljs-comment">// LinkList为指向结构体Lnode的指针类型，LinkList也就是别名</span><br></code></pre></td></tr></table></figure><p>定义链表L：LinkList L;  （指向头结点）</p><p>定义结点指针p：LNode * p等价于LinkList p;（指向中间结点，也就是结点的指针域）</p><h3 id="2-5-2-单链表基本操作的实现"><a href="#2-5-2-单链表基本操作的实现" class="headerlink" title="2.5.2 单链表基本操作的实现"></a>2.5.2 单链表基本操作的实现</h3><blockquote><p>算法2.6——单链表的初始化(带头结点的单链表)</p></blockquote><p>单链表的初始化即构造一个空表。</p><p>算法步骤：</p><ol><li><p>生成新结点作为头结点，用头指针L指向头结点</p></li><li><p>将头结点的指针域置空</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1：判断链表是否为空</p></blockquote><p>空表：链表中无元素，称为空链表(头指针和头结点仍然在)</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123; <span class="hljs-comment">// 若L为空表，则返回1，否则返回0</span><br>  <span class="hljs-keyword">if</span>(L-&gt;next)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法2：单链表的销毁：链表销毁后不存在</p></blockquote><p>算法思路：从头指针开始，依次释放所有结点</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">// 销毁单链表L</span><br>  Lnode *p;<br>  <span class="hljs-keyword">while</span>(L)&#123; <span class="hljs-comment">// 直至L为空</span><br>    p = L;<br>    L = L-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>  &#125;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3：清空链表</p></blockquote><p>链表仍存在，但链表中无元素，成为空链表(头指针和头结点仍然在)</p><p>算法思路：依次释放所有结点，并将头结点指针域设置为空</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">// 将L重置为空表</span><br>  Lnode *p, *q<br>  p = L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p)&#123;<br>    q = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = q;<br>  &#125;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 头结点指针域为空</span><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3：求单链表的表长</p></blockquote><p>算法思路：从首元结点开始，依次计数所有结点</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>&#123; <span class="hljs-comment">// 返回L中数据元素个数</span><br>  LinkList p;<br>  p = L-&gt;next;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(p)&#123; <span class="hljs-comment">// 遍历单链表，统计结点数</span><br>    i++;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.7——取值(取单链表中第i个元素的内容)</p></blockquote><p>算法思路：从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止。因此，<strong>链表不是随机存取结构</strong>。</p><p>算法步骤：</p><ol><li><p>从第一个结点(L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p &#x3D; L-&gt;next;</p></li><li><p>j做计数器，累计当前扫描过的结点数，j初值为1；</p></li><li><p>当p指向扫描到的下一个结点时，计数器j加1；</p></li><li><p>当j &#x3D;&#x3D; i时，p所指的结点就是要找的第i个结点。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-comment">// 获取线性表L中的某个数据元素的内容，通过变量e返回</span><br>  p = L-&gt;next; j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(!p || j &gt; i) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 第i个元素不存在</span><br>  e = p-&gt;data;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找：</p><ul><li><p>按值查找：根据指定数据获取该数据所在的位置（该数据的地址）；</p></li><li><p>按值查找：根据指定数据获取该数据所在位置序号（是第几个元素）</p></li></ul><blockquote><p>算法2.8——按值查找：根据指定数据获取该数据所在的位置（地址）</p></blockquote><p>算法步骤：</p><ol><li><p>从第一个结点起，依次和e相比较</p></li><li><p>如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址；</p></li><li><p>如果查遍整个链表都没有找到其值和e相等的元素，则返回0或NULL。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Lnode* <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 在线性表L中查找值e的数据元素</span><br>  <span class="hljs-comment">// 找到，则返回L中值为e的数据元素的地址，查找失败返回NULL</span><br>  p = L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.8 变化——按值查找：根据指定数据获取该数据所在的位置序号</p></blockquote><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 返回L中值为e的数据元素的位置序号，查找失败返回0</span><br>  p = L-&gt;next; j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>    p = p-&gt;next;<br>    j++;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(p) <span class="hljs-keyword">return</span> j;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.9 插入——在第i个结点前插入值为e的新结点</p></blockquote><p>算法步骤：</p><ol><li><p>首先找到ai-1的存储位置p</p></li><li><p>生成一个数据域为e的新结点s</p></li><li><p>插入新结点：</p><ol><li><p>新结点的指针域指向结点ai</p></li><li><p>结点ai-1的指针域指向新结点</p></li></ol></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;<br>  p = L; j = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 寻找第i-1个结点，p指向i-1结点</span><br>  <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i - <span class="hljs-number">1</span>)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-comment">// /i大于表长+1或者小于1，插入位置非法</span><br>  <span class="hljs-keyword">if</span>(!p || j &gt; i - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <br>  <span class="hljs-comment">// 生成新结点s，将结点s的数据域置为e</span><br>  s = <span class="hljs-keyword">new</span> LNode;<br>  s-&gt;data = e;<br>  <span class="hljs-comment">// 将结点s插入L中</span><br>  s-&gt;next = p-&gt;next;<span class="hljs-comment">//把p的指针域的指针（原本指向p后面一个结点的指针）赋值给s的指针域里的指针</span><br>  p-&gt;next = s;<span class="hljs-comment">//把指向s结点的指针赋值给p的指针域里的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.10 删除——删除第i个结点</p></blockquote><p>算法步骤：</p><ol><li><p>首先找到ai-1的存储位置p，保存要删除的ai的值</p></li><li><p>令p-&gt;next指向ai+1</p></li><li><p>释放结点ai的空间</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// 将线性表L中第i个数据元素删除</span><br>  <span class="hljs-function">Status <span class="hljs-title">ListDelete_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType&amp;e)</span></span>&#123;<br>  p = L; j = <span class="hljs-number">0</span>; <br>  <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="hljs-number">-1</span>)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-comment">// 寻找第i个结点，并令p指向其前驱</span><br>  <span class="hljs-keyword">if</span>(!(p-&gt;next) || j &gt; i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR；<span class="hljs-comment">//删除位置不合理</span><br>  q = p-&gt;next;  <span class="hljs-comment">// 临时保存被删结点的地址以备释放</span><br>  <span class="hljs-comment">//让q指向p后面的一个结点</span><br>  p-&gt;next = q-&gt;next; <span class="hljs-comment">// 改变删除结点前驱结点的指针域</span><br>  <span class="hljs-comment">//让p指向q后面的一个结点，此时q变成了原来要删除的结点，而p跳过了q，指向q后面的一个结点</span><br>  e = q-&gt;data;  <span class="hljs-comment">// 保存删除结点的数据域</span><br>  <span class="hljs-keyword">delete</span> q;     <span class="hljs-comment">// 释放删除结点的空间</span><br>  <span class="hljs-keyword">return</span> OK;<br>&#125; <span class="hljs-comment">// ListDelete_L</span><br></code></pre></td></tr></table></figure><blockquote><p>算法2.11 建立单链表——头插法（倒位序）</p></blockquote><p>头插法：元素插入在链表头部，也叫前插法</p><p>算法步骤：</p><ol><li><p>从一个空表开始，重复读入数据；</p></li><li><p>生成新结点，将读入数据存放到新结点的数据域中</p></li><li><p><strong>从最后一个结点开始</strong>，依次将各结点插入到链表的前端</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142235433.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先建立一个带头结点的单链表</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; --i)&#123;<br>    p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点p</span><br>    cin &gt;&gt; p-&gt;data; <span class="hljs-comment">// 输入元素值</span><br>    p-&gt;next = L-&gt;next;  <span class="hljs-comment">// 插入到表头</span><br>    L-&gt;next = p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.11 建立单链表——尾插法（正位序）</p></blockquote><p>尾查法：元素插入在链表尾部，也叫后插法</p><p>算法步骤：</p><ol><li><p>从一个空表开始，正位序将新结点逐个插入到链表的尾部，尾指针r始终指向链表的尾结点。</p></li><li><p>初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142255418.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>;<br>  r = L;  <span class="hljs-comment">// 尾指针r指向头结点</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点，输入元素值</span><br>    cin &gt;&gt; p-&gt;data;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//新结点指针域先赋值为空</span><br>    r-&gt;next = p;<span class="hljs-comment">//把新的结点插入到链表尾部</span><br>    r = p;<span class="hljs-comment">//更新尾指针</span><br>  &#125;<br>&#125; <span class="hljs-comment">// CreateList_R</span><br></code></pre></td></tr></table></figure><h3 id="2-5-3-单链表的查找、插入、删除算法时间效率分析"><a href="#2-5-3-单链表的查找、插入、删除算法时间效率分析" class="headerlink" title="2.5.3 单链表的查找、插入、删除算法时间效率分析"></a>2.5.3 单链表的查找、插入、删除算法时间效率分析</h3><ol><li><p>因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为O(n)</p></li><li><p>插入和删除：</p><p> 因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为O(1)。</p><p> 但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)</p></li><li><p>头插法的时间复杂度是O(n)</p></li><li><p>尾插法的时间复杂度是O(n)</p></li></ol><h3 id="2-5-4-循环链表"><a href="#2-5-4-循环链表" class="headerlink" title="2.5.4 循环链表"></a>2.5.4 循环链表</h3><p>循环链表：是一种头尾相接的链表（即：表中最后一个结点的指针域指向头结点，整个链表形成一个环）。</p><p>优点：<strong>从表中任一结点出发均可找到表中其他结点</strong>。</p><p>循环链表的空表表示：头指针的指针域指向自己。</p><blockquote><p>注意：</p></blockquote><p>由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p-&gt;next是否为空，而是判断它们<strong>是否等于头指针</strong>。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151549155.png"></p><blockquote><p>头指针表示单循环链表</p></blockquote><p>找a1的时间复杂度：O(1)</p><p>找an的时间复杂度：O(n)</p><p>但考虑到表的操作常常是在表的首尾位置上进行，因此更过的是考虑用<strong>尾指针表示单循环链表</strong></p><blockquote><p>尾指针表示单循环链表</p></blockquote><p>设尾指针为R：</p><p>找a1的时间复杂度：O(1)，a1的存储位置是：R-&gt;next-&gt;next</p><p>找an的时间复杂度：O(1)，an的存储位置是：R</p><blockquote><p>带尾指针循环链表的合并（将Tb合并在Ta之后）</p></blockquote><p>操作步骤：</p><ol><li><p>p存表头结点：p &#x3D; Ta-&gt;next;</p></li><li><p>Tb表头连接到Ta表尾:Ta-&gt;next &#x3D; Tb-&gt;next-&gt;next;</p></li><li><p>释放Tb表头结点:delete Tb-&gt;next;</p></li><li><p>修改指针:Tb-&gt;next &#x3D; p;</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151601055.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span></span>&#123;<br>  <span class="hljs-comment">// 假设Ta、Tb都是非空的单循环链表</span><br>  p = Ta-&gt;next;     <span class="hljs-comment">// 1. p存表头结点</span><br>  Ta-&gt;next = Tb-&gt;next-&gt;next;  <span class="hljs-comment">// Tb表头连接到Ta表尾</span><br>  <span class="hljs-keyword">delete</span> Tb-&gt;next;         <span class="hljs-comment">// 释放Tb表头结点</span><br>  Tb-&gt;next = p;           <span class="hljs-comment">// 修改指针</span><br>  <span class="hljs-keyword">return</span> Tb;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(1)</p><h3 id="2-5-5-双向链表"><a href="#2-5-5-双向链表" class="headerlink" title="2.5.5 双向链表"></a>2.5.5 双向链表</h3><p>双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了有两个方向不同的链，故称为双向链表。</p><p>双向链表结构定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>&#123;<br>  Elemtype data;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *prior, *next;<br>&#125;DuLNode, *DuLinkList;<br></code></pre></td></tr></table></figure><p>双向循环链表:</p><p>和单链的循环表类似，双向链表也可以有循环表</p><ul><li><p>让头结点的前驱指针指向链表的最后一个结点</p></li><li><p>让最后一个结点的后继指针指向头结点。</p></li></ul><p>在双向链表中有些操作（如：ListLength、GetElem等），因仅涉及一个方向的指针，故它们的算法与线性链表的相同。但在插入、删除时，则需同时修改两个方向上的指针，两者的操作的时间复杂度均为O(n)。</p><blockquote><p>算法2.13 双向链表的插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 在带头结点的双向循环链表L中第i个位置之前插入元素e</span><br>  <span class="hljs-keyword">if</span>(!(p = <span class="hljs-built_in">GetElemP_DuL</span>(L, i))) <span class="hljs-keyword">return</span> ERROR;<br>  s = <span class="hljs-keyword">new</span> DuLNode;<br>  s-&gt;data = e;<br>  s-&gt;prior = p-&gt;prior;<br>  p-&gt;prior-&gt;next = s;<br>  s-&gt;next = p;<br>  p-&gt;prior = s;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.14 双向链表的删除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListDelete_DuL</span><span class="hljs-params">(DuLinkList&amp; L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-comment">// 删除带头结点的双向循环链表L的第i个元素，并用e返回。</span><br>  <span class="hljs-keyword">if</span>(!(p = <span class="hljs-built_in">GetElemP_DuL</span>(L, i))) <span class="hljs-keyword">return</span> ERROR;<br>  e = p-&gt;data;<br>  p-&gt;prior-&gt;next = p-&gt;next;<br>  p-&gt;next-&gt;prior = p-&gt;prior;<br>  <span class="hljs-keyword">delete</span> p;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单链表、循环链表和双向链表的时间效率比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131139437.png"></p><h2 id="2-6-顺序表和链式表的比较"><a href="#2-6-顺序表和链式表的比较" class="headerlink" title="2.6 顺序表和链式表的比较"></a>2.6 顺序表和链式表的比较</h2><blockquote><p>链式存储结构的优点：</p></blockquote><ul><li><p>结点空间可以动态申请和释放；</p></li><li><p>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素。</p></li></ul><blockquote><p>链式存储结构的缺点</p></blockquote><ul><li><p>存储密度小：每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大。</p></li><li><p>链式存储结构是非随机存取结构。对任一结点的操作都需要从头指针依指针链查找到该结点，这增加了算法的复杂度。</p></li></ul><blockquote><p>顺序表和链式表的比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131138707.png"></p><h2 id="2-7-线性表的应用"><a href="#2-7-线性表的应用" class="headerlink" title="2.7 线性表的应用"></a>2.7 线性表的应用</h2><p>主要介绍线性表的合并和有序表的合并。</p><blockquote><p>线性表的合并 </p></blockquote><ul><li><p>问题描述：</p><p>假设利用两个线性表La和Lb分别表示两个集合A和B，现要求合一个新的集合A &#x3D; A∪B</p></li><li><p>算法步骤：</p><p>依次取出Lb中的每个元素，执行以下操作：</p><ol><li><p>在La中查找该元素</p></li><li><p>如果找不到，则将其插入La的最后</p></li></ol></li><li><p>算法描述：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(List &amp;La, List Lb)</span></span>&#123;<br>  La_len = <span class="hljs-built_in">ListLength</span>(La);<br>  Lb_len = <span class="hljs-built_in">ListLength</span>(Lb);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; Lb_len; i++)&#123;<br>    <span class="hljs-built_in">GetElem</span>(Lb, i, e);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">LocateElem</span>(La, e))&#123;<br>      <span class="hljs-built_in">ListInsert</span>(&amp;La, ++La_len, e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述算法时间复杂度为O(La_len*Lb_len)。</p><blockquote><p>有序表的合并</p></blockquote><ul><li><p>问题描述：</p><p>已知线性表La和Lb的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素仍按值非递减有序排列。</p></li><li><p>算法步骤：</p><ol><li><p>创建一个空表Lc</p></li><li><p>依次从La或Lb中“摘取”元素值较小的结点插入到Lc表的最后，直至其中一个表变空为止</p></li><li><p>继续将La或Lb其中一个表的剩余结点插入在Lc表的最后</p></li></ol></li></ul><blockquote><p>算法2.16 有序表合并——用顺序表实现</p></blockquote><ul><li>用顺序表实现</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_sq</span><span class="hljs-params">(SqList LA, SqList LB, SqList&amp; LC)</span></span>&#123;<br>  <span class="hljs-comment">// 指针pa和pb的初值分别指向两个表的第一个元素</span><br>  pa = LA.elem;<br>  pb = LB.elem;<br><br>  <span class="hljs-comment">// 新表长度为待合并两表的长度和</span><br>  LC.length = LA.length + LB.length;<br>  <span class="hljs-comment">// 为新表分配空间</span><br>  LC.elem = <span class="hljs-keyword">new</span> ElemType[LC.length];<br>  pc = LC.elem;<br><br>  <span class="hljs-comment">// 找到LA和LB的最后一个元素</span><br>  pa_last = LA.elem + LA.length - <span class="hljs-number">1</span>;<br>  pb_last = LB.elem + LB.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 两个表都非空</span><br>  <span class="hljs-keyword">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)&#123;<br>    <span class="hljs-keyword">if</span>(*pa &lt;= *pb)&#123;<br>      *pc++ = *pa++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      *pc++ = *pb++;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// LB已到达表尾，将LA中剩余元素加入LC</span><br>  <span class="hljs-keyword">while</span>(pa &lt;= pa_last) *pc++ = *pa++;<br><br>  <span class="hljs-comment">// LA已到达表尾，将LB中剩余元素加入LC</span><br>  <span class="hljs-keyword">while</span>(pb &lt;= pb_last) *pc++ = *pb++;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为：O(ListLength(LA)+ListLength(LB))</p><p>空间复杂度为：O(ListLength(LA)+ListLength(LB))</p><blockquote><p>算法2.17 有序表合并——用链表实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_L</span><span class="hljs-params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;<br>  pa = La-&gt;next;<br>  pb = Lb-&gt;next;<br>  <span class="hljs-comment">// pc指针指向头结点</span><br>  pc = Lc = La; <span class="hljs-comment">// 用La的头结点作为Lc的头结点</span><br>  <span class="hljs-keyword">while</span>(pa &amp;&amp; pb)&#123;<br>    <span class="hljs-keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;<br>      pc-&gt;next = pa;<br>      pc = pa;<br>      pa = pa-&gt;next;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      pc-&gt;next = pb;<br>      pc = pb;<br>      pb = pb-&gt;next;<br>    &#125;<br>  &#125;<br>  pc-&gt;next = pa ? pa : pb;  <span class="hljs-comment">// 插入剩余段</span><br>  <span class="hljs-keyword">delete</span> Lb;  <span class="hljs-comment">// 删除Lb的头结点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为：O(ListLength(La)+ListLength(Lb))</p><p>空间复杂度为：O(1)</p><h2 id="2-8-案例分析与实现"><a href="#2-8-案例分析与实现" class="headerlink" title="2.8 案例分析与实现"></a>2.8 案例分析与实现</h2><blockquote><p>案例2.1：一元多项式的运算，实现两个多项式的加、减、乘运算</p></blockquote><p>可用顺序表实现。</p><blockquote><p>案例2.2：稀疏多项式的运算</p></blockquote><p>对于稀疏多项式，可考虑创建一个新的结构体，分别保存指数和系数。</p><p>利用顺序表实现时存在<strong>存储空间分配不灵活、运算得空间复杂度高</strong>等缺点。可考虑利用链式存储结构实现。</p><p>定义新的链表结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span>&#123;<br>  <span class="hljs-type">float</span> coeff;  <span class="hljs-comment">// 系数</span><br>  <span class="hljs-type">int</span> expn;     <span class="hljs-comment">// 指数</span><br>  PNode *next;  <span class="hljs-comment">// 指针域</span><br>&#125;PNode， *Polynomial;<br></code></pre></td></tr></table></figure><ul><li><p>多项式相加</p><ul><li><p>多项式创建——算法步骤</p><ol><li><p>创建一个只有头结点的空链表；</p></li><li><p>根据多项式的项的个数n，循环n次执行以下操作：</p><ul><li><p>生成一个新结点*s；</p></li><li><p>输入多项式当前项的系数和指数赋给新结点*s的数据域；</p></li><li><p>设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点；</p></li><li><p>指针q初始化，指向首元结点；</p></li><li><p>循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点*q；</p></li><li><p>将输入项结点*s插入到结点q之前。</p></li></ul></li></ol></li><li><p>多项式创建——算法描述(头插法)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatePolyn</span><span class="hljs-params">(Polynomial &amp;P, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  <span class="hljs-comment">// 输入m项的系数和指数，建立表示多项式的有序链表P</span><br>  P = <span class="hljs-keyword">new</span> PNode;<br>  P-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先建立一个带头结点的单链表</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;  <span class="hljs-comment">// 依次输入n个非零项</span><br>    s = <span class="hljs-keyword">new</span> PNode;  <span class="hljs-comment">// 生成新结点</span><br>    cin &gt;&gt; s-&gt;coef &gt;&gt; s-&gt;expn;<br>    pre = p;      <span class="hljs-comment">// pre用于保存q的前驱，初值为头结点</span><br>    q = p-&gt;next;  <span class="hljs-comment">// q初始化，指向首元结点</span><br>    <span class="hljs-keyword">while</span>(q &amp;&amp; q-&gt;expn &lt; s-&gt;expn)&#123;  <span class="hljs-comment">// 找到第一个大于输入项指数的项*q</span><br>      pre = q;<br>      q = p-&gt;next;<br>    &#125;<br>    s-&gt;next = q;  <span class="hljs-comment">// 将输入项s插入到q和其前驱结点pre之间</span><br>    pre-&gt;next = s;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多项式相加——算法步骤</p><ol><li><p>指针p1和p2初始化，分别指向Pa和Pb的首元结点。</p></li><li><p>p3指向和多项式的当前结点，初值为Pa的头结点。</p></li><li><p>当指针p1和p2均未到达相应表尾时，则循环比较p1和p2所指结点对应的指值(p1-&gt;expn与p2-&gt;expn)，有下列三种情况：</p><ul><li><p>当p1-&gt;expn &#x3D;&#x3D; p2-&gt;expn时，则将两个结点中的系数相加</p><ul><li><p>若和不为零，则修改p1所指结点的系数值，同时删除p2所指结点</p></li><li><p>若和为零，则删除p1和p2所指结点</p></li></ul></li><li><p>当p1-&gt;expn &lt; p2-&gt;expn时，则应摘取p1所指结点插入到“和多项式”链表中表；</p></li><li><p>当p1-&gt;expn &gt; p2-&gt;expn时，则应摘取p2所指结点插入到“和多项式”链表中表；</p></li></ul></li><li><p>将非空多项式的剩余段浦入到p3所指结点之后</p></li><li><p>释放Pb的头结点。</p></li></ol></li></ul></li></ul><blockquote><p>案例2.3 图书信息管理系统</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构绪论——王卓</title>
    <link href="/2022/10/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-数据结构绪论"><a href="#第一章-数据结构绪论" class="headerlink" title="第一章 数据结构绪论"></a>第一章 数据结构绪论</h1><h2 id="1-1-数据结构的研究内容"><a href="#1-1-数据结构的研究内容" class="headerlink" title="1.1 数据结构的研究内容"></a>1.1 数据结构的研究内容</h2><p>计算机进行数值计算式，首先从具体问题抽象出数学模型，然后设计一个解此数学模型的算法，最后编写程序，进行测试、调试，直到解决问题。</p><p><strong>数据结构</strong>是一门研究<strong>非数值计算</strong>的程序设计中计算机的操作对象（表、树、图等）以及它们之间关系和操作的学科。</p><h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><h3 id="1-2-1-数据、数据元素、数据项和数据对象"><a href="#1-2-1-数据、数据元素、数据项和数据对象" class="headerlink" title="1.2.1 数据、数据元素、数据项和数据对象"></a>1.2.1 数据、数据元素、数据项和数据对象</h3><p><strong>数据</strong>(<strong>Data</strong>)：是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p><strong>数据元素</strong>(<strong>Data Element</strong>)：是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、记录、结点或顶点等。</p><p><strong>数据项</strong>(<strong>Data Item</strong>)：是组成数据元素的、有独立含义的、不可分割的最小单位。</p><p><strong>数据对象</strong>(<strong>Data Object</strong>)：是性质相同的数据元素的集合，是数据的一个子集。不论数据元素集合是无限集（如整数集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生表）的集合，只要集合内元素的性质均相同，都可称之为一个数据对象。</p><blockquote><p>数据元素与数据对象：</p></blockquote><p>数据元素——组成数据的基本单位，与数据的关系是：集合的个体。</p><p>数据对象——性质相同的数据元素的集合，与数据的关系是：集合的子集。</p><h3 id="1-2-2-数据结构"><a href="#1-2-2-数据结构" class="headerlink" title="1.2.2 数据结构"></a>1.2.2 数据结构</h3><p><strong>数据结构</strong>(<strong>Data Structure</strong>)是<strong>相互之间存在一种或多种特定关系</strong>的数据元素的集合。</p><p>换而言之，数据元素之间不是孤立存在的，它们之间存在某种关系，<strong>数据元素相互之间的关系称为结构</strong>(<strong>structure</strong>)。</p><p>数据结构是带结构的数据元素的集合。</p><blockquote><p>数据结构包括以下三个方面的内容：</p></blockquote><ol><li><p>数据元素之间的逻辑关系，也称为<strong>逻辑结构</strong>。</p></li><li><p>数据元素及其关系在计算机构中的表示（又称为映像），称为数据的<strong>物理结构</strong>或数据的<strong>存储结构</strong>。</p></li><li><p>数据的<strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</p></li></ol><blockquote><p>数据结构的两个层次：</p></blockquote><ul><li><p>逻辑结构</p><ul><li>描述描述数据元素之间的逻辑关系</li><li>与数据的存储无关，独立于计算机</li><li>是从具体问题抽象出来的数学模型</li></ul></li><li><p>物理结构(存储结构)</p><ul><li>数据元素及其关系在计算机存储器中的结构（存储方式）</li><li>是数据结构在许算机中的表示</li></ul></li><li><p>逻辑结构与存储结构的关系</p><ul><li>存储结构是逻辑关系的映象与元素本身的映象</li><li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li><li>两者综合起来建立了数据元素之间的结构关系。</li></ul></li></ul><blockquote><p>逻辑结构的种类</p></blockquote><ol><li><p>划分方法一</p><ol><li><p>线性结构：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。例如：线性表、栈、队列、串。</p></li><li><p>非线性结构：一个结点可能有多个直接前趋和直接后继例如：树、图。</p></li></ol></li><li><p>划分方法二——四类基本逻辑结构</p><ol><li><p>集合结构：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。</p></li><li><p>线性结构：结构中的数据元素之间存在着一对一的线性关系。</p></li><li><p>树形结构：结构中的数据元素之间存在着一对多的层次关系。</p></li><li><p>图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。</p></li></ol></li></ol><blockquote><p>存储结构的种类</p></blockquote><p>四种基本的存储结构：顺序存储结构、链式存储结构、索引存储结构、散列存储结构。</p><ul><li><p>顺序存储结构</p><ul><li><p>用一组<strong>连续</strong>的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的<strong>存储位置</strong>来表示。</p></li><li><p>C语言中用数组来实现顺序存储结构</p></li></ul></li><li><p>链式存储结构</p><ul><li><p>用一组<strong>任意</strong>的存储单元存储数据元素，数据元素之间的逻辑关系用<strong>指针</strong>来表示。</p></li><li><p>C语言中用指针来实现链式存储结构</p></li><li><p>存储一个元素的同时，还存储了下一个元素的地址。</p></li></ul></li><li><p>索引存储结构</p><ul><li>在存储节点信息的同时，还建立附加的<strong>索引表</strong>。</li></ul></li><li><p>散列存储结构</p><ul><li>根据结点的关键字直接计算处该结点的存储地址。</li></ul></li></ul><h3 id="1-2-3-数据类型和抽象数据类型"><a href="#1-2-3-数据类型和抽象数据类型" class="headerlink" title="1.2.3 数据类型和抽象数据类型"></a>1.2.3 数据类型和抽象数据类型</h3><p>高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的<strong>取值范围</strong>，以及在这些数值范围上所允许进行的<strong>操作</strong>。</p><blockquote><p>数据类型(Data Type)</p></blockquote><p>数据类型是一组性质相同的<strong>值的集合</strong>以及定义于这个值集合上的<strong>一组操作</strong>的总称。</p><p>数据类型 &#x3D; 值的集合 + 值集合上的一组操作</p><blockquote><p>抽象数据类型(Abstract Data Type, ADT)</p></blockquote><p><strong>指一个数学模型以及定义在此数学模型上的一组操作。</strong></p><ul><li><p>由用户定义，从问题抽象出的<strong>数据模型</strong>（逻辑结构）</p></li><li><p>还包括定义在数据模型上的一组<strong>抽象运算</strong>（相关操作）</p></li><li><p>不考虑计算机内的具体存储结构与运算的具体实现算法</p></li></ul><blockquote><p>抽象数据类型的形式定义</p></blockquote><p>抽象数据类型可用(D, S, P)三元组表示：</p><ul><li><p>D是数据对象</p></li><li><p>S是D上的关系集</p></li><li><p>P是对D的基本操作</p></li></ul><blockquote><p>抽象数据类型(ADT)定义举例：Circle的定义</p></blockquote><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT抽象数据类型名&#123;<br>  Data<br>    数据对象的定义<br>    数据元素之间的逻辑关系定义<br>  Operation<br>    操作<span class="hljs-number">1</span><br>      初始条件<br>      操作结果描述<br>    操作<span class="hljs-number">2</span><br>      ......<br>    操作n<br>      ......<br>&#125;ADT 抽象数据类型名<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT Circle&#123;<br>  数据对象：D=&#123;r, x, y|r, x, y均为实数&#125;<br>  数据关系：R=&#123;&lt;r, x, y&gt;|r是半径, &lt;x, y&gt;是圆心坐标&#125;<br>  基本操作：<br>    <span class="hljs-built_in">Circle</span>(&amp;C, r, x, y)<br>      操作结果：构造一个圆<br>    <span class="hljs-type">double</span> <span class="hljs-built_in">Area</span>(C)<br>      初始条件：圆已存在<br>      操作结果：计算面积<br>&#125;ADT Circle<br></code></pre></td></tr></table></figure><h2 id="1-3-抽象数据类型的表示与实现"><a href="#1-3-抽象数据类型的表示与实现" class="headerlink" title="1.3 抽象数据类型的表示与实现"></a>1.3 抽象数据类型的表示与实现</h2><p>C语言实现抽象数据类型：</p><ul><li><p>用已有数据类型定义描述它的存储结构</p></li><li><p>用函数定义描述它的操作</p></li></ul><blockquote><p>抽象数据类型如何实现</p></blockquote><ul><li><p>抽象数据类型可以通过固有的数据类型（如整型、实型、字符型）来表示和实现。</p><ul><li>即利用处理器中已存在的数据类型来说明新的结构，用已实现的操作来组合新的操作。</li></ul></li></ul><h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><blockquote><p>算法的定义</p></blockquote><p>算法：对特定问题<strong>求解方法和步骤</strong>的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。</p><blockquote><p>算法的描述</p></blockquote><ul><li><p>自然语言</p></li><li><p>流程图</p></li><li><p>伪代码、类语言</p></li><li><p>程序代码</p></li></ul><blockquote><p>算法与程序</p></blockquote><p>程序 &#x3D; 数据结构 + 算法</p><ul><li><p>数据结构通过算法实现操作</p></li><li><p>算法根据数据结构设计程序</p></li></ul><blockquote><p>算法特性</p></blockquote><ul><li><p>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</p></li><li><p>确定性：对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，使算法的执行者或阅读者都能明确其含义及如何执行。</p></li><li><p>可行性：算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。</p></li><li><p>输入：一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。</p></li><li><p>输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。</p></li></ul><blockquote><p>算法设计的要求</p></blockquote><ul><li><p>正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。</p></li><li><p>可读性。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。</p></li><li><p>健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。</p></li><li><p>高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。</p></li></ul><blockquote><p>算法效率</p></blockquote><ul><li><p>时间效率：指的是算法所耗费的时间；</p></li><li><p>空间效率：指的是算法执行过程中所耗费的存储空间。</p></li></ul><p>时间效率和空间效率有时候是矛盾的。</p><blockquote><p>算法事件效率的度量</p></blockquote><ul><li><p>算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。</p></li><li><p>两种度量方法</p><ul><li><p>事后统计</p></li><li><p>事前分析</p></li></ul></li></ul><blockquote><p>事前分析算法</p></blockquote><p>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的<strong>时间</strong>与算法中进行的简单操作<strong>次数乘积</strong>。</p><p>算法运行时间 &#x3D; 一个简单操作所需的时间x简单操作次数</p><blockquote><p>算法时间复杂度的渐进表示法</p></blockquote><p>若有某个辅助函数f(n)，使得n趋近于无穷大时，T(n)&#x2F;f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)&#x3D;O(f(n))，称O(f(n))为<strong>算法的渐进时间复杂度</strong>(O是数量级的符号)，简称<strong>时间复杂度</strong>。</p><blockquote><p>分析算法时间复杂度的基本方法</p></blockquote><ol><li><p>找出<strong>语句频度最大</strong>的那条语句作为<strong>基本语句</strong></p></li><li><p>计算<strong>基本语句</strong>的频度得到问题规模n的某个函数f(n)</p></li><li><p>取其数量级用符号“O”表示</p></li></ol><p>有的情况下，算法中基本操作重复执行的次数还随问题的<strong>输入数据集</strong>不同而不同。</p><blockquote><p>算法时间复杂度</p></blockquote><ul><li><p>最坏时间复杂度：指在最坏情况下，算法的时间复杂度。</p></li><li><p>平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p></li><li><p>最好时间复杂度：指在最好情况下，算法的时间复杂度。</p></li></ul><p>对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度。</p><blockquote><p>算法时间效率的比较</p></blockquote><ul><li><p>当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊</p></li><li><p>时间复杂度按数量级递增顺序为：</p><ul><li><p>常数阶-&gt;对数阶-&gt;线性阶-&gt;线性对数阶-&gt;平方阶-&gt;立方阶-&gt;…-&gt;K次方阶-&gt;指数阶</p></li><li><p>O(1)-&gt;O(logn)-&gt;O(n)-&gt;O(nlogn)-&gt;O(n^2)-&gt;O(n^3)-&gt;…-&gt;O(n^K)-&gt;O(2^n)</p></li></ul></li></ul><blockquote><p>渐进空间复杂度</p></blockquote><p>空间复杂度：算法所需要的存储空间的度量。</p><p>算法要占据的空间：</p><ul><li><p>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</p></li><li><p>算法要使用的辅助空间</p></li></ul><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><blockquote><p>设计好算法的过程</p></blockquote><p>抽象数据类型 &#x3D; 数据的逻辑结构 + 抽象运算</p>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>板绘</title>
    <link href="/2022/10/12/%E6%9D%BF%E7%BB%98/"/>
    <url>/2022/10/12/%E6%9D%BF%E7%BB%98/</url>
    
    <content type="html"><![CDATA[<h2 id="让自己线稿变得漂亮的方法"><a href="#让自己线稿变得漂亮的方法" class="headerlink" title="让自己线稿变得漂亮的方法"></a>让自己线稿变得漂亮的方法</h2><ul><li><p>干净、流畅、整洁</p><ul><li>要一笔画好，放轻松不要压，要光滑，二次元用的画笔就普通色块笔刷平涂用，或者尖头19号</li><li>线条要有粗细深浅变化</li></ul></li><li><p>外边框（闭合空间）稍微粗一些,细节细一些（眼睛、头发丝等）</p></li><li><p>外轮廓、结构转折处、两根线交接处，线条粗一些</p></li><li><p>钢笔</p></li><li><p>自由变换</p></li><li><p>临摹的不是线条，而是发现看他用线条表现出来的，解决造型问题</p></li><li><p>描完还要调整，要思考</p></li></ul><h2 id="画画辅助"><a href="#画画辅助" class="headerlink" title="画画辅助"></a>画画辅助</h2><ul><li><p>自己动笔画之前，先把型打出来，头，眼睛，关键地方先定好位置</p></li><li><p>ctrl + R 呼出标尺，可以添加参考线</p></li><li><p>自己设置了快捷键Ctrl + X 水平翻转画布</p></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li><p>画人体</p><ul><li>画脑袋两种方法，一是描线</li><li>二是借助正圆，来画</li></ul></li><li><p>头发分层</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>板绘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>板绘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期任务</title>
    <link href="/2022/10/11/%E8%BF%91%E6%9C%9F%E4%BB%BB%E5%8A%A1/"/>
    <url>/2022/10/11/%E8%BF%91%E6%9C%9F%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="要完成的任务"><a href="#要完成的任务" class="headerlink" title="要完成的任务"></a>要完成的任务</h2><ul><li><p>概统小尉老师网课3、4、5、6（3小时）</p></li><li><p>数据结构——王卓（40.5小时）</p></li><li><p>C艹——黑马程序员（52.5小时）</p></li><li><p>Verilog HDL学习</p></li><li><p>计算机组成原理——华科</p></li><li><p>计算机系统基础——袁春风</p></li><li><p>英语四级考试刷真题</p></li><li><p>学画画</p></li></ul><h2 id="时间分配"><a href="#时间分配" class="headerlink" title="时间分配"></a>时间分配</h2><ul><li><p>数字逻辑课堂学习Verilog HDL</p></li><li><p>毛概课堂学习计算机系统基础</p></li><li><p>概统课堂学习小尉老师概统课</p></li><li><p>数据结构、C++课堂学习C++</p></li><li><p>周一下午第二节课刷一套四级卷子</p></li><li><p>周二晚打排球</p></li><li><p>周三下午第二节到晚上学数据结构</p></li><li><p>周四早学习数据结构</p></li><li><p>周四晚学习计算机组成原理</p></li><li><p>周五早上第二节刷一套四级卷子</p></li><li><p>周六学习计算机系统基础和计算机组成原理</p></li><li><p>周日学习Verilog HDL</p></li><li><p>学不下去就画画</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PS教学</title>
    <link href="/2022/10/03/PS%E6%95%99%E5%AD%A6/"/>
    <url>/2022/10/03/PS%E6%95%99%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>新建、打开</li><li>图像大小调整</li><li>快速导出为png</li><li>置入嵌入文件（注意变换完后记得打钩或者按enter键）</li><li>图像</li><li>图层<ul><li>一层一层，在每一层的操作不会干扰别的层</li></ul></li><li>文字</li><li>选择</li><li>滤镜</li><li>窗口<ul><li>历史记录</li><li>图层</li><li>字符</li></ul></li><li>调整</li><li>左侧工具栏</li><li>常用快捷键<ul><li>撤回Ctrl+Z</li><li>向前一步CTRL+SHIFT+Z</li><li>向后一步CTRL+ALT+Z</li><li>剪切CTRL+X</li><li>复制CTRL+C</li><li>粘贴CTRL+V</li><li>自由变换CTRL+T</li><li>CTRL+SHIFT+K</li><li>新建图层CTRL+SHIFT+N</li><li>合并图层CTRL+E</li><li>合并可见图层CTRL+SHIFT+E</li><li>取消选择CTRL+D</li><li>放大CTRL++</li><li>缩小CTRL+-</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>怎么给图片调色？<ul><li>调整</li></ul></li><li>怎么去水印？<ul><li>污点修复工具</li><li>画笔（直接画）注意不透明度调低一点，涂完可以再用一下涂抹、液化，看起来更自然一点</li></ul></li><li>怎么更改文字、图形样式？<ul><li>图层样式&#x2F;混合选项</li><li>刚开始可能没有全部东西，点fx调出来</li></ul></li><li>怎么抠图？<ul><li>思想：直接用橡皮擦擦去背景，留下想要的元素</li><li>直接裁剪出所需元素的区域，然后魔术橡皮擦，比较智能</li><li>套索，选中后，Ctrl+j复制图层，</li><li>快速选择+ctrl j+关闭背景</li><li>快速选择+选择遮住+调整边缘+输出到建有图层蒙版的图层</li></ul></li><li>怎么运用蒙版？<ul><li>先放图片然后创建蒙版</li><li>创建剪贴蒙版，需要让蒙版在需要遮住的图层上面且紧挨着这一图层</li><li>添加图层蒙版+渐变工具，然后线拉长一些，过渡会比较自然</li><li>黑白色画笔，调成黑色，会让蒙版的背景变谈，调成白色会让蒙版的背景再回来</li></ul></li><li>党政海报<ul><li>颜色不要太艳</li><li>字体不要太俏皮</li></ul></li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul><li><p>霜降海报和万圣节海报二选一</p></li><li><p>要求</p><ul><li>尽量用到抠图、蒙版、改变文字样式、</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>影视后期</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影视后期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概统小尉老师第三讲</title>
    <link href="/2022/10/02/%E6%A6%82%E7%BB%9F%E5%B0%8F%E5%B0%89%E8%80%81%E5%B8%88%E7%AC%AC%E4%B8%89%E8%AE%B2/"/>
    <url>/2022/10/02/%E6%A6%82%E7%BB%9F%E5%B0%8F%E5%B0%89%E8%80%81%E5%B8%88%E7%AC%AC%E4%B8%89%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="多维随机变量"><a href="#多维随机变量" class="headerlink" title="多维随机变量"></a>多维随机变量</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021824739.png"></p><h2 id="联合分布函数"><a href="#联合分布函数" class="headerlink" title="联合分布函数"></a>联合分布函数</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021826418.png"><br>大括号里面逗号的意思就表示交。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021828708.png"></p><ul><li>有界性<ul><li>括号中有一个是负无穷，那么函数值（也就是概率）等于0，因为怎么会有数小于负无穷呢，并且之前说道，逗号相当于是交的意思，有一个是不可能事件，交起来肯定也是不可能事件，也就是说概率为0</li></ul></li></ul><h2 id="边缘分布函数"><a href="#边缘分布函数" class="headerlink" title="边缘分布函数"></a>边缘分布函数</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021838555.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021840244.png"></p><h1 id="二维离散型随机变量"><a href="#二维离散型随机变量" class="headerlink" title="二维离散型随机变量"></a>二维离散型随机变量</h1><h2 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021853349.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021853402.png"></p><h2 id="联合分布函数-1"><a href="#联合分布函数-1" class="headerlink" title="联合分布函数"></a>联合分布函数</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021856507.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021857308.png"><br>左下阴影包含的所有点加起来就是函数值</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021856958.png"><br>G是范围，就把范围内所有的点加起来，就是函数值</p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论与数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDL设计方法简介</title>
    <link href="/2022/09/30/HDL%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/09/30/HDL%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="HDL-设计与验证流程"><a href="#HDL-设计与验证流程" class="headerlink" title="HDL 设计与验证流程"></a>HDL 设计与验证流程</h2><p>虚线框表示的步骤可以根据项目的复杂度省略，而实线框表示的步骤为必须执行的步骤</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209300912607.png"></p><h3 id="关键设计步骤与概念"><a href="#关键设计步骤与概念" class="headerlink" title="关键设计步骤与概念"></a>关键设计步骤与概念</h3><h4 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h4><ul><li>RTL级：寄存器传输级</li><li>EDA工具：电子辅助设计工具</li></ul><h4 id="系统与功能模块定义"><a href="#系统与功能模块定义" class="headerlink" title="系统与功能模块定义"></a>系统与功能模块定义</h4><p>大型系统的设计与实现，首先要进行详细的系统规划和描述，此时HDL描述侧重整体系统的划分和实现对系统级的仿真侧重于对整个系统的功能和性能指标的考量。功能模块级设计时将系统整体功能划分为可实现的具体功能模块，大致确定模块间的接口，如时钟、读写信号、数据流、控制信号等。在有些情况下，还要根据系统要求，描述每个模块或进程的时序约束。另外在此层次，必须权衡整个系统多种的实现方式的优劣，选出系统性能指标优并且可以高效实现的设计方案</p><h4 id="行为级描述测试激励"><a href="#行为级描述测试激励" class="headerlink" title="行为级描述测试激励"></a>行为级描述测试激励</h4><p>最大特点是必须明确每个模块间的所有接口和边界。此时模块内部的功能已经明确，模块间的所有接口，顶层的输入、输出信号等在行为级已经被清晰地描述出来。</p><h4 id="寄存器传输级"><a href="#寄存器传输级" class="headerlink" title="寄存器传输级"></a>寄存器传输级</h4><p>寄存器传输级指不关注寄存器和组合逻辑的细节，通过描述寄存器到寄存器之间的逻辑功能描述电路的HDL层次。RTL级是比门级更高的抽象层次，一般使用RTL级语言描述硬件电路比门级描述电路简单、高效。寄存器传输级的最大特点是可以直接用综合工具综合为门级网表。RTL设计直接决定着设计的功能和效率</p><h4 id="对RTL级描述进行功能仿真"><a href="#对RTL级描述进行功能仿真" class="headerlink" title="对RTL级描述进行功能仿真"></a>对RTL级描述进行功能仿真</h4><p>一般来说需要对RTL级设计进行功能仿真，仿真的目的为验证RTL级描述是否与设计意图一致。</p><h4 id="逻辑综合（使用RTL级EDA工具）"><a href="#逻辑综合（使用RTL级EDA工具）" class="headerlink" title="逻辑综合（使用RTL级EDA工具）"></a>逻辑综合（使用RTL级EDA工具）</h4><p>RTL级综合指将RTL级HDL语言翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件。最重要的代码设计层次就是RTL级</p><h4 id="门级"><a href="#门级" class="headerlink" title="门级"></a>门级</h4><p>门级描述的特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述了设计的引脚、功能、时钟周期等所有信息。目前直接使用门级描述较少，直接使用门级描述的场合一般是ASIC和FPGA设计中某些面积或时序要求较高的模块</p><h4 id="综合后门级仿真"><a href="#综合后门级仿真" class="headerlink" title="综合后门级仿真"></a>综合后门级仿真</h4><p>综合完成后，如果需要检查综合结果是否与原设计一致，就需要做综合后仿真。<br>在仿真时，把综合生产的标准延时文件反标注到综合仿真模型中去，可估计门延时带来的影响。<br>综合仿真虽然比功能仿真精确一些，但是只能估计门延时，不能估计线延时，仿真结果与布线后的实际情况还有一定的差距，并不十分准确<br>这种仿真的主要目的在于检查综合器的综合结果是否与设计输入一致，如果设计者确信自己表述明确，没有综合歧义发生，则可以省略这一步</p><h4 id="布局规划与布局布线"><a href="#布局规划与布局布线" class="headerlink" title="布局规划与布局布线"></a>布局规划与布局布线</h4><p>综合的门级结果最终要映射到目标库或目标器件</p><h4 id="布局布线后时序仿真与验证"><a href="#布局布线后时序仿真与验证" class="headerlink" title="布局布线后时序仿真与验证"></a>布局布线后时序仿真与验证</h4><p>将最终的布局规划或者布局布线的时延信息反标注到设计网表中，所进行的仿真就叫时序仿真或布局规划与布局布线后仿真，<strong>简称后仿真</strong><br>时序仿真包含的信息最全，所以最准确，能较好反映芯片的实际工作情况<br>一般来说建议进行此步骤，检查设计时序与芯片的实际运行情况是否一致<br>时序仿真主要目的在于发现时序违规</p>]]></content>
    
    
    <categories>
      
      <category>Verilog HDL实用精解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概统小尉老师第二讲</title>
    <link href="/2022/09/27/%E6%A6%82%E7%BB%9F%E5%B0%8F%E5%B0%89%E8%80%81%E5%B8%88%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
    <url>/2022/09/27/%E6%A6%82%E7%BB%9F%E5%B0%8F%E5%B0%89%E8%80%81%E5%B8%88%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="一维随机变量分布"><a href="#一维随机变量分布" class="headerlink" title="一维随机变量分布"></a>一维随机变量分布</h1><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271510691.png"></p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271511366.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271512170.png"></p><p>把一些变量映射到实数轴上</p><h3 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271516324.png"><br><strong>取遍负无穷到正无穷</strong><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271518989.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271518781.png"></p><ul><li>单调不减：包括进来的随机变量越来越多或者不变，总之不会变少</li><li>右连续：左空心右实心（x在左，x在右）</li><li>F(a-0)是左极限（因为有右连续的性质，去掉等号就是左极限）</li></ul><h3 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271527165.png"></p><p><strong>概率都大于等于0，且所有概率加起来等于1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271533776.png"></p><h3 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271534778.png"></p><ul><li>概率密度</li><li>注意充要条件</li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271540767.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271542272.png"><br>通过右连续得到a+b&#x3D;0</p><h3 id="五大分布"><a href="#五大分布" class="headerlink" title="五大分布"></a>五大分布</h3><h4 id="离散型"><a href="#离散型" class="headerlink" title="离散型"></a>离散型</h4><h5 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271546081.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281113039.png"></p><h5 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281113284.png"><br>单位时间内源源不断的质点来流个数<br>$\lambda$称为强度<br>用车流来说，$\lambda$相当于车流量<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281124389.png"></p><h5 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281124619.png"><br>首中即停止</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281127926.png"></p><h5 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281127801.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281129887.png"></p><h4 id="连续型"><a href="#连续型" class="headerlink" title="连续型"></a>连续型</h4><h5 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281725242.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281731806.png"></p><h5 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281732009.png"><br>$\lambda$叫死亡率</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281739573.png"></p><h5 id="正态分布（非常重要）"><a href="#正态分布（非常重要）" class="headerlink" title="正态分布（非常重要）"></a>正态分布（非常重要）</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281740602.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281743832.png"><br>上$\alpha$分位点，看横坐标右边的面积是多少，是多少，该点横坐标就是miu的下标多少</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281745323.png"><br>将一般正态分布转换为标准正态分布<br>这是只有一个不等号，有两个不等号，就把两个式子都列出来然后右边减去左边<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281759267.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281817139.png"><br>右边面积为横坐标下标</p><h3 id="一维随机变量函数"><a href="#一维随机变量函数" class="headerlink" title="一维随机变量函数"></a>一维随机变量函数</h3><p>改变积分规则<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281818831.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281820508.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281832870.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281835409.png"><br>注意<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281837594.png"><br>分布函数求导就是概率密度了</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281852906.png"><br>概率分布函数，概率密度，注意公式运用</p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281853844.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281853605.png"></p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281854113.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209281854452.png"></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论与数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计小尉老师第一讲</title>
    <link href="/2022/09/27/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%B0%8F%E5%B0%89%E8%80%81%E5%B8%88%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
    <url>/2022/09/27/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%B0%8F%E5%B0%89%E8%80%81%E5%B8%88%E7%AC%AC%E4%B8%80%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="随机事件与概率"><a href="#随机事件与概率" class="headerlink" title="随机事件与概率"></a>随机事件与概率</h1><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271029236.png"></p><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><h3 id="随机事件"><a href="#随机事件" class="headerlink" title="随机事件"></a>随机事件</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271031165.png"></p><h3 id="事件的关系"><a href="#事件的关系" class="headerlink" title="事件的关系"></a>事件的关系</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271031932.png"></p><ul><li><p>积事件：两个事件A、B，积事件就是A交B,就是AB</p></li><li><p>和事件：A并B 就是A+B</p></li><li><p>相容：A交B不等于空集</p></li><li><p>互斥：A交B等于空集（不可能同时发生）</p></li><li><p>差事件：A-B，把A减去与B重合的地方，$A-B&#x3D;A\bar{B}$</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271038505.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271048818.png"></li></ul></li><li><p>对立事件（逆事件）：两事件没有交集，并起来等于全集</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271039495.png"></li></ul></li><li><p>完备事件组：A1…An任意两个都没有交集，但是所有并起来是全集，用四个字概括就是不重不漏</p></li></ul><h3 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271044753.png"></p><p><strong>对偶律（德摩根律）：长杠变短杠，开口变方向</strong></p><h4 id="例题：判断命题是否成立"><a href="#例题：判断命题是否成立" class="headerlink" title="例题：判断命题是否成立"></a>例题：判断命题是否成立</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271052332.png"><br>用到$A-B&#x3D;A\bar{B}$<br> 算出来不等于右边，所以错误，不成立</p><h3 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271057961.png"></p><ul><li>有界性<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271100200.png"></li><li>全集概率等于1，空集概率等于0</li><li>但是概率等于1的事件就是全集吗？概率等于0的事件就是空集吗？—-不是这样的</li><li>有时概率为零的事件是有可能发生的，不是空集</li></ul></li><li>逆事件（对立事件）概率公式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271103043.png"></li></ul></li><li>加法公式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271103003.png"></li></ul></li><li>减法公式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271113328.png"></li></ul></li><li>条件概率公式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271114704.png"></li><li>B在A发生的条件下的概率</li></ul></li><li>乘法公式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271116617.png"></li><li>P（AB）&#x3D;（A先发生的概率）乘上（B在A已经发生的条件下发生的概率）</li><li>P（ABC）&#x3D;（A先发生的概率）乘上（B在A已经发生的条件下发生的概率）再乘上（C在A和B都发生条件下的概率）</li></ul></li><li>全概率公式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271201470.png"></li><li>需要注意的是：Ai需要是完备事件组</li></ul></li><li>贝叶斯公式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271204495.png"></li></ul></li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271206437.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271209589.png"><br>P（AB）&#x3D;0，并不就说AB等于空集<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271211351.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271420831.png"></p><p>P(Ai)表示有i件次品的概率，P(B)表示拿到正品的概率，P(C)表示通过检验的概率</p><p>运用贝叶斯公式<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271423312.png"></p><h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271427057.png"><br><strong>有限、等可能</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271430365.png"></p><h3 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271437948.png"></p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271439421.png"></p><h3 id="事件的独立性"><a href="#事件的独立性" class="headerlink" title="事件的独立性"></a>事件的独立性</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271440246.png"><br>A发生与否不影响B是否发生<br>两事件相互独立时，P(AB)&#x3D;P(A)P(B)<br>满足前三条可以说A1A2A3两两独立<br>满足所有四条才能说A1A2A3相互独立</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271445106.png"></p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271447396.png"></p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271448481.png"></p><h4 id="习题解答"><a href="#习题解答" class="headerlink" title="习题解答"></a>习题解答</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209271448356.png"></p>]]></content>
    
    
    <categories>
      
      <category>概率论与数理统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论与数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半导体二极管</title>
    <link href="/2022/09/19/%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1/"/>
    <url>/2022/09/19/%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="常见结构"><a href="#常见结构" class="headerlink" title="常见结构"></a>常见结构</h2><ul><li>二极管的几种外形<ul><li>将PN结用外壳封装起来，并加上电极引线就构成了半导体二极管</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191114072.png"></li></ul></li><li>二极管的几种常见结构<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191116543.png"></li><li>a是点接触型</li><li>b是面接触型</li><li>c是平面型</li></ul></li></ul><h2 id="伏安特性"><a href="#伏安特性" class="headerlink" title="伏安特性"></a>伏安特性</h2><ul><li>二极管的伏安特性<ul><li>伏安特性曲线</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191123558.png"><ul><li>与PN结的区别<ul><li>由于体电阻的存在，相同电压下，电流比PN结小</li><li>反向电流大一些</li></ul></li></ul></li><li>温度的影响<ul><li>温度升高，正向左移，反向下移</li><li>在室温的情况下，每升高1摄氏度，正向电压降2-2.5毫伏，每升高10摄氏度，反向电流增大一倍</li></ul></li><li>应用<ul><li>可做温度传感器</li></ul></li></ul></li></ul><h2 id="二极管的应用"><a href="#二极管的应用" class="headerlink" title="二极管的应用"></a>二极管的应用</h2><ul><li><p>参数</p><ul><li>$I_F$正向导通电流，应该要比工作要求大一些</li><li>$U_R$最高反向工作电压，一般为$U_{BR}$的百分之五十</li><li>$I_R$反向电流，越小反向截止特性越好</li><li>$f_M$最高工作频率，否则二极管的单向导电性会被破坏，电流会在二极管里面的电容出现。</li></ul></li><li><p>二极管的等效电路</p><ul><li>用伏安特性折线化得到的等效电路<ul><li>（均为直流情况下）左为理想二极管，中为理想二级管加电源，正向导通时端电压为常量，右为理想二极管加电源和电阻，正向导通时端电压与电流成线性关系<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209241238831.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261036042.png"></li></ul></li><li>二极管的微变等效电路<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261052851.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261053878.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261053039.png"><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261054083.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261146863.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>龙芯</category>
      
      <category>模拟电子技术基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言后续</title>
    <link href="/2022/09/14/c%E8%AF%AD%E8%A8%80%E5%90%8E%E7%BB%AD/"/>
    <url>/2022/09/14/c%E8%AF%AD%E8%A8%80%E5%90%8E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c语言指针</title>
    <link href="/2022/09/14/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"/>
    <url>/2022/09/14/c%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一章-常用半导体器件</title>
    <link href="/2022/09/13/%E5%B8%B8%E7%94%A8%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6--%E6%A8%A1%E7%94%B5/"/>
    <url>/2022/09/13/%E5%B8%B8%E7%94%A8%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6--%E6%A8%A1%E7%94%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="常用半导体"><a href="#常用半导体" class="headerlink" title="常用半导体"></a>常用半导体</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h3><ul><li>半导体<ul><li>概念：导电能力介于导体与绝缘体之间</li><li>本征半导体：纯净的、具有晶体结构的半导体</li></ul></li><li>本征半导体的晶体结构<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131118308.png"></li></ul></li><li>载流子<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131122995.png"></li><li>本征激发<ul><li>速度与温度有关，温度越高，本征激发越快</li></ul></li><li>自由电子</li><li>空穴，注意空穴的移动是相对的，是由于价电子按一定方向填补空穴，导致空穴相对移动</li><li>复合：与本征激发相反的一个运动<ul><li>与载流子浓度有关</li></ul></li></ul></li><li>载流子的浓度（导电性能与什么有关？？–载流子的浓度）<ul><li>温度升高时，本征激发速度加快，载流电子变多，载流子浓度升高，复合加快，最后达到一个动态平衡，本征激发的速度与复合的速度相等</li><li>但是加热并不是一个很好的提高导电性能的方法，加热到70度以上，材料本身就不行了，那么用什么办法来提高导电性能呢？？–杂质半导体</li></ul></li><li>杂质半导体<ul><li>概念：掺入少量的杂质元素</li><li>N型半导体<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131204033.png"></li><li>掺入少量五价元素磷</li><li>五价磷进入，代替硅原子，四个电子形成共价对，还有一个电子很容易就出来，变成自由电子，这就使得半导体内自由电子大大增加</li><li>多子：自由电子，因为很多</li><li>少子：空穴，空穴少</li><li>导电主要靠自由电子，电子带负电，而N型半导体的N就代表negative，代表电子是多子（注意即使这样，半导体还是不带电，因为失去电子的磷离子带正电，正好和磷原子产生的自由电子数目一样，互相抵消）</li><li>此时温度因素对自由电子影响就很小了，温度升高而产生出的自由电子太少了，但是对少子影响很大</li><li>掺入的杂质越多，多子（自由电子）的浓度就越高，导电性能也就越强</li><li>磷原子可提供电子，因此被称为施主原子</li></ul></li><li>P型半导体<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131406422.png"></li><li>P代表Positive，表示多子是带正电的空穴</li><li>掺入少量三价杂质原子，比如硼</li><li>硼原子最外层有三个价电子，当它们与周围的硅原子形成共价键时，就产生了一个“空位”，空位为电中性，当硅原子的外层电子填补此空位时，其共价键中便产生一个空穴，而杂质原子成为不可移动的负离子</li><li>P型半导体，空穴为多子，自由电子为少子，主要靠空穴导电，掺入杂质越多，空穴的浓度就越高，使得导电性能越强</li><li>因为杂质原子中的空位吸收电子，故被称之为受主原子</li></ul></li><li>由以上分析可知，由于掺入的杂质使多子的数目大大增加，从而使多子与少子复合的机会大大增多。因此，对于杂质半导体，多子的浓度越高，少子的浓度就越低。可以认为，多子的浓度约等于所掺杂质原子的浓度，因而它受温度的影响很小，而少子是本征激发形成的，所以尽管其浓度很低，却对温度非常敏感，这将影响半导体器件的性能</li></ul></li></ul><h3 id="PN结的形成"><a href="#PN结的形成" class="headerlink" title="PN结的形成"></a>PN结的形成</h3><ul><li>PN结的形成<ul><li>扩散运动：多子</li><li>空间电荷区：可称为耗尽层，阻挡层，PN结 </li><li>漂移运动：少子在空间电场区的电场力作用下的运动</li><li>对称结、不对称结：不对称结指两边掺杂浓度不一样，浓度高的地方空间电荷区窄，浓度低的地方空间电荷区宽</li></ul></li><li>PN结的单向导电性<ul><li>把PN结外加正向电压<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141201475.png"></li><li>外电场削弱内电场，随着内电场慢慢被削弱，电流猛猛增长，所以要对电流加一个限制，于是电路中有一个限流电阻R，使得电路中电流最大也不会超过U&#x2F;R</li></ul></li><li>PN结外加反向电压<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141208161.png"></li><li>PN结越来越厚，阻碍作用越来越强，最后截止</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141430450.png"></li><li>PN结的电流方程<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141431775.png"></li><li>锗管0.2V-0.3V     硅管0.6-0.7V</li></ul></li><li>PN结的伏安特性<ul><li>正向特性<ul><li>死区</li></ul></li><li>反向特性</li><li>反向击穿<ul><li>雪崩击穿（掺杂浓度低）：温度越高，需要的击穿电压越高</li><li>齐纳击穿（掺杂浓度高）：温度越高，需要的击穿电压越低</li><li>反向击穿，PN结不一定就坏了，反向击穿电压可以通过掺杂浓度控制。如果能控制其不过热，那么它还可以从通过降低反向电压将击穿状态逆回去，但是一旦过热发生二次击穿，那PN结就彻底坏了</li><li>PN结的伏安图中，U（BR）这个地方，电流变化极大，而电压基本不变，利用这一特性可以做出稳压二极管。</li></ul></li></ul></li><li>PN结的电容效应<ul><li>势垒电容：可以做可变电容</li><li>扩散电容：非平衡少子和电压之间的关系</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>龙芯</category>
      
      <category>模拟电子技术基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正逻辑和负逻辑</title>
    <link href="/2022/09/12/%E6%AD%A3%E9%80%BB%E8%BE%91%E5%92%8C%E8%B4%9F%E9%80%BB%E8%BE%91/"/>
    <url>/2022/09/12/%E6%AD%A3%E9%80%BB%E8%BE%91%E5%92%8C%E8%B4%9F%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MOS型集成门电路</title>
    <link href="/2022/09/12/MOS%E5%9E%8B%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/"/>
    <url>/2022/09/12/MOS%E5%9E%8B%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLL型集成门电路</title>
    <link href="/2022/09/12/TLL%E5%9E%8B%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/"/>
    <url>/2022/09/12/TLL%E5%9E%8B%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单逻辑门电路</title>
    <link href="/2022/09/12/%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/"/>
    <url>/2022/09/12/%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191032272.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191034597.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191036993.png"></p><h2 id="二极管与门电路"><a href="#二极管与门电路" class="headerlink" title="二极管与门电路"></a>二极管与门电路</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191410568.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191412395.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191412148.png"></p><h2 id="二极管或门电路"><a href="#二极管或门电路" class="headerlink" title="二极管或门电路"></a>二极管或门电路</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418343.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418004.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418583.png"></p><h2 id="非门电路-反相器"><a href="#非门电路-反相器" class="headerlink" title="非门电路-反相器"></a>非门电路-反相器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191419553.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191419536.png"><br>椭圆处相当于断开</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191420754.png"><br>三极管导通，接地</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半导体器件的开关特性</title>
    <link href="/2022/09/12/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7/"/>
    <url>/2022/09/12/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="半导体器件的开关特性"><a href="#半导体器件的开关特性" class="headerlink" title="半导体器件的开关特性"></a>半导体器件的开关特性</h1><ul><li><p>半导体</p><ul><li>常温下导电性能介于导体和绝缘体之间的材料</li><li>特性：半导体是一种导电性可受控制，范围可从绝缘体至导体之间的材料</li><li>常见的半导体材料：硅、砷化镓、锗</li><li>常见半导体元件：晶体二极管、晶体三极管</li></ul></li><li><p>半导体器件的开关特性</p><ul><li>以开关方式运用 </li><li>运用在开关频率十分高的电路中</li><li>静态特性<ul><li>半导体器件处于导通和截止两种稳定状态下的特性</li></ul></li><li>动态特性<ul><li>半导体器件在导通和截止两种状态转换过程中的特性</li><li>反向恢复时间<ul><li>让电路截止时，不是马上截止的，有一个恢复时间，这个恢复时间越短，电路变化的次数才可能做到越快，决定了元件的性能</li><li>从开通变成截止的时间</li></ul></li><li>开通时间</li><li>从截止变成导通的时间</li></ul></li></ul></li><li><p>晶体二极管的开关特性</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131022934.png"></li><li>静态特性<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121811012.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121811597.png"><ul><li>Vth是门槛电压，当电压等于门槛电压时，管子开始导通；大于门槛电压时，彻底导通</li><li>Vbr是反向击穿电压，随着反向电压增加，反向电流猛增，二极管被击穿</li></ul></li><li>单向导电性</li><li>正向导通</li><li>反向截止<ul><li>正向导通时可能因为电流过大而导致二极管烧坏</li><li>组成实际电路时，通常串接一只电阻R，以限制二极管正向电流</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121818009.png"></li></ul></li></ul></li><li><p>动态特性</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121819846.png"></p><ul><li>加了反向电压后，并不是马上是电路为0，而是一个过程</li><li>ts叫做存储时间</li><li>tt加做渡越时间</li><li>反向恢复时间tre&#x3D;ts+tt</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121823049.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131014962.png"><ul><li>当它的电压相反时，空间电荷区发生变化，使得电流方向互反</li></ul></li><li>还有个概念叫开通时间，相对于反向恢复时间，非常短<ul><li>不需要重点讨论，但需要把物理上原因搞清楚，为什么开通时间很短？模拟电路的知识能搞明白！！！找一本模拟电路的书看看</li><li>截止转为正向导通所需的时间</li><li>主要由外电路参数决定</li><li>加入输入电压后，回路电流几乎是立即达到最大值</li><li>开通时间与反向恢复时间相比很小，可以忽略不计</li></ul></li></ul></li><li><p>晶体三级管的开关特性</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131021557.png"></li><li>三种状态<ul><li>截止、放大、饱和</li></ul></li><li>三极管的静态特性（在截止和饱和这两种稳态下的特性） <ul><li>由基极信号控制的无触点开关，其作用对应与开关的闭合和断开</li></ul></li><li>三级管的动态特性（三极管在饱和与截止两种状态转换过程中的具有的特性）<ul><li>三极管内部存在着电荷的建立与消失过程</li><li>饱和和截止两种状态的转换需要一定的时间才能完成</li></ul></li></ul></li></ul></li><li><p>简单逻辑门电路</p><ul><li>二极管与门电路</li><li>二极管或门电路</li><li>非门电路-反相器</li><li>非门电路-BJT反相器</li></ul></li><li><p>典型TLL与非门电路</p><ul><li>电路结构<ul><li>输入级<ul><li>多发射极T1和电阻R1</li><li>3个输入信号通过的发射结实现与功能</li></ul></li><li>中间级<ul><li>晶体管T2和电阻R2和R3组成</li><li>T2集电极和发射极分别控制T3和T4</li></ul></li></ul></li><li>输出级（推拉式）<br> - 晶体管T3、T4、二极管D4和电阻R4<br> - 优点：提高开关速度和负载能力</li><li>工作原理<ul><li>输入电压为高、输出电压为低</li><li>输入电压有低、输出电压为高</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路的分类（了解即可）</title>
    <link href="/2022/09/12/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <url>/2022/09/12/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h1><ul><li><p>集成电路</p><ul><li>一个电路中所需的晶体管、二极管、电阻、电容和电感等元件及布线互连一起，制作在一小块或几小块半导体晶片或介质基片上</li><li>通过引脚与外部联系</li><li>特点<ul><li>可靠性高</li><li>可维护性好</li><li>功耗低 </li><li>成本低</li><li>大大简化设计和调试过程</li></ul></li></ul></li><li><p>数字集成电路分类</p><ul><li>根据半导体器件进行分类<ul><li>双极型集成电路<ul><li>采用双极型半导体器件作为元件</li><li>速度快、负载能力强，功耗较大、集成度较低</li><li>双极型集成电路又包括：<ul><li>TTL：三极管-三极管电路</li><li>ECL：射极耦合电路</li><li>$I^2$L:集成注入电路</li></ul></li></ul></li><li>单极型集成电路<ul><li>金属-氧化物半导体场效应管作为元件</li><li>结构简单、制造方便、集成度高、功耗低，速度较慢</li></ul></li></ul></li><li>根据集成电路规模的大小进行分类<ul><li>SSI（小规模集成电路）<ul><li>逻辑门小于10门或元件数小于100个</li></ul></li><li>MSI（中规模集成电路）<ul><li>逻辑门10门<del>99门或元件数100个</del>999</li></ul></li><li>LSI（大规模集成电路）<ul><li>逻辑门数为100门<del>9999门或元件数1000个</del>9999个</li></ul></li><li>VLSI（超大规模集成电路）<ul><li>逻辑门数大于10000门或元件数大于100000个</li></ul></li></ul></li><li>根据设计方法和功能定义分类<ul><li>非用户定制电路：标准集成电路<ul><li>特点：生产量大、使用方便、价格便宜</li><li>各种小、中、大规模通用集成电路</li></ul></li><li>全用户定制电路：专用集成电路ASIC<ul><li>为了满足用户特殊应用要求而专门生产的集成电路</li><li>特点：可靠性高、保密性好；设计费用高、销量小</li></ul></li><li>半用户定制电路<ul><li>厂家生产出功能不确定的集成电路，用户对已有的芯片进行功能定义将通用产品专用化</li><li>可编程逻辑器件</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2022/09/11/Git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/11/Git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p>常用命令</p><ul><li>git init<ul><li>初始化，在本地git bash使用此命令后创建.git文件夹，使本地文件夹成为仓库，即每次版本的代码都会在里面</li></ul></li><li>git clone &lt;链接&gt; 将所需要的东西下载到本地，且用此命令下载的是仓库，里面的每次修改也在里面，而直接download zip 只是最新版本</li><li>git add<ul><li>git add 后可跟文件名也可直接git add -A 表示将所有文件送入暂存区</li></ul></li><li>git commit<ul><li>git commit -m “引号里面输入你对提交的信息的描述”    用于提交信息</li></ul></li><li>git checkout &lt;文件名&gt;<ul><li>在工作区中的更改给打回去</li></ul></li><li>git reset HEAD^<ul><li>提交后撤回</li></ul></li><li>git push 推送当前分支的最新提交到远程</li><li>git pull   拉取远程分支最新的提交到本地</li><li>本地远程双向更新先pull后push</li></ul></li><li><p>分支</p><ul><li>git checkout -b  &lt;分支名&gt; 从当前节点新建分支 </li><li>git branch 列举所有分支</li><li>git checkout &lt;分支名&gt; 单纯切换到某个分支</li><li>git branch -D &lt;分支名&gt; 删掉特定的分支</li><li>git merge &lt;分支名&gt; 合并分支</li></ul></li><li><p>远程</p><ul><li>命令git remote add origin <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#116;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#x6f;&#109;</a>:Nick-JY&#x2F;Loongson_FirstLogs.git  </li><li>git push origin 本地分支名:远程分支名</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209112251180.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121048470.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121055062.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121128369.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121131666.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121456714.png"></p>]]></content>
    
    
    <categories>
      
      <category>龙芯</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑函数化简</title>
    <link href="/2022/09/11/%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E5%8C%96%E7%AE%80/"/>
    <url>/2022/09/11/%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E5%8C%96%E7%AE%80/</url>
    
    <content type="html"><![CDATA[<h2 id="逻辑函数化简法"><a href="#逻辑函数化简法" class="headerlink" title="逻辑函数化简法"></a>逻辑函数化简法</h2><h3 id="代数化简法"><a href="#代数化简法" class="headerlink" title="代数化简法"></a>代数化简法</h3><ul><li>代数化简法<ul><li>参考离散数学</li></ul></li></ul><h3 id="卡诺图化简法"><a href="#卡诺图化简法" class="headerlink" title="卡诺图化简法"></a>卡诺图化简法</h3><ul><li>卡诺图化简法<ul><li><p>卡诺图是一个平面的方格图，每一个小方格代表一个最小项</p></li><li><p>2变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111007414.png"></p></li><li><p>3变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111013107.png"></p></li><li><p>11和10为什么换了位置呢？–对于01和11只有一个变量不同，同样，对于11和10也只有一个变量不同，对于00和10也只有一个变量不同，这样排列能够让相邻最小项挨在一起</p></li><li><p>4变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111013379.png"></p></li><li><p>卡诺图特点</p><ul><li>n个变量的卡诺图由2的n次方个小方格构成</li><li>几何图形上处在相邻、相对、相重位置的小方格代表的最小项为相邻最小项</li><li>卡诺图中最小项排列方案不是惟一的</li><li>但是任何一种方案都应保证能清楚反映最小项的相邻关系</li><li>相邻关系最小项只有一位相反</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111019097.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111019517.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111020055.png"></li></ul></li><li><p>逻辑函数在卡诺图上的表示</p><ul><li>标准与-或表达式在卡诺图上的表示<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111022838.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111022041.png"></li></ul></li><li>一般与-或表达式的卡诺图<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111024909.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111026972.png"></li><li>AB取11，CD取11，所在行和列填1，A非B非C,再补充填1</li></ul></li></ul></li><li><p>卡诺图上最小项的合并规律</p><ul><li>理论依据：并项定理</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111121375.png"></li><li>两个相邻最小项有一个变量互反，可以合并为一项，消去一个变量</li><li>卡诺图的重要特征：直观、清晰地反映了最小项的相邻关系</li><li>卡诺图化简逻辑函数的基本原理<ul><li>将逻辑依据和图形特征结合起来</li><li>将卡诺图上表征相邻最小项的相邻小方格“圈”在一起进行合并</li><li>达到用一个简单与项代替若干最小项的目的</li><li>用来包围那些能由一个简单与项代替的若干最小项的圈称为“卡诺圈”</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111142393.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111222401.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111223287.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111224274.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111226921.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111228271.png"></li><li>总结<ul><li>卡诺图中小方格的个数必须为$2^m$个，m为小于或等于n的整数</li><li>卡诺图中的$2^m$个小方格含有m个不同变量,（n-m）个相同变量</li><li>卡诺图中的$2^m$个小方格对应的最小项可用（n-m）个变量的“与”项表示，该“与项”由这些最小项中的相同变量构成</li><li>当m&#x3D;n时，卡诺圈包围了整个卡诺图，可用1表示，即n个变量的全部最小项之和为1</li></ul></li></ul></li><li><p>卡诺图化简逻辑函数的步骤</p><ul><li>几个术语<ul><li>蕴涵项：“与-或”表达式中，每个与项被称为该函数的蕴涵项<ul><li>注：在函数卡诺图中，任何一个1方格所对应的最小项或者卡诺圈中的$2^m$各1方格对应的与项都是函数的蕴涵项</li></ul></li><li>质蕴涵项：若函数的一个蕴涵项不是该函数中其他蕴涵项的子集，则称为质蕴涵项，简称为质项<ul><li>在函数卡诺图中，按照最小项合并规律</li><li>如果某个卡诺圈不可能被其他更大的卡诺圈包含</li><li>该卡诺圈所对应的与项为质蕴涵项</li></ul></li><li>必要质蕴涵项：若函数的一个质蕴涵项包含有不被函数的其他任何质蕴涵项所包含的最小项，则此质蕴涵项被称为必要质蕴涵项，简称为必要质项<ul><li>在函数卡诺图中，若某个卡诺圈包含了不可能被任何其他卡诺圈包含的1方格</li><li>该卡诺圈所对应的与项为必要质蕴涵项</li></ul></li></ul></li><li>求逻辑函数最简与-或表达式的一般步骤<ul><li>第一步：作出函数的卡诺图</li><li>第二步：在卡诺图上圈出函数的全部质蕴涵项</li><li>第三步：从全部质蕴涵项中找出所有必要质蕴涵项</li><li>第四步：求函数的最简质蕴涵项集<ul><li>当函数的所有必要质蕴涵项尚不能覆盖卡诺图上的所有1方格时</li><li>从剩余质蕴涵项中找出最简的所需质蕴涵项</li><li>使它和必要质蕴涵项一起构成函数的最小覆盖</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111316319.png"><ul><li>最小项标1，这些最小项就是蕴涵项</li><li>找出质蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111318159.png"></li><li>找出必要质蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111318523.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111319387.png"></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111346588.png"><ul><li>覆盖m10?–找到的必要质蕴涵项所在的卡诺圈应该覆盖所有蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111347349.png"></li><li>两个与-或式的复杂程度相同</li><li>一个函数的最简与-或表达式不一定是唯一的</li></ul></li></ul></li><li>卡诺图化简的原则<ul><li>在覆盖函数中所有最小项前提下，卡诺圈的个数应达到最少</li><li>在满足合并规律的前提下卡诺圈应达到最大</li><li>根据合并的需要，每个最小项可以被多个卡诺圈包围</li></ul></li><li>求逻辑函数最简或-与表达式的一般步骤”两次取反法“<ul><li>情况一：当给定逻辑函数为“与-或”表达式或者标准“与-或表达式”时 <ul><li>作出函数F的卡诺图</li><li>合并卡诺图上的0方格，求出反函数F‘的最简与-或表达式</li><li>对F’的最简与或表达式取反，得到或-与表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111403894.png"></li></ul></li><li>情况二：当给定逻辑函数为或-与表达式或标准或-与表达式时<ul><li>求出函数F的反函数F‘，并作出F’的卡诺图</li><li>合并卡诺图上的1方格，求出F‘最简与或表达式</li><li>对F’的最简与-或表达式取反，得到F的最简或-与表达式</li></ul></li></ul></li></ul></li><li><p>卡诺图化简的优缺点</p><ul><li>优点：方便、直观、容易掌握</li><li>缺点：受到变量个数的约束，当变量个数大于6时，画图以及对图形的识别都变得相当复杂</li></ul></li></ul></li></ul><h3 id="列表化简法"><a href="#列表化简法" class="headerlink" title="列表化简法"></a>列表化简法</h3><ul><li>列表化简法<ul><li>通过约定的表格形式，按照一定规则完成化简过程</li><li>通过找出函数F的全部质蕴涵项，必要质蕴涵项以及最简质蕴涵项集来求得最简表达式</li><li>列表化简法的步骤<ul><li>第一步：将函数表示成“最小项之和”形式，并用二进制码表示每一个最小项</li><li>第二步：做出质蕴涵项产生表，找出函数的全部质蕴涵项</li><li>第三步：做出必要质蕴涵产生表，找出函数的必要质蕴涵项</li><li>第四步：当必要质蕴涵项不能覆盖所有最小项时，借助所需的质蕴涵项产生表，找出函数的最小覆盖</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111456360.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111502526.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111503537.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111503587.png"></li><li>列表化简法特点<ul><li>优点：规律性强，对变量数较多的函数，可经过反复比较、合并，得到最简结果</li><li>适用：计算机处理</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>数字逻辑基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冷战史</title>
    <link href="/2022/08/31/%E5%86%B7%E6%88%98%E5%8F%B2/"/>
    <url>/2022/08/31/%E5%86%B7%E6%88%98%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是冷战"><a href="#什么是冷战" class="headerlink" title="什么是冷战"></a>什么是冷战</h1><h2 id="两大阵营"><a href="#两大阵营" class="headerlink" title="两大阵营"></a>两大阵营</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208311420774.png"></p><h2 id="冷战的层面"><a href="#冷战的层面" class="headerlink" title="冷战的层面"></a>冷战的层面</h2><ul><li><p>冷战是由两大阵营推行的一种政策以及由此造成的局面或状态</p></li><li><p>这种对立或斗争包含这几个层面的含义</p><ul><li>两种意识形态的斗争：资本主义和马列主义</li><li>两种制度的斗争：资本主义和社会主义</li><li>两大阵营的斗争：美及其盟友同苏联及其盟友的军事对抗、意识形态斗争以及为争夺第三世界的角逐。双方都试图追求对世界的统治，试图通过长期斗争完成自己的历史使命</li></ul></li></ul><h3 id="意识形态的对立和斗争"><a href="#意识形态的对立和斗争" class="headerlink" title="意识形态的对立和斗争"></a>意识形态的对立和斗争</h3><ul><li>冷战在意识形态的特征是相互敌对和互不信任，每一方都认定和相信对方具有不同的价值观、寻求不同的目标，认为对方的存在和发展是对自己核心价值取向的根本威胁。这种斗争同时在国内和国外两个战场展开</li><li>美国：颁布国家安全法、成立国安会和中情局，开展忠诚运动，麦卡锡主义盛行一时，攻击苏联的制度和生活方式、宣传活动与和平演变</li><li>苏联：意识形态是立国之本，严控思想和舆论，开展思想惩戒运动；揭露和批判西方社会制度、生活方式和价值观；对外宣传苏联的成就与政策主张</li></ul><p>钱学森当时拥有很高的权利和自由，可以自由出入国防部、五角大楼，但是因为他享受着这种权利和自由还仍然不愿加入美国籍，于是认为他是潜在的共产党分子，于是”软禁“了他</p><h3 id="国家安全与安全困境"><a href="#国家安全与安全困境" class="headerlink" title="国家安全与安全困境"></a>国家安全与安全困境</h3><ul><li>冷战时期，美苏形成了政治、经济、意识形态对立的两大军事集团的对抗。冷战时期的安全体系建立在战略核威慑和集体安全以及同盟战略的基础之上，互相视为主要敌人<ul><li>意识形态的对立和两极化，为军事集团的建立和存在提供了框架与理由</li><li>核威慑和有限主权则成为两大对立的军事政治集团或联盟一体化的支柱与推行全球干涉的工具</li></ul></li><li>为了在争夺中占据主动，就必须确保或获得军事战略优势，为此展开了激烈的军备竞赛<ul><li>加速军备建设。开发包括核弹头到运载工具、反弹道导弹系统和太空武器在内的核武器攻防体系</li><li>组织军事集团，扩大和维持对外驻军</li><li>扩大武器输出，角逐世界军火市场，进而控制或支配他国</li><li>制定相应的军事战略</li><li>通过军备控制和裁军谈判，谋求自身军事优势，并获取政治和宣传上的好处</li></ul></li><li>地缘政治利益的争夺<ul><li>作为具有全国利益和全国义务的超级大国，美苏都把对安全利益威胁的理解和安全概念扩大化，并最终把每一件事同社会主义与资本主义的斗争联系在一起</li><li>美苏都把欧洲视为地缘政治利益最优先的地区，势力范围、军事部署和直接的军事对峙</li><li>第三世界是美苏争夺、进行冷战的重要战场<ul><li>美国通过军事入侵、政治颠覆、经济与军事援助向第三世界扩张；重点关注中东地区、视拉美为自己的后院和传统势力范围</li><li>苏联通过政治支持、经济和军事援助、意识形态宣传，在第三世界建立和扩大势力范围</li></ul></li></ul></li><li>冷战中的缓和与合作<ul><li>零和博弈下的对立与对抗是美苏关系的基本形式，同时，为了各自的战略和政策目标，有时也进行某种程度的合作：<ul><li>举行最高级首脑会晤，加强领导人接触与相互理解</li><li>通过协商确定两国关系基本原则</li><li>在解决重大问题和紧迫问题时及时准确沟通信息、阐发自己的要求，以及做出相互让步，避免危机的进一步升级和扩大</li><li>展开裁军谈判，减轻政治经济压力</li><li>在解决人类面临的共同问题时进行有限合作</li></ul></li></ul></li></ul><h2 id="冷战的起源"><a href="#冷战的起源" class="headerlink" title="冷战的起源"></a>冷战的起源</h2><ul><li>客观来说，冷战的出现是国际政治和各国，特别是美苏政治、军事、经济、意识形态、决策机构和决策人等诸多因素互相作用的结果</li><li>战后的国际格局两极化走向以及在这一进程中出现的动荡、重组和权力真空，为大国其战略目标提供了机遇和活动空间</li><li>战后美苏成为大国，由于它们的国家利益和意识形态对立，决定了它们在推行外交政策和建立两极体制中不可避免地发生冲突。美苏之间缺乏最起码的理解和信任，彼此奉行“零和“的游戏规则</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208311532591.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208311537021.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208311539414.png"></p>]]></content>
    
    
    <categories>
      
      <category>通核</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PR+AE学习</title>
    <link href="/2022/08/22/PR-AE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/22/PR-AE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p>新建序列</p><ul><li>快捷键ctrl+n</li><li>预设设置（TV-NTSC制、TV-PAL制）</li><li>帧大小</li><li>像素长宽比（一般选方形像素）</li><li>场序（通常选择无场）</li><li>自己设置常用预设<ul><li>时基24帧</li><li>帧大小1920 * 1080</li><li>方形像素</li><li>无场</li><li>采样率（48000和44100最常用）</li></ul></li></ul></li><li><p>PR工作区</p><ul><li>项目窗口可在素材区对导入的视频素材可点击鼠标右键选择从剪辑新建序列</li><li>可自定义各个面板的位置，设置完后可以通过窗口-工作区-重置为保存的面板</li><li>CTRL+SHIFT快捷键可使轨道快速恢复到相同宽度</li></ul></li><li><p>标记入点及出点</p><ul><li>节目窗口，如果黄条中出现红色，应该标记出入点，覆盖红色范围，按住ENTER键进行渲染，至其变成绿色或黄色，就会不卡顿了</li><li>用完出点、入点后，不再需要，记得删除</li><li>拖拽既有音频也有视频的素材时，如果单显示一个，很可能是V、A轨道只开了一个，把他们全关闭就好</li></ul></li><li><p>取消音视频链接</p><ul><li>快捷键CTRL+L</li></ul></li><li><p>标记点</p><ul><li>快捷键CTRL+M</li></ul></li><li><p>速度与持续时间</p><ul><li>可以左键长按第三个，使用比率拉伸工具。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208311656667.png"></li></ul></li><li><p>新建项</p><ul><li>新建脱机文件，用来代替空缺的素材</li><li>调整图层放在剪辑的视频之上，却不会覆盖视频，在调整图层上进行一些调色、加效果，比较好</li><li></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>影视后期</category>
      
    </categories>
    
    
    <tags>
      
      <tag>影视后期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路设计实例</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071712386.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713039.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713450.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713896.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713270.png"></p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714955.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714333.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714011.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714851.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714578.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714124.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071715706.png"></p><h2 id="自启动问题"><a href="#自启动问题" class="headerlink" title="自启动问题"></a>自启动问题</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716529.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716582.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716894.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716984.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717729.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717060.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717475.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717771.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071718045.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071718022.png"></p><p>要讨论在无效状态时，电路输出和状态转移</p><ul><li>讨论<ul><li>电路是否具有自恢复功能<ul><li>电路万一偶然进入无效状态，如果能在输入信号时和时钟脉冲作用下自动进入有效状态，则称为具有自恢复功能，否则称为“挂起”</li><li>存在挂起，必须修正</li></ul></li><li>电路是否会产生错误输出信号<ul><li>电路万一处在无效状态，是否会在输入信号和时钟脉冲作用下产生错误输出信号</li><li>存在错误输出信号，必须修正</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071721689.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071721579.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722229.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722721.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722919.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722408.png"><br>对于无效序列，如果在某种输入情况下，电路可以回到正常序列中去，电路就不存在挂起问题了</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723138.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723171.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723035.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路设计过程</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="同步时序逻辑电路的设计步骤"><a href="#同步时序逻辑电路的设计步骤" class="headerlink" title="同步时序逻辑电路的设计步骤"></a>同步时序逻辑电路的设计步骤</h1><p>用尽可能少的触发器和逻辑门实现预定的逻辑要求</p><ul><li>完全确定同步时序逻辑电路<ul><li>电路在不同输入取值下都有确定的次态和输出</li></ul></li><li>不 完全确定同步时序逻辑电路<ul><li>电路中存在不确定的次态或输出，即某些状态在输入取值下的次态或输出是随意的<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071608587.png"></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071609288.png"></p><ul><li>第一步作原始状态图状态表的首要任务<ul><li>正确反映题意</li><li>是否最简不做要求</li></ul></li></ul><h1 id="原始状态图"><a href="#原始状态图" class="headerlink" title="原始状态图"></a>原始状态图</h1><ul><li>根据对设计要求的文字描述，抽象出电路的输入、输出以及状态之间的关系，形成状态图和状态表</li><li>先画状态图后画状态表</li></ul><h2 id="建立原始状态图步骤"><a href="#建立原始状态图步骤" class="headerlink" title="建立原始状态图步骤"></a>建立原始状态图步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071612910.png"></p><ul><li>确定各时刻电路的输出<ul><li>时序逻辑电路的功能是通过输出对输入的响应来体现的</li><li>在建立原始状态图时，必须确定各时刻的输出值<ul><li>在Moore型电路中，应指明每周状态下对应的输出</li><li>在Mealy型电路中应指明从每一个状态出发，在不同输入作用下的输出值</li></ul></li></ul></li><li>注意：<ul><li>状态数目能否达到最少无关紧要，因为可以再化简</li><li>设计者应把清晰、正确地描述设计要求放在第一位</li><li>一般用字母或数字表示状态</li></ul></li></ul><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616693.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616515.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616857.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617938.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617064.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617070.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617849.png"></p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618569.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618950.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618908.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071619460.png"></p><ul><li>总结<ul><li>一个序列检测器所需要的状态数与要识别的序列长度相关<ul><li>序列越长，需要记忆的代码位数越多，状态数也就越多</li></ul></li><li>Mealy型一般比Moore型所需状态数少</li></ul></li></ul><h2 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071621929.png"></p><p>代码检测器的特点是输入信号是按位分组的，每组的监测过程相同，即一组检测完后，电路回到初始状态，接着进行下一组的监测</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071622810.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071624175.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071624469.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071625568.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071625820.png"></p><h1 id="状态化简"><a href="#状态化简" class="headerlink" title="状态化简"></a>状态化简</h1><p>从原始状态表中消去多余状态，的到一个描述给定的逻辑功能的包含状态数目达到最少的状态表，即最简状态表或最小化状态表</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071628802.png"></p><ul><li>化简方法<ul><li>观察法</li><li>输出分类法</li><li>隐含表法</li></ul></li></ul><p>等效状态：<br>设S和J是完全确定状态表中的两个状态，若对于所有可能的输入序列，分别从S和J出发所得到的输出响应序列完全相同，则称它们是等效的</p><ul><li>等效状态的判断方法<ul><li>输出相同</li><li>次态输入下列情况之一<ul><li>次态相同</li><li>次态交错或为各自的现态</li><li>次态循环或为等效对</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071633310.png"></p><p>等效状态的性质：<br>等效状态具有传递性<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071634046.png"></p><p>等效类</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071634807.png"></p><p>最大等效类：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071635236.png"></p><h2 id="状态化简步骤"><a href="#状态化简步骤" class="headerlink" title="状态化简步骤"></a>状态化简步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636882.png"></p><h3 id="做隐含表"><a href="#做隐含表" class="headerlink" title="做隐含表"></a>做隐含表</h3><p>直角三角形阶梯网格<br>每个方格代表一个状态对</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636855.png"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636466.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636817.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636262.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637536.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637832.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637191.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071638004.png"></p><h1 id="状态编码"><a href="#状态编码" class="headerlink" title="状态编码"></a>状态编码</h1><p>给最小化状态表中用字母或数字表示的状态指定一个二进制代码，形成二进制状态表，也称状态分配，或者状态赋值</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640804.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640753.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640308.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640926.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640003.png"></p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640697.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641903.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641938.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641862.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641772.png"></p><h1 id="确定激励函数和输出函数"><a href="#确定激励函数和输出函数" class="headerlink" title="确定激励函数和输出函数"></a>确定激励函数和输出函数</h1><ul><li>触发器的激励表<ul><li>反映了触发器从现态转移到某种次态时，对输入条件的要求</li><li>把触发器的现态和次态作为自变量，而把触发器的输入作为因变量</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071643187.png"></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>列出激励函数和输出函数的真值表</li><li>用卡诺图化简后写出最简表达式</li><li>熟练时刻直接根据激励函数和输出函数真值表，作出激励函数和输出函数卡诺图化简</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071644897.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645942.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645674.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645148.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646456.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646483.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646182.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646374.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646346.png"><br>回答–确实<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646227.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646762.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071647300.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071647004.png"></p><p>注意：<br>在同步时序逻辑电路的设计中，采用不同的触发器，会导致激励函数不同，使得设计出来的检录的组合电路部分的复杂程度会不同。因此，在具体的设计中，要进行分析、对比，选择合适的存储元件，从而使最终设计的电路最简单</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路分析</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="同步时序逻辑的表格分析法"><a href="#同步时序逻辑的表格分析法" class="headerlink" title="同步时序逻辑的表格分析法"></a>同步时序逻辑的表格分析法</h1><p>分析的关键在于找出电路状态和输出随输入变化而变化的规律，以便确定其逻辑功能</p><h2 id="表格法分析步骤"><a href="#表格法分析步骤" class="headerlink" title="表格法分析步骤"></a>表格法分析步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071547947.png"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071548977.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071548315.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071549737.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550747.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550693.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550446.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550589.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550986.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071551959.png"></p><p>加1计数<br>2位二进制数逆计数器</p><h2 id="作时间图的一般步骤"><a href="#作时间图的一般步骤" class="headerlink" title="作时间图的一般步骤"></a>作时间图的一般步骤</h2><p>在时序逻辑电路分析中，除了状态图和状态表，通常还用到时间图</p><ul><li>作时间图的一般步骤<ul><li>假设电路初始状态，并拟定一典型输入序列</li><li>作出状态和输出响应序列</li><li>根据响应序列画出波形图</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071555605.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071555131.png"></p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071600116.png"></p><p>两个D触发器–相同时钟端，同步时序逻辑逻辑电路<br>三个或非门<br>输入：x<br>输出：z<br>电路的状态：<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602074.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602033.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602708.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602577.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602984.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602048.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071603845.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071603296.png"></p><p>实际问题分析时，可视具体情况灵活运用，根据给定逻辑电路的复杂程度不同，通常可以省去某些步骤，例如列次态真值表或画时间图等</p><h1 id="同步时序逻辑电路的代数分析法"><a href="#同步时序逻辑电路的代数分析法" class="headerlink" title="同步时序逻辑电路的代数分析法"></a>同步时序逻辑电路的代数分析法</h1><h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071557564.png"></p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558378.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558630.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558346.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558844.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071559344.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时序逻辑电路基础</title>
    <link href="/2022/07/27/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/27/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="时序逻辑电路概述"><a href="#时序逻辑电路概述" class="headerlink" title="时序逻辑电路概述"></a>时序逻辑电路概述</h1><ul><li>若逻辑电路在任何时候产生的稳定输出信号不仅与电路该时刻的输入信号有关，还与电路过去的输入信号有关，则称为时序逻辑电路</li></ul><h2 id="时序逻辑电路一般结构"><a href="#时序逻辑电路一般结构" class="headerlink" title="时序逻辑电路一般结构"></a>时序逻辑电路一般结构</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071510178.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051005132.png"><br>这是图左的电路分析</p><ul><li><p>状态</p><ul><li>时序逻辑电路的状态是存储电路对过去输入信号记忆的结果</li><li>随着外部信号的作用而变化</li><li>在对电路功能进行研究时，通常将某一时刻的现状称为现态</li><li>在某一状态下，外部信号发生变化后达到的新的状态称为次态</li></ul></li><li><p>时序逻辑电路的特点</p><ul><li>电路又组合电路和存储电路组成，具有对过去输入进行记忆的功能</li><li>电路中包含反馈回路，通过反馈使电路功能与时序相关</li><li>电路的输出由电路当时的输入和状态共同决定</li></ul></li></ul><h2 id="时序逻辑电路的分类"><a href="#时序逻辑电路的分类" class="headerlink" title="时序逻辑电路的分类"></a>时序逻辑电路的分类</h2><h3 id="按照电路的工作方式分类"><a href="#按照电路的工作方式分类" class="headerlink" title="按照电路的工作方式分类"></a>按照电路的工作方式分类</h3><ul><li><p>同步时序逻辑电路</p><ul><li>电路中有统一的定时信号，存储器件采用时钟控制触发器，电路状态在时钟脉冲控制下同时发生转换</li></ul></li><li><p>异步时序逻辑电路</p><ul><li>电路中没有统一的时钟信号同步，电路输入信号的变化将直接导致电路状态的变化</li></ul></li><li><p>电路状态的改变依赖于输入信号和时钟脉冲信号</p><ul><li>状态变化时间—-取决于时钟信号</li><li>状态如何变化—-取决于输入信号</li><li>每个状态维持时间—-取决于时钟脉冲的周期</li></ul></li></ul><p>研究同步时序逻辑电路时，通常不把同步时钟信号作为输入信号处理，而是将它当成一种默认的时间基准</p><p>同步时序逻辑电路中的现态与次态时针对某个时钟脉冲而言的</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071521085.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071521436.png"></p><ul><li>同步时序逻辑电路对时钟的要求（为了稳定可靠工作）<ul><li>脉冲的宽度—-必须保证触发器可靠翻转</li><li>脉冲的频率—-必须保证前一个脉冲引起的电路响应完全结束后，后一个脉冲才能到来</li></ul></li></ul><h3 id="按照电路输出与输入的依存关系分类"><a href="#按照电路输出与输入的依存关系分类" class="headerlink" title="按照电路输出与输入的依存关系分类"></a>按照电路输出与输入的依存关系分类</h3><ul><li>Mealy型—-时序逻辑电路的输出是电路输入和电路状态的函数</li><li>Moore型—-时序逻辑电路的输出仅仅是电路状态的函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071525968.png"><br>X是输入<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071525889.png"></p><ul><li><p>两者区别</p><ul><li><p>Mealy型电路的输入和输出之间存在直接联系</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051026577.png"></li></ul></li><li><p>Moore型电路则是将全部输入转换为电路状态后再和输出建立联系</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051026338.png"></li></ul></li></ul></li><li><p>Moore型电路的特殊状况</p><ul><li>时序逻辑电路没有专门的外部输入信号，而是以电路状态作为输出</li></ul></li></ul><h3 id="按照电路输入信号形式划分"><a href="#按照电路输入信号形式划分" class="headerlink" title="按照电路输入信号形式划分"></a>按照电路输入信号形式划分</h3><ul><li>脉冲型<ul><li>有相同的间隔</li></ul></li><li>电平型<ul><li>0和1间隔是不等的，是任意的</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071529650.png"></p><h2 id="时序逻辑电路的描述"><a href="#时序逻辑电路的描述" class="headerlink" title="时序逻辑电路的描述"></a>时序逻辑电路的描述</h2><ul><li>逻辑函数表达式<ul><li>输出函数表达式</li><li>激励函数表达式</li><li>次态函数表达式</li></ul></li><li>状态图</li><li>状态表</li><li>时间表</li></ul><h3 id="逻辑函数表达式"><a href="#逻辑函数表达式" class="headerlink" title="逻辑函数表达式"></a>逻辑函数表达式</h3><ul><li>激励函数表达式<ul><li>反映了存储电路的输入与外部的输入和电路状态之间的关系</li></ul></li><li>输出函数表达式<ul><li>反映电路输出与外部输入和状态之间关系</li></ul></li><li>次态函数表达式<ul><li>同步时序电路的次态与激励函数和电路现态之间的关系</li></ul></li></ul><h4 id="Moore型电路"><a href="#Moore型电路" class="headerlink" title="Moore型电路"></a>Moore型电路</h4><h5 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071534670.png"></p><h5 id="个例"><a href="#个例" class="headerlink" title="个例"></a>个例</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071536531.png"></p><h4 id="Mealy型电路"><a href="#Mealy型电路" class="headerlink" title="Mealy型电路"></a>Mealy型电路</h4><h5 id="范式-1"><a href="#范式-1" class="headerlink" title="范式"></a>范式</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071537820.png"></p><h5 id="个例-1"><a href="#个例-1" class="headerlink" title="个例"></a>个例</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071537364.png"></p><h3 id="状态表"><a href="#状态表" class="headerlink" title="状态表"></a>状态表</h3><ul><li>状态转移表</li><li>反映同步时序电路输出、次态与电路输入与现态之间关系的表格</li><li>状态表示同步时序电路分析和实际中常用的工具</li><li>非常清晰给出了同步时序电路在不同输入和现态下的次态和输出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071539807.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071540681.png"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>反映同步时序电路状态转换规律及相应输入、输出取值关系的有向图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071541443.png"></p><ul><li>优点<ul><li>直观、形象</li></ul></li><li>状态图和状态表对比<ul><li>状态表更规范</li><li>状态图更形象</li></ul></li></ul><p>时间图—-表示输入信号、输出信号和电路状态的取值在各时刻的对应关系的波形图，通常又称作为工作波形图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071543391.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>维持阻塞触发器</title>
    <link href="/2022/07/27/%E7%BB%B4%E6%8C%81%E9%98%BB%E5%A1%9E%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E7%BB%B4%E6%8C%81%E9%98%BB%E5%A1%9E%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="维持阻塞触发器"><a href="#维持阻塞触发器" class="headerlink" title="维持阻塞触发器"></a>维持阻塞触发器</h1><h2 id="典型维持阻塞D触发器"><a href="#典型维持阻塞D触发器" class="headerlink" title="典型维持阻塞D触发器"></a>典型维持阻塞D触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271100068.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271100886.png"><br>输入$R_D$ ,$S_D$</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>CP&#x3D;0<ul><li>RS&#x3D;11</li><li>Q不变</li></ul></li><li>CP&#x3D;1<ul><li>D&#x3D;0  Q&#x3D;0</li><li>D&#x3D;1   Q&#x3D;1</li><li>D: 0–&gt;1–&gt;0<ul><li>无空翻</li></ul></li><li>D: 1–&gt;0–&gt;1<ul><li>无空翻</li></ul></li></ul></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>结论<ul><li>CP&#x3D;0<ul><li>RS&#x3D;11</li><li>Q不变</li></ul></li><li>CP&#x3D;1<ul><li>Q&#x3D;D</li><li>无空翻<br>也就是逻辑功能和钟控D触发器一样</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271106444.png"><br>仅仅在时钟脉冲上升沿响应输入变化</p><ul><li>边沿触发器：仅在时钟脉冲的上升或下降的时刻相应输入信号的触发器<ul><li>只在时钟脉冲的边沿进行采样并确定触发器的状态</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031054950.png"></li><li>大大提高了抗干扰性<br>以后没有特殊说明，我们一般采用的就是维持阻塞触发器</li></ul></li></ul><h2 id="触发器的对比"><a href="#触发器的对比" class="headerlink" title="触发器的对比"></a>触发器的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271108435.png"></p><h2 id="TTL集成JK触发器——74LS76"><a href="#TTL集成JK触发器——74LS76" class="headerlink" title="TTL集成JK触发器——74LS76"></a>TTL集成JK触发器——74LS76</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271109582.png"></p><ul><li>集成触发器的性能参数<ul><li>直流参数<ul><li>电源电流</li><li>低电平输入电流</li><li>高电平输入电流</li><li>输出高电平</li><li>输出低电平</li><li>扇出系数</li></ul></li><li>开关参数<ul><li>最高时钟频率</li><li>时钟信号的延迟时间</li><li>直接置0端的延迟</li><li>直接置1端的延迟</li></ul></li></ul></li></ul><p><strong>熟记触发器的功能表、状态表、激励表、次态方程</strong></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主从J-K触发器</title>
    <link href="/2022/07/27/%E4%B8%BB%E4%BB%8EJ-K%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E4%B8%BB%E4%BB%8EJ-K%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="主从JK触发器"><a href="#主从JK触发器" class="headerlink" title="主从JK触发器"></a>主从JK触发器</h1><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031022993.png"><br>由主从RS触发器演变而来<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271052522.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271052718.png"></p><ul><li>优点<ul><li>输入信号J和K无约束</li><li>无空翻</li><li>功能全</li><li>使用方便</li></ul></li><li>缺点<ul><li>存在“一次翻转”问题</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271056877.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271056271.png"><br>t7和t11时刻为什么没有变化呢</p><ul><li>一次翻转：指在时钟脉冲作用（CP&#x3D;1）期间，主触发器的状态只能根据输入信号的变化改变一次<ul><li>主触发器在接收输入信号发生一次翻转之后，状态保持不变，不再受J、K变化的影响</li><li>和空翻不同，一次翻转会导致触发器的状态转移与触发器的逻辑功能不一致，这是不允许的</li></ul></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>造成一次翻转现象的原因是什么呢？<br>是因为我们引入了两个反馈线。<br>而钟控JK触发器也引入了两根反馈线，为什么就没事呢？<br>因为钟控JK触发器钟，J、K发生变化时，触发器的状态会跟着发生变化，因此每次J、K发生变化，反馈回来的都是上次J、K发生变化后的状态<br>而在主从JK触发器里，由于从触发器被锁，因此JK发生变化时，从触发器不能跟着变化，因此，反馈回来的不是JK当前的状态，而是从前的状态<br>当输入端JK出现干扰信号的时候，就可能破幻触发器的正常逻辑功能，为了客服这一缺点，就要求在时钟脉冲作用期间，输入JK的值不能发生变化，这就降低了它的抗干扰能力。<br>而且和主从RS触发器一样，这种对输入端的约束，就失去了主从结构的意义，因此主从JK触发器是不能使用的</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主从R-S触发器</title>
    <link href="/2022/07/27/%E4%B8%BB%E4%BB%8ER-S%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E4%B8%BB%E4%BB%8ER-S%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="主从RS触发器"><a href="#主从RS触发器" class="headerlink" title="主从RS触发器"></a>主从RS触发器</h1><p>为了解决空翻问题引入</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270933441.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270934220.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270935644.png"></p><ul><li>输入端$R_D$：直接置0端<ul><li>$R_D$等于0时，会使得Q等于0</li></ul></li><li>输入端$S_D$：直接置1端<ul><li>$S_D$等于0时，Q就等于1</li></ul></li><li>在正常工作时，它们都不能等于0，因为它一旦等于0，直接置0或者置1了。都等于0，又违背了约束条件，所以正常工作时，一般让它们都为1</li><li>因为它们都为1，对与非门是不起作用的，于是分析的时候可以不看它们</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270942684.png"><br>主触发器的输出是从触发器的输入<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270942377.png"><br>主触发器和从触发器时钟反相</p><ul><li>CP&#x3D;1<ul><li>从触发器锁定</li><li>主触发器响应</li></ul></li><li>CP&#x3D;0<ul><li>主触发器锁定</li><li>从触发器响应</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270948578.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>总结<ul><li>前沿采样</li><li>后沿定局</li><li>状态变化是在时钟脉冲的后沿</li><li>状态变化锁定在一个时间点，而不是一个时间段，过了这个状态，无论它怎么变化，主触发器的状态是被锁定的，因此不会导致从触发器发生变化（就是图中一点的例子），因此无“空翻”<br>对于此触发器而言。它的状态变化是发生在CP的下降沿，因此称它为下降沿触发器<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031013494.png"><br>加了一个小圆圈，加了表示下降沿触发，不加便是上升沿触发</li></ul></li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>主触发器输出</li><li>从触发器输入</li><li>与钟控触发器功能一致</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031015139.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271050266.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271050046.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时钟控制触发器</title>
    <link href="/2022/07/27/%E9%92%9F%E6%8E%A7%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E9%92%9F%E6%8E%A7%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="钟控触发器"><a href="#钟控触发器" class="headerlink" title="钟控触发器"></a>钟控触发器</h1><ul><li>具有时钟脉冲控制的触发器<ul><li>时钟控制触发器</li><li>定时触发器</li><li>clocked flip-flop</li></ul></li><li>工作特点<ul><li>何时转换？<ul><li>由时钟脉冲确定状态转换的时刻</li></ul></li><li>如何转换？<ul><li>由输入信号确定触发器状态转换的方向</li></ul></li></ul></li></ul><h2 id="钟控R-S触发器"><a href="#钟控R-S触发器" class="headerlink" title="钟控R-S触发器"></a>钟控R-S触发器</h2><p>加入两个与非门和一个时钟端CP<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917441.png"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917659.png"></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917694.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918772.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918396.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>钟控R-S触发器受时间脉冲信号控制，只有在CP&#x3D;1时，才会和或非门构成的R-S触发器功能相同。<br>但是它的输入信号仍然存在约束—-引入钟控D触发器</p><h2 id="钟控D触发器"><a href="#钟控D触发器" class="headerlink" title="钟控D触发器"></a>钟控D触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918114.png"><br><strong>在钟控RS触发器的基础上加了一根线，可以这样理解：原来的R变成现在的S’，而S’它等于（CP与D）的非，这样输入就变成一组互补的输入，不存在约束了</strong><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919484.png"></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919524.png"></p><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919432.png"><br>钟控D触发器解除了钟控RS触发器对输入的约束，也就没有约束方程了<br><strong>钟控D触发器在时钟脉冲作用后，它的次态和它输入的值相同，所以我们也叫他锁存器</strong><br>但是它功能比较单一，所以我们引入钟控JK触发器</p><h2 id="钟控J-K触发器"><a href="#钟控J-K触发器" class="headerlink" title="钟控J-K触发器"></a>钟控J-K触发器</h2><p>在钟控RS触发器上进行改造，首先把输入端变成K、J，然后 加入两根反馈线<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021521328.png"></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922866.png"><br>根据R’+S’&#x3D;1推出的最后表达式，恒等于1，所以输入也不存在约束的问题</p><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922796.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922638.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922916.png"></p><h2 id="钟控T触发器"><a href="#钟控T触发器" class="headerlink" title="钟控T触发器"></a>钟控T触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021533308.png"><br>在JK触发器上进行调整，将J端和K端连在一起用一个新的输入端T表示</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270923088.png"></p><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270923617.png"></p><h2 id="总结与补充"><a href="#总结与补充" class="headerlink" title="总结与补充"></a>总结与补充</h2><ul><li>电位控制触发器（上述的钟控触发器均有这些共性，它们都是电位控制触发器）<ul><li>CP&#x3D;0，也就是低电平，触发器保持状态不变</li><li>CP&#x3D;1，也就是高电平，触发器在输入信号作用下发生状态变化</li><li>触发器状态转移被控制在一个约定的时间间隔内，而不是控制在某一时刻</li><li>但是有一个缺陷是会产生空翻现象</li></ul></li></ul><p>空翻：同一个时钟脉冲作用期间触发器状态发生两次或两次以上变化的现象</p><ul><li>空翻原因<ul><li>时钟脉冲作用期间，输入信号直接控制着触发器状态的变化<ul><li>CP&#x3D;1时，输入信号发生变化，触发器状态会跟着变化</li></ul></li><li>时钟宽度控制不够<ul><li>CP为1的时间过长，输入的多次变化得到完全响应，使得一个时钟脉冲作用期间触发器多次翻转</li></ul></li></ul></li></ul><p>空翻将造成状态的不确定和系统工作的混乱，这是不允许的</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路险象</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E9%99%A9%E8%B1%A1/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E9%99%A9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="组合逻辑电路中的险象"><a href="#组合逻辑电路中的险象" class="headerlink" title="组合逻辑电路中的险象"></a>组合逻辑电路中的险象</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>信号经过任何逻辑门和导线都会产生时间延迟<ul><li>当电路所有输入达到稳定状态时，输出并不是立即达到稳定状态</li><li>延迟时间<ul><li>与信号经过的门的级数有关</li><li>与具体逻辑门的时延大小有关</li><li>与导线的长短有关</li></ul></li><li>延迟时间对数字系统是一个有害的因素<ul><li>使得系统操作速度下降</li><li>引出电路中信号的波形参数变坏</li><li>产生竞争险象</li></ul></li></ul></li><li>竞争<ul><li>由于延迟时间的影响，输入信号经过不同路径到达输出端的时间有先有后的现象</li><li>广义理解：多个信号到达某一点有时差的现象</li><li>竞争的类型<ul><li>非临界竞争：不产生错误输出的竞争</li><li>临界竞争：导致错误输出的竞争</li></ul></li></ul></li><li>险象<ul><li>由竞争导致的错误输出信号<ul><li>组合电路中的险象是一种瞬态现象</li><li>表现为在输出端产生不应有的尖脉冲，暂时地破坏正常逻辑关系</li><li>一旦瞬态过程结束，即可恢复正常逻辑关系</li></ul></li><li>险象分类<ul><li>静态险象：输入变化而输出不应发生变化的情况下，输出端产生的短暂错误输出</li><li>动态险象：在输入变化而输出应该发生变化的情况下，输出在变化过程中产生的短暂的错误输出</li><li>按错误输出脉冲信号的极性划分<ul><li>错误输出信号为负脉冲（0型险象）</li><li>错误输出信号为正脉冲（1型险象）</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251227911.png"></li></ul></li></ul></li></ul><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251222912.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251223478.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251223015.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251224198.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251224711.png"></p><h2 id="险象的判断"><a href="#险象的判断" class="headerlink" title="险象的判断"></a>险象的判断</h2><p>卡诺图法和代数法</p><h3 id="代数法"><a href="#代数法" class="headerlink" title="代数法"></a>代数法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210932027.png"></p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221200831.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221200684.png"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201503.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201279.png"></p><h3 id="卡诺图法"><a href="#卡诺图法" class="headerlink" title="卡诺图法"></a>卡诺图法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201026.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221206150.png"></p><p><strong>注意：判断组合逻辑电路中的竞争和险象时，一定不能改变电路的结构，即不对原来的电路做任何的化简、变换等</strong></p><h2 id="险象的消除"><a href="#险象的消除" class="headerlink" title="险象的消除"></a>险象的消除</h2><h3 id="增加冗余项法"><a href="#增加冗余项法" class="headerlink" title="增加冗余项法"></a>增加冗余项法</h3><p>或上冗余的与项<br>与上冗余的或项</p><p>代数法&#x2F;卡诺图法</p><h4 id="例（代数法）"><a href="#例（代数法）" class="headerlink" title="例（代数法）"></a>例（代数法）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630116.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630288.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630070.png"></p><h4 id="卡诺图法-1"><a href="#卡诺图法-1" class="headerlink" title="卡诺图法"></a>卡诺图法</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261631128.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261631075.png"></p><h4 id="例（卡诺图法）"><a href="#例（卡诺图法）" class="headerlink" title="例（卡诺图法）"></a>例（卡诺图法）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261632893.png"></p><p><strong>注意：用增加冗余项的方法消除险象时，一定不能改变电路的功能，即增加冗余项后电路的真值表不会发生改变</strong></p><h3 id="增加惯性延时环节法"><a href="#增加惯性延时环节法" class="headerlink" title="增加惯性延时环节法"></a>增加惯性延时环节法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634006.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634308.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634516.png"></p><h3 id="选通法"><a href="#选通法" class="headerlink" title="选通法"></a>选通法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634582.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261635125.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路设计</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="组合逻辑电路设计"><a href="#组合逻辑电路设计" class="headerlink" title="组合逻辑电路设计"></a>组合逻辑电路设计</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241825036.png"></p><ul><li>分析设计要求</li><li>列出真值表</li><li>得到最简逻辑表达式</li><li>表达式变换</li><li>修正表达式</li><li>得到逻辑电路图</li></ul><h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><ul><li>正确理解要求</li><li>确定电路的输入和输出</li><li>确定函数与变量之间的逻辑关系</li></ul><h3 id="例1：设计三变量“多数表决电路”"><a href="#例1：设计三变量“多数表决电路”" class="headerlink" title="例1：设计三变量“多数表决电路”"></a>例1：设计三变量“多数表决电路”</h3><ul><li>定义：三变量多数表决电路是指三个人对一件事进行表决，根据大家投票的结果来决定这件事的最终结果</li><li>分析<ul><li>输入：A、B、C为代表参加表决的三个成员，0表示反对，1表示赞成</li><li>输出：F：表决结果，0表示决议被否定，1表示决议通过</li><li>逻辑关系：当3个变量中有两个及以上取值为1时，函数F的值为1，其它情况下F的值为0</li></ul></li></ul><h4 id="真值表-逻辑表达式"><a href="#真值表-逻辑表达式" class="headerlink" title="真值表+逻辑表达式"></a>真值表+逻辑表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241830432.png"></p><h4 id="函数化简-器件选择"><a href="#函数化简-器件选择" class="headerlink" title="函数化简+器件选择"></a>函数化简+器件选择</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191632069.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241830926.png"></p><h4 id="逻辑电路图"><a href="#逻辑电路图" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p>用与非门实现<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241831005.png"></p><h3 id="例2：设计一个比较两个三位二进制数是否相等的数值比较器"><a href="#例2：设计一个比较两个三位二进制数是否相等的数值比较器" class="headerlink" title="例2：设计一个比较两个三位二进制数是否相等的数值比较器"></a>例2：设计一个比较两个三位二进制数是否相等的数值比较器</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>输入：<ul><li>A &#x3D; a0a1a2, B &#x3D; b0b1b2</li><li>6个输入变量</li></ul></li><li>输出：<ul><li>F：比较结构</li><li>当A&#x3D;B时，F为1，否则F为0</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241835015.png"></p><h4 id="逻辑电路图-1"><a href="#逻辑电路图-1" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241836396.png"><br>三个异或门和一个或非门</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>真值表法<ul><li>优点：规整、清晰</li><li>缺点：不方便，尤其当变量较多时十分麻烦</li></ul></li><li>分析法<ul><li>通过对设计要求的分析、理解，直接写出逻辑表达式</li></ul></li></ul><h2 id="包含无关条件的组合逻辑电路设计"><a href="#包含无关条件的组合逻辑电路设计" class="headerlink" title="包含无关条件的组合逻辑电路设计"></a>包含无关条件的组合逻辑电路设计</h2><ul><li>无关最小项<ul><li>由于输入变量之间存在的相互制约，问题的某种特殊限定，使得逻辑函数与输入变量的某些取值组合无关，这些取值组合称为无关最小项，也叫无关项，任意项</li><li>描述包含无关条件的逻辑问题的逻辑函数称为包含无关条件的逻辑函数</li></ul></li></ul><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241840396.png"></p><ul><li>分析<ul><li>只能取值：000，001，010，100</li><li>不允许出现：011，101，110，111</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191650832.png"></li><li>包含无关条件的逻辑函数</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201049010.png"></p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201049013.png"></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>输入：4个<br>输出：4个<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201050121.png"></p><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241841489.png"></p><p><strong>如何由真值表求得逻辑函数表达式？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201125808.png"><br>找输出端的1，对应的输入相乘，再把每一个相加，就是逻辑函数表达式<br>或者找输出端的0，对应的输入相加，再把每一项相乘</p><h4 id="表达式化简"><a href="#表达式化简" class="headerlink" title="表达式化简"></a>表达式化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241841445.png"></p><p>左图是普通的卡诺图化简，右图是用d把无关最小项表示了出来，因为它无关，所以取0取1都没关系，为了化简方便，我们给它取1，然后再圈出卡诺圈化简，发现得到的函数表达式简单了不少</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842385.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842972.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842183.png"></p><h4 id="逻辑电路图-2"><a href="#逻辑电路图-2" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842741.png"></p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241843960.png"></p><ul><li>分析<ul><li>输入变量：ABCD</li><li>输出函数：F</li><li>逻辑关系：当ABCD表示的十进制数为合数(4、6、8、9)时，输出F为1，否则F为0</li><li>无关项：0000、0001、0010、1101、1110、1111</li></ul></li></ul><h4 id="真值表-1"><a href="#真值表-1" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241845454.png"></p><h4 id="表达式化简-1"><a href="#表达式化简-1" class="headerlink" title="表达式化简"></a>表达式化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846423.png"></p><h4 id="表达式变换"><a href="#表达式变换" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846951.png"></p><h4 id="逻辑电路图-3"><a href="#逻辑电路图-3" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846105.png"></p><h2 id="多输出函数的组合逻辑电路设计"><a href="#多输出函数的组合逻辑电路设计" class="headerlink" title="多输出函数的组合逻辑电路设计"></a>多输出函数的组合逻辑电路设计</h2><ul><li>由同一组输入变量产生多个输出函数</li><li>应该将多个输出函数当作一个整体考虑，而不应该将其截然分开</li><li>关键：在函数化简时找出各输出函数的公用项，实现对逻辑门的共享</li></ul><h3 id="例子：设计一个全加器"><a href="#例子：设计一个全加器" class="headerlink" title="例子：设计一个全加器"></a>例子：设计一个全加器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241858665.png"></p><ul><li><p>全加器可以用于实现两个n尾数相加<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241903918.png"></p></li><li><p>分析</p><ul><li>输入端：<ul><li>Ai：被加数</li><li>Bi：加数</li><li>Ci-1：来自低位的进位输入</li></ul></li><li>输出端<ul><li>Si：本位和</li><li>Ci：向高位的进位</li></ul></li></ul></li></ul><h4 id="真值表-2"><a href="#真值表-2" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241903645.png"></p><h4 id="函数化简"><a href="#函数化简" class="headerlink" title="函数化简"></a>函数化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241904386.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241904066.png"></p><h4 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905696.png"></p><h4 id="函数化简-1"><a href="#函数化简-1" class="headerlink" title="函数化简"></a>函数化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905944.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905997.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241915420.png"></p><p>多输出组合逻辑电路达到最简的关键是在函数化简时找到各输出函数的公用项，以便在逻辑电路中实现对逻辑门的共享 </p><h4 id="电路图-1"><a href="#电路图-1" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241916670.png"></p><h3 id="例子：设计一个乘法器，用于产生两个2位二进制数相乘的积"><a href="#例子：设计一个乘法器，用于产生两个2位二进制数相乘的积" class="headerlink" title="例子：设计一个乘法器，用于产生两个2位二进制数相乘的积"></a>例子：设计一个乘法器，用于产生两个2位二进制数相乘的积</h3><ul><li>分析<ul><li>输入：A1A0和B1B0</li><li>输出函数：4<ul><li>Max（A1A0）&#x3D; 11  Max（B1B0）&#x3D; 11</li><li>Max（A1A0xB1B0）&#x3D; 1011</li><li>相乘的积为M3M2M1M0</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251015731.png"></p><h4 id="真值表-3"><a href="#真值表-3" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251023898.png"></p><h4 id="表达式变换-1"><a href="#表达式变换-1" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024596.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024133.png"></p><h4 id="电路图-2"><a href="#电路图-2" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024192.png"></p><h4 id="用全加器如何实现？"><a href="#用全加器如何实现？" class="headerlink" title="用全加器如何实现？"></a>用全加器如何实现？</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251025693.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251025509.png"></p><h2 id="无反变量提供的组合逻辑电路设计"><a href="#无反变量提供的组合逻辑电路设计" class="headerlink" title="无反变量提供的组合逻辑电路设计"></a>无反变量提供的组合逻辑电路设计</h2><ul><li>问题提出（为什么有这个东西？）<ul><li>为了减少各部件之间的连线，在某些问题的设计中，不提供反变量</li><li>若直接用非门将原变量转换成相应的反变量，则处理结果往往是不经济的</li><li>通常进行适当的变换，以便在无反变量提供的前提下，尽可能减少非门数量，使逻辑电路尽可能的简化</li></ul></li></ul><h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251031672.png"></p><ul><li>分析<ul><li>F已经是最简的“与-或“表达式，可直接变换成“与非-与非”表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251033415.png"></li></ul></li></ul><h4 id="逻辑电路图-4"><a href="#逻辑电路图-4" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251033919.png"></p><h4 id="对函数F表达式整理变换"><a href="#对函数F表达式整理变换" class="headerlink" title="对函数F表达式整理变换"></a>对函数F表达式整理变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251034854.png"></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251034826.png"></p><h3 id="例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容"><a href="#例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容" class="headerlink" title="例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容"></a>例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251042018.png"></p><ul><li>分析<ul><li>电路输入变量为献血者和受血者血型</li><li>血型共4种 <ul><li>可以用两个变量的4种编码进行区分</li><li>WX表现献血者血型，YZ表示受血者血型</li></ul></li></ul></li></ul><h4 id="血型编码"><a href="#血型编码" class="headerlink" title="血型编码"></a>血型编码</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251046277.png"></p><h4 id="电路输出用F表示"><a href="#电路输出用F表示" class="headerlink" title="电路输出用F表示"></a>电路输出用F表示</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049530.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049491.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049919.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251050103.png"></p><h4 id="逻辑电路图-5"><a href="#逻辑电路图-5" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251050665.png"></p><h4 id="怎么让电路图更简单呢？"><a href="#怎么让电路图更简单呢？" class="headerlink" title="怎么让电路图更简单呢？"></a>怎么让电路图更简单呢？</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844664.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844722.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844771.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845072.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845845.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845235.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路的分类及其分析</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="逻辑电路的分类（按照对电路的记忆）"><a href="#逻辑电路的分类（按照对电路的记忆）" class="headerlink" title="逻辑电路的分类（按照对电路的记忆）"></a>逻辑电路的分类（按照对电路的记忆）</h2><ul><li>组合逻辑电路<ul><li>电路输出仅取决于当时的输入，而与过去的输入情况无关</li><li>可以完成各种复杂的逻辑功能</li><li>是时序逻辑电路的组成部分</li></ul></li><li>时序逻辑电路<ul><li>电路输出不仅取决于当时的输入，而且也与过去的输入情况有关，即与过去的电路状态有关</li></ul></li></ul><h3 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h3><h4 id="一般结构"><a href="#一般结构" class="headerlink" title="一般结构"></a>一般结构</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241715622.png"></p><h4 id="组合逻辑电路特点"><a href="#组合逻辑电路特点" class="headerlink" title="组合逻辑电路特点"></a>组合逻辑电路特点</h4><ul><li>由逻辑门电路组成</li><li>不包含任何记忆元件</li><li>信号是单向传输的，不存在反馈电路</li></ul><h3 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h3><ul><li>若逻辑电路在任何时刻产生的稳定输出信号不仅与电路该时刻的输入信号有关还与电路过去的输入信号有关，则称为时序逻辑电路<ul><li>比如电话，电子密码锁这样的</li></ul></li></ul><h4 id="一般结构-1"><a href="#一般结构-1" class="headerlink" title="一般结构"></a>一般结构</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241732878.png"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>电路由组合电路和存储电路组成，具有对过去输入进行记忆的功能</li><li>电路中包含反馈回路，通过反馈是电路功能与时序相关</li><li>电路的输出由电路当时的输入和状态共同决定</li></ul><h4 id="分类（按照电路的工作方式）"><a href="#分类（按照电路的工作方式）" class="headerlink" title="分类（按照电路的工作方式）"></a>分类（按照电路的工作方式）</h4><ul><li>同步时序逻辑电路<ul><li>电路中有统一的定时信号，存储器件采用时钟控制触发器，电路状态在时钟脉冲控制下同时发生转换</li></ul></li><li>异步时序逻辑电路<ul><li>电路汇总没有统一的时钟信号同步，电路输入信号的变化将直接导致电路状态的变化</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241742394.png"></p><h2 id="组合逻辑电路的分析"><a href="#组合逻辑电路的分析" class="headerlink" title="组合逻辑电路的分析"></a>组合逻辑电路的分析</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>画&#x2F;看逻辑电路图找出电路的输入、输出</li><li>写出输出逻辑函数表达式<ul><li>根据电路逐级写出各门的输出表达式，直至写出整个电路的输出逻辑表达式</li></ul></li><li>表达式化简</li><li>画出真值表</li><li>分析逻辑功能</li><li>改进电路</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241815864.png"></p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241817244.png"></p><p>三个输入A B C<br>一个输出F<br>七个与非门</p><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241817680.png"></p><h4 id="逻辑功能"><a href="#逻辑功能" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p>ABC 的输入相同时，输出为0，输入不同时，输出为1.此电路逻辑功能为三变量非一致电路</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241818293.png"><br>一个非门<br>一个或门<br>四个与非门</p><h4 id="表达式-1"><a href="#表达式-1" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241818421.png"><br>A异或B或上A异或C</p><h4 id="真值表-1"><a href="#真值表-1" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819550.png"></p><h4 id="逻辑功能-1"><a href="#逻辑功能-1" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p>仍是三变量非一致电路</p><h4 id="改进电路"><a href="#改进电路" class="headerlink" title="改进电路"></a>改进电路</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819507.png"></p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>**<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819630.png"></p><h4 id="表达式-2"><a href="#表达式-2" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820248.png"></p><h4 id="真值表-2"><a href="#真值表-2" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820115.png"></p><h4 id="逻辑功能-2"><a href="#逻辑功能-2" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p><strong>半加器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820531.png"></p><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241821866.png"><br>或门和异或门</p><h4 id="表达式-3"><a href="#表达式-3" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822156.png"></p><h4 id="表达式变换"><a href="#表达式变换" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822649.png"></p><h4 id="真值表-3"><a href="#真值表-3" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822587.png"></p><h4 id="逻辑功能-3"><a href="#逻辑功能-3" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p><strong>二进制变补器</strong><br><strong>16变补器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822920.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本概念和基本R-S结构</title>
    <link href="/2022/07/24/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%ACR-S%E7%BB%93%E6%9E%84/"/>
    <url>/2022/07/24/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%ACR-S%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="触发器结构"><a href="#触发器结构" class="headerlink" title="触发器结构"></a>触发器结构</h2><ul><li>有两个互补的输出端Q和“非Q”</li><li>有两个稳定状态1和0<ul><li>1状态：Q&#x3D;1    非Q&#x3D;0</li><li>0状态：Q&#x3D;0   非Q&#x3D;1</li></ul></li><li>输入信号不发生变化时， 触发器状态稳定不变</li><li>在一定输入信号作用下，触发器可以从一个稳定状态转移到另一个稳定状态，输入信号撤销后，保持新的状态不变</li></ul><h2 id="触发器状态"><a href="#触发器状态" class="headerlink" title="触发器状态"></a>触发器状态</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261722903.png"></p><h2 id="触发器常用描述方法"><a href="#触发器常用描述方法" class="headerlink" title="触发器常用描述方法"></a>触发器常用描述方法</h2><ul><li>功能表</li><li>状态表</li><li>状态图</li><li>次态方程</li><li>激励表</li><li>卡诺图</li></ul><h3 id="功能表"><a href="#功能表" class="headerlink" title="功能表"></a>功能表</h3><p>反映了触发器在不同输入下对应的表格</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261725285.png"><br>不定，是说明不允许这种输入</p><h3 id="状态表"><a href="#状态表" class="headerlink" title="状态表"></a>状态表</h3><p>反映了触发器在输入作用下现态和次态之间的转移关系</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261726923.png"></p><h3 id="激励表"><a href="#激励表" class="headerlink" title="激励表"></a>激励表</h3><p>反映了触发器从现态Q转移到某种次态时，对输入信号的要求</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261727016.png"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><ul><li>反映触发器两种状态之间转移关系的有向图 </li><li>圆圈表示稳定状态</li><li>有向线段表示状态转移的方向<ul><li>起点：现态</li><li>终点：次态</li><li>触发条件</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261740349.png"><br>两个稳定状态：0和1</p><h3 id="卡诺图"><a href="#卡诺图" class="headerlink" title="卡诺图"></a>卡诺图</h3><p>根据触发器的功能表或状态表所得到的反映触发器次态和现态以及输入关系的卡诺图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261741176.png"></p><h3 id="次态方程"><a href="#次态方程" class="headerlink" title="次态方程"></a>次态方程</h3><p>反映触发器次态和现态以及输入关系的表达式（常与约束方程一起使用）</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261742329.png"></p><h2 id="基本R-S触发器"><a href="#基本R-S触发器" class="headerlink" title="基本R-S触发器"></a>基本R-S触发器</h2><h3 id="与非门构成的基本R-S触发器"><a href="#与非门构成的基本R-S触发器" class="headerlink" title="与非门构成的基本R-S触发器"></a>与非门构成的基本R-S触发器</h3><p>两个与非门和两根反馈线耦合而成</p><ul><li>直接复位置位触发器</li><li>构成各种功能触发器的基本部件</li><li>R：置0端或者复位端</li><li>S：置1端或置位端</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270834974.png"></p><h4 id="RS-x3D-11"><a href="#RS-x3D-11" class="headerlink" title="RS&#x3D;11"></a>RS&#x3D;11</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270835009.png"></p><h4 id="RS-x3D-01"><a href="#RS-x3D-01" class="headerlink" title="RS&#x3D;01"></a>RS&#x3D;01</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270836978.png"></p><h4 id="RS-x3D-10"><a href="#RS-x3D-10" class="headerlink" title="RS&#x3D;10"></a>RS&#x3D;10</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270837587.png"></p><h4 id="RS-x3D-00"><a href="#RS-x3D-00" class="headerlink" title="RS&#x3D;00"></a>RS&#x3D;00</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270837625.png"></p><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280832129.png"></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><h5 id="功能表-状态表"><a href="#功能表-状态表" class="headerlink" title="功能表+状态表"></a>功能表+状态表</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853274.png"><br>d表示不确定</p><h5 id="激励表-1"><a href="#激励表-1" class="headerlink" title="激励表"></a>激励表</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853981.png"></p><h5 id="次态方程（重要点）"><a href="#次态方程（重要点）" class="headerlink" title="次态方程（重要点）"></a>次态方程（重要点）</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853185.png"></p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>当与非门构成的基本R-S触发器的同一输入端连续出现多个负脉冲信号，仅第一个使触发器状态发生改变</li><li>可以用来消除毛刺</li></ul><h3 id="或非门构成的基本R-S触发器"><a href="#或非门构成的基本R-S触发器" class="headerlink" title="或非门构成的基本R-S触发器"></a>或非门构成的基本R-S触发器</h3><p>两个或非门与两根反馈线耦合而成</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270858725.png"></p><h4 id="RS-x3D-00-1"><a href="#RS-x3D-00-1" class="headerlink" title="RS&#x3D;00"></a>RS&#x3D;00</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270858912.png"></p><h4 id="RS-x3D-01-1"><a href="#RS-x3D-01-1" class="headerlink" title="RS&#x3D;01"></a>RS&#x3D;01</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859900.png"></p><h4 id="RS-x3D-10-1"><a href="#RS-x3D-10-1" class="headerlink" title="RS&#x3D;10"></a>RS&#x3D;10</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859879.png"></p><h4 id="RS-x3D-11-1"><a href="#RS-x3D-11-1" class="headerlink" title="RS&#x3D;11"></a>RS&#x3D;11</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859918.png"></p><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280857367.png"></p><h4 id="描述（重点注意次态方程和约束方程）"><a href="#描述（重点注意次态方程和约束方程）" class="headerlink" title="描述（重点注意次态方程和约束方程）"></a>描述（重点注意次态方程和约束方程）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900970.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900245.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900132.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280903090.png"></p><ul><li><p>与非门构成的，输入端加圈，只有R、S等于0时，才可以改变状态，因此称对低电平有效</p></li><li><p>而或非门构成的，输入端没有加圈只有R、S等于1时，才可以改变状态，因此称对高电平有效</p></li><li><p>优点（两种共有的优点）</p><ul><li>结构简单</li><li>可作为记忆元件独立使用</li><li>被作为各种性能完善的触发器的基本组成部分<ul><li>具有直接复位、置位的功能</li></ul></li></ul></li><li><p>缺点</p><ul><li>R、S之间具有约束关系</li><li>不能进行定时控制</li><li>使用受到一定限制</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径问题</title>
    <link href="/2022/07/24/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/24/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径问题的抽象"><a href="#最短路径问题的抽象" class="headerlink" title="最短路径问题的抽象"></a>最短路径问题的抽象</h1><ul><li><p>在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径</p><ul><li>这条路径就是两点之间的最短路径</li><li>第一个顶点为源点</li><li>最后一个顶点为终点</li></ul></li><li><p>问题分类</p><ul><li>单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径<ul><li>（有向）无权图</li><li>（有向）有权图</li></ul></li><li>多源最短路径问题：求任意两顶点间的最短路径</li></ul></li></ul><h1 id="实现的算法"><a href="#实现的算法" class="headerlink" title="实现的算法"></a>实现的算法</h1><h2 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h2><ul><li>无权图的单源最短路算法<ul><li>按照递增（非递减）的顺序找到各个顶点的最短路</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241414319.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241414328.png"></li></ul></li></ul><h2 id="有权图的单源最短路算法"><a href="#有权图的单源最短路算法" class="headerlink" title="有权图的单源最短路算法"></a>有权图的单源最短路算法</h2><ul><li>有权图的单源最短路算法<ul><li>按照递增的顺序找出到各个顶点的最短路</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241415387.png"></li><li>Dijkstra算法<ul><li>令S&#x3D;{源点s + 已经确定了最短路径的顶点Vi}</li><li>对任意未收录的顶点v，定义dist[v]为s到b的最短路径长度，但该路径仅经过S中的顶点。</li><li>若路径是按照递增（非递减）的顺序生成的，则<ul><li>真正的最短路必须只经过s中的顶点</li><li>每次从未收录的顶点中选一个dist最小的收录（贪心）</li><li>增加一个v进入s，可能影响另外一个w的dist值<ul><li>dist[w] &#x3D; min{ dist[w],dist[v] +&lt;v,w&gt;的权重) }</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241421373.png"></p><ul><li>有权图的单源最短路径算法<ul><li><p>方法一：直接扫描所有为收录顶点</p><ul><li>对于稠密图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425725.png"></li></ul></li><li><p>方法二：将dist存在最小堆中</p><ul><li>对于稀疏图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425297.png"></li></ul></li></ul></li></ul><h2 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h2><ul><li><p>多源最短路算法</p><ul><li><p>方法一：直接将单源最短路算法调用|V|遍</p><ul><li>对于稀疏图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425954.png"></li></ul></li><li><p>方法二：Floyd算法</p><ul><li>对于稠密图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425387.png"></li></ul></li></ul></li><li><p>Floyd算法</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241427841.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241428522.png"></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="邻接表存储-无权图的单源最短路算法"><a href="#邻接表存储-无权图的单源最短路算法" class="headerlink" title="邻接表存储 - 无权图的单源最短路算法"></a>邻接表存储 - 无权图的单源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接表存储 - 无权图的单源最短路算法 */</span> <br><br><span class="hljs-comment">/* dist[]和path[]全部初始化为-1 */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Unweighted</span> <span class="hljs-params">( LGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> path[], Vertex S )</span> <br>&#123;     <br>Queue Q;     <br>Vertex V;     <br>PtrToAdjVNode W;          <br>Q = CreateQueue( Graph-&gt;Nv ); <span class="hljs-comment">/* 创建空队列, MaxSize为外部定义的常数 */</span>     <br>dist[S] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始化源点 */</span>     <br>AddQ (Q, S);     <br><br><span class="hljs-keyword">while</span>( !IsEmpty(Q) )&#123;         <br>V = DeleteQ(Q);         <br><span class="hljs-keyword">for</span> ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="hljs-comment">/* 对V的每个邻接点W-&gt;AdjV */</span>             <span class="hljs-keyword">if</span> ( dist[W-&gt;AdjV]==<span class="hljs-number">-1</span> ) &#123; <span class="hljs-comment">/* 若W-&gt;AdjV未被访问过 */</span>                 <br>        dist[W-&gt;AdjV] = dist[V]+<span class="hljs-number">1</span>; <span class="hljs-comment">/* W-&gt;AdjV到S的距离更新 */</span>     path[W-&gt;AdjV] = V; <span class="hljs-comment">/* 将V记录在S到W-&gt;AdjV的路径上 */</span>       AddQ(Q, W-&gt;AdjV);             <br>&#125;     <br>&#125; <span class="hljs-comment">/* while结束*/</span><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵存储-有权图的单源最短路算法"><a href="#邻接矩阵存储-有权图的单源最短路算法" class="headerlink" title="邻接矩阵存储 - 有权图的单源最短路算法"></a>邻接矩阵存储 - 有权图的单源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储 - 有权图的单源最短路算法 */</span> <br><br>Vertex <span class="hljs-title function_">FindMinDist</span><span class="hljs-params">( MGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> collected[] )</span> <br>&#123; <span class="hljs-comment">/* 返回未被收录顶点中dist最小者 */</span>     <br>Vertex MinV, V;     <br><span class="hljs-type">int</span> MinDist = INFINITY;     <br><br><span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++) &#123;         <span class="hljs-keyword">if</span> ( collected[V]==<span class="hljs-literal">false</span> &amp;&amp; dist[V]&lt;MinDist) &#123;             <span class="hljs-comment">/* 若V未被收录，且dist[V]更小 */</span>             MinDist = dist[V]; <span class="hljs-comment">/* 更新最小距离 */</span>             MinV = V; <span class="hljs-comment">/* 更新对应顶点 */</span>         <br>    &#125;     <br>&#125;     <br><span class="hljs-keyword">if</span> (MinDist &lt; INFINITY) <span class="hljs-comment">/* 若找到最小dist */</span>         <span class="hljs-keyword">return</span> MinV; <span class="hljs-comment">/* 返回对应的顶点下标 */</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">/* 若这样的顶点不存在，返回错误标记 */</span> &#125; <br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Dijkstra</span><span class="hljs-params">( MGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> path[], Vertex S )</span> <br>&#123;     <br>    <span class="hljs-type">int</span> collected[MaxVertexNum];     <br>    Vertex V, W;     <br>    <span class="hljs-comment">/* 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示 */</span>     <span class="hljs-keyword">for</span> ( V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++ ) &#123;         dist[V] = Graph-&gt;G[S][V];         <br>        <span class="hljs-keyword">if</span> ( dist[V]&lt;INFINITY )             <br>        path[V] = S;         <br>        <span class="hljs-keyword">else</span>             <br>        path[V] = <span class="hljs-number">-1</span>;         <br>    collected[V] = <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-comment">/* 先将起点收入集合 */</span>     <br>dist[S] = <span class="hljs-number">0</span>;     <br>collected[S] = <span class="hljs-literal">true</span>;     <br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;         <br><span class="hljs-comment">/* V = 未被收录顶点中dist最小者 */</span>         V = FindMinDist( Graph, dist, collected );         <span class="hljs-keyword">if</span> ( V==ERROR ) <span class="hljs-comment">/* 若这样的V不存在 */</span>             <span class="hljs-keyword">break</span>;      <span class="hljs-comment">/* 算法结束 */</span>         collected[V] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">/* 收录V */</span>         <span class="hljs-keyword">for</span>( W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="hljs-comment">/* 对图中的每个顶点W */</span>             <br><span class="hljs-comment">/* 若W是V的邻接点并且未被收录 */</span>             <span class="hljs-keyword">if</span> ( collected[W]==<span class="hljs-literal">false</span> &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;                 <br><span class="hljs-keyword">if</span> ( Graph-&gt;G[V][W]&lt;<span class="hljs-number">0</span> ) <span class="hljs-comment">/* 若有负边 */</span>                     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 不能正确解决，返回错误标记 */</span>                 <br><span class="hljs-comment">/* 若收录V使得dist[W]变小 */</span>                 <br><span class="hljs-keyword">if</span> ( dist[V]+Graph-&gt;G[V][W] &lt; dist[W] ) &#123;                     dist[W] = dist[V]+Graph-&gt;G[V][W]; <span class="hljs-comment">/* 更新dist[W] */</span>                     path[W] = V; <span class="hljs-comment">/* 更新S到W的路径 */</span>                 &#125;             &#125;     <br>&#125; <span class="hljs-comment">/* while结束*/</span>    <br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br> <span class="hljs-comment">/* 算法执行完毕，返回正确标记 */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵存储-多源最短路算法"><a href="#邻接矩阵存储-多源最短路算法" class="headerlink" title="邻接矩阵存储 - 多源最短路算法"></a>邻接矩阵存储 - 多源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储 - 多源最短路算法 */</span> <br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Floyd</span><span class="hljs-params">( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )</span> <br>&#123;     <br>Vertex i, j, k;     <span class="hljs-comment">/* 初始化 */</span>     <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Nv; i++ )         <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;Graph-&gt;Nv; j++ ) &#123;            <br> D[i][j] = Graph-&gt;G[i][j];             path[i][j] = <span class="hljs-number">-1</span>;         <br> &#125;     <br><span class="hljs-keyword">for</span>( k=<span class="hljs-number">0</span>; k&lt;Graph-&gt;Nv; k++ )         <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Nv; i++ )             <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;Graph-&gt;Nv; j++ )                 <span class="hljs-keyword">if</span>( D[i][k] + D[k][j] &lt; D[i][j] ) &#123;                     D[i][j] = D[i][k] + D[k][j];                     <span class="hljs-keyword">if</span> ( i==j &amp;&amp; D[i][j]&lt;<span class="hljs-number">0</span> ) <span class="hljs-comment">/* 若发现负值圈 */</span>                         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 不能正确解决，返回错误标记 */</span>                     path[i][j] = k;                 &#125;     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br><span class="hljs-comment">/* 算法执行完毕，返回正确标记 */</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡二叉树</title>
    <link href="/2022/07/24/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/07/24/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是平衡二叉树"><a href="#什么是平衡二叉树" class="headerlink" title="什么是平衡二叉树"></a>什么是平衡二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241012577.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241015263.png"><br><strong>判断关键，任一结点左右子树高度差的绝对值是否超过1</strong></p><h2 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h2><h3 id="RR旋转（右单旋）"><a href="#RR旋转（右单旋）" class="headerlink" title="RR旋转（右单旋）"></a>RR旋转（右单旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241018029.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241018405.png"></p><h3 id="LL旋转（左单旋）"><a href="#LL旋转（左单旋）" class="headerlink" title="LL旋转（左单旋）"></a>LL旋转（左单旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241020782.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241021910.png"></p><h3 id="LR旋转（左-右双旋）"><a href="#LR旋转（左-右双旋）" class="headerlink" title="LR旋转（左-右双旋）"></a>LR旋转（左-右双旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241022482.png"><br>中间图的OR表示两种情况：<br>一种情况是C为发现者<br>另一种是$C_L$为发现者<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241025084.png"></p><h3 id="RL旋转（右-左双旋）"><a href="#RL旋转（右-左双旋）" class="headerlink" title="RL旋转（右-左双旋）"></a>RL旋转（右-左双旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241026477.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241026015.png"></p><p>注意：<br><strong>有时插入元素不需要调整结构，但一些平衡因子需要重新计算</strong></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="AVL树的旋转与插入"><a href="#AVL树的旋转与插入" class="headerlink" title="AVL树的旋转与插入"></a>AVL树的旋转与插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span> *<span class="hljs-title">Position</span>;</span> <br><span class="hljs-keyword">typedef</span> Position AVLTree; <span class="hljs-comment">/* AVL树类型 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span>&#123;</span>     <br>ElementType Data; <span class="hljs-comment">/* 结点数据 */</span>     <br>AVLTree Left;     <span class="hljs-comment">/* 指向左子树 */</span>     <br>AVLTree Right;    <span class="hljs-comment">/* 指向右子树 */</span>     <br><span class="hljs-type">int</span> Height;       <span class="hljs-comment">/* 树高 */</span> <br>&#125;; <br><span class="hljs-type">int</span> <span class="hljs-title function_">Max</span> <span class="hljs-params">( <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b )</span> <br>&#123;     <br><span class="hljs-keyword">return</span> a &gt; b ? a : b; <br>&#125;<br>AVLTree <span class="hljs-title function_">SingleLeftRotation</span> <span class="hljs-params">( AVLTree A )</span> <br>&#123; <span class="hljs-comment">/* 注意：A必须有一个左子结点B */</span>   <br>  <span class="hljs-comment">/* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */</span>          AVLTree B = A-&gt;Left;     <br>    A-&gt;Left = B-&gt;Right;     <br>    B-&gt;Right = A;     <br>    A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + <span class="hljs-number">1</span>;     B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + <span class="hljs-number">1</span>;       <span class="hljs-keyword">return</span> B; <br>&#125;<br><br>AVLTree <span class="hljs-title function_">DoubleLeftRightRotation</span> <span class="hljs-params">( AVLTree A )</span> <br>&#123; <span class="hljs-comment">/* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */</span>   <br>  <span class="hljs-comment">/* 将A、B与C做两次单旋，返回新的根结点C */</span>          <br>  <br>  <span class="hljs-comment">/* 将B与C做右单旋，C被返回 */</span>     <br>  A-&gt;Left = SingleRightRotation(A-&gt;Left);     <br>  <span class="hljs-comment">/* 将A与C做左单旋，C被返回 */</span>     <br>  <span class="hljs-keyword">return</span> SingleLeftRotation(A); <br>&#125; <br><br><br>AVLTree <span class="hljs-title function_">Insert</span><span class="hljs-params">( AVLTree T, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 将X插入AVL树T中，并且返回调整后的AVL树 */</span>     <br><span class="hljs-keyword">if</span> ( !T ) &#123; <span class="hljs-comment">/* 若插入空树，则新建包含一个结点的树 */</span>         T = (AVLTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AVLNode));         <br>T-&gt;Data = X;         <br>T-&gt;Height = <span class="hljs-number">0</span>;         <br>T-&gt;Left = T-&gt;Right = <span class="hljs-literal">NULL</span>;     <br>&#125; <span class="hljs-comment">/* if (插入空树) 结束 */</span>     <br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( X &lt; T-&gt;Data ) &#123;         <br><span class="hljs-comment">/* 插入T的左子树 */</span>         <br>T-&gt;Left = Insert( T-&gt;Left, X);         <br><span class="hljs-comment">/* 如果需要左旋 */</span>         <br><span class="hljs-keyword">if</span> ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == <span class="hljs-number">2</span> )             <span class="hljs-keyword">if</span> ( X &lt; T-&gt;Left-&gt;Data )                 T = SingleLeftRotation(T);      <span class="hljs-comment">/* 左单旋 */</span>             <span class="hljs-keyword">else</span>                 T = DoubleLeftRightRotation(T); <span class="hljs-comment">/* 左-右双旋 */</span>     &#125; <span class="hljs-comment">/* else if (插入左子树) 结束 */</span>          <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( X &gt; T-&gt;Data ) &#123;         <br><span class="hljs-comment">/* 插入T的右子树 */</span>         <br>T-&gt;Right = Insert( T-&gt;Right, X );        <br> <span class="hljs-comment">/* 如果需要右旋 */</span>         <br> <span class="hljs-keyword">if</span> ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == <span class="hljs-number">-2</span> )             <br> <span class="hljs-keyword">if</span> ( X &gt; T-&gt;Right-&gt;Data )                 <br> T = SingleRightRotation(T);     <span class="hljs-comment">/* 右单旋 */</span>             <br><span class="hljs-keyword">else</span>                 <br>T = DoubleRightLeftRotation(T); <span class="hljs-comment">/* 右-左双旋 */</span>     <br>&#125; <span class="hljs-comment">/* else if (插入右子树) 结束 */</span>     <br><span class="hljs-comment">/* else X == T-&gt;Data，无须插入 */</span>    <br> <span class="hljs-comment">/* 别忘了更新树高 */</span>     <br> T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + <span class="hljs-number">1</span>;          <br> <span class="hljs-keyword">return</span> T; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2022/07/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/07/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240942238.png"><br>左边小，右边大</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240944509.png"></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240943255.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240945111.png"><br>什么是尾递归？？？<br>就是在最后返回这一步用到了递归<br>而尾递归可用循坏代替，提高效率<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240947234.png"></p><h4 id="查找最大和最小元素"><a href="#查找最大和最小元素" class="headerlink" title="查找最大和最小元素"></a>查找最大和最小元素</h4><p>利用二叉树的性质<br>最大元素一定在树的最右分支的端结点上<br>最小元素一定在树的最左分支的端结点上<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240948853.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240950565.png"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>关键是要找到元素应该插入的位置</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951332.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951767.png"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951648.png"><br>以字母顺序来排<br>JAN为根节点<br>FEB，F在J前面所以放JAN左子树<br>MAR，M比J大放在JAN右子树<br>APR，比JAN小，往左走，比FEB小，继续往左走，就放到了FEB左子树<br>……</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>考虑三种情况</p><h4 id="要删除的是叶结点"><a href="#要删除的是叶结点" class="headerlink" title="要删除的是叶结点"></a>要删除的是叶结点</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240955228.png"><br>删除35，把33的指针置为NULL</p><h4 id="要删除的结点只有一个孩子结点"><a href="#要删除的结点只有一个孩子结点" class="headerlink" title="要删除的结点只有一个孩子结点"></a>要删除的结点只有一个孩子结点</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240956621.png"><br>把41的左子树指针指向35</p><h4 id="要删除的结点有左、右子树"><a href="#要删除的结点有左、右子树" class="headerlink" title="要删除的结点有左、右子树"></a>要删除的结点有左、右子树</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240957122.png"><br>1 把50放到原来41的位置<br>2 把35放到原来41的位置，34接到33上</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241001874.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Insert</span><span class="hljs-params">( BinTree BST, ElementType X )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( !BST )&#123; <span class="hljs-comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span>         BST = (BinTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TNode));         <br>BST-&gt;Data = X;         <br>BST-&gt;Left = BST-&gt;Right = <span class="hljs-literal">NULL</span>;     <br>&#125;    <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 开始找要插入元素的位置 */</span>         <br><span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data )             <br>BST-&gt;Left = Insert( BST-&gt;Left, X );   <span class="hljs-comment">/*递归插入左子树*/</span>         <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data )            <br>BST-&gt;Right = Insert( BST-&gt;Right, X ); <span class="hljs-comment">/*递归插入右子树*/</span>         <br><span class="hljs-comment">/* else X已经存在，什么都不做 */</span>     <br>&#125;     <br><span class="hljs-keyword">return</span> BST; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Delete</span><span class="hljs-params">( BinTree BST, ElementType X )</span>  <br>&#123;      <br>Position Tmp;      <br><span class="hljs-keyword">if</span>( !BST )          <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的元素未找到&quot;</span>);      <br><span class="hljs-keyword">else</span> &#123;         <br><span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data )              <br>BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class="hljs-comment">/* 从左子树递归删除 */</span>         <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data )              <br>BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class="hljs-comment">/* 从右子树递归删除 */</span>         <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* BST就是要删除的结点 */</span>             <br><span class="hljs-comment">/* 如果被删除结点有左右两个子结点 */</span>              <br><span class="hljs-keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;                 <br><span class="hljs-comment">/* 从右子树中找最小的元素填充删除结点 */</span>                 <br>Tmp = FindMin( BST-&gt;Right );                         BST-&gt;Data = Tmp-&gt;Data;                  <br>                        <span class="hljs-comment">/* 从右子树中删除最小元素 */</span>                  <br>                        BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );             <br>                    &#125;             <br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 被删除结点有一个或无子结点 */</span>                            Tmp = BST;                  <br>                           <span class="hljs-keyword">if</span>( !BST-&gt;Left )       <br>                           <span class="hljs-comment">/* 只有右孩子或无子结点 */</span>                               BST = BST-&gt;Right;                   <br>                           <span class="hljs-keyword">else</span>                   <br>                           <span class="hljs-comment">/* 只有左孩子 */</span>                      <br>                              BST = BST-&gt;Left;                 <span class="hljs-built_in">free</span>( Tmp );             <br>                    &#125;         <br>            &#125;     <br>        &#125;     <br>        <span class="hljs-keyword">return</span> BST; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2022/07/24/%E5%9B%BE/"/>
    <url>/2022/07/24/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h2><ul><li>表示“多对多”的关系</li><li>包含<ul><li>一组顶点，通常用V表示顶点集合</li><li>一组边，通常用E表示边的集合<ul><li><p>边是顶点对，（v,w）</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241304379.png"></p></li><li><p>有向边&lt;v,w&gt;表示从v指向w的边(单行线)</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241305424.png"></p></li><li><p>不考虑重边和自回路</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241305953.png"></p></li></ul></li></ul></li></ul><h2 id="抽象数据类型定义"><a href="#抽象数据类型定义" class="headerlink" title="抽象数据类型定义"></a>抽象数据类型定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241306801.png"></p><h2 id="怎么在程序中表示一个图"><a href="#怎么在程序中表示一个图" class="headerlink" title="怎么在程序中表示一个图"></a>怎么在程序中表示一个图</h2><h3 id="用邻接矩阵"><a href="#用邻接矩阵" class="headerlink" title="用邻接矩阵"></a>用邻接矩阵</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241306436.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241307505.png"></p><ul><li>邻接矩阵有什么好处？<ul><li>直观、简单、好理解</li><li>方便检查任意一对顶点间是否存在边</li><li>方便找任一顶点的度（出度、入度）<ul><li>无向图的度：对应行或列非0元素的个数</li><li>有向图的度：对应行非0元素的个数是出度，对应列非0元素的个数是入度</li></ul></li></ul></li><li>邻接矩阵有什么不好？<ul><li>浪费空间<ul><li>存稀疏图（点多边少）有大量无效元素</li><li>但对稠密图还是合算的</li></ul></li><li>浪费时间<ul><li>统计稀疏图中一共有多少边</li></ul></li></ul></li></ul><h3 id="用邻接表"><a href="#用邻接表" class="headerlink" title="用邻接表"></a>用邻接表</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241312979.png"><br><strong>一定要够稀疏才合算</strong></p><ul><li>邻接表<ul><li>方便找任一顶点的所有邻接点</li><li>节约稀疏图的空间<ul><li>需要N个头指针加2E个结点（每个结点至少两个域）</li></ul></li><li>方便计算任一顶点的度？<ul><li>对于无向图：是的</li><li>对于有向图：只能计算出度，需要构造逆邻接表（存储指向自己的边）来方便计算入度</li><li>不方便检查任意一对顶点间是否存在边</li></ul></li></ul></li></ul><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><ul><li>深度优先搜索</li><li>广度优先搜索</li></ul><p>图不连通怎么办？</p><ul><li>连通：如果从v到w存在一条无向路径，则称v和w连通</li><li>路径：从v到w的路径是一系列顶点的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中边数。如果v到w之间的所有顶点都不同，则称简单路径</li><li>回路：起点等于终点的路径</li><li>连通图：图中任意两顶点均相同</li><li>连通分量：无向图的极大连通子图<ul><li>极大顶点数：再加1个顶点就不连通了</li><li>极大边数：包含子图中所有顶点相连的所有边</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241400121.png"></li><li>强连通：有向图中顶点v和w之间存在双向路径，则称v和w是强连通的</li><li>强连通图：有向图中任意两顶点均强连通</li><li>强连通分量：有向图的极大强连通子图</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241402102.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241402099.png"></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="邻接矩阵表示"><a href="#邻接矩阵表示" class="headerlink" title="邻接矩阵表示"></a>邻接矩阵表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 图的邻接矩阵表示法 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100    <span class="hljs-comment">/* 最大顶点数设为100 */</span> #<span class="hljs-keyword">define</span> INFINITY 65535        <span class="hljs-comment">/* ∞设为双字节无符号整数的最大值65535*/</span> </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Vertex;         <span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> WeightType;        <span class="hljs-comment">/* 边的权值设为整型 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> DataType;        <span class="hljs-comment">/* 顶点存储的数据类型设为字符型 */</span> <br><span class="hljs-comment">/* 边的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span>     <br>Vertex V1, V2;      <span class="hljs-comment">/* 有向边&lt;V1, V2&gt; */</span>     <br>WeightType Weight;  <span class="hljs-comment">/* 权重 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToENode Edge;         <br><br><span class="hljs-comment">/* 图结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span>     <br><span class="hljs-type">int</span> Nv;  <span class="hljs-comment">/* 顶点数 */</span>     <br><span class="hljs-type">int</span> Ne;  <span class="hljs-comment">/* 边数   */</span>     <br>WeightType G[MaxVertexNum][MaxVertexNum]; <span class="hljs-comment">/* 邻接矩阵 */</span>     <br>DataType Data[MaxVertexNum];      <span class="hljs-comment">/* 存顶点的数据 */</span>     <br><span class="hljs-comment">/* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToGNode MGraph; <span class="hljs-comment">/* 以邻接矩阵存储的图类型 */</span> <br><br><br>MGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">( <span class="hljs-type">int</span> VertexNum )</span> <br>&#123; <span class="hljs-comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span>     Vertex V, W;     MGraph Graph;          Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode)); <span class="hljs-comment">/* 建立图 */</span>      <br>      Graph-&gt;Nv = VertexNum;     <br>      Graph-&gt;Ne = <span class="hljs-number">0</span>;     <br>      <span class="hljs-comment">/* 初始化邻接矩阵 */</span>     <br>      <span class="hljs-comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span>      <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)          <br>          <span class="hljs-keyword">for</span> (W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++)               Graph-&gt;G[V][W] = INFINITY;                  <span class="hljs-keyword">return</span> Graph;  <br>&#125;         <br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">( MGraph Graph, Edge E )</span> <br>&#123;      <br>    <span class="hljs-comment">/* 插入边 &lt;V1, V2&gt; */</span>      <br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;          <br>    <span class="hljs-comment">/* 若是无向图，还要插入边&lt;V2, V1&gt; */</span>      <br>    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight; <br>&#125; <br><br>MGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span> <br>&#123;     <br>    MGraph Graph;     <br>    Edge E;     <br>    Vertex V;     <br>    <span class="hljs-type">int</span> Nv, i;          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Nv);   <span class="hljs-comment">/* 读入顶点个数 */</span>     Graph = CreateGraph(Nv); <span class="hljs-comment">/* 初始化有Nv个顶点但没有边的图 */</span>           <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));   <span class="hljs-comment">/* 读入边数 */</span>     <span class="hljs-keyword">if</span> ( Graph-&gt;Ne != <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">/* 如果有边 */</span>          E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode)); <span class="hljs-comment">/* 建立边结点 */</span>          <br>    <span class="hljs-comment">/* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span>         <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++) &#123;             <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);              <br>    <span class="hljs-comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span>             InsertEdge( Graph, E );         <br>    &#125;     <br>&#125;      <br><span class="hljs-comment">/* 如果顶点有数据的话，读入数据 */</span>     <br><span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)         <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;(Graph-&gt;Data[V]));     <br><span class="hljs-keyword">return</span> Graph; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="邻接表表示"><a href="#邻接表表示" class="headerlink" title="邻接表表示"></a>邻接表表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 图的邻接表表示法 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100    <span class="hljs-comment">/* 最大顶点数设为100 */</span> typedef int Vertex;         <span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span> typedef int WeightType;        <span class="hljs-comment">/* 边的权值设为整型 */</span> typedef char DataType;        <span class="hljs-comment">/* 顶点存储的数据类型设为字符型 */</span> </span><br><span class="hljs-comment">/* 边的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span>     <br>    Vertex V1, V2;      <span class="hljs-comment">/* 有向边&lt;V1, V2&gt; */</span>     WeightType Weight;  <span class="hljs-comment">/* 权重 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToENode Edge; <br><br><span class="hljs-comment">/* 邻接点的定义 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span> *<span class="hljs-title">PtrToAdjVNode</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span>&#123;</span>     <br>    Vertex AdjV;        <span class="hljs-comment">/* 邻接点下标 */</span>     WeightType Weight;  <span class="hljs-comment">/* 边权重 */</span>     PtrToAdjVNode Next;    <span class="hljs-comment">/* 指向下一个邻接点的指针 */</span> <br>&#125;; <br><br><span class="hljs-comment">/* 顶点表头结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vnode</span>&#123;</span>     <br>    PtrToAdjVNode FirstEdge;<span class="hljs-comment">/* 边表头指针 */</span>     DataType Data;            <span class="hljs-comment">/* 存顶点的数据 */</span>     <br>    <span class="hljs-comment">/* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */</span> &#125; AdjList[MaxVertexNum];    <span class="hljs-comment">/* AdjList是邻接表类型 */</span> <br>    <br>    <br><span class="hljs-comment">/* 图结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span>       <br>    <span class="hljs-type">int</span> Nv;     <span class="hljs-comment">/* 顶点数 */</span>     <br>    <span class="hljs-type">int</span> Ne;     <span class="hljs-comment">/* 边数   */</span>     <br>    AdjList G;  <span class="hljs-comment">/* 邻接表 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToGNode LGraph; <span class="hljs-comment">/* 以邻接表方式存储的图类型 */</span> <br><br><br>LGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">( <span class="hljs-type">int</span> VertexNum )</span> <br>&#123; <span class="hljs-comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span>     <br>    Vertex V;     <br>    LGraph Graph;          Graph = (LGraph)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode) ); <span class="hljs-comment">/* 建立图 */</span>     <br>    <br>    Graph-&gt;Nv = VertexNum;     <br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;     <br>    <span class="hljs-comment">/* 初始化邻接表头指针 */</span>     <br>    <span class="hljs-comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span>        <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)         <br>        Graph-&gt;G[V].FirstEdge = <span class="hljs-literal">NULL</span>;                  <span class="hljs-keyword">return</span> Graph;  <br>&#125;         <br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">( LGraph Graph, Edge E )</span> &#123;     PtrToAdjVNode NewNode;                          <br>      <span class="hljs-comment">/* 插入边 &lt;V1, V2&gt; */</span>     <br>      <span class="hljs-comment">/* 为V2建立新的邻接点 */</span>     NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));     <br>      NewNode-&gt;AdjV = E-&gt;V2;     <br>      NewNode-&gt;Weight = E-&gt;Weight;     <br>      <span class="hljs-comment">/* 将V2插入V1的表头 */</span>     <br>      NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;      <br>      Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;               <br>      <span class="hljs-comment">/* 若是无向图，还要插入边 &lt;V2, V1&gt; */</span>     <br>      <span class="hljs-comment">/* 为V1建立新的邻接点 */</span>     NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));     <br>      NewNode-&gt;AdjV = E-&gt;V1;     <br>      NewNode-&gt;Weight = E-&gt;Weight;     <br>      <span class="hljs-comment">/* 将V1插入V2的表头 */</span>     <br>      NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;     Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode; <br>&#125; <br>LGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span> <br>&#123;     <br>    LGraph Graph;     <br>    Edge E;     <br>    Vertex V;     <br>    <span class="hljs-type">int</span> Nv, i;          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Nv);   <span class="hljs-comment">/* 读入顶点个数 */</span>     Graph = CreateGraph(Nv); <span class="hljs-comment">/* 初始化有Nv个顶点但没有边的图 */</span>           <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));   <span class="hljs-comment">/* 读入边数 */</span>     <span class="hljs-keyword">if</span> ( Graph-&gt;Ne != <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">/* 如果有边 */</span>          E = (Edge)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode) ); <span class="hljs-comment">/* 建立边结点 */</span>          <br>        <span class="hljs-comment">/* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span>         <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++) &#123;             <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);              <span class="hljs-comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span>             <br>        InsertEdge( Graph, E );         <br>        &#125;     <br>    &#125;      <span class="hljs-comment">/* 如果顶点有数据的话，读入数据 */</span>     <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;(Graph-&gt;G[V].Data));     <span class="hljs-keyword">return</span> Graph; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS-邻接表存储"><a href="#DFS-邻接表存储" class="headerlink" title="DFS-邻接表存储"></a>DFS-邻接表存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接表存储的图 - DFS */</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">Visit</span><span class="hljs-params">( Vertex V )</span> <br>&#123;     <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正在访问顶点%d\n&quot;</span>, V); &#125; <br>    <span class="hljs-comment">/* Visited[]为全局变量，已经初始化为false */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">( LGraph Graph, Vertex V, <span class="hljs-type">void</span> (*Visit)(Vertex) )</span> <br>&#123;   <span class="hljs-comment">/* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */</span>     PtrToAdjVNode W;          <br>    Visit( V ); <span class="hljs-comment">/* 访问第V个顶点 */</span>     Visited[V] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记V已访问 */</span>     <br>    <span class="hljs-keyword">for</span>( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="hljs-comment">/* 对V的每个邻接点W-&gt;AdjV */</span>         <br>        <span class="hljs-keyword">if</span> ( !Visited[W-&gt;AdjV] )    <span class="hljs-comment">/* 若W-&gt;AdjV未被访问 */</span>             DFS( Graph, W-&gt;AdjV, Visit );    <span class="hljs-comment">/* 则递归访问之 */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS-邻接矩阵存储"><a href="#BFS-邻接矩阵存储" class="headerlink" title="BFS-邻接矩阵存储"></a>BFS-邻接矩阵存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储的图 - BFS */</span> <br><br><span class="hljs-comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span> <br><span class="hljs-comment">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span> <br><span class="hljs-comment">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">IsEdge</span><span class="hljs-params">( MGraph Graph, Vertex V, Vertex W )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> Graph-&gt;G[V][W]&lt;INFINITY ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <br>&#125; <br><br><span class="hljs-comment">/* Visited[]为全局变量，已经初始化为false */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span> <span class="hljs-params">( MGraph Graph, Vertex S, <span class="hljs-type">void</span> (*Visit)(Vertex) )</span> <br>&#123;   <span class="hljs-comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span>     Queue Q;          <br>    Vertex V, W;     <br>    Q = CreateQueue( MaxSize ); <span class="hljs-comment">/* 创建空队列, MaxSize为外部定义的常数 */</span>     <br>    <span class="hljs-comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span>     Visit( S );     <br>    Visited[S] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记S已访问 */</span>     AddQ(Q, S); <span class="hljs-comment">/* S入队列 */</span>          <span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;         V = DeleteQ(Q);  <span class="hljs-comment">/* 弹出V */</span>         <span class="hljs-keyword">for</span>( W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="hljs-comment">/* 对图中的每个顶点W */</span>             <br>            <span class="hljs-comment">/* 若W是V的邻接点并且未访问过 */</span>             <span class="hljs-keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;                 <span class="hljs-comment">/* 访问顶点W */</span>                 Visit( W );                 Visited[W] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记W已访问 */</span>                 AddQ(Q, W); <span class="hljs-comment">/* W入队列 */</span>             &#125;     &#125; <span class="hljs-comment">/* while结束*/</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合及运算</title>
    <link href="/2022/07/24/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
    <url>/2022/07/24/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h1><ul><li>集合运算：交、并、补、差，判定一个元素是否属于某一集合</li><li>并查集：集合并、查某元素属于什么集合</li><li>并查集问题中集合存储如何实现？<ul><li>用树结构表示集合，树的每个结点代表一个集合元素</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241251680.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241252797.png"></p><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="查找某元素所在集合（用根节点表示）"><a href="#查找某元素所在集合（用根节点表示）" class="headerlink" title="查找某元素所在集合（用根节点表示）"></a>查找某元素所在集合（用根节点表示）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241253516.png"></p><h3 id="集合的并运算"><a href="#集合的并运算" class="headerlink" title="集合的并运算"></a>集合的并运算</h3><ul><li>分别找到X1和X2两个元素所在集合树的根结点</li><li>如果它们不同根，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241254732.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241255267.png"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1000                  <span class="hljs-comment">/* 集合最大元素个数 */</span> typedef int ElementType;           <span class="hljs-comment">/* 默认元素可以用非负整数表示 */</span> typedef int SetName;               <span class="hljs-comment">/* 默认用根结点的下标作为集合名称 */</span> </span><br><span class="hljs-keyword">typedef</span> ElementType SetType[MAXN]; <span class="hljs-comment">/* 假设集合元素下标从0开始 */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType S, SetName Root1, SetName Root2 )</span> <br>&#123; <span class="hljs-comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span>     <br>    <span class="hljs-comment">/* 保证小集合并入大集合 */</span>     <br>    <span class="hljs-keyword">if</span> ( S[Root2] &lt; S[Root1] ) &#123; <br>    <span class="hljs-comment">/* 如果集合2比较大 */</span>         <br>    S[Root2] += S[Root1];     <br>    <span class="hljs-comment">/* 集合1并入集合2  */</span>         <br>    S[Root1] = Root2;     <br>    &#125;     <br>    <span class="hljs-keyword">else</span> &#123;                         <br>    <span class="hljs-comment">/* 如果集合1比较大 */</span>         <br>    S[Root1] += S[Root2];     <br>    <span class="hljs-comment">/* 集合2并入集合1  */</span>         <br>    S[Root2] = Root1;     &#125; &#125; SetName <span class="hljs-title function_">Find</span><span class="hljs-params">( SetType S, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 默认集合元素全部初始化为-1 */</span>     <br>    <span class="hljs-keyword">if</span> ( S[X] &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">/* 找到集合的根 */</span>         <br>    <span class="hljs-keyword">return</span> X;     <br>    <span class="hljs-keyword">else</span>         <br>    <span class="hljs-keyword">return</span> S[X] = Find( S, S[X] ); <span class="hljs-comment">/* 路径压缩 */</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <link href="/2022/07/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <url>/2022/07/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241227734.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241229585.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241229037.png"></p><p><strong>问题来了：如何根据结点不同的查找频率构造更有效的搜索树？</strong></p><h2 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231882.png"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231185.png"></p><h2 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231082.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241233586.png"></p><h2 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241233573.png"></p><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><p>给定一段字符串，如何对字符串进行编码，可以使得该字符串的编码存储空间最少？</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241235132.png"></p><p>怎么进行不等长编码？</p><p>如何避免二义性？<br>用前缀码<br>前缀码：任何字符的编码都不是另一字符编码的前缀<br>这样就可以无二义地解码</p><h2 id="二叉树用于编码"><a href="#二叉树用于编码" class="headerlink" title="二叉树用于编码"></a>二叉树用于编码</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241238663.png"></p><p><strong>怎样构造一棵编码代价最小的二叉树？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241240737.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2022/07/24/%E5%A0%86/"/>
    <url>/2022/07/24/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241122025.png"><br>如何组织优先队列？<br>用一般的数组、链表？<br>有序的数组或者链表？<br>二叉搜索树？AVL树？</p><h3 id="采用数组或链表？"><a href="#采用数组或链表？" class="headerlink" title="采用数组或链表？"></a>采用数组或链表？</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241123470.png"></p><h3 id="采用二叉树？"><a href="#采用二叉树？" class="headerlink" title="采用二叉树？"></a>采用二叉树？</h3><ul><li>采用二叉搜索树？<ul><li>需要树的高度适合，而二叉搜索树，经过删除操作容易歪掉</li></ul></li><li>更应该关注插入还是删除？  <ul><li>更应该关注删除，因为删除操作更难实现</li></ul></li><li>树结点顺序怎么安排？<ul><li>最值放在树根</li></ul></li><li>树结构怎么样？     <ul><li>用完全二叉树，会更加平衡一点</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241125555.png"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241126397.png"><br>判断是不是堆<br>条件一：看它是不是完全二叉树<br>条件二：任一子树的根是不是该子树的最大值或者最小值<br>图中左边两个都不是完全二叉树<br>而右边两个虽然是完全二叉树，但不满足第二个条件</p><h2 id="堆的抽象数据类型描述"><a href="#堆的抽象数据类型描述" class="headerlink" title="堆的抽象数据类型描述"></a>堆的抽象数据类型描述</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241127568.png"></p><h3 id="最大堆的操作"><a href="#最大堆的操作" class="headerlink" title="最大堆的操作"></a>最大堆的操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241219352.png"><br>把MaxData换成小于堆中所有元素的MiniData，同样适合于创建最小堆</p><ul><li>将已存在的N个元素按最大堆的要求存放在一个一维数组中<ul><li>方法一：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为o（N logN）</li><li>方法二：在线性时间复杂度下建立最大堆<ul><li>将N个元素按输入顺序存入，先满足完全二叉树的结构特性</li><li>调整各结点位置，以满足最大堆的有序特性</li></ul></li></ul></li></ul><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221880.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221708.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221259.png"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241222284.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241222831.png"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> *<span class="hljs-title">Heap</span>;</span> <span class="hljs-comment">/* 堆的类型定义 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> &#123;</span>     <br>ElementType *Data; <span class="hljs-comment">/* 存储元素的数组 */</span>     <span class="hljs-type">int</span> Size;          <span class="hljs-comment">/* 堆中当前元素个数 */</span>     <span class="hljs-type">int</span> Capacity;      <span class="hljs-comment">/* 堆的最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> Heap MaxHeap; <span class="hljs-comment">/* 最大堆 */</span> <br><span class="hljs-keyword">typedef</span> Heap MinHeap; <span class="hljs-comment">/* 最小堆 */</span> <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXDATA 1000  <span class="hljs-comment">/* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span> </span><br>MaxHeap <span class="hljs-title function_">CreateHeap</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> <br>&#123; <span class="hljs-comment">/* 创建容量为MaxSize的空的最大堆 */</span><br><br>MaxHeap H = (MaxHeap)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> HNode));     <br>H-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>((MaxSize+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(ElementType));     H-&gt;Size = <span class="hljs-number">0</span>;     <br>    H-&gt;Capacity = MaxSize;     <br>    H-&gt;Data[<span class="hljs-number">0</span>] = MAXDATA; <span class="hljs-comment">/* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/</span>     <span class="hljs-keyword">return</span> H; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> (H-&gt;Size == H-&gt;Capacity); <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( MaxHeap H, ElementType X )</span> <br>&#123;   <span class="hljs-comment">/* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span>     <br><span class="hljs-type">int</span> i;       <br><span class="hljs-keyword">if</span> ( IsFull(H) ) &#123;          <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br>i = ++H-&gt;Size; <span class="hljs-comment">/* i指向插入后堆中的最后一个元素的位置 */</span>     <span class="hljs-keyword">for</span> ( ; H-&gt;Data[i/<span class="hljs-number">2</span>] &lt; X; i/=<span class="hljs-number">2</span> )         <br>H-&gt;Data[i] = H-&gt;Data[i/<span class="hljs-number">2</span>]; <span class="hljs-comment">/* 上滤X */</span>     <br>H-&gt;Data[i] = X; <span class="hljs-comment">/* 将X插入 */</span>     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1 <span class="hljs-comment">/* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span> </span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> (H-&gt;Size == <span class="hljs-number">0</span>); <br>&#125; <br>ElementType <span class="hljs-title function_">DeleteMax</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123; <span class="hljs-comment">/* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span>     <span class="hljs-type">int</span> Parent, Child;     <br>    ElementType MaxItem, X;     <br>    <span class="hljs-keyword">if</span> ( IsEmpty(H) ) &#123;         <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已为空&quot;</span>);         <br>    <span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br>MaxItem = H-&gt;Data[<span class="hljs-number">1</span>]; <span class="hljs-comment">/* 取出根结点存放的最大值 */</span>     <br><span class="hljs-comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span>     <br>X = H-&gt;Data[H-&gt;Size--]; <span class="hljs-comment">/* 注意当前堆的规模要减小 */</span>     <span class="hljs-keyword">for</span>( Parent=<span class="hljs-number">1</span>; Parent*<span class="hljs-number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;         Child = Parent * <span class="hljs-number">2</span>;         <br>    <span class="hljs-keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="hljs-number">1</span>]) )             Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span>         <span class="hljs-keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>         <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>             <br>        H-&gt;Data[Parent] = H-&gt;Data[Child];     &#125;     <br>        H-&gt;Data[Parent] = X;     <span class="hljs-keyword">return</span> MaxItem; &#125;  <br>        <span class="hljs-comment">/*----------- 建造最大堆 -----------*/</span> <span class="hljs-type">void</span> <span class="hljs-title function_">PercDown</span><span class="hljs-params">( MaxHeap H, <span class="hljs-type">int</span> p )</span> <br>&#123; <br>    <span class="hljs-comment">/* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span>     <span class="hljs-type">int</span> Parent, Child;     <br>    ElementType X;     <br>    X = H-&gt;Data[p]; <span class="hljs-comment">/* 取出根结点存放的值 */</span>     <br>    <span class="hljs-keyword">for</span>( Parent=p; Parent*<span class="hljs-number">2</span>&lt;=H-&gt;Size; Parent=Child ) <br>    &#123;         <br>    Child = Parent * <span class="hljs-number">2</span>;         <br>    <span class="hljs-keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="hljs-number">1</span>]) )             Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span>         <span class="hljs-keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>         <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>             <br>    H-&gt;Data[Parent] = H-&gt;Data[Child];     <br>&#125;     <br>H-&gt;Data[Parent] = X; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildHeap</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123; <br><span class="hljs-comment">/* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span>   <br><span class="hljs-comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span>    <br>    <span class="hljs-type">int</span> i;     <span class="hljs-comment">/* 从最后一个结点的父节点开始，到根结点1 */</span>     <span class="hljs-keyword">for</span>( i = H-&gt;Size/<span class="hljs-number">2</span>; i&gt;<span class="hljs-number">0</span>; i-- )         <br>    PercDown( H, i ); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的基本概念及相关</title>
    <link href="/2022/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240856336.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240856794.png"></p><p> 完美二叉树就是除了最后一层，其余每个子树都有左右子树</p><p> 完全二叉树是指按序号位置排列不中断，不空缺，可以少后面的编号，但前面一定不能断开  </p><h2 id="二叉树几个重要性质"><a href="#二叉树几个重要性质" class="headerlink" title="二叉树几个重要性质"></a>二叉树几个重要性质</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240857254.png"></p><p>可用来粗略判断是不是二叉树</p><h2 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240858122.png"></p><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240859721.png"></p><p>依靠数组来实现</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240900427.png"></p><p>一般二叉树的顺序存储结构会造成空间浪费<br>不好！！！</p><h3 id="链表存储"><a href="#链表存储" class="headerlink" title="链表存储"></a>链表存储</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240901673.png"></p><p>仍然是父子兄弟表示法</p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>有先序遍历、中序遍历、后序遍历三种<br>先、中、后都是指向对根的访问<br>先序就是根左右<br>中序就是左根右<br>后序就是左右根</p><h2 id="三种递归调用实现的遍历"><a href="#三种递归调用实现的遍历" class="headerlink" title="三种递归调用实现的遍历"></a>三种递归调用实现的遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907236.png"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907401.png"></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907322.png"></p><h3 id="三种遍历的区分"><a href="#三种遍历的区分" class="headerlink" title="三种遍历的区分"></a>三种遍历的区分</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240909169.png"></p><p>**经过结点的路线一样，只是访问各结点的时机不同</p><h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><p>**基本思路：堆栈</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240912811.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240912008.png"></p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240913587.png"><br>**核心问题是要记住访问的结点，怎么记住？堆栈或队列！！！</p><h4 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240914981.png"><br>A先入队然后出队<br>A的儿子B和C入队<br>B出队，B的儿子D和F入队<br>C出队，C的儿子G和I入队<br>D出队<br>F出队，F的儿子E入队<br>G出队，G的儿子H入队<br>I出队<br>E出队<br>H出队<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240922079.png"></p><h2 id="遍历二叉树的应用"><a href="#遍历二叉树的应用" class="headerlink" title="遍历二叉树的应用"></a>遍历二叉树的应用</h2><h3 id="输出二叉树中的叶子结点"><a href="#输出二叉树中的叶子结点" class="headerlink" title="输出二叉树中的叶子结点"></a>输出二叉树中的叶子结点</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240923837.png"></p><h3 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240923052.png"></p><h3 id="二元运算表达式树及其遍历"><a href="#二元运算表达式树及其遍历" class="headerlink" title="二元运算表达式树及其遍历"></a>二元运算表达式树及其遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240924502.png"></p><p>中序遍历不一定得到中缀表达式<br>因为会受到运算符优先级的影响<br>可以引入括号来解决</p><h3 id="由两种遍历序列确定二叉树"><a href="#由两种遍历序列确定二叉树" class="headerlink" title="由两种遍历序列确定二叉树"></a>由两种遍历序列确定二叉树</h3><p>这两种遍历中必须要有中序遍历，如果只有先序和后序则无法确定</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240925601.png"><br>不断分割<br>先用先序遍历找到根<br>然后去中序序列的找到已知的根<br>进而找到已知根的左子树和右子树的中序序列<br>我们可以得到左子树的元素个数，那么再去先序序列中，往后对应个数的元素就是左子树的先序序列<br>右子树与左子树同理<br>这样就不断循环分割，确定出一颗二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240925919.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span> *<span class="hljs-title">Position</span>;</span> <br><span class="hljs-keyword">typedef</span> Position BinTree; <span class="hljs-comment">/* 二叉树类型 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span>&#123;</span> <br><span class="hljs-comment">/* 树结点定义 */</span>     <br>ElementType Data; <span class="hljs-comment">/* 结点数据 */</span>     <br>BinTree Left;     <span class="hljs-comment">/* 指向左子树 */</span>     <br>BinTree Right;    <span class="hljs-comment">/* 指向右子树 */</span> <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树的四种遍历"><a href="#二叉树的四种遍历" class="headerlink" title="二叉树的四种遍历"></a>二叉树的四种遍历</h3><p>中序、先序、后序、层序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InorderTraversal</span><span class="hljs-params">( BinTree BT )</span> &#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br>InorderTraversal( BT-&gt;Left );         <br><span class="hljs-comment">/* 此处假设对BT结点的访问就是打印数据 */</span>         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data); <span class="hljs-comment">/* 假设数据为整型 */</span>         InorderTraversal( BT-&gt;Right );     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderTraversal</span><span class="hljs-params">( BinTree BT )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data );         <br>PreorderTraversal( BT-&gt;Left );         PreorderTraversal( BT-&gt;Right );     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">PostorderTraversal</span><span class="hljs-params">( BinTree BT )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br>PostorderTraversal( BT-&gt;Left );         PostorderTraversal( BT-&gt;Right );         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data);     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelorderTraversal</span> <span class="hljs-params">( BinTree BT )</span> <br>&#123;      <br>Queue Q;      <br>BinTree T;     <br><span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span>          Q = CreatQueue(); <span class="hljs-comment">/* 创建空队列Q */</span>     <br>AddQ( Q, BT );     <br><span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;         <br>T = DeleteQ( Q );         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;Data); <span class="hljs-comment">/* 访问取出队列的结点 */</span>          <br>    <span class="hljs-keyword">if</span> ( T-&gt;Left )   AddQ( Q, T-&gt;Left );         <br>    <span class="hljs-keyword">if</span> ( T-&gt;Right )  AddQ( Q, T-&gt;Right );     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/07/18/%E9%98%9F%E5%88%97/"/>
    <url>/2022/07/18/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>什么是队列？<ul><li>具有一定操作约束的线性表</li><li>只能在一端插入，而在另一端删除</li><li>数据插入：入队列</li><li>数据删除：出队列</li><li>先来先服务</li><li>先进先出：FIFO</li></ul></li><li>队列的抽象数据类型描述<ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的队列Q$\in$Qyeue,队列元素item$\in$ElementType</li><li>基本操作<ul><li>Queue CreatQueue(int MaxSize)：生成长度为MaxSize的空队列</li><li>int IsFullQ(Queue Q,int MaxSize)：判断队列Q是否已满</li><li>void AddQ(Queue Q, ElementType item)：将数据元素item插入队列Q中</li><li>int IsEmptyQ(Queue Q)：判断队列Q是否为空</li><li>ElementType DeleteQ(Queue Q)：将队头数据元素从队列中删除并返回</li></ul></li></ul></li><li>队列的顺序存储实现<ul><li>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成的顺环队列</li></ul></li><li>队列的链式存储实现<ul><li>可以用一个单链表实现，插入和删除操作分别在链表的两头进行</li><li>注意：队列指针front应在单向链表的开头rear在尾（尾部删除操作找不到前面的元素，所有不能把front放在尾）</li></ul></li><li>应用实例（多项式加法）<ul><li>主要思路：相同指数项系数相加，不同指数项系数进行拷贝</li><li>采用不带头结点的单向链表，按照指数递减的顺序排列各项</li><li>两个指针P1和P2分别指向这两个多项式的第一个结点，不断循环<ul><li>P1指向的项如果指数等于P2指向的项的指数：系数相加，若结果不为0，则作为结果多项式对应项的系数。同时，P1和P2都分别指向下一项<ul><li>P1所指指数大于P2：将P1的当前项存入结果多项式，并使P1指向下一项</li><li>P1所指指数小于P2：将P2的当前项存入结果多项式，并使P2指向下一项</li><li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去</li></ul></li></ul></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span>     Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> &#123;     Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));     Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;     <br>Q-&gt;MaxSize = MaxSize;         <br><span class="hljs-keyword">return</span> Q;      <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span> &#123;     <br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;   Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>&#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear); &#125; <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">if</span> ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span>  <br>&#123;   Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;         <br><span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-comment">/* 队列中的结点 */</span>     <br>ElementType Data;     <br>PtrToNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToNode Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> &#125;; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>); &#125; ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br>Position FrontCell;      <br>ElementType FrontElem;          <br><span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;    FrontCell = Q-&gt;Front;         <br><span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span>                 Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span> <br>            <span class="hljs-keyword">else</span>                                  <br> Q-&gt;Front = Q-&gt;Front-&gt;Next;         <br> FrontElem = FrontCell-&gt;Data;         <br> <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span>         <br> <span class="hljs-keyword">return</span>  FrontElem;     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多项式加法用队列实现"><a href="#多项式加法用队列实现" class="headerlink" title="多项式加法用队列实现"></a>多项式加法用队列实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆栈</title>
    <link href="/2022/07/18/%E5%A0%86%E6%A0%88/"/>
    <url>/2022/07/18/%E5%A0%86%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>中缀表达式：运算符号位于两个运算数之间，如a+b*c-d&#x2F;e</p></li><li><p>后缀表达式：运算符号位于两个运算数之后，如abc*+de&#x2F;-</p></li><li><p>前缀表达式：运算符号位于两个运算数之前，如-+a*bc&#x2F;de</p></li><li><p>前缀表达式怎么求值？？？</p></li><li><p>后缀表达式求值策略：从左往右扫描，逐个处理运算数和运算符号</p><ul><li>遇到运算数怎么办？–把运算数记住</li><li>遇到运算符号怎么办？–把最近记住的两个数拿来做对应的运算</li></ul></li><li><p>这就给我们带来启示，需要有种存储方法，能顺序存储运算数，并在需要时“倒序”输出</p></li><li><p>于是，堆栈的意义也就出来了，先放进去的后拿出来，后放进去的先拿出来运算</p></li><li><p>堆栈的抽象数据类型描述</p><ul><li>具有一定操作约束的线性表</li><li>只在一端（栈顶，Top）做插入、删除</li><li>插入数据：入栈（Push）</li><li>删除数据：出栈（Pop）</li><li>后入先出：Last In First Out(LIFO)</li></ul></li><li><p>堆栈的操作</p><ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的堆栈S $\in$ Stack,堆栈元素item$\in$ ElementType</li><li>Stack CreateStack( int MaxSize )：生成空堆栈，其最大长度为MaxSize</li><li>bool IsFull( Stack S )：判断堆栈S是否已满</li><li>bool Push( Stack S, ElementType item )：将元素item压入堆栈</li><li>bool IsEmpty ( Stack S )：判断堆栈S是否为空</li><li>ElementType Pop( Stack S )：删除并返回栈顶元素</li></ul></li><li><p>栈的顺序储存实现</p><ul><li>xxxxxxxxxx typedef struct HNode <em>Heap; &#x2F;</em> 堆的类型定义 <em>&#x2F; struct HNode {         ElementType <em>Data; &#x2F;</em> 存储元素的数组 <em>&#x2F;     int Size;          &#x2F;</em> 堆中当前元素个数 <em>&#x2F;     int Capacity;      &#x2F;</em> 堆的最大容量 <em>&#x2F; }; typedef Heap MaxHeap; &#x2F;</em> 最大堆 <em>&#x2F; typedef Heap MinHeap; &#x2F;</em> 最小堆 <em>&#x2F; ​#define MAXDATA 1000  &#x2F;</em> 该值应根据具体情况定义为大于堆中所有可能元素的值 <em>&#x2F; MaxHeap CreateHeap( int MaxSize ) { &#x2F;</em> 创建容量为MaxSize的空的最大堆 <em>&#x2F;​MaxHeap H &#x3D; (MaxHeap)malloc(sizeof(struct HNode));     H-&gt;Data &#x3D; (ElementType <em>)malloc((MaxSize+1)<em>sizeof(ElementType));     H-&gt;Size &#x3D; 0;         H-&gt;Capacity &#x3D; MaxSize;         H-&gt;Data[0] &#x3D; MAXDATA; &#x2F;</em> 定义”哨兵”为大于堆中所有可能元素的值</em>&#x2F;     return H; } bool IsFull( MaxHeap H ) {         return (H-&gt;Size &#x3D;&#x3D; H-&gt;Capacity); } bool Insert( MaxHeap H, ElementType X ) {   &#x2F;</em> 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 <em>&#x2F;         int i;           if ( IsFull(H) ) {                  printf(“最大堆已满”);                 return false;         }         i &#x3D; ++H-&gt;Size; &#x2F;</em> i指向插入后堆中的最后一个元素的位置 <em>&#x2F;     for ( ; H-&gt;Data[i&#x2F;2] &lt; X; i&#x2F;&#x3D;2 )                 H-&gt;Data[i] &#x3D; H-&gt;Data[i&#x2F;2]; &#x2F;</em> 上滤X <em>&#x2F;             H-&gt;Data[i] &#x3D; X; &#x2F;</em> 将X插入 <em>&#x2F;             return true;     } #define ERROR -1 &#x2F;</em> 错误标识应根据具体情况定义为堆中不可能出现的元素值 <em>&#x2F; bool IsEmpty( MaxHeap H ) {         return (H-&gt;Size &#x3D;&#x3D; 0); } ElementType DeleteMax( MaxHeap H ) { &#x2F;</em> 从最大堆H中取出键值为最大的元素，并删除一个结点 <em>&#x2F;     int Parent, Child;         ElementType MaxItem, X;         if ( IsEmpty(H) ) {                 printf(“最大堆已为空”);                 return ERROR;         }         MaxItem &#x3D; H-&gt;Data[1]; &#x2F;</em> 取出根结点存放的最大值 <em>&#x2F;         &#x2F;</em> 用最大堆中最后一个元素从根结点开始向上过滤下层结点 <em>&#x2F;         X &#x3D; H-&gt;Data[H-&gt;Size–]; &#x2F;</em> 注意当前堆的规模要减小 <em>&#x2F;     for( Parent&#x3D;1; Parent</em>2&lt;&#x3D;H-&gt;Size; Parent&#x3D;Child ) {         Child &#x3D; Parent * 2;                 if( (Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]<H->Data[Child+1]) )             Child++;  &#x2F;</em> Child指向左右子结点的较大者 <em>&#x2F;         if( X &gt;&#x3D; H-&gt;Data[Child] ) break; &#x2F;</em> 找到了合适位置 <em>&#x2F;         else  &#x2F;</em> 下滤X <em>&#x2F;                         H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];     }                 H-&gt;Data[Parent] &#x3D; X;     return MaxItem; }              &#x2F;</em>———– 建造最大堆 ———–<em>&#x2F; void PercDown( MaxHeap H, int p ) {     &#x2F;</em> 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 <em>&#x2F;     int Parent, Child;         ElementType X;         X &#x3D; H-&gt;Data[p]; &#x2F;</em> 取出根结点存放的值 <em>&#x2F;         for( Parent&#x3D;p; Parent</em>2&lt;&#x3D;H-&gt;Size; Parent&#x3D;Child )     {                 Child &#x3D; Parent * 2;                 if( (Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]<H->Data[Child+1]) )             Child++;  &#x2F;* Child指向左右子结点的较大者 <em>&#x2F;         if( X &gt;&#x3D; H-&gt;Data[Child] ) break; &#x2F;</em> 找到了合适位置 <em>&#x2F;         else  &#x2F;</em> 下滤X <em>&#x2F;                     H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];         }         H-&gt;Data[Parent] &#x3D; X; } void BuildHeap( MaxHeap H ) { &#x2F;</em> 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  <em>&#x2F;   &#x2F;</em> 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 <em>&#x2F;        int i;     &#x2F;</em> 从最后一个结点的父节点开始，到根结点1 *&#x2F;     for( i &#x3D; H-&gt;Size&#x2F;2; i&gt;0; i– )                 PercDown( H, i ); }c</li></ul></li><li><p>堆栈的链式储存实现</p><ul><li>实际上就是一个单链表，叫做链栈。插入和删除操作只能在栈的栈顶进行。栈顶指针只能在链表的开头，不能用结尾做top</li></ul></li><li><p>中缀表达式转化为后缀表达式</p><ul><li>从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理</li><li>运算数直接输出</li><li>左括号压入堆栈</li><li>右括号将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）</li><li>运算符<ul><li>若优先级大于栈顶运算符，就把它压栈</li><li>若优先级小于等于栈顶运算符，就把栈顶运算符弹出并输出，再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈</li></ul></li><li>若各对象处理完毕，就把堆栈中存留的运算符一并输出</li></ul></li><li><p>堆栈的一些其他应用</p><ul><li>函数调用及递归实现</li><li>深度优先搜索</li><li>回溯算法</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3></li></ul><h4 id="堆栈的定义与操作——顺序存储"><a href="#堆栈的定义与操作——顺序存储" class="headerlink" title="堆栈的定义与操作——顺序存储"></a>堆栈的定义与操作——顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> </span><br><span class="hljs-class">&#123;</span>     <br> ElementType *Data; <br> <span class="hljs-comment">/* 存储元素的数组 */</span>     <br> Position Top;      <br> <span class="hljs-comment">/* 栈顶指针 */</span>     <br> <span class="hljs-type">int</span> MaxSize;       <br> <span class="hljs-comment">/* 堆栈最大容量 */</span> &#125;; <br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span> <br> Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> <br> &#123;     <br> Stack S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br> S-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));    <br> S-&gt;Top = <span class="hljs-number">-1</span>;     <br> S-&gt;MaxSize = MaxSize;     <br> <span class="hljs-keyword">return</span> S; <br> &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Stack S )</span> &#123;     <span class="hljs-keyword">return</span> (S-&gt;Top == S-&gt;MaxSize<span class="hljs-number">-1</span>); &#125; <span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span> <br>&#123;     <span class="hljs-keyword">if</span> ( IsFull(S) ) <br>  &#123;   <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;     <br>      <span class="hljs-keyword">else</span> <br>      &#123;         <br>      S-&gt;Data[++(S-&gt;Top)] = X;         <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>      &#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Stack S )</span> &#123;     <span class="hljs-keyword">return</span> (S-&gt;Top == <span class="hljs-number">-1</span>); &#125; ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span><br>&#123;     <span class="hljs-keyword">if</span> ( IsEmpty(S) ) <br>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);         <br> <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* ERROR是ElementType的特殊值，标志错误 */</span>     <br>&#125;     <br>   <span class="hljs-keyword">else</span>          <br>         <span class="hljs-keyword">return</span> ( S-&gt;Data[(S-&gt;Top)--] ); <br> &#125;<br></code></pre></td></tr></table></figure><h4 id="堆栈的定义与操作——链式存储"><a href="#堆栈的定义与操作——链式存储" class="headerlink" title="堆栈的定义与操作——链式存储"></a>堆栈的定义与操作——链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">PtrToSNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span>     <br>ElementType Data;     <br>PtrToSNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToSNode Stack; <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( )</span>  &#123; <br><span class="hljs-comment">/* 构建一个堆栈的头结点，返回该结点指针 */</span>     <br>Stack S;     <br>S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br>S-&gt;Next = <span class="hljs-literal">NULL</span>;     <br><span class="hljs-keyword">return</span> S; &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span> <span class="hljs-params">( Stack S )</span> <br>&#123; <span class="hljs-comment">/* 判断堆栈S是否为空，若是返回true；否则返回false */</span>     <br><span class="hljs-keyword">return</span> ( S-&gt;Next == <span class="hljs-literal">NULL</span> ); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 将元素X压入堆栈S */</span>     <br>PtrToSNode TmpCell;     TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br>TmpCell-&gt;Data = X;     <br>TmpCell-&gt;Next = S-&gt;Next;     <br>S-&gt;Next = TmpCell;     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125; <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span>   <br>&#123; <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span>     <br>PtrToSNode FirstCell;     <br>ElementType TopElem;     <br><span class="hljs-keyword">if</span>( IsEmpty(S) ) <br>        &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);          <br><span class="hljs-keyword">return</span> ERROR;     <br>    &#125;    <br><span class="hljs-keyword">else</span> <br>   &#123;         <br>  FirstCell = S-&gt;Next;          <br>  TopElem = FirstCell-&gt;Data;        <br>   S-&gt;Next = FirstCell-&gt;Next;         <br>   <span class="hljs-built_in">free</span>(FirstCell);         <br>   <span class="hljs-keyword">return</span> TopElem;     <br>   &#125; <br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本概念</title>
    <link href="/2022/07/18/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/07/18/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h1><ul><li>查找<ul><li>静态查找<ul><li>没有插入和删除操作，只有查找</li></ul></li><li>动态查找<ul><li>除查找，还有插入和删除操作</li></ul></li></ul></li></ul><h2 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h2><h4 id="方法一-顺序查找"><a href="#方法一-顺序查找" class="headerlink" title="方法一 顺序查找"></a>方法一 顺序查找</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240828985.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240828985.png"></p><p>哨兵的作用？<br>        可以在数组的最后或者边界上面设置一个值，不需要每次去判断下标的值是不是达到边界，而只要按照循环一般的规则，当碰到放置的值时，循环就会退出来了<br>哨兵的目的？<br>        简化代码，写循环时可以少写一个判断的分支</p><h4 id="方法二-二分查找"><a href="#方法二-二分查找" class="headerlink" title="方法二 二分查找"></a>方法二 二分查找</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240833949.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834711.png"></p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><h6 id="查找成功"><a href="#查找成功" class="headerlink" title="查找成功"></a>查找成功</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834403.png"></p><p>mid&#x3D;(left+right)&#x2F;2,比较后，如果在右半部分，则right不动，left变为mid加一，然后再求mid，直到找到关键字</p><h6 id="查找失败的例子"><a href="#查找失败的例子" class="headerlink" title="查找失败的例子"></a>查找失败的例子</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834592.png"></p><p>最后left大于right则查找失败，所要找的关键字不在所给的范围内</p><h6 id="十一个元素的二分查找判定树"><a href="#十一个元素的二分查找判定树" class="headerlink" title="十一个元素的二分查找判定树"></a>十一个元素的二分查找判定树</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240838860.png"></p><p>二分查找引出二叉树</p><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240840764.png"></p><h3 id="树与非树（什么样的不是树？）"><a href="#树与非树（什么样的不是树？）" class="headerlink" title="树与非树（什么样的不是树？）"></a>树与非树（什么样的不是树？）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240841898.png"><br>左：C和D为A的子树，他们相交了<br>中：E有了B和C两个父亲结点<br>右：多了一条AG边</p><h3 id="树的一些术语"><a href="#树的一些术语" class="headerlink" title="树的一些术语"></a>树的一些术语</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240844812.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240844048.png"><br>    图中A结点的度数为3<br>    图所示树的度为3<br>    图中F为叶结点<br>    图中A在第一层<br>    树的深度为4</p><h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><h4 id="单纯用链表表示"><a href="#单纯用链表表示" class="headerlink" title="单纯用链表表示"></a>单纯用链表表示</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240846604.png"></p><p>这样的形式不够好，每个结点的结构不统一，且很多空间会被浪费</p><h4 id="儿子-兄弟表示法"><a href="#儿子-兄弟表示法" class="headerlink" title="儿子-兄弟表示法"></a>儿子-兄弟表示法</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240847688.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240847052.png"><br>      每个结点结构都一样，且空间浪费不大</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科目二窍门</title>
    <link href="/2022/07/17/%E7%A7%91%E7%9B%AE%E4%BA%8C%E7%AA%8D%E9%97%A8/"/>
    <url>/2022/07/17/%E7%A7%91%E7%9B%AE%E4%BA%8C%E7%AA%8D%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h1><ul><li>驶入弯道前，打转向灯</li><li>然后点对线</li><li>视野里车头与前方黄线三十公分左右，轻拔转向灯，使取消</li><li>视角里看到开门地方一指距离对准黄线尖角，方向盘左打死</li><li>等到点再擦到黄线边缘时，立马回正</li></ul><h1 id="S弯曲线行驶"><a href="#S弯曲线行驶" class="headerlink" title="S弯曲线行驶"></a>S弯曲线行驶</h1><p>S弯的步骤<br>1：看见弯口向弯口打方向，打半圈180度，仪表盘12点钟对弯口中间回正方向盘。<br>2：用左镜架子的点碰左边黄线右边缘进弯。<br>3：看左镜架子最低的点碰右边黄线内边缘向左打一圈+90°方向盘。<br>4：看左镜架子的点离黄线2个拳头宽（一部手机长）的距离回90°方向盘。<br>5：看左镜架子的点碰左边黄线回一圈方向盘。<br>6：看右镜架子最低点离左边黄线一拳距离向右打一圈+90°方向盘。<br>7：看右镜架子的点离左边黄线2只筷子长的距离回90°方向盘。<br>8：握着一圈方向盘就出弯了。</p><h1 id="侧方停车"><a href="#侧方停车" class="headerlink" title="侧方停车"></a>侧方停车</h1><ul><li>1肩膀与参照物平行，向右打一圈。</li><li>2看左后视镜看到三个轮胎回一圈。</li><li>3左后视镜看见左后轮压上黄线向左打死。</li><li>4前进左前角与黄线重合停车。</li><li>5换一档转向灯前进左筋与黄线交接回一圈半。</li><li>6车头三分之二与黄线交接向右打一圈</li></ul><h1 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h1><ul><li>肩膀与线平行，向右打死</li><li>车身到30厘米回半圈</li><li>车身与线平行回一圈</li><li>肩膀于线平行停车</li><li>伸头看左前轮与黄线保持30公分，适当调整</li><li>肩膀过线25厘米，打左一圈加90度</li><li>窗条过黄线上口停车</li><li>倒车，从左后视镜看自己的左后轮压白线10厘米回90度</li><li>如果车轮压不到线左打死</li><li>将轮胎压上线回半圈</li><li>将车尾对上后面一个底座回一圈</li><li>肩膀与黄线平行停车</li><li>车头看不到黄线右打死</li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>学车</category>
      
    </categories>
    
    
    <tags>
      
      <tag>驾照考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游武汉美术馆的一些收获</title>
    <link href="/2022/07/13/%E6%B8%B8%E6%AD%A6%E6%B1%89%E7%BE%8E%E6%9C%AF%E9%A6%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/"/>
    <url>/2022/07/13/%E6%B8%B8%E6%AD%A6%E6%B1%89%E7%BE%8E%E6%9C%AF%E9%A6%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<p>武汉美术馆是我第一次游览的美术馆，这一次游览不仅让我领略了许多美丽，更让我看到了艺术家们深邃的思想</p><p>先从史金淞个展说起， 他用枯木和自己加工的一些材料制造出摩托车，并用落叶点缀。他用不同人所收集的一些铁质材料，比如：螺丝、小刀、废铁，自己熔铸、锻造、磨砺，制造出了一把大刀，小小螺丝也可以变成削铁如泥的刀。他分别用1500摄氏度，和2500摄氏度点燃木炭，相差一千摄氏度的火焰燃烧得各有各的风采。他用捡来的垃圾做成了漂亮的屏风，并赋“如心中有垃圾，花鸟矣垃圾；如心中有花鸟，垃圾矣花鸟”。</p><p>他的作品《铁丝人偶》，铁丝人偶在被设计的宿命中挣扎，于无形的系统中机械舞动，他用缠绕身体的铁丝形成人偶，肉身幻化为线条，让人们不禁思考“什么是人？”“人在此刻何为？”</p><p>看完个展后，去了三楼还有两个作品让我印象十分深刻，一个是卜桦导演的电影作品《LV森林》，一对全身赤裸的女孩，正在窃窃私语，她们耳语着对面水塘里的女人。这些长发女人，全身裸体，搔首弄姿。形如男性生殖器的怪异巨兽，背上驮着户型各异的“空中楼阁”。他们对每个女人品头论足，垂涎欲滴于美貌妖娆的丽人，无视于面貌普通的女人，甚至于鄙视唾弃。同样的，女人们也用相同的方法丈量评判这些巨兽们。她们关注的，无非是巨兽们背上的“空中楼阁”。第一个美女选择了雕栏玉砌的珍楼宝屋，第二个女人选择了面目清秀的“俊男”……剩下的名额越来越少，只剩下又矮又胖的女孩一人。选择“俊男”的女孩来到了极度繁华而又糜烂的世界里，她跟胖女孩炫耀自己是如何的挥金如土。最终，被这一切所冷落的胖女孩，独自一人划着船，观看岸上的女人们过着所谓的幸福的生活。还有一个是黄彦的《活标本》，夸张、怪诞的人形象放在玻璃器皿里，形成了活标本，我望着这一个个标本，竟好像看到了自己。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181240851.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241810.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241202.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242446.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241033.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242507.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242471.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>出去玩</category>
      
    </categories>
    
    
    <tags>
      
      <tag>武汉美术馆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象程序设计</title>
    <link href="/2022/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑基本知识</title>
    <link href="/2022/07/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/07/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-基本知识"><a href="#第一讲-基本知识" class="headerlink" title="第一讲 基本知识"></a>第一讲 基本知识</h1><h2 id="数字信号与系统"><a href="#数字信号与系统" class="headerlink" title="数字信号与系统"></a>数字信号与系统</h2><ul><li>模拟信号：信号的变换在时间上和数值上都是<strong>连续</strong>的</li><li>离散信号（数字信号）：信号的变化在时间上和数值上都是<strong>离散</strong>的，或者说<strong>断续</strong>的</li><li>离散信号的变化可以用不同的数字反映，所以又称为数字信号</li><li>数字系统<ul><li>数字系统是一个能对数字信号进行加工，传递和存储的实体，它由实现各种功能的数字逻辑电路相互连接而成</li><li>比如MP3、手机、数字计算机</li></ul></li><li>模拟信号与数字信号的相互转换<ul><li>A&#x2F;D-模数转换（Analog-Digital）</li><li>D&#x2F;A-数模转换（Digital-Analog）</li></ul></li><li>模拟信号数字化<ul><li>采样</li><li>量化与编码</li></ul></li><li>数字逻辑电路<ul><li>数字电路是用来处理数字信号的电子线路</li><li>由于数字电路的各种电路是通过逻辑运算和逻辑判断来实现的，所以数字电路又称为数字逻辑电路或者逻辑电路</li><li>数字逻辑电路的特点<ul><li>电路的基本工作信号是二值信号</li><li>电路中的半导体器件一般都工作在开、关状态</li><li>电路结构简单、功耗低、便于集成制造和系列化生产、产品价格低廉、使用方便、通用性好</li><li>工作速度快、精度高、功能强、可靠性好</li></ul></li><li>数字逻辑电路的类型（根据一个电路有无记忆功能划分）<ul><li>组合逻辑电路：无记忆功能<ul><li>在任何时刻稳定输出仅取决于该时刻的输入，而与电路的过去无关</li><li>类比行李箱的密码锁</li></ul></li><li>时序逻辑电路：有记忆功能<ul><li>在任何时刻的稳定输出不仅取决于该时刻的输入，而且与过去的输入相关</li><li>类比电话、电子密码锁</li><li>时序逻辑电路按照是否有统一的时钟信号进行同步可分为<ul><li>同步时序逻辑电路</li><li>异步时序逻辑电路</li></ul></li></ul></li></ul></li></ul></li><li>数字系统的层次结构<ul><li>第1级：电子元件，如二极管、三极管、电阻、电容</li><li>第2级：基本逻辑器件，如逻辑门、触发器 （SSI级）</li><li>第3级：逻辑功能部件，如加法器、计数器、乘法器（MSI、LSI级）</li><li>第4级：复杂逻辑功能部件，如微处理器（VLSI级）</li><li>第5级：复杂数字系统，含第2级到第4级的逻辑部件</li></ul></li><li>数字逻辑电路的研究方法<ul><li>两个任务<ul><li>逻辑设计<ul><li>根据提出的逻辑功能，在给定条件下构造出实现预定功能的逻辑电路</li></ul></li><li>逻辑分析 <ul><li>对一个已有的数字逻辑电路，研究它的工作性能和逻辑功能</li></ul></li></ul></li><li>传统方法<ul><li>以逻辑代数作为基本理论，从逻辑抽象到功能实现</li><li>建立在小规模集成电路基础之上</li><li>以技术经济指标作为评价一个设计方案优劣的主要性能指标</li><li>设计时追求的是如何使一个电路达到最简</li></ul></li><li>注意：一个最简的方案并不等于一个最佳的方案</li></ul></li></ul><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><ul><li>原码不能直接进行减法运算<ul><li>当对两个数求和时，如果符号相异，则先比较绝对值大小，然后做减法</li><li>绝对值大的符号是结果的符号</li><li>绝对值的差值是结果的数值位</li><li>用原码进行加减法较为麻烦！！！</li></ul></li><li>怎么解决？？？<ul><li>减法变加法，符号位直接参与运算</li></ul></li><li>反码做加减法运算<ul><li>产生的进位移到末位才等于正确结果</li><li>并且反码也有正0和负0</li><li>这种机器码还是不能很好进行加减法运算</li></ul></li><li>模的概念<ul><li>模指一个计量系统的计数范围</li><li>模实质上是计量系统产生“溢出”的量，它的值在计量系统上表示不出来，计量系统上只能表示出模的余数</li><li>任何有模的计量系统，均可化减法为加法运算</li><li>计算机也可以看成一个计量系统，有一个模</li></ul></li><li>补码的意义<ul><li>计算机中的数据受字长限制，数据的运算属于有模运算</li><li>计算结果直接丢掉进位</li><li>可以将减法转为加法运算</li><li>计算机中可只设置加法器，简化设计、降低成本</li></ul></li></ul><h2 id="几种常用的编码"><a href="#几种常用的编码" class="headerlink" title="几种常用的编码"></a>几种常用的编码</h2><ul><li><p>十进制数的二进制编码（BCD码）</p><ul><li>8421码（有权码）<ul><li>权值 8 4 2 1</li><li>和十进制转化为二进制是一样的</li></ul></li><li>2421码（有权码）<ul><li>权值 2 4 2 1</li></ul></li><li>余3码（无权码）<ul><li>在8421码的基础上加3</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191553202.png"></li></ul></li><li><p>十进制数在机器中的两种表示</p><ul><li>字符串形式<ul><li>一个字节存放一个十进制位</li><li>符号位用8421码中未选用的编码，正号1100，负号1101</li></ul></li><li>压缩的十进制数串<ul><li>一个字节存放两个十进制位</li><li>符号位用8421码中未选用的编码，正号1100，负号1101</li></ul></li></ul></li><li><p>可靠性编码</p><ul><li>减少或者发现代码在形成和传送过程中可能发生的错误</li><li>提高系统的可靠性</li><li>两种可靠性编码<ul><li>奇偶校验码</li><li>格雷码</li></ul></li></ul></li><li><p>奇偶校验</p><ul><li>奇校验：让整个校验码（有效的信息位和校验位）中1的个数为偶数</li><li>偶校验：让整个校验码中1的个数为奇数</li><li>有效信息（被校验的信息）部分可能是奇性（1的个数为奇数），也可能是偶性</li><li>奇偶两种校验都只需配一个校验位，就可以使整个校验码满足指定的奇偶性要求</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191600341.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191600048.png"></li></ul></li><li><p>奇偶校验特点</p><ul><li>一种常见的简单校验，只需1位校验码</li><li>只具有发现错误的能力，不具备对错误定位和纠正错误的能力</li><li>只具有发现一串二进制代码中，同时出现奇数个代码出错的能力</li><li>如果同时发生偶数个代码出错，奇偶校验失效</li></ul></li><li><p>格雷码</p><ul><li>特点：任意两个相邻的数，其格雷码只有一位不同</li><li>作用：避免代码形成和变换过程中产生的错误</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191601819.png"></li></ul></li><li><p>二进制到格雷码的转换</p><ul><li>$G_{n-1}&#x3D;B_{n-1}$ （最高位不变）     $G_i&#x3D;B_{i+1}\bigoplus B_i$</li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191610080.png"></p></li><li><p>字符编码</p><ul><li>ASCII码</li></ul></li></ul><h1 id="第二讲-逻辑代数基础"><a href="#第二讲-逻辑代数基础" class="headerlink" title="第二讲 逻辑代数基础"></a>第二讲 逻辑代数基础</h1><h2 id="逻辑代数的基本概念"><a href="#逻辑代数的基本概念" class="headerlink" title="逻辑代数的基本概念"></a>逻辑代数的基本概念</h2><p><strong>加号表示或（析取），点乘号表示与（合取）</strong></p><ul><li><p>逻辑代数定义</p><ul><li>逻辑代数L是一个封闭的代数系统</li><li>由一个逻辑变量集K，常量0和1，以及或、与、非三种基本运算所构成</li></ul></li><li><p>逻辑代数公理</p><ul><li>交换律</li><li>结合律</li><li>分配律</li><li>0-1律<ul><li>A+0&#x3D;A        A+1&#x3D;1</li><li>A * 0&#x3D;0       A * 1&#x3D;A</li></ul></li><li>互补律<ul><li>对任意逻辑变量A，存在唯一B，使得A+B&#x3D;1,A * B&#x3D;0</li></ul></li></ul></li><li><p>逻辑变量及基本运算</p><ul><li><p>或运算</p><ul><li>实现或运算关系的逻辑电路称为或门</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101159454.png"></li></ul></li><li><p>与运算</p><ul><li>实现与运算关系的逻辑电路称为与门</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101200522.png"></li></ul></li><li><p>非运算</p><ul><li>实现非运算关系的逻辑电路称为非门或者<strong>反相器</strong></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101203717.png"></li></ul></li></ul></li><li><p>逻辑函数</p><ul><li>定义：随自变量变化的因变量</li><li>与普通代数函数概念相比，逻辑函数的特点：<ul><li>逻辑函数和逻辑变量一样，取值只有0和1两种可能</li><li>函数和变量之间的关系由或、与、非三种基本运算决定</li></ul></li></ul></li><li><p>逻辑函数相等</p><ul><li>两个因变量a和b随自变量变化，任何自变量的值对应的a值和b值都相同，则称a和b相等</li><li>判断方法<ul><li>真值表法</li><li>代数法</li></ul></li></ul></li><li><p>逻辑功能的表示法</p><ul><li>逻辑表达式<ul><li>逻辑函数的简写<ul><li>非运算符下可不加括号</li><li>与运算符一般可省略</li><li>既有与又有或，先与后或</li><li>运算优先法则：括号&gt;非&gt;与&gt;异或&gt;或</li><li>与运算和或运算均满足结合律</li></ul></li></ul></li><li>真值表</li><li>卡诺图<ul><li>由表示逻辑变量所有取值组合的小方格构成的平面图</li><li>图形化描述逻辑函数</li></ul></li></ul></li></ul><h2 id="逻辑表达式的形式与转换"><a href="#逻辑表达式的形式与转换" class="headerlink" title="逻辑表达式的形式与转换"></a>逻辑表达式的形式与转换</h2><h3 id="与或-x2F-或与表达式"><a href="#与或-x2F-或与表达式" class="headerlink" title="与或&#x2F;或与表达式"></a>与或&#x2F;或与表达式</h3><ul><li>与-或表达式<ul><li>若干与项进行或运算构成的表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101228547.png"></li></ul></li><li>或-与表达式<ul><li>若干或项进行与运算构成的表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101230829.png"></li></ul></li></ul><h3 id="最小项-x2F-最大项"><a href="#最小项-x2F-最大项" class="headerlink" title="最小项&#x2F;最大项"></a>最小项&#x2F;最大项</h3><ul><li><p>最小项定义</p><ul><li>具有n个变量的函数的“与项”包含全部n个变量（所有变量全都出现）</li><li>每个变量都以原变量或反变量形式出现一次，且仅出现一次 </li><li>该与项被称为最小项，有时称为标准与项</li></ul></li><li><p>最小项数目</p><ul><li>n个变量可以构成2的n次方个最小项</li></ul></li><li><p>简写$m_i$</p><ul><li>i的取值规则<ul><li>按照变量顺序将最小项中的原变量用1表示，反变量用0表示，由此得到一个二进制数，与该二进制数对应的十进制数即下标i的值</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101238970.png"></li><li>A为原变量用1表示，B为反变量用0表示，C为原变量用1表示，得到101，把101看成二进制数，转化为十进制就得到5</li></ul></li></ul></li><li><p>用最小项表示函数</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101243927.png"></li></ul></li><li><p>最小项性质</p><ul><li>任意一个最小项，其相应变量有且仅有一种取值使这个最小项的值为1，最小项不同，使其值为1的变量取值也不同，任何一种变量取值都不可能使两个不同的最小项同时为1<ul><li>在由n个变量构成的任意与项中，最小项是使其值为1的变量取值组合数最少的一种与项 </li><li>上面这点也是最小项名字的由来</li></ul></li><li>相同变量构成的两个不同最小项，相与为0</li><li>n个变量的全部最小项，相或为1</li><li>n个变量构成的最小项有n个相邻最小项<ul><li>相邻最小项：除一个变量相反外，其余变量均相同的最小项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101248868.png"></li></ul></li></ul></li><li><p>最大项定义</p><ul><li>具有n个变量的函数的”或项” 包含全部n个变量</li><li>每个变量都以原变量或反变量形式出现一次，且仅出现一次</li><li>该或项被称为最大项，有时称为标准或项</li></ul></li><li><p>最大项数目</p><ul><li>n个变量可以构成2的n次方个最小项</li></ul></li><li><p>简写$M_i$</p><ul><li>按照变量顺序将最大项中的原变量用0表示，反变量用1表示</li><li>由此得到一个二进制数，与该二进制数对应的十进制数就是下标i的取值</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101254386.png"></li></ul></li><li><p>最大项表示函数</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101319638.png"></li></ul></li><li><p>最大项性质</p><ul><li><p>任意一个最大项，其相应变量有且仅有一种取值使这个最大项的值为0，最大项不同，使其值为0的变量取值也不同</p><ul><li>在由n个变量构成的任意或项中，最大项是使其值为1的变量取值组合数最大的一种或项</li><li>上面这点也是最大项名字的由来</li></ul></li><li><p>相同变量构成的两个不同最大项，相或为1</p></li><li><p>n个变量的全部最大项，相与为0</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101325216.png"></li></ul></li><li><p>n个变量构成的最大项有n个相邻最大项</p><ul><li>相邻最大项：除一个变量相反外，其余变量均相同的最大项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101326271.png"></li></ul></li></ul></li><li><p>最小项和最大项的关系</p><ul><li>在同一个问题中，下标相同的最小项和最大项互为反函数</li><li>相同变量构成的最小项$m_i$和最大项$M_i$之间存在互补关系</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101328075.png"></li></ul></li></ul><h3 id="标准与或-x2F-或与表达式"><a href="#标准与或-x2F-或与表达式" class="headerlink" title="标准与或&#x2F;或与表达式"></a>标准与或&#x2F;或与表达式</h3><ul><li>标准与-或表达式<ul><li>由若干最小项相或构成的逻辑表达式</li><li>最小项表达式</li></ul></li><li>标准或-与表达式<ul><li>由若干最大项相与构成的逻辑表达式</li><li>最大项表达式<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101330732.png"></li></ul></li></ul><h3 id="逻辑函数表达式的转换方法"><a href="#逻辑函数表达式的转换方法" class="headerlink" title="逻辑函数表达式的转换方法"></a>逻辑函数表达式的转换方法</h3><p><strong>定理？？？？（记得补充）</strong></p><ul><li>逻辑函数表达式的转换方法<ul><li>代数转换法<ul><li>求标准与或表达式<ul><li>第一步，将函数表达式变换成一般与-或表达式</li><li>第二步，反复使用 <strong>X&#x3D;X(Y+(-Y))</strong> 即X等于X与上Y或非Y，将表达式中所有非最小项的与项扩展成最小项</li><li>注意：当给出的函数表达式已经是与或表达式，可直接第二步</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110913767.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110914559.png"></li></ul></li><li>求标准或与表达式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110917671.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110918477.png"></li></ul></li></ul></li><li>真值表转换法<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110919193.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110919404.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110928135.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110928485.png"><br> 任何一个逻辑函数的两种标准形式唯一</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>数字逻辑基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2022/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2022/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-基本概念"><a href="#第一讲-基本概念" class="headerlink" title="第一讲 基本概念"></a>第一讲 基本概念</h1><ul><li><p>什么是数据结构？（抽象数据类型的物理实现）</p><ul><li>解决问题方法的效率，和数据的组织方式是直接相关的，与空间的利用效率有关，与算法的巧妙程度相关</li></ul></li><li><p>什么是算法？（一系列解决问题的清晰指令）</p></li><li><p>什么是好的算法？（综合看空间复杂度和时间复杂度）</p></li><li><p>最大子列和的几种算法</p><ul><li>分而治之</li><li>在线处理<ul><li>在线的意思是指每输入一个数据就进行即时处理，在任何一个地方终止输出，算法都可以正确给出当前解</li></ul></li></ul></li></ul><h1 id="第二讲-线性结构"><a href="#第二讲-线性结构" class="headerlink" title="第二讲 线性结构"></a>第二讲 线性结构</h1><h2 id="线性表及其实现"><a href="#线性表及其实现" class="headerlink" title="线性表及其实现"></a>线性表及其实现</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>什么是线性表<ul><li>由同类型数据元素构成有序序列的线性结构<ul><li>表中元素个数称为线性表的长度</li><li>线性表没有元素时，称为空表</li><li>表起始位置称表头，结束位置表尾</li></ul></li></ul></li><li>线性表怎么存储？<ul><li>顺序存储（数组）</li><li>链式存储（链表）</li></ul></li><li>线性表的主要操作<br>- 初始化<br>- 根据位序返回相应元素<br>- 查找<br>- 插入<br>- 删除<br>- 返回线性表长度</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="线性表的定义与操作——顺序表"><a href="#线性表的定义与操作——顺序表" class="headerlink" title="线性表的定义与操作——顺序表"></a>线性表的定义与操作——顺序表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span>     ElementType Data[MAXSIZE];     Position Last; &#125;;<br><br><span class="hljs-comment">/* 初始化 */</span><br>List <span class="hljs-title function_">MakeEmpty</span><span class="hljs-params">()</span> &#123;     List L;     L = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>L-&gt;Last = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> L; &#125; <br><br><br><br><br><span class="hljs-comment">/* 查找 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1 Position Find( List L, ElementType X ) </span><br>&#123; Position i = <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )  <br>       i++;    <br>       <span class="hljs-keyword">if</span> ( i &gt; L-&gt;Last )  <br>         <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* 如果没找到，返回错误信息 */</span>    <br>       <span class="hljs-keyword">else</span><br>         <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">/* 找到后返回的是存储位置 */</span> &#125; <br><br><br><br><br><span class="hljs-comment">/* 插入 */</span> <span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span><br>&#123; <span class="hljs-comment">/* 在L的指定位置P前插入一个新元素X */</span> <br>Position i;    <br><span class="hljs-keyword">if</span> ( L-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>) <br>&#123; <span class="hljs-comment">/* 表空间已满，不能插入 */</span>   <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满&quot;</span>);   <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;       <br><span class="hljs-keyword">if</span> ( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last+<span class="hljs-number">1</span> )<br>&#123; <span class="hljs-comment">/* 检查插入位置的合法性 */</span> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置不合法&quot;</span>);  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;   <br><span class="hljs-keyword">for</span>( i=L-&gt;Last; i&gt;=P; i-- )  <br>L-&gt;Data[i+<span class="hljs-number">1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P及以后的元素顺序向后移动 */</span>  <br>L-&gt;Data[P] = X;  <span class="hljs-comment">/* 新元素插入 */</span>   <br>L-&gt;Last++;       <span class="hljs-comment">/* Last仍指向最后元素 */</span>  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125; <br><br><br><br><br><span class="hljs-comment">/* 删除 */</span> <span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span> <br>&#123; <span class="hljs-comment">/* 从L中删除指定位置P的元素 */</span>  <br>Position i;  <br><span class="hljs-keyword">if</span>( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last ) &#123; <span class="hljs-comment">/* 检查空表及删除位置的合法性 */</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置%d不存在元素&quot;</span>, P ); <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;   <br> <span class="hljs-keyword">for</span>( i=P+<span class="hljs-number">1</span>; i&lt;=L-&gt;Last; i++ ) <br> L-&gt;Data[i<span class="hljs-number">-1</span>] = L-&gt;Data[i]; <br> <span class="hljs-comment">/* 将位置P+1及以后的元素顺序向前移动 */</span> <br>L-&gt;Last--; <span class="hljs-comment">/* Last仍指向最后元素 */</span> <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线性表的定义与操作——链式表"><a href="#线性表的定义与操作——链式表" class="headerlink" title="线性表的定义与操作——链式表"></a>线性表的定义与操作——链式表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">PtrToLNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span>     ElementType Data;     PtrToLNode Next; &#125;; <br>   <span class="hljs-keyword">typedef</span> PtrToLNode Position;<br>   <span class="hljs-keyword">typedef</span> PtrToLNode List; <br>   <span class="hljs-comment">/* 查找 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR NULL Position Find( List L, ElementType X )</span><br>     &#123;     <br>     Position p = L; <span class="hljs-comment">/* p指向L的第1个结点 */</span>     <br>     <span class="hljs-keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )         <br>     p = p-&gt;Next;     <br>     <span class="hljs-comment">/* 下列语句可以用 return p; 替换 */</span>     <br>     <span class="hljs-keyword">if</span> ( p )         <br>      <span class="hljs-keyword">return</span> p;     <br>     <span class="hljs-keyword">else</span>         <br>      <span class="hljs-keyword">return</span> ERROR; &#125; <br><span class="hljs-comment">/* 带头结点的插入 */</span> <span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span> <br>   <span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span> <br>   &#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span>     <br>   Position tmp, pre;     <br>   <span class="hljs-comment">/* 查找P的前一个结点 */</span>             <br>   <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) <br>   ;                 <br>   <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> ) &#123; <br>   <span class="hljs-comment">/* P所指的结点不在L中 */</span>         <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置参数错误\n&quot;</span>);         <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     &#125;     <br>   <span class="hljs-keyword">else</span> &#123; <br>   <span class="hljs-comment">/* 找到了P的前一个结点pre */</span>         <br>   <span class="hljs-comment">/* 在P前插入新结点 */</span>     tmp = (Position)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>   <span class="hljs-comment">/* 申请、填装结点 */</span><br>   tmp-&gt;Data = X;          <br>   tmp-&gt;Next = P;         <br>   pre-&gt;Next = tmp;         <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>    &#125; <br>   &#125; <br>   <span class="hljs-comment">/* 带头结点的删除 */</span> <span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span> <br>   <span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>    &#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span>     <br>    Position pre;     <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>             <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) <br>    ;                 <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> || P==<span class="hljs-literal">NULL</span>)<br>     &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span>         <br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除位置参数错误\n&quot;</span>);         <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     &#125;     <br>     <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span>         <br>     <span class="hljs-comment">/* 将P位置的结点删除 */</span>         <br>     pre-&gt;Next = P-&gt;Next;         <br>     <span class="hljs-built_in">free</span>(P);         <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>       &#125; <br>     &#125;<br></code></pre></td></tr></table></figure><h2 id="广义表与多重链表"><a href="#广义表与多重链表" class="headerlink" title="广义表与多重链表"></a>广义表与多重链表</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>广义表<ul><li>广义表是线性表的推广</li><li>对于线性表而言，n个元素都是基本的单元素</li><li>而广义表中，这些元素不仅可以是单元素也可以是另一个广义表</li></ul></li><li>多重链表（链表中的节点可能同时隶属于多个链）<ul><li>多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域</li><li>但包含两个指针域的链表并不一定是多重链表，比如双向链表不是多重链表</li><li>多重链表用途广泛：树、图这样相对复杂的数据结构可以采用多重链表方式实现存储</li></ul></li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*广义表*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">GList</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br><span class="hljs-type">int</span> Tag;   <span class="hljs-comment">/*标志域：0表示结点是单元素，1表示结点是广义表*/</span><br><span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br><span class="hljs-comment">/*子表指针域Sublist与单元素数据域Data复用，即共用存储空间*/</span><br>ElementType Data;<br>GList Sublist;<br><br>&#125;URegion;<br>GList Next;  <span class="hljs-comment">/*指向后继结点*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>什么是队列？<ul><li>具有一定操作约束的线性表</li><li>只能在一端插入，而在另一端删除</li><li>数据插入：入队列</li><li>数据删除：出队列</li><li>先来先服务</li><li>先进先出：FIFO</li></ul></li><li>队列的抽象数据类型描述<ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的队列Q$\in$Qyeue,队列元素item$\in$ElementType</li><li>基本操作<ul><li>Queue CreatQueue(int MaxSize)：生成长度为MaxSize的空队列</li><li>int IsFullQ(Queue Q,int MaxSize)：判断队列Q是否已满</li><li>void AddQ(Queue Q, ElementType item)：将数据元素item插入队列Q中</li><li>int IsEmptyQ(Queue Q)：判断队列Q是否为空</li><li>ElementType DeleteQ(Queue Q)：将队头数据元素从队列中删除并返回</li></ul></li></ul></li><li>队列的顺序存储实现<ul><li>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成</li><li>顺环队列</li></ul></li><li>队列的链式存储实现<ul><li>可以用一个单链表实现，插入和删除操作分别在链表的两头进行</li><li>注意：队列指针front应在单向链表的开头rear在尾（尾部删除操作找不到前面的元素，所有不能把front放在尾）</li></ul></li><li>应用实例（多项式加法）<ul><li>主要思路：相同指数项系数相加，不同指数项系数进行拷贝</li><li>采用不带头结点的单向链表，按照指数递减的顺序排列各项</li><li>两个指针P1和P2分别指向这两个多项式的第一个结点，不断循环<ul><li>P1指向的项如果指数等于P2指向的项的指数：系数相加，若结果不为0，则作为结果多项式对应项的系数。同时，P1和P2都分别指向下一项<ul><li>P1所指指数大于P2：将P1的当前项存入结果多项式，并使P1指向下一项</li><li>P1所指指数小于P2：将P2的当前项存入结果多项式，并使P2指向下一项</li><li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去</li></ul></li></ul></li></ul></li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span>     Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> &#123;     Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));     Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;     <br>Q-&gt;MaxSize = MaxSize;         <br><span class="hljs-keyword">return</span> Q;      <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span> &#123;     <br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;   Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>&#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear); &#125; <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">if</span> ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span>  <br>&#123;   Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;         <br><span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-comment">/* 队列中的结点 */</span>     <br>ElementType Data;     <br>PtrToNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToNode Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> &#125;; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>); &#125; ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br>Position FrontCell;      <br>ElementType FrontElem;          <br><span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;    FrontCell = Q-&gt;Front;         <br><span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span>                 Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span> <br>            <span class="hljs-keyword">else</span>                                  <br> Q-&gt;Front = Q-&gt;Front-&gt;Next;         <br> FrontElem = FrontCell-&gt;Data;         <br> <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span>         <br> <span class="hljs-keyword">return</span>  FrontElem;     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多项式加法用队列实现"><a href="#多项式加法用队列实现" class="headerlink" title="多项式加法用队列实现"></a>多项式加法用队列实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
