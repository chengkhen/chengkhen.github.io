<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>湖科大计算机网络第一章</title>
    <link href="/2023/05/29/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/05/29/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h1><h2 id="网络、互联网与因特网的区别与关系"><a href="#网络、互联网与因特网的区别与关系" class="headerlink" title="网络、互联网与因特网的区别与关系"></a>网络、互联网与因特网的区别与关系</h2><ul><li><p>若干节点和链路互联形成网络</p></li><li><p>若干网络通过路由器互联形成互联网</p></li><li><p>因特网是当今世界上最大的互联网</p></li></ul><h3 id="intnet-vs-Internet"><a href="#intnet-vs-Internet" class="headerlink" title="intnet vs Internet"></a>intnet vs Internet</h3><blockquote><p>intnet</p></blockquote><ul><li><p>通用名词</p></li><li><p>互联网</p></li><li><p>任意通信协议</p></li></ul><blockquote><p>Internet</p></blockquote><ul><li>专有名词</li><li>因特网</li><li>TCP&#x2F;IP协议族</li></ul><h2 id="因特网简介"><a href="#因特网简介" class="headerlink" title="因特网简介"></a>因特网简介</h2><h3 id="因特网发展三个阶段"><a href="#因特网发展三个阶段" class="headerlink" title="因特网发展三个阶段"></a>因特网发展三个阶段</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292148425.png" alt="image-20230529214829332"></p><h3 id="因特网已发展为基于ISP的多层次结构的互连网络"><a href="#因特网已发展为基于ISP的多层次结构的互连网络" class="headerlink" title="因特网已发展为基于ISP的多层次结构的互连网络"></a>因特网已发展为基于ISP的多层次结构的互连网络</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292151514.png" alt="image-20230529215156452"></p><p>已经接入因特网的用户也可以成为一个ISP，只需要购买相关设备，如：调制解调器、路由器等</p><h3 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h3><ul><li>因特网标准化工作时面向公众的，其任何一个建议标准在成为因特网标准之前都以RFC技术文档的形式在因特网上发表</li><li>RFC的意思是请求评论，任何人都可以从因特网上免费下载RFC文档，并随时对某个RFC文档发表意见和建议</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292157751.png" alt="image-20230529215728689"></p><h3 id="因特网的管理机构"><a href="#因特网的管理机构" class="headerlink" title="因特网的管理机构"></a>因特网的管理机构</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292158161.png" alt="image-20230529215801115"></p><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292159608.png" alt="image-20230529215920553"></p><p>功能上简单地将其划分为两部分：核心部分, 边缘部分</p><ul><li>因特网的边缘部分由连接在英特网上的台式电脑服务器, 笔记本电脑, 平板电脑, 智能手机, 智能手表, 网络摄像头以及网络打印机等用户设备构成, 这些用户设备常称为主机, 由用户直接使用, 为用户直接提供各式各样的网络应用</li><li>因特网的核心部分由大量异构型网络和连接这些网络的路由器构成, 因特网的核心部分为其边缘部分提供联通性和数据交换等服务, 在网络核心部分起特殊作用的是路由器, 它是一种专用计算机, 但我们不称它为主机, 路由器是实现分组交换的关键构件, 其任务是转发收到的分组, 这是网络核心部分最重要的功能</li></ul><h1 id="1-3-电路交换、分组交换和报文交换"><a href="#1-3-电路交换、分组交换和报文交换" class="headerlink" title="1.3 电路交换、分组交换和报文交换"></a>1.3 电路交换、分组交换和报文交换</h1><p>电话交换机接通电话线的方式就是电路交换</p><p>使用电路交换进行通信，需要进行<strong>建立连接</strong>、<strong>通话</strong>、<strong>释放连接</strong>三个阶段</p><ul><li>建立连接, 也就是分配通信资源, 例如在使用电路交换打电话之前, 主叫方必须首先进行拨号, 以请求建立连接, 当被叫方听到电话交换机送来的振铃音, 并摘机后, 从主叫方到被叫方就建立了一条专用的物理通路, 简称为连接, 这条连接为通话双方提供了通信资源,</li><li>主叫方和被叫方现在可以基于已建立的连接进行通话了, 在整个通话期间, 通话双方始终占用着连接, 通信资源, 不会被其他用户占用, </li><li>通话完毕, 挂机后从主叫方到被叫方的这条专用物理通路被交换机释放, 将双方所占用的通信资源归还给电信网</li></ul><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292205193.png" alt="image-20230529220527126"></p><p><strong>计算机间的数据传输适合电路交换吗？</strong></p><p>计算机之间的数据传送是突发式的, 当使用电路交换来传送计算机数据时, 其线路的传输效率一般都会很低, 线路上真正用来传送数据的时间往往不到10%甚至1%，因此计算机网络通常采用分组交换</p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292213721.png" alt="image-20230529221352661"></p><p>路由器R1到R5 就是分组交换网中的交换节点</p><p>主机H1到H5 , 通过分组交换网进行通信</p><p>假设主机H1的用户要给主机H3 的用户发送一条消息, 通常我们把表示消息的整块数据称为一个报文, 较长的报文, 一般不适宜直接传输, 如果报文太长, 则对交换节点的缓存容量有很大的需求, 在错误处理方面也会比较低效, 因此需要将较长的报文划分成若干个较小的等长数据段, 在每个数据段前面添加一些有必要的控制信息组成的首部, 这样就构造出了一个个分组</p><p><strong>思考：添加首部的作用是什么？</strong></p><p>手部起着非常关键的作用, 首部中包含了分组的目的地址, 否则分组传输路径中的各交换节点就不知道如何转发分组了, 原主机将分组发送到分组交换网中, 分组交换网中的交换节点收到一个分组后, 先将其缓存下来, 然后从其首部中提取出目的地址, 按照目的地址查找自己的转发表, 找到相应的转发接口后, 将分组转发出去, 把分组交给下一个交换节点, 经过多个交换节点的存储转发后, 分组最终被转发到目的主机</p><h3 id="分组交换实例（H1到H3）"><a href="#分组交换实例（H1到H3）" class="headerlink" title="分组交换实例（H1到H3）"></a>分组交换实例（H1到H3）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292221565.png" alt="image-20230529222122484"></p><p>主机H1将分组逐个发送给与其直接相连的路由器R1 , 此时H1到R1的链路被占用, 而分组交换网中的其他链路并未被当前通信的双方占用</p><p>路由器R1对收到的分组进行存储转发, 假设R1根据分组首部中的目的地址, 查找自己的转发表的结果是下一跳为路由器R2 , 则R1转发分组给R2 </p><p>当分组正在R1与R2之间的链路上传送时, 仅占用R1与R2 这段链路, 而不会占用分组交换网中的其他资源, 路由器R2对收到的分组进行存储转发, 假设根据查表结果, 应转发给路由器R3 </p><p>路由器R3 对收到的分组进行存储转发, 将它们转发给主机H3 ,</p><p>在上述分组交换过程中：</p><ul><li>发送方所要完成的任务是构造分组和发送分组</li><li>交换节点所要完成的任务是缓存分组和转发分组, 简称为存储转发</li><li>接收方所要完成的任务是接收分组并还原成报文</li></ul><h2 id="分组交换优缺点"><a href="#分组交换优缺点" class="headerlink" title="分组交换优缺点"></a>分组交换优缺点</h2><p>优点：</p><ul><li>分组交换没有建立连接和释放连接的过程</li><li>分组传输过程中逐渐占用通信链路, 相比于采用电路交换传送突发式的计算机数据, 分组交换有较高的通信线路利用率</li><li>交换节点可以为每一个分组独立选择转发路由, 使得网络有很好的生存性</li></ul><p>缺点：</p><ul><li>分组首部带来了额外的传输开销</li><li>交换节点存储转发分组时会造成一定的时延</li><li>无法确保通信时端到端的通信资源全部可用, 在通信量较大时, 可能造成网络拥塞</li><li>分组可能出现失序和丢失等问题</li></ul><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><ul><li>报文交换是分组交换的前身</li><li>在报文交换中，报文被整个的发送, 而不是拆分成若干个分组进行发送</li><li>交换节点将报文整体接收完成后才能查找转发表, 将整个报文转发到下一个节点</li><li>因此报文交换比分组交换带来的转发时间要长很多, 需要交换节点具有的缓存空间也大很多</li></ul><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292230608.png" alt="image-20230529223057550"></p><ul><li>假设原主机和目的主机之间有两个交换节点, 纵坐标为时间</li><li>对于电路交换通信之前, 首先要建立连接, 成功建立连接之后, 就可以使用已建立的连接进行数据传送, 数据传送结束后需要释放连接, 将双方所占用的通信资源归还给电信网, </li><li>对于报文交换无需首先建立连接, 可以随时发送报文, 通信结束后也无需释放连接, 数据传送单元为整个报文传送路径中的交换节点, 只有在完整接收到整个报文后, 才能对其进行查表转发, 将整个报文发送到下一个节点</li><li>对于分组交换可以随时发送分组, 而不需要事先建立连接, 构成原始报文的一个个分组, 依次在各交换节点上存储转发, 各交换节点在转发分组的同时, 还缓存接收到的分组</li><li>当使用电路交换时, 一旦建立连接, 中间的各交换节点就是直通形式的数据可以直达终点</li><li>当使用报文交换时, 整个报文需要在各交换节点上存储转发, 由于不限制报文的大小, 因此需要各交换节点都具有较大的缓存空间</li><li>使用分组交换时, 构成原始报文的一个个分组, 在各交换节点上存储, 转发相比报文交换减少了转发时延, 还可以避免过长的报文长时间占用链路, 同时也有利于进行差错控制</li></ul><p>综上所述</p><ul><li>若要连续传送大量的数据, 并且数据传送时间远大于建立连接的时间, 则使用电路交换可以有较高的传输效率, 然而计算机的数据传送往往是突发式的, 采用电路交换通信线路的利用率会很低</li><li>报文交换和分组交换都不需要建立连接, 即预先分配通信资源, 在传送计算机的突发数据时, 可以提高通信线路的利用率</li><li>将报文构造成若干个更小的分组, 进行分组交换, 比将整个报文进行报文交换的时延要小, 并且还可以避免太长的报文长时间占用链路, 还有利于差错控制, 同时具有更好的灵活性</li></ul><h1 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h1><h2 id="现阶段计算机网络一个较好的定义"><a href="#现阶段计算机网络一个较好的定义" class="headerlink" title="现阶段计算机网络一个较好的定义"></a>现阶段计算机网络一个较好的定义</h2><ul><li>计算机网络主要是由一些通用的可编程的硬件互联而成的, 而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号） 这些可编程的硬件能够用来传送多种不同类型的数据, 并能支持广泛的和日益增长的应用<ul><li>注意<strong>可编程的硬件</strong>，表明这种硬件一定包含有中央处理单元CPU，所以计算机网络所连接的硬件，并不限于一般的计算机，还包括智能手机、具有网络功能的传感器，以及智能家电等</li><li>计算机网络并非只是用来传送数据，而是能够基于数据传送，进而实现各种各样的应用</li></ul></li></ul><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><blockquote><p>按交换方式分类</p></blockquote><p><strong>电路交换、分组交换、报文交换</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301032129.png" alt="image-20230530103242058"></p><blockquote><p>按使用者分类</p></blockquote><ul><li>公用网：通常是由电信公司出资建造的大型网络, 公众只要按照电信公司的规定缴纳费用, 就可以使用这种网络</li><li>专用网：由某个部门为满足本单位特殊业务的需要而建造的网络, 例如军队铁路, 电力银行等部门的专用网, 这种网络不向本单位以外的人提供服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301033944.png" alt="image-20230530103324878"></p><blockquote><p>按传输介质分类</p></blockquote><ul><li>有线网络：包括双绞线网络、光纤网络</li><li>无线网络：WiFi</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301034981.png" alt="image-20230530103440932"></p><blockquote><p>按覆盖范围分类</p></blockquote><ul><li>广域网（WAN）：几十到几千千米，可以覆盖一个国家地区, 甚至横跨几个洲，是因特网的核心部分，为因特网核心路由器提供远距离高速连接</li><li>城域网（MAN）：5到50千米，可以跨越几个街区, 甚至整个城市, 城域网通常作为城市骨干网, 互联大量机构企业以及校园局域网</li><li>局域网（LAN）：1千米左右，例如一个学生宿舍, 一栋楼或一个校园。局域网通常由微型计算机或工作站, 通过速率为十兆比特每秒以上的高速电路相连, 在过去一个企业或学校往往只拥有一个局域网, 而现在局域网已被广泛的应用, 一个企业或学校可能就会有多个互联的局域网, 这样的网络常称为校园网或企业网</li><li>个域网（PAN）：10米，把属于个人使用的笔记本电脑, 键盘, 鼠标, 耳机以及打印机等电子设备, 用wifi或蓝牙等无线技术连接起来的网络, 因此也常称为无线个域网（WPAN）</li></ul><blockquote><p>按拓扑结构分类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301044856.png" alt="image-20230530104419797"></p><ul><li>总线型：使用单根传输线把计算机连接起来, 其优点是建网容易、增减节点方便、节省线路, 缺点是重负载时通信效率不高, 总线任意一处出现故障则全网瘫痪</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301047615.png" alt="image-20230530104751576"></p><ul><li>星型网络：每个计算机都以单独的线路与中央设备相连, 中央设备早期是计算机, 后来是集线器, 现在一般是交换机或路由器。这种网络拓扑的优点是便于网络的集中控制和管理, 缺点是成本高, 中央设备对故障敏感</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301051320.png" alt="image-20230530105151276"></p><ul><li>环型网络：所有计算机的网络接口都连接成一个环, 最典型的例子是令牌环局域网, 环可以是单环, 也可以是双环, 环中信号是单向传输的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301055549.png" alt="image-20230530105510511"></p><ul><li>网状型：每个节点至少有两条路径与其他节点相连, 多用在广域网中, 其优点是可靠性高, 缺点是控制复杂, 线路成本高</li></ul><p><strong>说明：</strong>以上四种基本的网络拓扑还可以互联为更复杂的网络</p><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><ul><li>比特（bit，记为小写b）是计算机中数据量的基本单位，一个一个比特就是二进制数字中的一个1或0</li><li>数据量数据上的常用单位有字节（Byte，记为大写B）, 千字节（KB）, 兆字节（MB）, 吉字节（GB），太字节（TB）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301117686.png" alt="image-20230530111737626"></p><ul><li><p>速率是指指数据的传输速率（即每秒传送多少个比特）, 也称为数据率（Data Rate）或比特率（Bit Rate）</p></li><li><p>速率的基本单位是比特&#x2F;秒（bit&#x2F;s，可简记为b&#x2F;s，有时也可记为bps，即bit per second）。速率的常用单位有千比特每秒（kb&#x2F;s或kbps）, 兆比特每秒（Mb&#x2F;s或Mbps）, 吉比特每秒（Gb&#x2F;s或Gbps）, 太比特每秒（Tb&#x2F;s或Tbps）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301123175.png" alt="image-20230530112313126"></p><ul><li>数据量单位中的K、M、G、T的数值分别为$2^{10}$、$2^{20}$、$2^{30}$、$2^{40}$</li><li>速率单位中的k、M、G、T的数值分别为${10}^{3}$、${10}^{6}$、${10}^{9}$、${10}^{12}$。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301139131.png" alt="image-20230530113942056"></p><blockquote><p>练习：有一个待发送的数据块，大小为100MB，网卡的发送速率为100Mbps，则网卡发送完该数据块需要多长时间？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301146953.png" alt="image-20230530114615892"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><blockquote><p>带宽在模拟信号中的意义</p></blockquote><ul><li>某个信号所包含的各种不同频率成分所占据的<strong>频率范围</strong></li><li>单位：Hz（kHz，MHz，GHz）</li></ul><blockquote><p>带宽在计算机网络中的意义</p></blockquote><ul><li><p>用来表示网络的<strong>通信线路所能传送数据的能力</strong>，即在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong></p></li><li><p>单位：b&#x2F;s （kb&#x2F;s  Mb&#x2F;s  Gb&#x2F;s  Tb&#x2F;s）</p></li></ul><p>数据传送速率&#x3D;min{主机接口速率，线路带宽，交换机或路由器接口速率}</p><p>也就是有木桶效应</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301257444.png" alt="image-20230530125730363"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><ul><li>吞吐量是指在<strong>单位时间内通过某个网络或接口的实际数据量</strong>, 吞吐量常被用于对实际网络的测量, 以便获知到底有多少数据量通过了网络</li><li>吞吐量<strong>受网络带宽的限制</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301302042.png" alt="image-20230530130256972"></p><p>假设某用户接入因特网的带宽为100Mb&#x2F;s, 该用户同时进行：观看网络视频, 浏览网页, 以及给文件服务器上传文件</p><p>这三个网络应用：播放网络视频的下载速率为20Mb&#x2F;s，访问网页的下载速率为600kb&#x2F;s，向文件服务器上传文件的上传速率1Mb&#x2F;s</p><p>则网络吞吐量就是下载速率和上传速率的总和</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><ul><li>时延是指数据从网络的一端传送到另一端所耗费的时间, 也称为延迟或迟延, 数据可由一个或多个分组、甚至是一个比特构成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301311224.png" alt="image-20230530131139159"></p><ul><li><p>发送时延：原主机将分组发往传输线路花费的时间就叫做发送时延</p><ul><li>发送时延的计算公式为分组长度除以发送速率</li></ul></li><li><p>传播时延：代表分组的电信号在链路上传播所花费的时间就叫做传播时延</p><ul><li>传播时延的计算公式为信道长度除以信号传播速率</li></ul></li><li><p>排队时延：当分组进入路由器后, 会在路由器的输入队列中排队缓存并等待处理, 在路由器确定了分组的转发接口号, 分组会在输出队列中排队缓存, 并等待转发分组, 在路由器的输入队列和输出队列中，排队缓存所耗费的时间就是排队时延</p><ul><li>在分组从原主机传送到目的主机的过程中, 分组往往要经过多个路由器的转发, 分组在每个路由器上产生的排队时间的长短, 往往取决于网络当时的通信量和路由器的自身性能, 由于网络的通信量随时间变化很大, 各路由器的性能也可能并不完全相同, 因此排队时延一般无法用一个简单的公式进行计算, 另外当网络通信量很大时, 可能会造成路由器的队列溢出, 使分组丢失, 这相当于排队时延无穷大</li></ul></li><li><p>处理时延：路由器从自己的输入队列中取出排队缓存并等待处理的分组后, 会进行一系列处理工作, 例如检查分组的首部是否误码, 提取分组首部中的目的地址，为分组查找相应的转发接口, 以及修改分组首部中的部分内容, 例如生存时间等, 路由器对分组进行这一系列处理工作, 所耗费的时间就是处理时延</p><ul><li>与排队时延类似, 处理时间一般也无法用一个简单的公式进行计算</li></ul></li><li><p>对于本地分组经过路由器的转发传输到物理主机, 这又会耗费一个路由器的发送时延, 以及代表该分组的电信号在另一段链路上传播所耗费的传播时延</p></li></ul><p><strong>注意：</strong>为什么只有发送时延没有接收时延，因为发送和接收时同时进行的，计算时，只需计算一个就行，否则就加入了多余的时间</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301335867.png" alt="image-20230530133543794"></p><blockquote><p> 分析时延的图解方法</p></blockquote><p>主机A给主机B发送一个分组</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301341580.png" alt="image-20230530134155517"></p><p>主机A给主机B发送三个分组</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301342775.png" alt="image-20230530134249710"></p><p>主机A给主机B通过两个路由器发送四个分组</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301343795.png" alt="image-20230530134350717"></p><blockquote><p>真题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301402238.png" alt="image-20230530140218182"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301401217.png" alt="image-20230530140153150"></p><p>时延是发送时延占主导还是传播时延占主导？？？——具体情况具体分析</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301403328.png" alt="image-20230530140345275"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301404866.png" alt="image-20230530140404808"></p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2>]]></content>
    
    
    <categories>
      
      <category>计网湖科大</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络自顶向下第一章</title>
    <link href="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>注：第一章是最抽象的一章，拥有大量概念和从未见过的专有名词，初次阅读看不懂没有关系，后续章节会详细展开，第一章旨在让读者构建计算机网络知识体系的框架</strong></p><h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="1-1-什么是因特网？"><a href="#1-1-什么是因特网？" class="headerlink" title="1.1 什么是因特网？"></a>1.1 什么是因特网？</h2><p>回答什么是因特网这一问题</p><p>有两种回答方式：</p><ul><li>其一，我们能够描述因特网的具体构成，即构成因特网的基本硬件和软件组件</li><li>我们能够根据为分布式应用提供服务的联网基础设施来描述因特网</li></ul><p>先从描述因特网具体构成开始：</p><h3 id="1-1-1-具体构成描述"><a href="#1-1-1-具体构成描述" class="headerlink" title="1.1.1 具体构成描述"></a>1.1.1 具体构成描述</h3><blockquote><p>端系统</p></blockquote><p>因特网是一个互联了遍及全世界的数以亿计的计算设备的网络</p><p>这些设备有传统的桌面PC、Linux工作站以及所谓的服务器</p><p>以及非传统的因特网端系统（如便携机、智能手机、平板、电视、游戏机、汽车……）</p><p>所有这些设备都称为<strong>主机</strong>或<strong>端系统</strong></p><p>端系统通过通信链路和分组交换机连接到一起</p><blockquote><p>通信链路</p></blockquote><ul><li><p>通信链路有许多类型，它们由不推塔类型的物理媒体组成，包括同轴电缆、铜线、光纤和无线电频谱</p></li><li><p>不同的链路能够以不同的速率传输数据，链路的传输速率以比特&#x2F;秒度量（bit&#x2F;s ，或bps）</p></li></ul><blockquote><p>分组交换机</p></blockquote><ul><li>分组：当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包，用计算机网络的术语来说称为分组</li></ul><p>分组通过网络发送到目的端系统，在那里被装配成初始数据</p><p>分组交换机从它的一条入通信链路接受到达的分组，并从它的一条出通信链路转发该分组</p><ul><li>两种最著名的分组交换机：路由器和链路层交换机</li></ul><p>链路层交换机通常用于接入网中，路由器通常用于网络核心中</p><ul><li>路径：从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径</li></ul><blockquote><p>因特网服务提供商（ISP）</p></blockquote><p>端系统通过ISP接入因特网</p><p>每个ISP是一个由多个分组交换机和多段通信链路构成的网络</p><p>因特网将端系统彼此互联，因为端系统提供接入的ISP也必须互联。低层的ISP通过国家的、国际的高层ISP互联起来</p><blockquote><p>协议</p></blockquote><p>端系统、分组交换机、和其他因特网部件都需要运行一系列协议，协议控制因特网中信息的接收和发送</p><p>TCP（传输控制协议）和IP（网际协议）是因特网中两个最为重要的协议</p><p>IP协议定义了在路由器和端系统之间发送和接收分组的方式</p><p>因特网的主要协议统称为TCP&#x2F;IP</p><h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><p>从为应用程序提供服务的基础设施的角度来描述因特网</p><p>这些应用程序包括电子邮件、web冲浪、即时讯息、社交网络、IP语音、流式视频、分布式游戏、对等（P2P）文件共享、因特网电视、远程注册等</p><p>这些应用程序称为分布式应用程序，因为它们设计多态相互交换数据的端系统</p><p>运行在一个端系统上的应用程序怎样才能指令因特网向运行在另一个端系统上的软件发送数据呢？</p><ul><li>与因特网相连的端系统提供了一个应用程序编程接口（API）</li><li>该API规定了运行在一个端系统上的软件请求因特网基础设施项运行在另一个端系统上的特定目的地软件交付数据的方式</li><li>因特网API是一套发送软件必须遵循的规则集合</li></ul><h3 id="1-1-3-什么是协议"><a href="#1-1-3-什么是协议" class="headerlink" title="1.1.3 什么是协议"></a>1.1.3 什么是协议</h3><p>报文的交换以及发送和接收这些报文时所采取的动作是定义一个协议的关键元素：</p><ul><li>一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和&#x2F;或接收一条报文或其他事件所采取的动作</li></ul><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>端系统之所以被称为端系统是因为它们位于因特网的边缘</p><p>端系统也称主机，因为它们容纳（即运行）应用程序。</p><p>在本书中，主机&#x3D;端系统</p><p>主机有时被进一步分为两类：客户和服务器</p><ul><li>客户非正式地等同于桌面PC、移动PC和智能手机等</li><li>服务器非正式地等同于更为强大的机器，用于存储和发布Web页面、流视频、中继电子邮件等</li></ul><p>今天，大部分提供搜索结果、电子邮件、Web页面和视频的服务器都属于大型<strong>数据中心</strong>，许多数据中心都有10万台以上的服务器</p><h3 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h3><ul><li><p>接入网：将端系统连接到其<strong>边缘路由器</strong>的物理链路</p></li><li><p>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器</p></li></ul><h4 id="家庭接入：DSL、电缆、FTTH、拨号和卫星"><a href="#家庭接入：DSL、电缆、FTTH、拨号和卫星" class="headerlink" title="家庭接入：DSL、电缆、FTTH、拨号和卫星"></a>家庭接入：DSL、电缆、FTTH、拨号和卫星</h4><blockquote><p>DSL接入</p></blockquote><p>宽带住宅接入有两种最流行的类型：数字用户线（DSL）和电缆</p><p>住户通常从提供本地电话接入的本地电话公司处获得DSL因特网接入 ，因此，当使用DSL时，用户的本地电话公司也是它的ISP</p><p>每个用户的DSL调制解调器使用现有的电话线与位于本地电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）来交换数据</p><p>家庭的DSL调制解调器得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局，来自许多家庭的模拟信号在DSLAM处被转换会数字形式</p><p>家庭电话线同时承载了数据和传统的电话信号，它们编码为不同的频率：</p><ul><li>高速下行通道，位于50kHz到1MHz频段</li><li>中速上行通道，位于4kHz到50kHz频段</li><li>普通的双向电话信道，位于0到4kHz频段</li></ul><p>这种方法使单根DSL线路就像有3根单独的线路，因此一个电话呼叫和一个因特网连接能够同时共享DSL链路。</p><p>在用户一侧，一个分屏器把到达家庭的数据信号和电话信号分隔开来，并将数据信号转发给DSL调制解调器</p><p>在本地电话公司一侧，在本地中心局中，DSLAM把数据和电话信号分隔开，并将数据送往因特网中</p><p>数百甚至上千个家庭与同一个DSLAM相连</p><blockquote><p>电缆因特网接入</p></blockquote><p>电缆因特网接入，利用了有线电视公司现有的有线电视基础设施</p><p>电缆因特网接入需要特殊的调制解调器，称为电缆调制解调器，如同DSL调制解调器，电缆调制解调器通常是一个外部设备通过一个以太网端口连接到家庭PC</p><p>电缆因特网接入的一个重要特征是共享广播媒体。特别是由发送的每个分组向下行经每段链路到每个家庭，每个家庭发送的每个分组经上行信道向头端传输。</p><p>因此，如果几个用户同时经下行信道下载一个视频文件，每个用户接收视频文件的实际速率将大大地域电缆总计的下行速率</p><p>而另一方面，如果仅有很少的活跃用户进行Web冲浪，则每个用户都可以以下行速率的全部速率接收Web网页，因为用户们将很少在完全相同的时刻请求网页。</p><p>因为上行信道也是共享的，需要一个分布式多路访问协议来协调传输和避免碰撞</p><blockquote><p>光纤到户（FTTH）</p></blockquote><p>顾名思义，从本地中心局直接到家庭提供了一条光纤路径</p><h4 id="企业（和家庭）接入：以太网和WIFI"><a href="#企业（和家庭）接入：以太网和WIFI" class="headerlink" title="企业（和家庭）接入：以太网和WIFI"></a>企业（和家庭）接入：以太网和WIFI</h4><p>以太网用户使用双绞铜线与一台以太网交换机相连</p><p>使用以太网接入，用户通常以100Mbps速率接入以太网交换机，而服务器可能具有1Gbps甚至10Gbps的接入速率</p><p>在无线LAN环境中，无线用户从&#x2F;到一个接入点发送&#x2F;接收分组，该接入点与企业网连接（很肯包括有线以太网），该企业网再与有线因特网相连</p><p>一个无线LAN用户通常必须位于接入点的几十米的范围内</p><h4 id="广域无线接入：3G和LTE"><a href="#广域无线接入：3G和LTE" class="headerlink" title="广域无线接入：3G和LTE"></a>广域无线接入：3G和LTE</h4><p>智能手机等设备越来越多地用来在移动中访问互联网，这些设备应用了与移动电话相同的基础设施，通过蜂窝网提供商运营的基站来发送接收分组</p><p>与WIFI不同的是，一个用户仅需要位于基站的数万米（而不是几十米）范围内</p><h3 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h3>]]></content>
    
    
    <categories>
      
      <category>计网中科大郑烇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络自顶向下第三章</title>
    <link href="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计网中科大郑烇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库设计自学</title>
    <link href="/2023/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%AD%A6/"/>
    <url>/2023/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库需求与ER建模"><a href="#数据库需求与ER建模" class="headerlink" title="数据库需求与ER建模"></a>数据库需求与ER建模</h1><h2 id="ER建模基本构件"><a href="#ER建模基本构件" class="headerlink" title="ER建模基本构件"></a>ER建模基本构件</h2><ul><li><p>ER建模后得到的ER图是整个数据库的蓝图</p></li><li><p>实体和联系是ER图的两个基本构件</p></li><li><p>此次学习采用陈氏ER符号体系的修改版本</p></li></ul><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li><p>实体可以表示现实世界中的众多概念，如人、地点、对象、事件、项目等。</p></li><li><p>例如，一个零售公司的ER图可能包含顾客、商店、产品和交易额四个实体</p></li><li><p>ER图用矩形代表实体，实体名写在矩形里，同一个ER图中的不同实体应该有不同名字</p></li><li><p>每个实体包含多个<strong>实体实例&#x2F;实体成员</strong>，如实体CUSTOMER可能包含JOE,SUE,PAT等实例</p></li><li><p>实体本身需要画在ER图中，实体实例不需要表示在ER图中，会被记录到根据该ER图所创建的数据库之中</p></li></ul><h2 id="属性（唯一和非唯一）"><a href="#属性（唯一和非唯一）" class="headerlink" title="属性（唯一和非唯一）"></a>属性（唯一和非唯一）</h2><ul><li>ER图中每一个实体都有属性</li><li>实体的一个属性描述该实体的一种特征</li><li>实体属性表示每个实例需要记录的细节</li><li>例如，对实体CUSTOMER可以记录下下属性：编号、姓名、生日、性别</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211640744.png" alt="image-20230521164049678"></p><ul><li>唯一属性是指可以唯一标识实体实例的属性</li><li>通常来说，一个实体至少要有一个唯一属性</li><li>ER图中的唯一属性都带有下划线</li></ul><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><ul><li>ER图中每个实体必须通过联系至少与一个其他实体相关联</li><li>在ER图中联系表示为一个菱形，菱形与所有参与该联系的实体进行连线</li></ul><blockquote><p>基数约束</p></blockquote><p>基数约束用于表示实体可以有多少实例与另一实体的实例存在联系</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211645368.png" alt="image-20230521164507323"></p><p>每个基数约束包含以下两个部分：</p><ul><li>最大基数——靠近实体一端的基数约束部分</li><li>最小基数&#x2F;参与——原理实体一端的基数约束部分</li></ul><p>最大基数可以是：一个（表示为”|”）或多个（表示为”-&gt;”）</p><p>最小基数可以是：可选的（表示为”0”）或强制的（表示为”|”）</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211648283.png" alt="image-20230521164809225"></p><p><strong>注意：</strong>解释ER图中联系的合理方法，是利用矩形——菱形——基数约束——矩形规则分别从相反方向分两次来考虑这个关系</p><p>例如，联系Reports To就可以解释成：</p><ul><li>一个方向：矩形（职员)——菱形（做报告）——基数约束（有且仅有一个）——矩形（部门）</li><li>另一个方向：矩形（部门）——菱形（接受报告）——基数约束（从0到多个）——矩形（职员）</li></ul><h2 id="联系类型（最大基数侧）"><a href="#联系类型（最大基数侧）" class="headerlink" title="联系类型（最大基数侧）"></a>联系类型（最大基数侧）</h2><p>不考虑最小基数，仅考虑最大基数，则联系共有以下几种情况：</p><ul><li>一对一联系（1：1）</li><li>一对多联系（1：M）</li><li>多对多联系（M：N）</li></ul><p>下图省略了最小基数</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211653508.png" alt="image-20230521165345455"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211654558.png" alt="image-20230521165433480"></p><h2 id="联系和联系实例"><a href="#联系和联系实例" class="headerlink" title="联系和联系实例"></a>联系和联系实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305212301779.png" alt="image-20230521230110613"></p><ul><li>如图，当一个实体的实例通过联系与另一个实体的实例相关联时，一个联系实例就产生了</li><li>像实体和实体实例的情况一样，联系本身会被画进ER图，联系实例则不需要表示在ER图中，但会被记录到根据该ER图所创建的数据库中</li></ul><h2 id="联系属性"><a href="#联系属性" class="headerlink" title="联系属性"></a>联系属性</h2><p>许多情况下，多对多联系有自己的属性，这些属性就是联系属性</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305212338356.png" alt="image-20230521233807185"></p><p>图中最后一条需求表明，一个学生在不同的校园组织中可以有多个不同的职能。若将职能（Function）作为实体STUDENT的一个或多个属性，则无法知道某个职能是该学生在哪个社会组织中的职能。若将职能作为ORGANIZAATION的一个或多个属性，又无法知道某个职能是该学生在哪个社会组织中的职能，若将职能作为ORFANIZATION的一个或多个属性，又无法知道该社会组织的某职能具体由哪个学生来担任。</p><p>因此，职能属性唯一恰当的位置时作为BelongsTo联系的属性</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305212341848.png" alt="image-20230521234154719"></p><p>接下来讨论1：1联系与1：M联系是否也可以拥有属性，结合上面两个ER图给出答案，这两个图的需求如下：</p><ul><li>数据库记录学生和学院信息</li><li>对每个学生记录其姓名和唯一学号</li><li>对每个学院记录其唯一名称和位置</li><li>每个学生必须且只能加入一个学院</li><li>每个学院有多个学生</li><li>对每个学生记录其注册进入学院的日期</li></ul><p>图2-12的上半部分给出了1：M联系的属性。下半部分基于同样的需求，但将学生的注册日期作为实体STUDENT的属性StudentCollSdate，而不是作为联系Attends的属性DateStarted，由于一个学生只能加入一个学院，因此该学生加入该学院的日期可以作为STUDENT实体本身的一个属性，如本例所述，1：M联系的一个属性可转化为在该联系中最大基数为1的实体属性（本例中的STUDENT）。更一般地讲，联系属性可以转化为在该联系中最大基数为1的实体属性。</p><p><strong>因此，1：M或1：1联系的属性都不是必要的，相反，对一些M：N联系来说，属性是必要的</strong></p><h2 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h2><ul><li>复合属性是若干属性的组合</li><li>图2-14中，属性CUSTFULLNAME由两个部分组成：属性CustFName和属性CusrLName</li><li>复合属性用于表示由若干单个属性组成的属性集合拥有新含义的情况</li><li><strong>注意：</strong>CustFullName不是实体CUSTOMER的额外属性，它仅仅表示将名字和姓氏结合起来以后所得到的完整的顾客姓名</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220924232.png" alt="image-20230522092453170"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220927029.png" alt="image-20230522092746962"></p><h2 id="复合的唯一属性"><a href="#复合的唯一属性" class="headerlink" title="复合的唯一属性"></a>复合的唯一属性</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220928407.png" alt="image-20230522092809363"></p><p>图2-17中，教学楼（Building）、房间号（RoomNumebr）、座位数（Numeber of seats）、是实体CLASSROOM的三个属性，但它们都不唯一</p><p>CLASSROOM实体的需求表示如下：</p><ul><li>同一栋教学楼中可以有多个教室</li><li>可以有多个教室拥有相同的房间号（如A教学楼的111房间与B教学楼的111房间）</li><li>可以有多个监视拥有相同的座位数</li></ul><p>由于三个属性都不唯一，而教学楼和房间号两个属性的结合却是唯一，因此，这两个属性组成的复合属性可以作为唯一属性</p><h2 id="多个唯一属性（候选码）"><a href="#多个唯一属性（候选码）" class="headerlink" title="多个唯一属性（候选码）"></a>多个唯一属性（候选码）</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220935289.png" alt="image-20230522093515243"></p><ul><li>图2-18给出的实体同时拥有多个唯一属性，这里的每个唯一属性就叫做一个候选码</li><li>候选的意义在于：这些属性都可以作为构建整个数据库时主要区别属性（或称主码）的备选</li></ul><h2 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h2><ul><li><p>多值属性用于实体实例的统一属性可以有多个不同取值的情况</p></li><li><p>图2-20给出一个有多只属性的实体例子</p></li><li><p>表示多值属性的椭圆外画有双线</p></li><li><p>图2-20的情景：对于每个职员，需要记录若干个联系电话，某职员可能有两个联系电话，而有些职员可能有多于两个的联系电话</p></li><li><p>但如果对每个职员都记录两个联系电话，则不需要使用多值属性，只要分别使用两个单值属性就可以了</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220938059.png" alt="image-20230522093859015"></p><h2 id="派生属性"><a href="#派生属性" class="headerlink" title="派生属性"></a>派生属性</h2><ul><li>派生属性是非永久存于数据库的属性，派生属性的值可以从别的属性值或其他数据（如当前日期）派生出来</li><li>图2-22给出一个含派生属性的例子</li><li>派生属性用虚线的椭圆标识，属性Opening-Date作为一个常规属性会存于最终的数据库中，YearsInBuiness作为一个派生属性不会存于数据库中，而是从商店的OpeningDate及当前日期中派生出来</li><li>如果Yearbusiness是一个常规属性，其值将存于数据库中且需要人工更新，否则数据库将出现错误信息，而将YearsInBusiness作为派生属性后，就可以确保数据库以后将属性作为一个公式，用于得到正确的当前YearsInBusiness的属性值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220956559.png" alt="image-20230522095637513"></p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><ul><li>对每个实例，实体的大部分属性都有相应的取值，但有的属性也可能没有取值，这些属性就是可选属性</li></ul><p>图2-24给出一个可选属性的例子，表示了如下需求：</p><ul><li>对每个职员记录其唯一的编号（employee ID）及其薪水（salary）和年终奖（annual bonus），但并非所有职员都有年终奖</li></ul><p>在属性名后加一个带括号的大写字母O来表示可选属性</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221006226.png" alt="image-20230522100607185"></p><h2 id="联系中最小基数和最大基数确切值"><a href="#联系中最小基数和最大基数确切值" class="headerlink" title="联系中最小基数和最大基数确切值"></a>联系中最小基数和最大基数确切值</h2><p>在某些情况下，联系中的最小基数和最大基数确切值时事先知道的。本学习材料中，用圆括号括起来的一对数表示最小基数和最大基数，括号内的第一个数表示最小基数，第二个数表示最大基数</p><p>图2-26所示，对于联系EnrollsIN，需求如下：</p><ul><li>每名学生必须选择最少2门最多6门课程，且一门课程要有最少5名最多40名学生</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221015156.png" alt="image-20230522101504108"></p><p>本书中，当需要用圆括号括起来的数对表示最小和最大基数时，即使它们中的一个是不确定的值，我们仍需要将两个值（最小值和最大值）都表示出来，如图2-27所示，对于联系EnrollsIN，需求如下：</p><ul><li>每名学生最多选择6门课程，也可以不选任何课程。一门课程必须要有至少5名学生，选课人数没有上限</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221024889.png" alt="image-20230522102422828"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221025030.png" alt="image-20230522102520979"></p><h2 id="一元联系和联系的角色"><a href="#一元联系和联系的角色" class="headerlink" title="一元联系和联系的角色"></a>一元联系和联系的角色</h2><ul><li><p>联系的度：表示有多少个实体参与到该联系中</p></li><li><p>度为1的联系也称为一元联系或者递归联系</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221027353.png" alt="image-20230522102755311"></p><p>图2-28展示三个一元联系例子</p><p>例A需求：</p><ul><li>一个客户可以推荐多个客户，也可以不推荐任何客户，每个客户可以由另一个客户推荐或者没有被任何客户推荐</li></ul><p>例B需求：</p><ul><li>一个雇员可以指导许多雇员，也可以不指导任何雇员。一个雇员可以被多个雇员指导，也可也不被任何雇员指导</li></ul><p>例C需求：</p><ul><li>在一个赠送礼物活动数据库中，每个人只能向另一个人赠送礼物，每一个人也只能收到另一个人的礼物</li></ul><p>在ER图中，联系角色可以表达额外的语义信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能复习</title>
    <link href="/2023/05/18/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/18/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-经典逻辑推理"><a href="#第三章-经典逻辑推理" class="headerlink" title="第三章 经典逻辑推理"></a>第三章 经典逻辑推理</h1><h2 id="逻辑基础"><a href="#逻辑基础" class="headerlink" title="逻辑基础"></a>逻辑基础</h2><h3 id="谓词相关"><a href="#谓词相关" class="headerlink" title="谓词相关"></a>谓词相关</h3><ul><li><p>如果谓词公式P对非空个体域D上任一解释都取真值T，则称P在D上是永真的，如果P在任何非空个体域上均永真，则称P永真</p></li><li><p>如果谓词公式P对非空个体域D上至少存在一种解释，使得在此解释下取真值T，则称P在D上是可满足的</p></li><li><p>如果谓词公式P对非空个体域D上任一解释都取真值F，则称P在D上是永假的，如果P在任何非空个体域上均永假，则称P永假</p></li><li><p>前束范式</p></li></ul><p><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20230520220652414.png" alt="image-20230520220652414"></p><ul><li>Skolem范式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202208444.png" alt="image-20230520220736134"></p><h3 id="等价公式"><a href="#等价公式" class="headerlink" title="等价公式"></a>等价公式</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181606818.png" alt="image-20230518160610749"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181606323.png" alt="image-20230518160618291"></p><h3 id="永真蕴含式"><a href="#永真蕴含式" class="headerlink" title="永真蕴含式"></a>永真蕴含式</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181608797.png" alt="image-20230518160818726"></p><h3 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h3><p>代换可以简单理解为在一个谓词公式中用项替换变元</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181618926.png" alt="image-20230518161826867"></p><blockquote><p>例子</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181623949.png" alt="image-20230518162330903"></p><p>代换的目的是使某些变元被另外的变元、常数或者函数取代，让它不再在公式中出现</p><p>代换可以作用在谓词公式上，也可以作用在项上</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181629605.png" alt="image-20230518162941561"></p><h4 id="题型一、求代换的复合"><a href="#题型一、求代换的复合" class="headerlink" title="题型一、求代换的复合"></a>题型一、求代换的复合</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181638865.png" alt="image-20230518163858814"></p><p>生成代换，也就是把t1里面可用namida里面代换的代换掉</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181639941.png" alt="image-20230518163908904"></p><p>第一步生成代换，f(y)namida&#x2F;x，就在namida里找到可以代换f(y)里的，也就是b代换y，其他照写</p><h3 id="合一"><a href="#合一" class="headerlink" title="合一"></a>合一</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181710262.png" alt="image-20230518171011217"></p><blockquote><p>最一般合一</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181711051.png" alt="image-20230518171120001"></p><h4 id="题型二、求最一般合一"><a href="#题型二、求最一般合一" class="headerlink" title="题型二、求最一般合一"></a>题型二、求最一般合一</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181713566.png" alt="image-20230518171311514"></p><p>差异集求法</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181713134.png" alt="image-20230518171348085"></p><p>范例</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181715933.png" alt="image-20230518171510887"></p><p>判断是否可合一</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181726600.png" alt="image-20230518172624552"></p><p>如果差异集中不存在变元，则公式集不可合一</p><p>如果差异集中变元出现在项中，则公式集不可合一</p><h2 id="自然演绎推理"><a href="#自然演绎推理" class="headerlink" title="自然演绎推理"></a>自然演绎推理</h2><blockquote><p>推理的三个规则</p></blockquote><ul><li>P规则，在推理的任何步骤上都可以引入前提</li><li>T规则，如果前面步骤中有一个或多个公式永真蕴含公式S，则可以把S引入推理过程中</li><li>CP规则，如果能从R和前提集合中推导出S，则可以从前提集合推导出R–&gt;S</li></ul><h2 id="归结演绎推理"><a href="#归结演绎推理" class="headerlink" title="归结演绎推理"></a>归结演绎推理</h2><h3 id="字句集及其化简"><a href="#字句集及其化简" class="headerlink" title="字句集及其化简"></a>字句集及其化简</h3><ul><li><p>不含有任何连接词的谓词公式称为原子谓词公式</p></li><li><p>原子谓词公式及其否定统称为文字</p></li><li><p>任何文字的析取式称为子句</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202216649.png" alt="image-20230520221629604"></p><ul><li>不包含任何文字的子句称为空子句</li></ul><p>由于空子句不含有任何文字，它不能被任何解释满足，所以空子句是永假式，是不可满足的。空子句一般记为NIL</p><ul><li>由子句或空子句构成的集合称为子句集</li></ul><p><strong>子句集怎么化简？</strong></p><p>步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202219321.png" alt="image-20230520221919262"></p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202219693.png" alt="image-20230520221955638"></p><p>重点关注：怎么消去存在量词，怎么消去全称量词</p><h3 id="Robinson归结原理"><a href="#Robinson归结原理" class="headerlink" title="Robinson归结原理"></a>Robinson归结原理</h3><p><strong>最重要的知识点和考点</strong></p><p>鲁滨孙归结原理的基本思想是：检查子句集S中是否能归结或包含空子句，若能归结出空子句，则S不可满足；若不包含空子句，则S可以满足</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C51之点亮LED灯</title>
    <link href="/2023/05/17/C51%E4%B9%8B%E5%AE%9E%E7%8E%B0LED%E7%81%AF%E6%98%8E%E4%BA%AE/"/>
    <url>/2023/05/17/C51%E4%B9%8B%E5%AE%9E%E7%8E%B0LED%E7%81%AF%E6%98%8E%E4%BA%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="首要问题"><a href="#首要问题" class="headerlink" title="首要问题"></a>首要问题</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171640961.png" alt="image-20230517164032899"></p><ul><li><p>首先找到单片机上LED灯元件的位置，发现在74HC573上，74HC573是典型的锁存器芯片</p></li><li><p>D0<del>D7为数据输入，Q0</del>Q7为数据输出。Output Enable（OE）为输出使能端， Latch Enable（LE）为锁存使能端</p></li><li><p>OE为高电平时，无论LE与D端为何种电平状态，其输出都为高阻态，此时芯片处于不可控状态。所以在设计电路是我们直接将Output Enable接地，也就是74HC573一直处于输出使能状态</p></li><li><p>当OE为低电平，且LE为高电平时，D与Q同时为H或L。当LE为低电平时，无论D为何种电平，Q都保持上一次的数据状态。</p></li><li><p>即LE为高电平时，锁存器解锁，接受输入并原样输出，LE为低电平时，锁存器上锁，输出保持上一次的数据状态不变</p></li><li><p>而在此51单片机上想要使LED灯亮，首先要给74HC573解锁，要给74HC573解锁，也就是要让LE端为高电平，在此单片机上，也就是要Y4C为高电平（需求一）</p></li><li><p>然后使输出端为低电平，即为0，也就是要输入端为0，也就是P0寄存器的相应位要为0（需求二）</p></li></ul><h2 id="解决需求"><a href="#解决需求" class="headerlink" title="解决需求"></a>解决需求</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171746507.png" alt="image-20230517174652454"></p><ul><li>此图是Y4C的来源，怎么让Y4C为高电平呢？</li><li>74HC02是四路二输入或非门即Y&#x3D;(A或B)的非,要使Y4C为高电平，首先跳线选23，使得WR接地，为低电平，因此，Y4也应为低电平</li></ul><p>对此处J13做一下说明</p><ul><li>该开发板有两种编程模式，由J13这个跳线控制，当2-3短接的时候，是I&#x2F;O编程；当2-1短接的时候，编程模式为MM编程(存储器映射)。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202122160.png" alt="image-20230520212216044"></p><p>怎么样使Y4为低电平？</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305172147649.png" alt="image-20230517214709590"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305172152262.png" alt="image-20230517215224207"></p><ul><li>为了使Y4为低电平，要使38译码器输入为011，也就是把P2^5 , P2^6, P2^7设置为001</li></ul><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC15F2K60S2.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_led.h&quot;</span></span><br><br><span class="hljs-comment">//下面的sbit只有在操作某一个位时，才需前缀</span><br>sbit LED_0 = P0^<span class="hljs-number">0</span>;<br>sbit LED_1 = P0^<span class="hljs-number">1</span>;<br>sbit LED_2 = P0^<span class="hljs-number">2</span>;<br>sbit LED_3 = P0^<span class="hljs-number">3</span>;<br>sbit LED_4 = P0^<span class="hljs-number">4</span>;<br>sbit LED_5 = P0^<span class="hljs-number">5</span>;<br>sbit LED_6 = P0^<span class="hljs-number">6</span>;<br>sbit LED_7 = P0^<span class="hljs-number">7</span>;<br><br><span class="hljs-comment">//使P0=1111 1110，打开led_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">open_led_0</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  unlock_74HC573();  <br>P0 = <span class="hljs-number">0xfe</span>;<br>&#125;<br><br><br><span class="hljs-comment">//解锁74hc573锁存器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock_74HC573</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    P25 = <span class="hljs-number">0</span>;<br>  P26 = <span class="hljs-number">0</span>;<br>  P27 = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>open_led_0();<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC15F2K60S2.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_led.h&quot;</span></span><br><br><br><br><span class="hljs-comment">//使P0=1111 1110，打开led_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">open_led_0</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  unlock_74HC573();  <br>P0 = <span class="hljs-number">0xfe</span>;<br>&#125;<br><br><br><span class="hljs-comment">//解锁74HC573锁存器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock_74HC573</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    P25 = <span class="hljs-number">0</span>;<br>P26 = <span class="hljs-number">0</span>;<br>P27 = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//锁上74HC573锁存器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_74HC573</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    P2 &amp;= <span class="hljs-number">0x1f</span>;<br>&#125;<br><br><span class="hljs-comment">//关闭所有led灯</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">close_led</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    unlock_74HC573();  <br>  P0 = <span class="hljs-number">0xff</span>;<br>  lock_74HC573();<br>&#125;<br><br><span class="hljs-comment">//延时函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1000ms</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;<br><br>_nop_();<br><span class="hljs-comment">/*_使用_nop_()函数（可理解为软件延时）时，必须在开头添加头文件#include&lt;intrins.h&gt;</span><br><span class="hljs-comment">_nop_()函数相当于一个空操作（可以理解为NOP空操作指令）*/</span><br>i = <span class="hljs-number">8</span>;<br>j = <span class="hljs-number">1</span>;<br>k = <span class="hljs-number">243</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--k);<br>&#125; <span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>&#125;    <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>open_led_0();<br>delay1000ms();<br>close_led();<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
      <category>C51</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理第三章</title>
    <link href="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章、存储系统"><a href="#第三章、存储系统" class="headerlink" title="第三章、存储系统"></a>第三章、存储系统</h1><h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171101543.png" alt="image-20230517110154486"></p><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20230517092019116.png" alt="image-20230517092019116"></h3><h4 id="主存及以上"><a href="#主存及以上" class="headerlink" title="主存及以上"></a>主存及以上</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305170921241.png" alt="image-20230517092153197"></p><ul><li><p>在辅存里的数据，只有调入到主存之后才可以被cpu访问</p></li><li><p>主存和cpu所连接的这两个箭头就是指cpu可以直接从主存读数据也可以直接向主存写数据</p></li><li><p>Cache（高速缓冲存储器），主存的数据会被放到Cache当中然后cpu可以直接往Cache写数据和读数据，另外cash里被更改的数据也会被写回主存</p></li></ul><p><strong>增加这样的一层高速缓冲存储器有什么作用？</strong></p><p>主存的读写速度已经很快了<br>但是主存的读写速度<br>远远跟不上cpu的运算速度<br>为了缓解这种速度矛盾<br>通常计算机硬件会把当前有可能被频繁访问的代码数据从主存复制一份到Cache当中<br>然后cpu可以直接读取Cache当中的这个副本数据</p><ul><li><p>寄存器，寄存器的读写速度又要比Cache快得多，所以cpu在进行加减乘除之类的运算的时候，会把操作数先放到寄存器里面，cpu内部包含的寄存器数量是很有限的</p></li><li><p>总之越靠近上层存储器，速度越快，容量越小<br>造价也越高</p></li><li><p>主存和辅存之间的这些数据的交换是由硬件加上操作系统实现</p></li><li><p>操作系统需要负责实现页面置换算法<br>根据页面置换算法可以决定要把哪些数据从主存换出到外存</p></li><li><p>所以主存和辅存之间的数据交换<br>需要系统程序员关心</p></li><li><p>主存和Cache之间的数据交换<br>通常是由硬件自动完成的<br>所有的软件程序员都不需要关心<br>主存和Cache之间的数据交换如何实现<br>这部分是由硬件工程师来实现</p></li><li><p>主存——辅存：实现了虚拟存储系统，解决了主存容量不够的问题</p></li></ul><p><em>应用程序员所看到的这个储存的容量可以比它实际的容量要大得多,这就是虚拟的意思</em></p><ul><li>Cache——主存：解决了主存与CPU速度不匹配的问题</li></ul><h4 id="辅存、外存"><a href="#辅存、外存" class="headerlink" title="辅存、外存"></a>辅存、外存</h4><p>电脑里的机械硬盘也就是磁盘<br>它就是属于辅存</p><p>磁带、光盘、u盘<br>这些又属于外存<br>那有的教材当中会把安装在电脑内部的磁盘或者固态硬盘称为辅存<br>然后把u盘光盘这些称为外存</p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><blockquote><p>按照层次结构来分类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171013880.png" alt="image-20230517101345827"></p><blockquote><p>可以按照存储介质来分类</p></blockquote><ul><li><p>第一类存储器就是半导体存储器（主存、Cache）</p><ul><li>这一类的存储器读写速度通常要快一些</li></ul></li><li><p>磁性材料存储信息的存储器（软盘、磁盘、磁带）</p></li><li><p>光存储器，以光介质来存储信息（光盘、DVD、VCD)</p></li></ul><blockquote><p>按照存取方式分类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171034434.png" alt="image-20230517103403334"></p><ul><li><p>随机存取存储器(Random Access Memory,RAM)：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关</p><ul><li>内存条</li></ul></li><li><p>顺序存取存储器（Sequential Access Memory，SAM）：读写一个存储单元所需时间取决于存储单元所在的物理位置</p><ul><li>比如复读机用的磁带</li><li>复读机或者录音机会有一个磁头来读写磁带里边存放的数据，比如说磁头在中间这个位置，那么这个磁带中间的轴转动的时候，这个词条会划过读写磁头，可以读出里面存储的数据，如果现在这个读写磁头，要读取的是这个磁带后半部分的一段数据的话，需要让这个磁带一直转转转转，让这一段划过读写磁头才可以进行读写</li><li>读取存储单元里面所存储的数据的和存储单元的物理位置是有关</li></ul></li><li><p>直接存取存储器（Direction Access Memory, DAM)：既有随机存取特性，也有顺序存取特性，先直接选取信息所在区域，然后按顺序方式存取</p><ul><li>磁盘</li><li>它的读写速度要比顺序存取的这种存储器要更快，但是要比随机存取存储器要更慢</li></ul></li><li><p>顺序存取存储器和直接存取存储器可以被归为<strong>串行访问存储器</strong>：读写某个存储单元所需时间与存储单元的物理位置有关</p></li><li><p>这三种类型的存储器，都是我们要指明一个读写的地址。然后进行读取</p></li><li><p>还有一种存储器的存储方式不太一样，叫做相联存储器，也可以称为按内容访问的存储器，英文缩写叫CAM</p><ul><li>快表就是一种相联存储器</li></ul></li><li><p>下面三种是按照地址来访问<br>上面这种是按照内容来访问好</p></li></ul><blockquote><p>按照信息的可更改性分类</p></blockquote><ul><li><p>读写存储器——可读、可写（磁盘、内存、Cache）</p></li><li><p>只读存储器（ROM）——只能读、不能写（实体音乐专辑CD-ROM，实体电影采用蓝光光碟，BIOS写在ROM中）</p></li></ul><blockquote><p>按照信息的可保存器进行分类</p></blockquote><ul><li><p>断电后，存储信息消失的存储器——易失存储器（主存、Cache）</p></li><li><p>断电后，存储信息依然保持的存储器——非易失性存储器（磁盘、光盘）</p></li><li><p>信息读出后，原存储信息被破坏——破坏性读出（DRAM芯片，读出数据后要进行重写）</p></li><li><p>信息读出后，原存储信息不会被破坏——非破坏性读出（SRAM芯片、磁盘、光盘）</p></li></ul><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><ul><li>存储容量：存储字数*存储字长</li><li>单位成本：每一个比特位价格&#x3D;总成本&#x2F;总容量</li><li>存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171058581.png" alt="image-20230517105820508"></p><ul><li><p>存取时间：从启动一次存储器操作到完成该操作所经历的世界，分为读出时间和写入时间</p></li><li><p>存取周期：存取周期又称为读写周期或访问周期，它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作之间所需的最小时间间隔</p></li><li><p>主存带宽（Bm）:又称数据传输率，表示每秒从主存进出信息的最大数量</p></li></ul><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h3><h3 id="存储芯片的基本原理"><a href="#存储芯片的基本原理" class="headerlink" title="存储芯片的基本原理"></a>存储芯片的基本原理</h3><h3 id="如何实现不同的寻址方式"><a href="#如何实现不同的寻址方式" class="headerlink" title="如何实现不同的寻址方式"></a>如何实现不同的寻址方式</h3><h2 id="SRAM和DRAM"><a href="#SRAM和DRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h2><h2 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h2><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><h2 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h2><h2 id="固态硬盘SSD"><a href="#固态硬盘SSD" class="headerlink" title="固态硬盘SSD"></a>固态硬盘SSD</h2><h2 id="Cache的基本概念和原理"><a href="#Cache的基本概念和原理" class="headerlink" title="Cache的基本概念和原理"></a>Cache的基本概念和原理</h2><h2 id="Cache和主存的映射方式"><a href="#Cache和主存的映射方式" class="headerlink" title="Cache和主存的映射方式"></a>Cache和主存的映射方式</h2><h2 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h2><h2 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h2><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2>]]></content>
    
    
    <categories>
      
      <category>王道计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王道计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理第二章</title>
    <link href="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章、数据的表示和运算"><a href="#第二章、数据的表示和运算" class="headerlink" title="第二章、数据的表示和运算"></a>第二章、数据的表示和运算</h1><h2 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232026210.png" alt="image-20230523202651151"></p><h3 id="基本运算部件（ALU）"><a href="#基本运算部件（ALU）" class="headerlink" title="基本运算部件（ALU）"></a>基本运算部件（ALU）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305162110570.png" alt="image-20230516210920389"></p><blockquote><p>抽象ALU结构图（左下）</p></blockquote><ul><li><p>左边A右边B这两个指的是输入信号, 就比如说想实现两个八比特二进制数的加法, 其中一个数是从a端输入,另一个数是从b端输入, 输入的本质是一些电信号, 也就是高低电平, 这是两个需要进行运算的数</p></li><li><p>F指的是输出信号, 也就是运算结果是从这一端输出的, 两个八比特的数相加, 得到一个新的八比特的数, 从这一端输出</p></li><li><p>K端是控制信号, 控制信号是由控制单元CU发出的</p></li></ul><blockquote><p>具象ALU例子</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305162121576.png" alt="image-20230516212140542"></p><ul><li><p>74181是这块芯片的一个型号, 这块芯片就是一个很经典的四位的ALU</p></li><li><p>右边S1到S3 , 还有M是来自cu控制单元的控制信号, 控制单元会负责解析指令的含义,CU解析完指令之后, 会根据这个指令的含义发出一些控制信号, 就是一些0101的电信号, 那如果和这块芯片配合工作, CU需要发出这样的五个信号, 每个信号就是一个高低电平</p></li><li><p>这里的电信号M是用来指明, 当前ALU要执行的是一个逻辑运算, 还是一个算术运算, M&#x3D;1的时候表示这是一个逻辑运算, M&#x3D;0的时候表示这是一个算术运算</p></li><li><p>另外S0 到S3 , 这几个信号可以用来指明, 此次要进行的是哪一种算术运算, 哪一种逻辑运算，由于总共有四个比特的信息, 也就是可以对应16种状态, 因此这块芯片它可以支持16种算术运算, 和16种逻辑运算</p></li><li><p>A B F这几个部分, 和刚才的抽象图示能够对应上, 那A和B就是两个四比特的数据, 输入两个四比特的数据, 然后ALU经过加减乘除之类的运算之后, 会有一个四比特的输出F</p></li><li><p>机器字长的真面目, 就是ALU里边, 它可以支持同时输入多少个比特的信息, 这就是机器字长的本质</p></li><li><p>一般来说ALU可以处理多少比特的数据, 就会把这些寄存器的位数和ALU保持一致, 目的是让寄存器和ALU能够完美的适配</p></li></ul><h3 id="最基本的逻辑运算"><a href="#最基本的逻辑运算" class="headerlink" title="最基本的逻辑运算"></a>最基本的逻辑运算</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305231953257.png" alt="image-20230523195321134"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305231955961.png" alt="image-20230523195522910"></p><h3 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232005115.png" alt="image-20230523200522069"></p><h3 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h3><p> <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232014618.png" alt="image-20230523201433573"></p><p>串行加法器：只有一个全加器，数据逐位送入加法器中进行运算，进位触发器用来寄存进位信号，以便参与下一次运算</p><p>如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器</p><h3 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232019109.png" alt="image-20230523201921063"></p><p>串行进位的并行加法器：把n个全加器串接起来，就可以进行两个n位数的相加。串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的</p><p>多个全加器简单串联，可多位同时加</p><p>计算速度取决于进位产生和传递的速度</p><p><strong>如何更快的产生进位？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232045043.png" alt="image-20230523204516986"></p><h3 id="并行进位的并行加法器"><a href="#并行进位的并行加法器" class="headerlink" title="并行进位的并行加法器"></a>并行进位的并行加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232051132.png" alt="image-20230523205142077"></p><p>但是逻辑表达式C5,C6…随着套娃会导致电路越来越复杂，一般到四位并行进位就为止了</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232052590.png" alt="image-20230523205254546"></p>]]></content>
    
    
    <categories>
      
      <category>王道计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王道计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理第一章</title>
    <link href="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章、计算机系统概述"><a href="#第一章、计算机系统概述" class="headerlink" title="第一章、计算机系统概述"></a>第一章、计算机系统概述</h1><h2 id="1-1计算机发展"><a href="#1-1计算机发展" class="headerlink" title="1.1计算机发展"></a>1.1计算机发展</h2><h3 id="每一代的计算机的逻辑元件更替"><a href="#每一代的计算机的逻辑元件更替" class="headerlink" title="每一代的计算机的逻辑元件更替"></a>每一代的计算机的逻辑元件更替</h3><ul><li>第一代是采用电子管作为逻辑元件, 耗电量高, 体积大</li><li>第二代采用晶体管作为逻辑元件, 体积比电子管更小, 同时也更省电</li><li>而第三代的计算机是采用了中小规模集成电路, 其实就是把晶体管啊, 电容啊之类的这些元器件, 把这些电子元器件, 高密度的集成在了一个电路板上,</li><li>那随着集成电路制造工艺的一个提升, 就出现了第四代的计算机, 也就是采用大规模超大规模集成电路,</li></ul><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><h4 id="两种结构"><a href="#两种结构" class="headerlink" title="两种结构"></a>两种结构</h4><ul><li>第一种是早期的冯诺依曼结构,</li><li>另一种是现代计算机所普遍采用的结构, 其实也是冯诺依曼结构的一个优化</li></ul><h5 id="冯诺依曼结构计算机"><a href="#冯诺依曼结构计算机" class="headerlink" title="冯诺依曼结构计算机"></a>冯诺依曼结构计算机</h5><blockquote><p>背景</p></blockquote><p>世界上第一台计算机是ENIAC埃尼亚克, 当时冯诺依曼就是这台计算机设计的一个顾问, 这台计算机一个很大的缺点, 就是每一步的计算需要执行什么指令, 都需要程序员、操作员们通过手动连接这些线缆来告诉计算机,因此安尼亚克的计算速度就被手工操作的,所需要的耗时给抵消了, 为了解决这个问题, 冯诺依曼第一次提出了<strong>存储程序</strong>的概念</p><p>对于安尼亚克这台计算机, 是程序员们告诉他一条指令, 他就往下执行一条指令, 说一句做一句</p><p>而冯诺依曼提出的存储程序的这种实现方式意味着可以把我们想要让计算机执行的一系列指令一口气告诉他, 全部先放到储存里, 然后接下来会由计算机一条一条的来执行这些指令, 程序员们就不需要,每一步都进行手工连接的操作, 这就可以大幅提升计算机的一个计算速度</p><p>基于他提出的这个设计方案, 世界上第一台具有冯诺依曼结构的计算机, 就诞生了, 这台计算机的英文缩写叫EDVAC</p><blockquote><p>存储程序</p></blockquote><p>所谓存储程序就是指, 可以把我们需要执行的一系列指令, 以二进制代码的方式, 提前把它输入到计算机的主存储器当中, 也就是我们熟悉的内存里边, 然后计算机会根据存储器里边存储的, 这一系列的指令来一条一条的执行, 直到程序执行结束</p><blockquote><p>冯诺依曼结构图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305042327388.png" alt="image-20230504232729308"></p><ul><li>在这个图中, 实线箭头来表示数据线, 也就是说数据实线箭头的流动方向, 来传输, 双箭头意味着两个部件之间有你来我往的数据传输</li><li>虚线表示控制线和反馈线,</li><li>输入设备, 把数据输入到计算机当中,数据包含要进行数学运算的数据, 也包含了程序, 也就是指令集合, 所以输入设备的一个作用, 就是把计算机要处理的信息, 转换成机器能够识别的形式, 也就是0101这样的二进制数, </li><li>输入的数据、程序通过输入设备处理, 先流向运算器, 然后通过运算器的中转, 才会把这些程序数据放到内存, 也就存储器当中</li><li>存储器就是用来存放要处理的数据, 还有程序指令 </li><li>中间的这个运算器, 最主要的一个功能是实现算数运算和逻辑运算</li><li>经过运算器的处理, 数据的运算结果会通过输出设备转换成人类比较熟悉的形式</li><li>控制器会用一些电信号来协调其他部件相互配合的工作, 另外控制器也会负责来解析存储器里存储的那些程序指令, 所以我们会看到有一条存储器到控制器的数据线, 这条数据线其实就是控制器从存储器当中读取出一条指令的一个数据流, 所以程序指令的解析是由控制器来完成的</li><li>我们输入计算机的数据和程序, 其实就是所谓的软件的模块, 框里边的部分, 其实就是计算机的硬件部件, 在计算机系统中, 其实软件和硬件在逻辑上是等效的,也就是说对于同一个功能, 我们既可以用软件来实现, 也可以用硬件来实现, 不过通常来说用软件实现的成本更低, 但是效率也会更低, 而用硬件来实现成本会更高, 当然效率也会更高, </li><li>比如，如果我们要实现乘法运算, 那么我们完全可以在运算器里边, 设计一个专门的硬件电路来实现这种乘法运算, 我们只需要给出一条乘法指令, 运算器就可以得到最终的结果, 但是如果我们没有这个硬件部件, 其实也可以实现乘法, 乘法可以用多次的加法运算来模拟, 所以才说, 软件和硬件在逻辑上其实是等效的, 显然用硬件的方式乘法电路, 直接计算更快一些, 用软件的方式进行多次加法, 0需要消耗更长的时间</li></ul><blockquote><p>冯诺依曼计算机的特点</p></blockquote><ul><li>第一个特点计算机有五大部件组成, 也就是输入、输出、运算器、存储器、控制器</li><li>第二个特点, 指令和数据同样都是以同等的地位存放在存储器当中, 我们可以根据存储单元的地址, 来进行缓存的操作</li><li>第三个特点，指令和数据都用二进制表示</li><li>第四个特点, 指令由操作码和地址码组成</li><li>第五个特征就是存储程序</li><li>第六个特征就是冯诺依曼计算机是<strong>以运算器为中心</strong></li></ul><p><strong>什么叫以运算器为中心？</strong></p><p>运算器, 它处在整个结构的中间位置, 无论是输入设备, 输入数据还是输出设备输出数据, 都肯定需要经过运算器的一个中转, 虽然说刚开始输入的这些数据和程序, 本来就是想要放到这个存储器里的, 但是冯诺依曼这种结构的计算机, 都会通过运算器作为中转站, 把它转存到这个存储器里边的, 所以由于数据的传送必须经过运算器来完成, 因此我们说这种结构是以运算器为中心, 那这就产生了一个问题, 运算器本来是用来处理这些数据的核心部件, 但是现在所有的数据中转还需要它来帮忙完成, 导致数据计算的效率降低, </p><p>效率降低的解决方案很简单，其实就是现代计算机的一个结构, 以存储器为中心, 也就是说输入设备, 它的数据是直接放到存储器里边的, 当运算器处理完这些数据之后, 输出设备也会直接从存储器当中取走最终的数据, 进行计算结果的输出, 这样就可以解放运算器的时间, 让运算器进行更多的运算</p><h5 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305042343438.png" alt="image-20230504234331385"></p><ul><li>cpu里边包含了运算器和控制器, 控制器通过控制线来告诉运算器, 接下来应该执行的是什么样的运算, 另外控制器也会控制主存储器的读写, 以及输入输出设备的启动停止</li><li>主存储器和cpu之间会进行数据的交换, 第一种就是需要参与运算的数据, 比如xy之类的一些变量, 另外一种数据就是指令, 指令会放到控制器当中, 由控制器来解析指令的含义, 并且发出相应的控制信号</li><li>最右边的双向箭头是io设备, 也就是输入输出设备, 会直接的和主存储器进行数据的交换, 主存储器和cpu统称为主机</li><li>主存和辅存这两个东西, 那这两个东西都统称为存储器, 主存就是主存储器, 也就是我们熟知的内存, 而辅助存就是辅助存储器, 在电脑里边就是我们的机械硬盘, 固态硬盘, 需要注意的是, 虽然它们都是存储器, 但是主机是只包含了主存, 辅存我们应该把它归为io设备, 像我们平时手机里安装的app, 其实它就是存放在辅存里面的, 只有这个app需要启动运行的时候, 才会把辅存里边的app相关的程序, 数据代码的数据把它读到主存里边, 所以辅存应该把它看作是一种io设备, 像之前我们给的这个图, 华为这个手机, 他这所谓的运行内存八gb, 指的就是主存储器的大小容量是八gb, 然后机身存储是128gb, 这个指的就是辅存</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305161831724.png" alt="image-20230516183100607"></p><h2 id="各个硬件的工作原理"><a href="#各个硬件的工作原理" class="headerlink" title="各个硬件的工作原理"></a>各个硬件的工作原理</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061042365.png" alt="image-20230506104238310"></p><ul><li>主存储器里边用于存放数据的东西叫做存储体,</li><li>存储体就是由一系列的存储元件来构成的, 可以存放二进制0或1</li><li>两个重要的寄存器, 一个叫MAR, 一个叫MDR, 它们分别是存储地址寄存器和存储数据寄存器</li></ul><p>xxxxxxxxxx &#x2F;* 邻接矩阵存储 - 多源最短路算法 <em>&#x2F; ​bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] ) {         Vertex i, j, k;     &#x2F;</em> 初始化 <em>&#x2F;     for ( i&#x3D;0; i<Graph->Nv; i++ )         for( j&#x3D;0; j<Graph->Nv; j++ ) {                         D[i][j] &#x3D; Graph-&gt;G[i][j];             path[i][j] &#x3D; -1;                      }         for( k&#x3D;0; k<Graph->Nv; k++ )         for( i&#x3D;0; i<Graph->Nv; i++ )             for( j&#x3D;0; j<Graph->Nv; j++ )                 if( D[i][k] + D[k][j] &lt; D[i][j] ) {                     D[i][j] &#x3D; D[i][k] + D[k][j];                     if ( i&#x3D;&#x3D;j &amp;&amp; D[i][j]&lt;0 ) &#x2F;</em> 若发现负值圈 <em>&#x2F;                         return false; &#x2F;</em> 不能正确解决，返回错误标记 <em>&#x2F;                     path[i][j] &#x3D; k;                 }         return true;     &#x2F;</em> 算法执行完毕，返回正确标记 *&#x2F; }c</p><ul><li>一整个存储体会被分成一个一个的存储单元, 每一个存储单元会存放一串二进制代码</li><li>那每一个单元里边存储的这一串二进制代码, 我们就把它称为一个存储字</li><li>而每一个存储字包含多少个二进制位, 这个信息我们把它称为存储字长</li><li>存储元， 用于存储二进制数据的电子元件，每个存储元可存一个二进制的比特位(1bit),</li><li>MAR是指明了存储单元的地址, 所以MAR寄存器的位数反映了存储体里边到底有多少个存储单元, </li><li>另一方面, 从存储单元里边取出来的数据, 是要放到mdr当中的, 所以mdr的二进制位数, 应该和存储单元是保持一致的, 也就是要等于存储字长</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061059967.png" alt="image-20230506105948920"></p><ul><li>比如这个主存储器, 它的MDR地址寄存器只有四个比特位, 那么也就意味着它的存储体里边, 总共只有二的四次方个存储单元， </li><li>如果MDR, 总共有16位,一个字的大小就是16个比特</li><li>注意区分字和字节的概念</li><li>需要强调的点, 在描述一个字节的时候, 经常会用B表示， 但是在描述一个比特, 一个二进制位的时候, 一般是用b</li></ul><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061107190.png" alt="image-20230506110739134"></p><ul><li>ACC它其实是一个寄存器,  一般叫做累加器, 累加器可以用来存放, 进行加减乘除或者逻辑运算的那些操作数, 同时也会用于存放运算的结果,</li><li>第二个寄存器叫MQ, 就是乘商寄存器,这个寄存器只会在乘法除法才会用得到, 同样的会用来存放乘法, 除法的操作数或者运算的一个结果</li><li>第三个寄存器x它叫通用的操作数寄存器,简称为通用寄存器, 用于存放操作数，其实这种通用寄存器一般在运算器里边是可能会有多个, 但理论上我们只需要有一个通用寄存器, 就可以实现我们想要的那些算术运算, </li><li>ALU叫算术逻辑单元运算器的核心部件, 它里边集成了一些复杂的电路, 用这些复杂的电路可以实现算术运算, 或者逻辑运算</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061115974.png" alt="image-20230506111532922"></p><ul><li>CU，控制单元，是控制器里面最核心的一个部件,, 可以分析指令, 并且可以给其他的部件发出一些控制信号</li><li>IR是指令寄存器, 就是用来存放当前执行的指令</li><li>PC是程序计数器, 用来存放下一条指令的地址, 并且有自动加一的功能</li><li>完成一条指令需要分为这样的三个阶段：<ul><li>第一个阶段是取指令, 会根据PC里边所记录的指令地址，从内存里边取出那一条指令, 取出的指令会被放在IR</li><li>然后CU分析, 这条指令到底是要干什么的</li><li>分析完了之后, CU就会控制着其他部件, 来配合着完成指令的具体执行</li></ul></li></ul><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061125839.png" alt="image-20230506112526764"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061131119.png" alt="image-20230506113133054"></p><ul><li>初：这个程序要执行的第一个指令, 应该是存放在0号位置的这条指令, 所以在程序运行之后, PC会指向零这个位置, </li><li>接下来我们应该把这个位置存放的这条指令, 取出来执行, </li><li>#1：PC存放的内容, 需要通过地址总线, 把它传送到MAR中,  此时PC是零, 那这个操作就会导致MAR这个寄存器的值变为了零, 也就是说控制器向主存指明了接下来要访问的是0号地址所对应的一串数据</li><li>同时控制器会通过控制总线告诉主存储器, 这次要进行的是读操作</li><li>#3：接下来主存储器会根据MAR记录的这个地址信息去存储体里边, 找出0号地址所对应的这些二进制数据, 并且把这些二进制数据放到MDR中, 那么这就导致了MDR这个寄存器当中里边存放的就是我们想要读取的第一条指令,</li><li>我们把一个寄存器的名字外面打一个括号, 指的是这个寄存器里边的内容</li><li>然后这一个M表示的是memory, 也就是主存储器, 主存储器里边, MAR这个地址所指明的存储单元里边的数据, 放到MDR这个寄存器当中, 是这样的一个意思</li><li>#4：指令会通过数据总线把它放到IR中,  这就导致控制器的IR里边存放了此次要执行的指令, </li><li>#5：接下来这条指令的前边六个比特, 也就是操作码, 会被送到CU控制单元里边, 然后CU会分析这个操作吗, 它就可以知道00001, 它对应的是一条取数的指令, </li><li>#6：接下来要把这个地址码所指明的内存单元里的数据取出来, 并且放到ACC这个寄存器当中, 这是取数指令要做的事情, 那既然要读取储存的这个地址的信息, 于是就需要把这个地址码, 放到储存</li><li>的MAR当中, 这就导致此时MAR是等于五, 因为这个二进制数转换成十进制, 就是五, 那5号存储单元所指向的刚好就是a这个变量</li><li>#8：接下来主存储器根据MAR指明的这些地址, 去存储体当中, 找出5号单元的这些数据, 并且把这些数据放到MDR当中, 也就把a这个变量的值现在放到了MDR里, 那a的值是2</li><li>#9：最后在控制单元的指挥下, MDR里的数据会被传送到ACC, 也就累加寄存器当中, 到此为止我们就完成了一个取数的指令, 最终导致a这个变量的值已经被我们放到ACC当中了,</li><li>1234这几步, 其实就是对应取指令的一个过程, 然后第五步是对应了分析指令的过程, 后边的6~9步才是实际执行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061150132.png" alt="image-20230506115043064"></p><ul><li>那之前我们说过程序计数器, pc它有自动加1的功能, 其实在取指令这个动作完成之后, pc的值就会自动的加1了, 他以前是零, 那自动加1它就会指向1, 也就是指明了下一条我们要执行的指令</li><li>接下来根据程序计数器pc所指向的位置, 取得第二条指令, 那么取指令的过程和之前是类似的, 通过这样的四个步骤, 把第二条指令放到IR寄存器当中</li><li>取完指令之后就需要分析指令, 那和之前一样, 会把操作码这个部分送到cu控制单元, 然后经过CU分析之后, 可以知道, 000100, 这个操作码对应的是一个乘法操作, 所以这是一条乘法指令, 因此接下来CU会指挥其他部件来协调地完成,</li><li>现在这一步我们要完成的是a乘以b的操作, 而a这个变量之前已经被送到ACC, 里边了, 所以现在这一条乘法指令, 它的地址码指明的是另一个乘数b的存放位置, 那b存放在6这个位置, 刚好这个地址码把它翻译成十进制数也是等于六, 所以这条指令的地址码会被送到MAR当中, 指明我要取出的是6号存储单元里边的数据</li><li>所以接下来储存会根据MAR所指明的这些地址, 取出相应的这个数据, 也就是把b这个变量的值放到了MDR当中, 接下来b的值会从mdr, 再通过数据总线送到MQ, 也就是乘商寄存器当中, 所以现在b的值已经放到MQ里面了</li><li>接下来还需要把a的值先放到通用寄存器x当中, 也就是说当这个cpu执行乘法操作的时候, 他会把被乘数放到x这个通用寄存器里边, 然后把乘数放到mq这个乘商寄存器里边, </li><li>接下来CU会通过控制线告诉ALU让它进行乘法运算, ALU会把x和mq里边存储的这两个数, 把它们进行一个相乘的操作, 然后把最终乘得的结果放到ACC里边, 那这个操作导致acc里面得到了a乘以b的值, 2*3&#x3D;6</li><li>在我们这个例子当中进行相乘的这两个数很小, 但是如果说这两个数很大的话, 那么有可能ACC这个寄存器里边是存不下的, 这种情况下, 就需要mq乘商寄存器的一个辅助存储, mq里边会用来存放乘法运算结果的低位</li><li>那这样我们就完成了第二条指令, 也就是乘法指令, 那大家会发现和前边那条指令相比, 其实第一步到第五步, 这几个步骤, 每一步要做的事情都是一模一样的, 只有当CU控制单元, 分析出这条指令是乘法指令的时候, 接下来的操作就会产生一些区别</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061204145.png" alt="image-20230506120431084"></p><ul><li>当取指令结束之后, pc的值也会自动加一, 所以这条指令执行结束之后, 得到的效果就是pc指向了2, 也就指向了下一条要执行的指令, ACC里边此时存放我们上一个运算的结果, 也就是a乘以b的值, a乘以b等于六</li><li>接下来执行二这个地址存放的这条指令, 那前边的几个步骤都是一样的, 通过五个步骤, 可以完成取指令和分析指令的操作, </li><li>CU发现这次要执行的操作码, 应该是000011, 这个操作码对应的是一个加法操作</li><li>接下来CU会根据加法指令的这个执行步骤, 来指挥这其他部件协调工作, 这次要计算的是a乘以b加c, 而a乘以b的结果我们是已经存放在acc当中, 所以这个加法指令的地址码, 指明的是c这个变量它的存放地址, 那c是存放在7这个位置的, 刚好把这个二进制数转换成十进制, 就是7</li><li>因此接下来要取出7这个地址所存放的数据, 那么就需要把这个地址码, 把它放到mar地址寄存器当中, 接下来主存根据mar指明的地址, 取出相应的这个数据, 也就把c的值放到了mdr当中</li><li>接下来这一步会把mdr的值, 再传送到通用寄存器x当中, 也就是说当我们进行加法运算的时候, ACC里边会先存入被加数, 然后通用寄存器x当中会存放加数, 也就是c的值</li><li>接下来控制单元会向ALU发送一个信号, 告诉他你此次要执行的是加法操作, 那么ALU算术逻辑单元, 就会把acc和x里面存放的值进行一个相加, 并且把加的结果再次存回acc当中, 因此这就导致了acc等于七, 也就是把a乘以b加c的值存放到了acc里边, 好那到此为止, 我们完成了第三条指令, 也就是这个加法指令</li><li>另外在取完指令之后, 同样的也会自动的进行pc加一的操作, 也就是pc会指向下一条我们应该执行的指令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061213523.png" alt="image-20230506121302448"></p><ul><li>接下来这条指令的执行, 前边的这些步骤都是一样的, 根据pc记录的这个地址, 取出这条指令, 并且放到r指令寄存器当中, 然后第五个步骤会把这个指令的操作码, 把它送到CU当中进行分析, 然后CU分析之后发现000010, 这是一条纯数的指令, 也就是要把acc里边的数据, 把它存到地址码所指明的存储单元当中, 那这个地址码转换成十进制, 应该是8, 而8这个存储单元, 刚好对应的是y这个变量的存储位置, </li><li>那现在acc里面存的是七, 也就是a乘以b加c的值好, 接下来执行这个存储指令, 首先会把这个指令的地址码部分, 把它送到mar里边, 用来指明此次我要存入的是哪一个存储单元</li><li>另外还需要把acc里边的运算结果, 通过数据总线把它送到mdr当中, 也就是说, 此时mdr里边保存了a乘以b加c的值, 并且此时mar里边指明了这个值是要存到内存地址为八的这个地方</li><li>接下来, cu控制单元会通过控制总线告诉主存储器说, 我此次要进行的是一个存一个写的操作, 于是主存储器会根据mar所指明的地址, 把mdr当中的这个数据放到相应的位置当中, 这就导致了8号存储单元, 它的值变为了7, 也就是我们最终想要得到的这个结果, y等于a乘以b加c</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061215060.png" alt="image-20230506121532003"></p><ul><li>pc再加一指向下一条应该执行的指令,  首先需要取出指令, 把这个指令把它取到ir指令寄存器当中, 然后接下来要把操作码部分送到cu里边, 然后cu一分析发现000110 , 这个操作码对应的是停机指令, 所以执行到这一步, 就知道我们的这段程序运行结束了,</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061217589.png" alt="image-20230506121701532"></p><ul><li>取数指令的执行过程分为取指令, 分析指令和执行指令这样的三个阶段, 任何一条指令的执行一定都是这样的三个阶段, 那无论我们执行的是什么指令, 前边取指令和分析指令的这些步骤, 其实都是一模一样的</li><li>只有分析完指令之后, cu才可以知道这条指令到底是要做什么, 于是接下来的这些步骤啊, 对于不同的指令来说就有可能不一样, </li><li>在取指令的阶段, mdr里的数据肯定是要传送到ir指令寄存器当中, 而在执行指令的阶段, cu会根据具体的这条指令来决定mdr里的数据应该是放到acc还是放到mq, 还是放到其他的通用寄存器里边</li><li>所以根据指令执行周期的不同, 它处于不同的阶段, cpu就可以区分出这次从内存里取出的,到底是指令还是数据了</li></ul><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305111443076.png" alt="image-20230511144327858"></p><h3 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305111444479.png" alt="image-20230511144455380"></p><p><strong>编译程序和解释程序的区别</strong></p><ul><li>编译程序是直接把高级语言编写的语言程序, 全部一次性翻译成机器语言程序, 然后再来执行这个机器语言程序, 我们只需要进行一次编译，之后就不需要再编译了，比如我们用c语言写的程序, 把它经过编译啊, 还有汇编这些步骤之后, 最终会形成一个大家都很熟悉的文件, 叫做.exe文件, 那这个.exe文件, 其实就是用机器语言描述的程序</li><li>而解释程序是这样的一个原理, 比如我们用javascript这种脚本语言写了几句代码, 用高级语言写的代码, 这几句代码在执行的时候, 每执行一句都会丢给解释程序, 来帮我们把这个代码翻译成与之对等的机器语言, 翻译一句就立即执行, 紧接着再翻译下一句, 所以每一次我们要执行这段代码的时候, 解释程序都需要翻译一遍</li><li>显然编译型的语言, 执行效率更高，解释型的语言执行效率会更低</li></ul><h3 id="计算机体系结构VS计算机组成原理"><a href="#计算机体系结构VS计算机组成原理" class="headerlink" title="计算机体系结构VS计算机组成原理"></a>计算机体系结构VS计算机组成原理</h3><ul><li><p>计算机体系结构——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O机理）</p><ul><li>计算机体系结构这门课必须要探讨的是, 指令系统应该怎么设计, 也就是说我设计的这台计算机, 要对上层的机器语言程序员提供哪一些指令</li><li>也就是：如何设计, 硬件和软件之间的接口</li></ul></li><li><p>计算机组成原理——实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p><ul><li>怎么用硬件来实现我们定义的这些接口</li></ul></li></ul><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305111459898.png" alt="image-20230511145956781"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><strong>总容量&#x3D;存储单元个数*存储字长 bit</strong></p><p>​            <strong>&#x3D;存储单元个数*存储字长&#x2F;8 Byte</strong></p><ul><li>MAR（存储地址寄存器）位数反映存储单元的个数</li><li>MDR（存储数据寄存器）位数反映存储字长，也就是每个存储单元的大小</li></ul><blockquote><p>Eg: MAR为32位 MDR为8位</p></blockquote><p>总容量 &#x3D; 2^32*8 bit &#x3D; 2^32 Byte&#x3D; 4 GB</p><h3 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h3><ul><li><p>CPU主频：CPU内数字脉冲信号振荡的频率，也就是每秒钟有多少个脉冲信号振荡，为计算简便，可以看成每秒钟有多少个时钟周期.</p></li><li><p>CPU时钟周期：每个脉冲信号的时间  </p></li><li><p>CPU主频（时钟频率）&#x3D;1&#x2F;CPU时钟周期</p></li><li><p>CPI：执行一条指令所需的时钟周期</p><ul><li>不同的指令，CPI不同，甚至相同的指令，CPI也可能变化</li><li>一般考虑CPI，是平均的情况</li></ul></li><li><p>执行一条指令的耗时 &#x3D; CPI*CPU时钟周期</p></li><li><p>CPU执行时间（整个程序的耗时）&#x3D;CPU时间周期数&#x2F;主频&#x3D;（指令条数*CPI）&#x2F;主频</p></li><li><p>IPS：每秒执行多少条指令</p></li><li><p>IPS &#x3D; 主频&#x2F;平均CPI</p></li><li><p>FLOPS：每秒执行多少次浮点运算</p></li></ul><blockquote><p>Eg：某CPU主频为1000HZ，某程序包含100条指令，平均来看指令的CPI&#x3D;3，该程序在CPU上执行需要多久</p></blockquote><p>100 * 3 * 1&#x2F;1000 &#x3D;0.3 s</p><h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><ul><li><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p></li><li><p>吞吐量：指系统在单位时间内处理请求的数量</p><ul><li>取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，<strong>系统吞吐量主要取决于主存的存取周期</strong></li></ul></li><li><p>响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间</p></li><li><p>基准程序（跑分软件）：用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较</p></li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><blockquote><p>主频高的CPU一定比主频低的CPU快吗？</p></blockquote><ul><li>不一定，如两个CPU，A的主频为2GHz，平均CPI&#x3D;10；B的主频1GHz，平均CPI&#x3D;1，那么A一秒钟可以执行0.2G条指令，而B一秒钟可以执行1G条指令</li></ul><blockquote><p>若A、B两个CPU的平均CPI相同，那么A一定更快吗？</p></blockquote><p>不一定，还要看指令系统，如果A不支持乘法指令，只能用多次加法实现乘法，而B支持乘法指令 </p><blockquote><p>基准程序执行得越快，说明机器性能越好吗</p></blockquote><p>基准程序的语句存在频度差异，运行结果也不能完全说明问题</p>]]></content>
    
    
    <categories>
      
      <category>王道计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王道计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令大全</title>
    <link href="/2023/03/14/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <url>/2023/03/14/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>arch</td><td>显示机器的处理器架构(1)</td></tr><tr><td>uname -m</td><td>显示机器的处理器架构(2)</td></tr><tr><td>uname -r</td><td>显示正在使用的内核版本</td></tr><tr><td>dmidecode -q</td><td>显示硬件系统部件 - (SMBIOS &#x2F; DMI)</td></tr><tr><td>hdparm -i &#x2F;dev&#x2F;hda</td><td>罗列一个磁盘的架构特性</td></tr><tr><td>hdparm -tT &#x2F;dev&#x2F;sda</td><td>在磁盘上执行测试性读取操作</td></tr><tr><td>cat &#x2F;proc&#x2F;cpuinfo</td><td>显示CPU info的信息</td></tr><tr><td>cat &#x2F;proc&#x2F;interrupts</td><td>显示中断</td></tr><tr><td>cat &#x2F;proc&#x2F;meminfo</td><td>校验内存使用</td></tr><tr><td>cat &#x2F;proc&#x2F;swaps</td><td>显示哪些swap被使用</td></tr><tr><td>cat &#x2F;proc&#x2F;version</td><td>显示内核的版本</td></tr><tr><td>cat &#x2F;proc&#x2F;net&#x2F;dev</td><td>显示网络适配器及统计</td></tr><tr><td>cat &#x2F;proc&#x2F;mounts</td><td>显示已加载的文件系统</td></tr><tr><td>lspci -tv</td><td>罗列 PCI 设备</td></tr><tr><td>lsusb -tv</td><td>显示 USB 设备</td></tr><tr><td>date</td><td>显示系统日期</td></tr><tr><td>cal 2007</td><td>显示2007年的日历表</td></tr><tr><td>date 041217002007.00</td><td>设置日期和时间 - 月日时分年.秒</td></tr><tr><td>clock -w</td><td>将时间修改保存到 BIOS</td></tr></tbody></table><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>关闭系统(1)</td></tr><tr><td>init 0</td><td>关闭系统(2)</td></tr><tr><td>telinit 0</td><td>关闭系统(3)</td></tr><tr><td>shutdown -h hours:minutes</td><td>按预定时间关闭系统</td></tr><tr><td>shutdown -c</td><td>取消按预定时间关闭系统</td></tr><tr><td>shutdown -r now</td><td>重启(1)</td></tr><tr><td>reboot</td><td>重启(2)</td></tr><tr><td>logout</td><td>注销</td></tr></tbody></table><h3 id="文件和目录查看"><a href="#文件和目录查看" class="headerlink" title="文件和目录查看"></a>文件和目录查看</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>cd &#x2F;home</td><td>进入 ‘&#x2F; home’ 目录’</td></tr><tr><td>cd ..</td><td>返回上一级目录</td></tr><tr><td>cd ..&#x2F;..</td><td>返回上两级目录</td></tr><tr><td>cd</td><td>进入个人的主目录</td></tr><tr><td>cd ~user1</td><td>进入个人的主目录</td></tr><tr><td>cd -</td><td>返回上次所在的目录</td></tr><tr><td>pwd</td><td>显示工作路径</td></tr><tr><td>ls</td><td>查看目录中的文件</td></tr><tr><td>ls -F</td><td>查看目录中的文件</td></tr><tr><td>ls -l</td><td>显示文件和目录的详细资料</td></tr><tr><td>ls -a</td><td>显示隐藏文件</td></tr><tr><td>ls <em>[0-9]</em></td><td>显示包含数字的文件名和目录名</td></tr><tr><td>tree</td><td>显示文件和目录由根目录开始的树形结构(1)</td></tr><tr><td>lstree</td><td>显示文件和目录由根目录开始的树形结构(2)</td></tr><tr><td>mkdir dir1</td><td>创建一个叫做 ‘dir1’ 的目录’</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个目录</td></tr><tr><td>mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2</td><td>创建一个目录树</td></tr><tr><td>rm -f file1</td><td>删除一个叫做 ‘file1’ 的文件’</td></tr><tr><td>rmdir dir1</td><td>删除一个叫做 ‘dir1’ 的目录’</td></tr><tr><td>rm -rf dir1</td><td>删除一个叫做 ‘dir1’ 的目录并同时删除其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个目录及它们的内容</td></tr><tr><td>mv dir1 new_dir</td><td>重命名&#x2F;移动 一个目录</td></tr><tr><td>cp file1 file2</td><td>复制一个文件</td></tr><tr><td>cp dir&#x2F;* .</td><td>复制一个目录下的所有文件到当前工作目录</td></tr><tr><td>cp -a &#x2F;tmp&#x2F;dir1 .</td><td>复制一个目录到当前工作目录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制一个目录</td></tr><tr><td>ln -s file1 lnk1</td><td>创建一个指向文件或目录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建一个指向文件或目录的物理链接</td></tr><tr><td>touch -t 0712250000 file1</td><td>修改一个文件或目录的时间戳 - (YYMMDDhhmm)</td></tr><tr><td>iconv -l</td><td>列出已知的编码</td></tr></tbody></table><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>find &#x2F; -name file1</td><td>从 ‘&#x2F;‘ 开始进入根文件系统搜索文件和目录</td></tr><tr><td>find &#x2F; -user user1</td><td>搜索属于用户 ‘user1’ 的文件和目录</td></tr><tr><td>find &#x2F;home&#x2F;user1 -name *.bin</td><td>在目录 ‘&#x2F; home&#x2F;user1’ 中搜索带有’.bin’ 结尾的文件</td></tr><tr><td>find &#x2F;usr&#x2F;bin -type f -atime +100</td><td>搜索在过去100天内未被使用过的执行文件</td></tr><tr><td>find &#x2F;usr&#x2F;bin -type f -mtime -10</td><td>搜索在10天内被创建或者修改过的文件</td></tr><tr><td>find &#x2F; -name *.rpm -exec chmod 755 ‘{}’ ;</td><td>搜索以 ‘.rpm’ 结尾的文件并定义其权限</td></tr><tr><td>find &#x2F; -xdev -name *.rpm</td><td>搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备</td></tr><tr><td>locate *.ps 寻找以 ‘.ps’</td><td>结尾的文件 - 先运行 ‘updatedb’ 命令</td></tr><tr><td>whereis halt</td><td>显示一个二进制文件、源码或man的位置</td></tr><tr><td>which halt</td><td>显示一个二进制文件或可执行文件的完整路径</td></tr></tbody></table><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2</td><td>挂载一个叫做hda2的盘 - 确定目录 ‘&#x2F; mnt&#x2F;hda2’ 已经存在</td></tr><tr><td>umount &#x2F;dev&#x2F;hda2</td><td>卸载一个叫做hda2的盘 - 先从挂载点 ‘&#x2F; mnt&#x2F;hda2’ 退出</td></tr><tr><td>fuser -km &#x2F;mnt&#x2F;hda2</td><td>当设备繁忙时强制卸载</td></tr><tr><td>umount -n &#x2F;mnt&#x2F;hda2</td><td>运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用</td></tr><tr><td>mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy</td><td>挂载一个软盘</td></tr><tr><td>mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom</td><td>挂载一个cdrom或dvdrom</td></tr><tr><td>mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder</td><td>挂载一个cdrw或dvdrom</td></tr><tr><td>mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder</td><td>挂载一个cdrw或dvdrom</td></tr><tr><td>mount -o loop file.iso &#x2F;mnt&#x2F;cdrom</td><td>挂载一个文件或ISO镜像文件</td></tr><tr><td>mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5</td><td>挂载一个Windows FAT32文件系统</td></tr><tr><td>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk</td><td>挂载一个usb 捷盘或闪存设备</td></tr><tr><td>mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share</td><td>挂载一个windows网络共享</td></tr></tbody></table><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>df -h</td><td>显示已经挂载的分区列表</td></tr><tr><td>ls -lSr | more</td><td>以尺寸大小排列文件和目录</td></tr><tr><td>du -sh dir1</td><td>估算目录 ‘dir1’ 已经使用的磁盘空间’</td></tr><tr><td>du -sk * | sort -rn</td><td>以容量大小为依据依次显示文件和目录的大小</td></tr><tr><td>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n</td><td>以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</td></tr><tr><td>dpkg-query -W -f&#x3D;’<img src="https://math.jianshu.com/math?formula=%7BInstalled-Size;10%7Dt" alt="{Installed-Size;10}t">{Package}n’ | sort -k1,1n</td><td>以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</td></tr></tbody></table><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>groupadd group_name</td><td>创建一个新用户组</td></tr><tr><td>groupdel group_name</td><td>删除一个用户组</td></tr><tr><td>groupmod -n new_group_name old_group_name</td><td>重命名一个用户组</td></tr><tr><td>useradd -c “Name Surname “ -g admin -d &#x2F;home&#x2F;user1 -s &#x2F;bin&#x2F;bash user1</td><td>创建一个属于 “admin” 用户组的用户</td></tr><tr><td>useradd user1</td><td>创建一个新用户</td></tr><tr><td>userdel -r user1</td><td>删除一个用户 ( ‘-r’ 排除主目录)</td></tr><tr><td>usermod -c “User FTP” -g system -d &#x2F;ftp&#x2F;user1 -s &#x2F;bin&#x2F;nologin user1</td><td>修改用户属性</td></tr><tr><td>passwd</td><td>修改口令</td></tr><tr><td>passwd user1</td><td>修改一个用户的口令 (只允许root执行)</td></tr><tr><td>chage -E 2005-12-31 user1</td><td>设置用户口令的失效期限</td></tr><tr><td>pwck</td><td>检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的用户</td></tr><tr><td>grpck</td><td>检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的群组</td></tr><tr><td>newgrp group_name</td><td>登陆进一个新的群组以改变新创建文件的预设群组</td></tr></tbody></table><h3 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ls -lh</td><td>显示权限</td></tr><tr><td>ls &#x2F;tmp | pr -T5 -W$COLUMNS</td><td>将终端划分成5栏显示</td></tr><tr><td>chmod ugo+rwx directory1</td><td>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</td></tr><tr><td>chmod go-rwx directory1</td><td>删除群组(g)与其他人(o)对目录的读写执行权限</td></tr><tr><td>chown user1 file1</td><td>改变一个文件的所有人属性</td></tr><tr><td>chown -R user1 directory1</td><td>改变一个目录的所有人属性并同时改变改目录下所有文件的属性</td></tr><tr><td>chgrp group1 file1</td><td>改变文件的群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变一个文件的所有人和群组属性</td></tr><tr><td>find &#x2F; -perm -u+s</td><td>罗列一个系统中所有使用了SUID控制的文件</td></tr><tr><td>chmod u+s &#x2F;bin&#x2F;file1</td><td>设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</td></tr><tr><td>chmod u-s &#x2F;bin&#x2F;file1</td><td>禁用一个二进制文件的 SUID位</td></tr><tr><td>chmod g+s &#x2F;home&#x2F;public</td><td>设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</td></tr><tr><td>chmod g-s &#x2F;home&#x2F;public</td><td>禁用一个目录的 SGID 位</td></tr><tr><td>chmod o+t &#x2F;home&#x2F;public</td><td>设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</td></tr><tr><td>chmod o-t &#x2F;home&#x2F;public</td><td>禁用一个目录的 STIKY 位</td></tr></tbody></table><h3 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>chattr +a file1</td><td>只允许以追加方式读写文件</td></tr><tr><td>chattr +c file1</td><td>允许这个文件能被内核自动压缩&#x2F;解压</td></tr><tr><td>chattr +d file1</td><td>在进行文件系统备份时，dump程序将忽略这个文件</td></tr><tr><td>chattr +i file1</td><td>设置成不可变的文件，不能被删除、修改、重命名或者链接</td></tr><tr><td>chattr +s file1</td><td>允许一个文件被安全地删除</td></tr><tr><td>chattr +S file1</td><td>一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</td></tr><tr><td>chattr +u file1</td><td>若文件被删除，系统会允许你在以后恢复这个被删除的文件</td></tr></tbody></table><p>lsattr 显示特殊的属性</p><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>bunzip2 file1.bz2</td><td>解压一个叫做 ‘file1.bz2’的文件</td></tr><tr><td>bzip2 file1</td><td>压缩一个叫做 ‘file1’ 的文件</td></tr><tr><td>gunzip file1.gz</td><td>解压一个叫做 ‘file1.gz’的文件</td></tr><tr><td>gzip file1</td><td>压缩一个叫做 ‘file1’的文件</td></tr><tr><td>gzip -9 file1</td><td>最大程度压缩</td></tr><tr><td>rar a file1.rar test_file</td><td>创建一个叫做 ‘file1.rar’ 的包</td></tr><tr><td>rar a file1.rar file1 file2 dir1</td><td>同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’</td></tr><tr><td>rar x file1.rar</td><td>解压rar包</td></tr><tr><td>unrar x file1.rar</td><td>解压rar包</td></tr><tr><td>tar -cvf archive.tar file1</td><td>创建一个非压缩的 tarball</td></tr><tr><td>tar -cvf archive.tar file1 file2 dir1</td><td>创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件</td></tr><tr><td>tar -tf archive.tar</td><td>显示一个包中的内容</td></tr><tr><td>tar -xvf archive.tar</td><td>释放一个包</td></tr><tr><td>tar -xvf archive.tar -C &#x2F;tmp</td><td>将压缩包释放到 &#x2F;tmp目录下</td></tr><tr><td>tar -cvfj archive.tar.bz2 dir1</td><td>创建一个bzip2格式的压缩包</td></tr><tr><td>tar -jxvf archive.tar.bz2</td><td>解压一个bzip2格式的压缩包</td></tr><tr><td>tar -cvfz archive.tar.gz dir1</td><td>创建一个gzip格式的压缩包</td></tr><tr><td>tar -zxvf archive.tar.gz</td><td>解压一个gzip格式的压缩包</td></tr><tr><td>zip file1.zip file1</td><td>创建一个zip格式的压缩包</td></tr><tr><td>zip -r file1.zip file1 file2 dir1</td><td>将几个文件和目录同时压缩成一个zip格式的压缩包</td></tr><tr><td>unzip file1.zip</td><td>解压一个zip格式压缩包</td></tr></tbody></table><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>rpm -ivh package.rpm</td><td>安装一个rpm包</td></tr><tr><td>rpm -ivh –nodeeps package.rpm</td><td>安装一个rpm包而忽略依赖关系警告</td></tr><tr><td>rpm -U package.rpm</td><td>更新一个rpm包但不改变其配置文件</td></tr><tr><td>rpm -F package.rpm</td><td>更新一个确定已经安装的rpm包</td></tr><tr><td>rpm -e package_name.rpm</td><td>删除一个rpm包</td></tr><tr><td>rpm -qa</td><td>显示系统中所有已经安装的rpm包</td></tr><tr><td>rpm -qa | grep httpd</td><td>显示所有名称中包含 “httpd” 字样的rpm包</td></tr><tr><td>rpm -qi package_name</td><td>获取一个已安装包的特殊信息</td></tr><tr><td>rpm -qg “System Environment&#x2F;Daemons”</td><td>显示一个组件的rpm包</td></tr><tr><td>rpm -ql package_name</td><td>显示一个已经安装的rpm包提供的文件列表</td></tr><tr><td>rpm -qc package_name</td><td>显示一个已经安装的rpm包提供的配置文件列表</td></tr><tr><td>rpm -q package_name –whatrequires</td><td>显示与一个rpm包存在依赖关系的列表</td></tr><tr><td>rpm -q package_name –whatprovides</td><td>显示一个rpm包所占的体积</td></tr><tr><td>rpm -q package_name –scripts</td><td>显示在安装&#x2F;删除期间所执行的脚本l</td></tr><tr><td>rpm -q package_name –changelog</td><td>显示一个rpm包的修改历史</td></tr><tr><td>rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</td><td>确认所给的文件由哪个rpm包所提供</td></tr><tr><td>rpm -qp package.rpm -l</td><td>显示由一个尚未安装的rpm包提供的文件列表</td></tr><tr><td>rpm –import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY</td><td>导入公钥数字证书</td></tr><tr><td>rpm –checksig package.rpm</td><td>确认一个rpm包的完整性</td></tr><tr><td>rpm -qa gpg-pubkey</td><td>确认已安装的所有rpm包的完整性</td></tr><tr><td>rpm -V package_name</td><td>检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</td></tr><tr><td>rpm -Va</td><td>检查系统中所有已安装的rpm包- 小心使用</td></tr><tr><td>rpm -Vp package.rpm</td><td>确认一个rpm包还未安装</td></tr><tr><td>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em></td><td>从一个rpm包运行可执行文件</td></tr><tr><td>rpm -ivh  &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;arch&#x2F;package.rpm</td><td>从一个rpm源码安装一个构建好的包</td></tr><tr><td>rpmbuild –rebuild package_name.src.rpm</td><td>从一个rpm源码构建一个 rpm 包</td></tr></tbody></table><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>yum install package_name</td><td>下载并安装一个rpm包</td></tr><tr><td>yum localinstall package_name.rpm</td><td>将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</td></tr><tr><td>yum update package_name.rpm</td><td>更新当前系统中所有安装的rpm包</td></tr><tr><td>yum update package_name</td><td>更新一个rpm包</td></tr><tr><td>yum remove package_name</td><td>删除一个rpm包</td></tr><tr><td>yum list</td><td>列出当前系统中安装的所有包</td></tr><tr><td>yum search package_name</td><td>在rpm仓库中搜寻软件包</td></tr><tr><td>yum clean packages</td><td>清理rpm缓存删除下载的包</td></tr><tr><td>yum clean headers</td><td>删除所有头文件</td></tr><tr><td>yum clean all</td><td>删除所有缓存的包和头文件</td></tr></tbody></table><h2 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>dpkg -i package.deb</td><td>安装&#x2F;更新一个 deb 包</td></tr><tr><td>dpkg -r package_name</td><td>从系统删除一个 deb 包</td></tr><tr><td>dpkg -l</td><td>显示系统中所有已经安装的 deb 包</td></tr><tr><td>dpkg -l | grep httpd</td><td>显示所有名称中包含 “httpd” 字样的deb包</td></tr><tr><td>dpkg -s package_name</td><td>获得已经安装在系统中一个特殊包的信息</td></tr><tr><td>dpkg -L package_name</td><td>显示系统中已经安装的一个deb包所提供的文件列表</td></tr><tr><td>dpkg –contents package.deb</td><td>显示尚未安装的一个包所提供的文件列表</td></tr><tr><td>dpkg -S &#x2F;bin&#x2F;ping</td><td>确认所给的文件由哪个deb包提供</td></tr></tbody></table><h2 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>apt-get install package_name</td><td>安装&#x2F;更新一个 deb 包</td></tr><tr><td>apt-cdrom install package_name</td><td>从光盘安装&#x2F;更新一个 deb 包</td></tr><tr><td>apt-get update</td><td>升级列表中的软件包</td></tr><tr><td>apt-get upgrade</td><td>升级所有已安装的软件</td></tr><tr><td>apt-get remove package_name</td><td>从系统删除一个deb包</td></tr><tr><td>apt-get check</td><td>确认依赖的软件仓库正确</td></tr><tr><td>apt-get clean</td><td>从下载的软件包中清理缓存</td></tr><tr><td>apt-cache search searched-package</td><td>返回包含所要搜索字符串的软件包名称</td></tr></tbody></table><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容*"></a>查看文件内容*</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>cat file1</td><td>从第一个字节开始正向查看文件的内容</td></tr><tr><td>tac file1</td><td>从最后一行开始反向查看一个文件的内容</td></tr><tr><td>more file1</td><td>查看一个长文件的内容</td></tr><tr><td>less file1</td><td>类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</td></tr><tr><td>head -2 file1</td><td>查看一个文件的前两行</td></tr><tr><td>tail -2 file1</td><td>查看一个文件的最后两行</td></tr><tr><td>tail -f &#x2F;var&#x2F;log&#x2F;messages</td><td>实时查看被添加到一个文件中的内容</td></tr></tbody></table><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt</td><td>合并一个文件的详细说明文本，并将简介写入一个新文件中</td></tr><tr><td>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt</td><td>合并一个文件的详细说明文本，并将简介写入一个已有的文件中</td></tr><tr><td>grep Aug &#x2F;var&#x2F;log&#x2F;messages</td><td>在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找关键词”Aug”</td></tr><tr><td>grep ^Aug &#x2F;var&#x2F;log&#x2F;messages</td><td>在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找以”Aug”开始的词汇</td></tr><tr><td>grep [0-9] &#x2F;var&#x2F;log&#x2F;messages</td><td>选择 ‘&#x2F;var&#x2F;log&#x2F;messages’ 文件中所有包含数字的行</td></tr><tr><td>grep Aug -R &#x2F;var&#x2F;log&#x2F;*</td><td>在目录 ‘&#x2F;var&#x2F;log’ 及随后的目录中搜索字符串”Aug”</td></tr><tr><td>sed ‘s&#x2F;stringa1&#x2F;stringa2&#x2F;g’ example.txt</td><td>将example.txt文件中的 “string1” 替换成 “string2”</td></tr><tr><td>sed ‘&#x2F;^$&#x2F;d’ example.txt</td><td>从example.txt文件中删除所有空白行</td></tr><tr><td>sed ‘&#x2F; *#&#x2F;d; &#x2F;^$&#x2F;d’ example.txt</td><td>从example.txt文件中删除所有注释和空白行</td></tr><tr><td>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’</td><td>合并上下单元格内容</td></tr><tr><td>sed -e ‘1d’ result.txt 从文件example.txt</td><td>中排除第一行</td></tr><tr><td>sed -n ‘&#x2F;stringa1&#x2F;p’</td><td>查看只包含词汇 “string1”的行</td></tr><tr><td>sed -e ‘s&#x2F; *$&#x2F;&#x2F;‘ example.txt</td><td>删除每一行最后的空白字符</td></tr><tr><td>sed -e ‘s&#x2F;stringa1&#x2F;&#x2F;g’ example.txt</td><td>从文档中只删除词汇 “string1” 并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ example.txt</td><td>查看从第一行到第5行内容</td></tr><tr><td>sed -n ‘5p;5q’ example.txt</td><td>查看第5行</td></tr><tr><td>sed -e ‘s&#x2F;00*&#x2F;0&#x2F;g’ example.txt</td><td>用单个零替换多个零</td></tr><tr><td>cat -n file1</td><td>标示文件的行数</td></tr><tr><td>cat example.txt | awk ‘NR%2&#x3D;&#x3D;1’</td><td>删除example.txt文件中的所有偶数行</td></tr><tr><td>echo a b c | awk ‘{print $1}’</td><td>查看一行第一栏</td></tr><tr><td>echo a b c | awk ‘{print <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141134478.svg+xml;%20charset=utf-8" alt="1,">3}’</td><td>查看一行的第一和第三栏</td></tr><tr><td>paste file1 file2</td><td>合并两个文件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个文件或两栏的内容，中间用”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个文件的内容</td></tr><tr><td>sort file1 file2 | uniq</td><td>取出两个文件的并集(重复的行只保留一份)</td></tr><tr><td>sort file1 file2 | uniq -u</td><td>删除交集，留下其他的行</td></tr><tr><td>sort file1 file2 | uniq -d</td><td>取出两个文件的交集(只留下同时存在于两个文件中的文件)</td></tr><tr><td>comm -1 file1 file2</td><td>比较两个文件的内容只删除 ‘file1’ 所包含的内容</td></tr><tr><td>comm -2 file1 file2</td><td>比较两个文件的内容只删除 ‘file2’ 所包含的内容</td></tr><tr><td>comm -3 file1 file2</td><td>比较两个文件的内容只删除两个文件共有的部分</td></tr></tbody></table><h2 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>dos2unix filedos.txt fileunix.txt</td><td>将一个文本文件的格式从MSDOS转换成UNIX</td></tr><tr><td>unix2dos fileunix.txt filedos.txt</td><td>将一个文本文件的格式从UNIX转换成MSDOS</td></tr><tr><td>recode ..HTML &lt; page.txt &gt; page.html</td><td>将一个文本文件转换成html</td></tr><tr><td>recode -l | more</td><td>显示所有允许的转换格式</td></tr></tbody></table><h2 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>badblocks -v &#x2F;dev&#x2F;hda1</td><td>检查磁盘hda1上的坏磁块</td></tr><tr><td>fsck &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上linux文件系统的完整性</td></tr><tr><td>fsck.ext2 &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上ext2文件系统的完整性</td></tr><tr><td>e2fsck &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上ext2文件系统的完整性</td></tr><tr><td>e2fsck -j &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上ext3文件系统的完整性</td></tr><tr><td>fsck.ext3 &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上ext3文件系统的完整性</td></tr><tr><td>fsck.vfat &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上fat文件系统的完整性</td></tr><tr><td>fsck.msdos &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上dos文件系统的完整性</td></tr><tr><td>dosfsck &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上dos文件系统的完整性</td></tr></tbody></table><h2 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>mkfs &#x2F;dev&#x2F;hda1</td><td>在hda1分区创建一个文件系统</td></tr><tr><td>mke2fs &#x2F;dev&#x2F;hda1</td><td>在hda1分区创建一个linux ext2的文件系统</td></tr><tr><td>mke2fs -j &#x2F;dev&#x2F;hda1</td><td>在hda1分区创建一个linux ext3(日志型)的文件系统</td></tr><tr><td>mkfs -t vfat 32 -F &#x2F;dev&#x2F;hda1</td><td>创建一个 FAT32 文件系统</td></tr><tr><td>fdformat -n &#x2F;dev&#x2F;fd0</td><td>格式化一个软盘</td></tr><tr><td>mkswap &#x2F;dev&#x2F;hda3</td><td>创建一个swap文件系统</td></tr></tbody></table><h2 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>mkswap &#x2F;dev&#x2F;hda3</td><td>创建一个swap文件系统</td></tr><tr><td>swapon &#x2F;dev&#x2F;hda3</td><td>启用一个新的swap文件系统</td></tr><tr><td>swapon &#x2F;dev&#x2F;hda2 &#x2F;dev&#x2F;hdb3</td><td>启用两个swap分区</td></tr></tbody></table><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home</td><td>制作一个 ‘&#x2F;home’ 目录的完整备份</td></tr><tr><td>dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home</td><td>制作一个 ‘&#x2F;home’ 目录的交互式备份</td></tr><tr><td>restore -if &#x2F;tmp&#x2F;home0.bak</td><td>还原一个交互式备份</td></tr><tr><td>rsync -rogpav –delete &#x2F;home &#x2F;tmp</td><td>同步两边的目录</td></tr><tr><td>rsync -rogpav -e ssh –delete &#x2F;home ip_address:&#x2F;tmp</td><td>通过SSH通道rsync</td></tr><tr><td>rsync -az -e ssh –delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local</td><td>通过ssh和压缩将一个远程目录同步到本地目录</td></tr><tr><td>rsync -az -e ssh –delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public</td><td>通过ssh和压缩将本地目录同步到远程目录</td></tr><tr><td>dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr ‘dd of&#x3D;hda.gz’</td><td>通过ssh在远程主机上执行一次备份本地磁盘的操作</td></tr><tr><td>dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1</td><td>备份磁盘内容到一个文件</td></tr><tr><td>tar -Puf backup.tar &#x2F;home&#x2F;user</td><td>执行一次对 ‘&#x2F;home&#x2F;user’ 目录的交互式备份操作</td></tr><tr><td>( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p’</td><td>通过ssh在远程目录中复制一个目录内容</td></tr><tr><td>( tar c &#x2F;home )</td><td>ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录</td></tr><tr><td>tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - )</td><td>本地将一个目录复制到另一个地方，保留原有权限及链接</td></tr><tr><td>find &#x2F;home&#x2F;user1 -name ‘*.txt’ | xargs cp -av –target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; –parents</td><td>从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录</td></tr><tr><td>find &#x2F;var&#x2F;log -name ‘*.log’ | tar cv –files-from&#x3D;- | bzip2 &gt; log.tar.bz2</td><td>查找所有以 ‘.log’ 结尾的文件并做成一个bzip包</td></tr><tr><td>dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1</td><td>做一个将 MBR (Master Boot Record)内容复制到软盘的动作</td></tr><tr><td>dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1</td><td>从已经保存到软盘的备份中恢复MBR内容</td></tr></tbody></table><h2 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>cdrecord -v gracetime&#x3D;2 dev&#x3D;&#x2F;dev&#x2F;cdrom -eject blank&#x3D;fast -force</td><td>清空一个可复写的光盘内容</td></tr><tr><td>mkisofs &#x2F;dev&#x2F;cdrom &gt; cd.iso</td><td>在磁盘上创建一个光盘的iso镜像文件</td></tr><tr><td>mkisofs &#x2F;dev&#x2F;cdrom | gzip &gt; cd_iso.gz</td><td>在磁盘上创建一个压缩了的光盘iso镜像文件</td></tr><tr><td>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o .&#x2F;cd.iso data_cd</td><td>创建一个目录的iso镜像文件</td></tr><tr><td>cdrecord -v dev&#x3D;&#x2F;dev&#x2F;cdrom cd.iso</td><td>刻录一个ISO镜像文件</td></tr><tr><td>gzip -dc cd_iso.gz | cdrecord dev&#x3D;&#x2F;dev&#x2F;cdrom -</td><td>刻录一个压缩了的ISO镜像文件</td></tr><tr><td>mount -o loop cd.iso &#x2F;mnt&#x2F;iso</td><td>挂载一个ISO镜像文件</td></tr><tr><td>cd-paranoia -B</td><td>从一个CD光盘转录音轨到 wav 文件中</td></tr><tr><td>cd-paranoia – “-3”</td><td>从一个CD光盘转录音轨到 wav 文件中（参数-3）</td></tr><tr><td>cdrecord –scanbus</td><td>扫描总线以识别scsi通道</td></tr><tr><td>dd if&#x3D;&#x2F;dev&#x2F;hdc | md5sum</td><td>校验一个设备的md5sum编码，例如一张 CD</td></tr></tbody></table><h2 id="网络-（以太网和WIFI无线-）"><a href="#网络-（以太网和WIFI无线-）" class="headerlink" title="网络 - （以太网和WIFI无线**）"></a>网络 - （以太网和WIFI无线**）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ifconfig eth0</td><td>显示一个以太网卡的配置</td></tr><tr><td>ifup eth0</td><td>启用一个 ‘eth0’ 网络设备</td></tr><tr><td>ifdown eth0</td><td>禁用一个 ‘eth0’ 网络设备</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>控制IP地址</td></tr><tr><td>ifconfig eth0 promisc 设置 ‘eth0’</td><td>成混杂模式以嗅探数据包 (sniffing)</td></tr><tr><td>dhclient eth0 以dhcp</td><td>模式启用 ‘eth0’</td></tr></tbody></table><p>作者：yichen_china<br>链接：<a href="https://www.jianshu.com/p/ca2d79cc344f">https://www.jianshu.com/p/ca2d79cc344f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习</title>
    <link href="/2023/03/14/Linux%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/14/Linux%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux文件基本属性"><a href="#Linux文件基本属性" class="headerlink" title="Linux文件基本属性"></a>Linux文件基本属性</h1><p>在Linux中我们常用一下两个命令来修改文件或目录的所属用户与权限：</p><ul><li>chown（change owner）：修改所属用户与组</li><li>chmod（change mode）：修改用户的权限</li></ul><p>在Linux中我们可使用<code>ls -l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www /]<span class="hljs-comment"># ls -l</span><br>total 64<br>dr-xr-xr-x  <span class="hljs-number"> 2 </span>root root<span class="hljs-number"> 4096 </span>Dec<span class="hljs-number"> 14 </span><span class="hljs-number"> 2012 </span>bin<br>dr-xr-xr-x  <span class="hljs-number"> 4 </span>root root<span class="hljs-number"> 4096 </span>Apr<span class="hljs-number"> 19 </span><span class="hljs-number"> 2012 </span>boot<br>……<br></code></pre></td></tr></table></figure><p>实例中，<strong>bin</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p><p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为 <strong>d</strong> 则是目录</li><li>当为 <strong>-</strong> 则是文件；</li><li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li><li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141141687.png" alt="image-20230314114115614"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141156823.png" alt="image-20230314115600767"></p><h2 id="Linux文件属主和属组"><a href="#Linux文件属主和属组" class="headerlink" title="Linux文件属主和属组"></a>Linux文件属主和属组</h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www /]<span class="hljs-comment"># ls -l</span><br>total 64<br>drwxr-xr-x<span class="hljs-number"> 2 </span>root  root <span class="hljs-number"> 4096 </span>Feb<span class="hljs-number"> 15 </span>14:46 cron<br>drwxr-xr-x<span class="hljs-number"> 3 </span>mysql mysql<span class="hljs-number"> 4096 </span>Apr<span class="hljs-number"> 21 </span><span class="hljs-number"> 2014 </span>mysql<br>……<br></code></pre></td></tr></table></figure><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p><p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p><h2 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h2><h3 id="1、chgrp：更改文件属组"><a href="#1、chgrp：更改文件属组" class="headerlink" title="1、chgrp：更改文件属组"></a>1、chgrp：更改文件属组</h3><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chgrp</span> [-R] 属组名 文件名<br></code></pre></td></tr></table></figure><p>参数选项</p><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><h3 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h3><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [–R] 属主名 文件名<br><span class="hljs-built_in">chown</span> [-R] 属主名：属组名 文件名<br></code></pre></td></tr></table></figure><p>进入 &#x2F;root 目录（~）将install.log的拥有者改为bin这个账号：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~] cd ~<br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># chown bin install.log</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls -l</span><br>-rw-r--r--  <span class="hljs-number">1</span> bin  users <span class="hljs-number">68495</span> Jun <span class="hljs-number">25</span> <span class="hljs-number">08</span>:<span class="hljs-number">53</span> install.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>将install.log的拥有者与群组改回为root：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># chown root:root install.log</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls -l</span><br>-rw-r--r--  <span class="hljs-number">1</span> root root <span class="hljs-number">68495</span> Jun <span class="hljs-number">25</span> <span class="hljs-number">08</span>:<span class="hljs-number">53</span> install.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h3 id="chmod：更改文件九个属性"><a href="#chmod：更改文件九个属性" class="headerlink" title="chmod：更改文件九个属性"></a>chmod：更改文件九个属性</h3><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux 文件的基本权限就有九个，分别是 <strong>owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他)</strong> 三种身份各有自己的 <strong>read&#x2F;write&#x2F;execute</strong> 权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为： <strong>-rwxrwxrwx</strong> ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为： <strong>-rwxrwx—</strong> 分数则是：</p><ul><li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li><li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li><li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是 <strong>770</strong>。变更权限的指令 chmod 的语法是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>xyz</strong> : 就是刚刚提到的数字类型的权限属性，为 <strong>rwx</strong> 属性数值的相加。</li><li><strong>-R</strong> : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更</li></ul><p>举例来说，如果要将 <strong>.bashrc</strong> 这个文件所有的权限都设定启用，那么命令如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www ~]<span class="hljs-comment"># ls -al .bashrc</span><br>-rw-r--r-- <span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 395 </span>Jul <span class="hljs-number"> 4 </span>11:45 .bashrc<br>[root@www ~]<span class="hljs-comment"># chmod 777 .bashrc</span><br>[root@www ~]<span class="hljs-comment"># ls -al .bashrc</span><br>-rwxrwxrwx <span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 395 </span>Jul <span class="hljs-number"> 4 </span>11:45 .bashrc<br></code></pre></td></tr></table></figure><p>那如果要将权限变成 <em>-rwxr-xr–</em> 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]&#x3D;754。</p><h3 id="符号类型改变文件权限"><a href="#符号类型改变文件权限" class="headerlink" title="符号类型改变文件权限"></a>符号类型改变文件权限</h3><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p><ul><li>user：用户</li><li>group：组</li><li>others：其他</li></ul><p>那么我们就可以使用 <strong>u, g, o</strong> 来代表三种身份的权限。</p><p>此外， <strong>a</strong> 则代表 <strong>all</strong>，即全部的身份。读写的权限可以写成 <strong>r, w, x</strong>，也就是可以使用下表的方式来看：</p><table><thead><tr><th>chmod</th><th>u g o a</th><th>+(加入) -(除去) &#x3D;(设定)</th><th>r w x</th><th>文件或目录</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>如果我们需要将文件权限设置为 <strong>-rwxr-xr–</strong> ，可以使用 <strong>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r 文件名</strong> 来设定:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment">#  touch test1    // 创建 test1 文件</span><br><span class="hljs-comment"># ls -al test1    // 查看 test1 默认权限</span><br>-rw-r--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>Nov<span class="hljs-number"> 15 </span>10:32 test1<br><span class="hljs-comment"># chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限</span><br><span class="hljs-comment"># ls -al test1</span><br>-rwxr-xr--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>Nov<span class="hljs-number"> 15 </span>10:32 test1<br></code></pre></td></tr></table></figure><p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment">#  chmod  a-x test1</span><br><span class="hljs-comment"># ls -al test1</span><br>-rw-r--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>Nov<span class="hljs-number"> 15 </span>10:32 test1<br></code></pre></td></tr></table></figure><h1 id="Linux文件与目录管理"><a href="#Linux文件与目录管理" class="headerlink" title="Linux文件与目录管理"></a>Linux文件与目录管理</h1><p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 **&#x2F;**。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><ul><li><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>&#x2F;</strong> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。</li><li><strong>相对路径：</strong><br>路径的写法，不是由 <strong>&#x2F;</strong> 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： <strong>cd ..&#x2F;man</strong> 这就是相对路径的写法。</li></ul><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><ul><li>ls（英文全拼：list files）: 列出目录及文件名</li><li>cd（英文全拼：change directory）：切换目录</li><li>pwd（英文全拼：print work directory）：显示目前的目录</li><li>mkdir（英文全拼：make directory）：创建一个新的目录</li><li>rmdir（英文全拼：remove directory）：删除一个空的目录</li><li>cp（英文全拼：copy file）: 复制文件或目录</li><li>rm（英文全拼：remove）: 删除文件或目录</li><li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">[root@www ~]# <span class="hljs-keyword">ls</span> [-aAdfFhilnrRSt] 目录名称<br>[root@www ~]# <span class="hljs-keyword">ls</span> [--<span class="hljs-keyword">color</span>=&#123;never,auto,always&#125;] 目录名称<br>[root@www ~]# <span class="hljs-keyword">ls</span> [--full-time] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls -al ~</span><br></code></pre></td></tr></table></figure><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"> <span class="hljs-attribute">cd</span> [相对路径或绝对路径]<br><span class="hljs-comment">#使用 mkdir 命令创建 runoob 目录</span><br>[root<span class="hljs-variable">@www</span> ~]<span class="hljs-comment"># mkdir runoob</span><br><br><span class="hljs-comment">#使用绝对路径切换到 runoob 目录</span><br>[root<span class="hljs-variable">@www</span> ~]<span class="hljs-comment"># cd /root/runoob/</span><br><br><span class="hljs-comment">#使用相对路径切换到 runoob 目录</span><br>[root<span class="hljs-variable">@www</span> ~]<span class="hljs-comment"># cd ./runoob/</span><br><br><span class="hljs-comment"># 表示回到自己的家目录，亦即是 /root 这个目录</span><br>[root<span class="hljs-variable">@www</span> runoob]<span class="hljs-comment"># cd ~</span><br><br><span class="hljs-comment"># 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span><br>[root<span class="hljs-variable">@www</span> ~]<span class="hljs-comment"># cd ..</span><br></code></pre></td></tr></table></figure><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># pwd [-P]</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li></ul><p>实例：单纯显示出目前的工作目录：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># pwd</span><br>/root   &lt;== 显示出目录啦～<br></code></pre></td></tr></table></figure><p>实例显示出实际的工作目录，而非链接档本身的目录名而已。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@www ~]# cd <span class="hljs-regexp">/var/m</span>ail   &lt;==注意，<span class="hljs-regexp">/var/m</span>ail是一个链接档<br>[root@www mail]# pwd<br><span class="hljs-regexp">/var/m</span>ail         &lt;==列出目前的工作目录<br>[root@www mail]# pwd -P<br><span class="hljs-regexp">/var/</span>spool/mail   &lt;==怎么回事？有没有加 -P 差很多～<br>[root@www mail]# ls -ld <span class="hljs-regexp">/var/m</span>ail<br>lrwxrwxrwx <span class="hljs-number">1</span> root root <span class="hljs-number">10</span> Sep  <span class="hljs-number">4</span> <span class="hljs-number">17</span>:<span class="hljs-number">54</span> <span class="hljs-regexp">/var/m</span>ail -&gt; spool/mail<br># 看到这里应该知道为啥了吧？因为 <span class="hljs-regexp">/var/m</span>ail 是链接档，链接到 <span class="hljs-regexp">/var/</span>spool/mail <br># 所以，加上 pwd -P 的选项后，会不以链接档的数据显示，而是显示正确的完整路径啊！<br></code></pre></td></tr></table></figure><h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir [-mp] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：请到&#x2F;tmp底下尝试创建数个新目录看看：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">[root@www ~]# <span class="hljs-keyword">cd</span> /tmp<br>[root@www tmp]# <span class="hljs-keyword">mkdir</span> <span class="hljs-keyword">test</span>    &lt;==创建一名为 <span class="hljs-keyword">test</span> 的新目录<br>[root@www tmp]# <span class="hljs-keyword">mkdir</span> test1/test2/test3/test4<br><span class="hljs-keyword">mkdir</span>: cannot create directory `test1/test2/test3/test4&#x27;: <br><span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory       &lt;== 没办法直接创建此目录啊！<br>[root@www tmp]# <span class="hljs-keyword">mkdir</span> -p test1/test2/test3/test4<br></code></pre></td></tr></table></figure><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p><p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www tmp]<span class="hljs-comment"># mkdir -m 711 test2</span><br>[root@www tmp]<span class="hljs-comment"># ls -l</span><br>drwxr-xr-x <span class="hljs-number"> 3 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:50 test<br>drwxr-xr-x <span class="hljs-number"> 3 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:53 test1<br>drwx--x--x <span class="hljs-number"> 2 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:54 test2<br></code></pre></td></tr></table></figure><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p><p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmdir [-p] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-p ：</strong>从该目录起，一次删除多级空目录</li></ul><p>删除 runoob 目录</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># rmdir runoob/</span><br></code></pre></td></tr></table></figure><p>将 mkdir 实例中创建的目录(&#x2F;tmp 底下)删除掉！</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www tmp]<span class="hljs-comment"># ls -l   &lt;==看看有多少目录存在？</span><br>drwxr-xr-x <span class="hljs-number"> 3 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:50 test<br>drwxr-xr-x <span class="hljs-number"> 3 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:53 test1<br>drwx--x--x <span class="hljs-number"> 2 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:54 test2<br>[root@www tmp]<span class="hljs-comment"># rmdir test   &lt;==可直接删除掉，没问题</span><br>[root@www tmp]<span class="hljs-comment"># rmdir test1  &lt;==因为尚有内容，所以无法删除！</span><br>rmdir: `test1&#x27;: Directory not empty<br>[root@www tmp]<span class="hljs-comment"># rmdir -p test1/test2/test3/test4</span><br>[root@www tmp]<span class="hljs-comment"># ls -l        &lt;==您看看，底下的输出中test与test1不见了！</span><br>drwx--x--x <span class="hljs-number"> 2 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:54 test2<br></code></pre></td></tr></table></figure><p>利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除。</p><p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p><p>语法:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[root@www ~]</span># cp <span class="hljs-selector-attr">[-adfilprsu]</span> 来源档(source) 目标档(destination)<br><span class="hljs-selector-attr">[root@www ~]</span># cp <span class="hljs-selector-attr">[options]</span> source1 source2 source3 .... directory<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-d：</strong>若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式链接(hard link)的链接档创建，而非复制文件本身；</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-s：</strong>复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@www ~]# cp ~<span class="hljs-regexp">/.bashrc /</span>tmp/bashrc<br>[root@www ~]# cp -i ~<span class="hljs-regexp">/.bashrc /</span>tmp/bashrc<br>cp: overwrite `<span class="hljs-regexp">/tmp/</span>bashrc<span class="hljs-string">&#x27;? n  &lt;==n不覆盖，y为覆盖</span><br></code></pre></td></tr></table></figure><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> [-fir] 文件或目录<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li><li></li></ul><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">[root@www tmp]# <span class="hljs-keyword">rm</span> -i bashrc<br><span class="hljs-keyword">rm</span>: remove regular <span class="hljs-keyword">file</span> <span class="hljs-symbol">`bashrc&#x27;</span>? y<br></code></pre></td></tr></table></figure><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># mv [-fiu] source destination</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># mv [options] source1 source2 source3 .... directory</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>复制一文件，创建一目录，将文件移动到目录中</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># cd /tmp</span><br>[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># cp ~/.bashrc bashrc</span><br>[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># mkdir mvtest</span><br>[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># mv bashrc mvtest</span><br></code></pre></td></tr></table></figure><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># mv mvtest mvtest2</span><br></code></pre></td></tr></table></figure><h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p><p>语法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span><span class="hljs-meta"> [-AbEnTv]</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>检看 &#x2F;etc&#x2F;issue 这个文件的内容：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@www ~]<span class="hljs-comment"># cat /etc/issue</span><br>CentOS release <span class="hljs-number">6.4</span> (Final)<br>Kernel <span class="hljs-string">\r</span> <span class="hljs-literal">on</span> an <span class="hljs-string">\m</span><br></code></pre></td></tr></table></figure><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@www ~]<span class="hljs-comment"># tac /etc/issue</span><br><br>Kernel <span class="hljs-string">\r</span> <span class="hljs-literal">on</span> an <span class="hljs-string">\m</span><br>CentOS release <span class="hljs-number">6.4</span> (Final)<br></code></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nl</span> [-bnw] 文件<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>实例一：用 nl 列出 &#x2F;etc&#x2F;issue 的内容</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@www ~]<span class="hljs-comment"># nl /etc/issue</span><br>     <span class="hljs-number">1</span>  CentOS release <span class="hljs-number">6.4</span> (Final)<br>     <span class="hljs-number">2</span>  Kernel <span class="hljs-string">\r</span> <span class="hljs-literal">on</span> an <span class="hljs-string">\m</span><br></code></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@www ~]<span class="hljs-comment"># more /etc/man_db.config </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Generated automatically from man.conf.in by the</span><br><span class="hljs-comment"># configure script.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># man.conf from man-1.6d</span><br><span class="hljs-string">....</span><span class="hljs-params">(中间省略)</span><span class="hljs-string">....</span><br><span class="hljs-params">--More--</span><span class="hljs-params">(28%)</span>  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令<br></code></pre></td></tr></table></figure><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter     ：代表向下翻『一行』；</li><li>&#x2F;字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f      ：立刻显示出档名以及目前显示的行数；</li><li>q       ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@www ~]<span class="hljs-comment"># less /etc/man.config</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Generated automatically from man.conf.in by the</span><br><span class="hljs-comment"># configure script.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># man.conf from man-1.6d</span><br><span class="hljs-string">....</span><span class="hljs-params">(中间省略)</span><span class="hljs-string">....</span><br>:   &lt;== 这里可以等待你输入命令！<br></code></pre></td></tr></table></figure><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>&#x2F;字串   ：向下搜寻『字串』的功能；</li><li>?字串   ：向上搜寻『字串』的功能；</li><li>n     ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li><li>N     ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li><li>q     ：离开 less 这个程序；</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p><p>语法：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">head [-n <span class="hljs-built_in">number</span>] 文件 <br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># head /etc/man.config</span><br></code></pre></td></tr></table></figure><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># head -n 20 /etc/man.config</span><br></code></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p><p>语法：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">tail [-n <span class="hljs-built_in">number</span>] 文件 <br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># tail /etc/man.config</span><br><span class="hljs-meta"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># tail -n 20 /etc/man.config</span><br></code></pre></td></tr></table></figure><h1 id="Linux-vim"><a href="#Linux-vim" class="headerlink" title="Linux vim"></a>Linux vim</h1><p>vim 键盘图：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141208876.png" alt="image-20230314120835808"> </p><h2 id="vi-x2F-vim-的使用"><a href="#vi-x2F-vim-的使用" class="headerlink" title="vi&#x2F;vim 的使用"></a>vi&#x2F;vim 的使用</h2><p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p><h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li><li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li><li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><h2 id="vi-x2F-vim-使用实例"><a href="#vi-x2F-vim-使用实例" class="headerlink" title="vi&#x2F;vim 使用实例"></a>vi&#x2F;vim 使用实例</h2><h3 id="使用-vi-x2F-vim-进入一般模式"><a href="#使用-vi-x2F-vim-进入一般模式" class="headerlink" title="使用 vi&#x2F;vim 进入一般模式"></a>使用 vi&#x2F;vim 进入一般模式</h3><p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>vim runoob.txt<br></code></pre></td></tr></table></figure><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141210433.png" alt="image-20230314121017372"></p><h3 id="按下-i-进入输入模式-也称为编辑模式-，开始编辑文字"><a href="#按下-i-进入输入模式-也称为编辑模式-，开始编辑文字" class="headerlink" title="按下 i 进入输入模式(也称为编辑模式)，开始编辑文字"></a>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</h3><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141210770.png" alt="image-20230314121036712"></p><h3 id="按下-ESC-按钮回到一般模式"><a href="#按下-ESC-按钮回到一般模式" class="headerlink" title="按下 ESC 按钮回到一般模式"></a>按下 ESC 按钮回到一般模式</h3><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p><h3 id="在一般模式中按下-wq-储存后离开-vi"><a href="#在一般模式中按下-wq-储存后离开-vi" class="headerlink" title="在一般模式中按下 :wq 储存后离开 vi"></a>在一般模式中按下 <strong>:wq</strong> 储存后离开 vi</h3><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141210979.png" alt="image-20230314121057916"></p><h2 id="vi-x2F-vim-按键说明"><a href="#vi-x2F-vim-按键说明" class="headerlink" title="vi&#x2F;vim 按键说明"></a>vi&#x2F;vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><h3 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table><thead><tr><th align="left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">n<space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="left">n<Enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr><tr><td align="left">搜索替换</td><td></td></tr><tr><td align="left">&#x2F;word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="left">使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td align="left">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="left"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="left"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td align="left">删除、复制与贴上</td><td></td></tr><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="left">ndd</td><td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td align="left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table><thead><tr><th align="left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="left">a, A</td><td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="left">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr><td align="left">r, R</td><td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr><td align="left">ZQ</td><td>不保存，强制退出。效果等同于 **:q!**。</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！</td></tr><tr><td align="left">vim 环境的变更</td><td></td></tr><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>特别注意，在 vi&#x2F;vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p><p>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p><p><strong>vim 中批量添加注释</strong></p><p>方法一 ：块选择模式</p><p>批量注释：</p><p><strong>Ctrl + v</strong> 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 <strong>I</strong> 进入行首插入模式输入注释符号如 <strong>&#x2F;&#x2F;</strong> 或 <strong>#<strong>，输入完毕之后，按两下 <strong>ESC</strong>，</strong>Vim</strong> 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p><p>取消注释：</p><p><strong>Ctrl + v</strong> 进入块选择模式，选中你要删除的行首的注释符号，注意 <strong>&#x2F;&#x2F;</strong> 要选中两个，选好之后按 <strong>d</strong> 即可删除注释，<strong>ESC</strong> 保存退出。</p><p>方法二: 替换命令</p><p>批量注释。</p><p>使用下面命令在指定的行首添加注释。</p><p>使用名命令格式： <strong>:起始行号,结束行号s&#x2F;^&#x2F;注释符&#x2F;g</strong>（注意冒号）。</p><p>取消注释：</p><p>使用名命令格式： <strong>:起始行号,结束行号s&#x2F;^注释符&#x2F;&#x2F;g</strong>（注意冒号）。</p><p>例子：</p><p>1、在 10 - 20 行添加 <strong>&#x2F;&#x2F;</strong> 注释</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s#^#<span class="hljs-comment">//#g</span><br></code></pre></td></tr></table></figure><p>2、在 10 - 20 行删除 <strong>&#x2F;&#x2F;</strong> 注释</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s<span class="hljs-meta">#^<span class="hljs-comment">//##g</span></span><br></code></pre></td></tr></table></figure><p>3、在 10 - 20 行添加 <strong>#</strong> 注释</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s<span class="hljs-regexp">/^/</span><span class="hljs-comment">#/g</span><br></code></pre></td></tr></table></figure><p>4、在 <strong>10 - 20</strong> 行删除 # 注释</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s/<span class="hljs-meta">#<span class="hljs-comment">//g</span></span><br></code></pre></td></tr></table></figure><p><strong>vim快捷键补充（插入模式）</strong></p><ol><li>自动补全：<strong>ctrl</strong> + <strong>n</strong></li><li>**\p&lt;** 插入一个include，并把光标置于&lt;&gt;中间</li><li><strong>\im</strong> 插入主函数</li><li><strong>\ip</strong> 插入printf，并自动添加<strong>\n</strong>，且把光标置于双引号中间</li></ol><p>vim快捷键补充（编辑模式）</p><ol><li>dw 删除一个单词（配合b：将光标置于所在单词的首部）</li><li>yw 复制一个单词（配合p：粘贴）</li></ol><p>vim快捷键补充（插入与编辑模式通用）</p><ol><li>\rr 运行程序</li><li>\rc 保存并编译程序（会生成二进制文件）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统概述复习</title>
    <link href="/2023/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="#%E7%AC%AC1%E7%AB%A0%20%E6%A6%82%E8%BF%B0">第1章 概述</a></p><p><a href="#1.1%20DBS%E6%A6%82%E8%BF%B0">1.1 DBS概述</a></p><p><a href="#1.1.1%20%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.1.1 四个基本概念</a></p><p><a href="#1.1.2%20%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5">1.1.1 1.1.2 数据管理的三个阶段</a></p><p><a href="#1.1.3%20DBS%E7%9A%84%E7%89%B9%E7%82%B9">1.1.3 DBS的特点</a></p><p><a href="#1.2%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2 数据模型</a></p><p><a href="#1.2.1%20%E4%B8%A4%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2.1 两类数据模型</a></p><p><a href="#1.2.2%20%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B">1.2.2 概念模型</a></p><p><a href="#1.2.3%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0">1.2.3 数据模型的组成要素</a></p><p><a href="#1.2.4%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2.4 常用的数据模型</a></p><p><a href="#1.2.7%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B">1.2.7 关系模型</a></p><p><a href="#1.3%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84">1.3 数据库系统的结构</a></p><p><a href="#1.3.1%20DBS%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5">1.3.1 DBS模式的概念</a></p><p><a href="#1.3.2%20DBS%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84">1.3.2 DBS的三级模式结构</a></p><p><a href="#1.3.3%20DB%E7%9A%84%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%83%8F%E5%8A%9F%E8%83%BD%E5%92%8C%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7">1.3.3 DB的二级映像功能和数据独立性</a></p><p><a href="#%E7%AC%AC2%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">第2章 关系数据库</a></p><p><a href="#2.1%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89">2.1 关系数据结构及形式化定义</a></p><p><a href="#2.1.1%20%E5%85%B3%E7%B3%BB">2.1.1 关系</a></p><p><a href="#2.1.2%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F">2.1.2 关系模式</a></p><p><a href="#2.2%20%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C">2.2 关系操作</a></p><p><a href="#2.3%20%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">2.3 关系的完整性</a></p><p><a href="#2.3.1%20%E5%AE%9E%E4%BD%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.1 实体的完整性</a></p><p><a href="#2.3.2%20%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.2 参照完整性</a></p><p><a href="#2.3.3%20%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.3 用户定义完整性</a></p><p><a href="#2.4%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0">2.4 关系代数</a></p><p><a href="#2.4.1%20%E4%BC%A0%E7%BB%9F%E7%9A%84%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97">2.4.1 传统的集合运算</a></p><p><a href="#2.4.2%20%E4%B8%93%E9%97%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97">2.4.2 专门的关系运算</a></p><p><a href="#%E7%AC%AC3%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL">第3章 关系型数据库标准语言SQL</a></p><p><a href="#3.1%20SQL%E6%A6%82%E8%BF%B0">3.1 SQL概述</a></p><p><a href="#3.1.3%20SQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5P78">3.1.3 SQL的基本概念P78</a></p><p><a href="#3.3%20%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89">3.3 数据定义</a></p><p><a href="#3.3.1%20%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%A0%E9%99%A4">3.3.1 模式的定义和删除</a></p><p><a href="#3.3.2%20%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9">3.3.2 基本表的定义、删除与修改</a></p><p><a href="#3.3.3%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E5%88%A0%E9%99%A4">3.3.3 索引的建立与删除</a></p><p><a href="#3.4%20%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2">3.4 数据查询</a></p><p><a href="#3.4.1%20%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2">3.4.1 单表查询</a></p><p><a href="#3.4.2%20%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2">3.4.2 连接查询</a></p><p><a href="#3.4.3%20%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2">3.4.3 嵌套查询（nested query）凸显结构化</a></p><p><a href="#3.4.4%20%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2">3.4.4 集合查询</a></p><p><a href="#3.4.5%20%E5%9F%BA%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2">3.4.5 基于派生表的查询</a></p><p><a href="#3.4.6%20select%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F">3.4.6 select语句的一般格式</a></p><p><a href="#3.5%20%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0">3.5 数据更新</a></p><p><a href="#3.5.1%20%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">3.5.1 插入数据</a></p><p><a href="#3.5.2%20%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE">3.5.2 修改数据</a></p><p><a href="#3.5.3%20%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">3.5.3 删除数据</a></p><p><a href="#3.6%20%E7%A9%BA%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86">3.6 空值的处理</a></p><p><a href="#3.7%20%E8%A7%86%E5%9B%BE">3.7 视图</a></p><p><a href="#3.7.1%20%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE">3.7.1 定义视图</a></p><p><a href="#3.7.2%20%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE">3.7.2 查询视图</a></p><p><a href="#3.7.3%20%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE">3.7.3 更新视图</a></p><p><a href="#3.7.4%20%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8">3.7.4 视图的作用</a></p><p><a href="#%E7%AC%AC4%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7">第4章 数据库安全性</a></p><p><a href="#4.2%20DB%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6">4.2 DB安全性控制</a></p><p><a href="#4.2.1%20%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E5%88%AB">4.2.1 用户身份鉴别</a></p><p><a href="#4.2.2%20%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">4.2.2 存取控制</a></p><p><a href="#4.2.3%20%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95">4.2.3 自主存取控制方法</a></p><p><a href="#4.2.4%20%E6%8E%88%E6%9D%83%EF%BC%9A%E6%8E%88%E4%BA%88%E4%B8%8E%E6%94%B6%E5%9B%9E">4.2.4 授权：授予与收回</a></p><p><a href="#%E7%AC%AC5%E7%AB%A0">第5章</a></p><p><a href="#5.3%20%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">5.3 用户定义的完整性</a></p><p><a href="#5.3.1%20%E5%B1%9E%E6%80%A7%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6(P163)">5.3.1 属性上的约束条件(P163)</a></p><p><a href="#5.3.2%20%E5%85%83%E7%BB%84%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89">5.3.2 元组上的约束条件的定义</a></p><p><a href="#%E7%AC%AC7%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1">第7章 数据库设计</a></p><p><a href="#7.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0">7.1 数据库设计概述</a></p><p><a href="#7.1.3%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">7.1.3 数据库设计基本步骤</a></p><p><a href="#7.3%20%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">7.3 概念结构设计</a></p><p><a href="#7.4%20%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">7.4 逻辑结构设计</a></p><p><a href="#7.4.1%20ER%E5%9B%BE%E5%90%91%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2">7.4.1 ER图向关系模型的转换</a></p><p><a href="#7.6%20DB%E7%9A%84%E5%AE%9E%E6%96%BD%E5%92%8C%E7%BB%B4%E6%8A%A4">7.6 DB的实施和维护</a></p><p><a href="#7.6.1%20%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E8%AF%95">7.6.1 数据载入和应用程序的调试</a></p><p><a href="#%E7%AC%AC9%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">第9章 关系查询处理和查询优化</a></p><p><a href="#9.1%20%E5%85%B3%E7%B3%BBDBS%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86">9.1 关系DBS的查询处理</a></p><p><a href="#1.%20%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90">1. 查询分析</a></p><p><a href="#2.%20%E6%9F%A5%E8%AF%A2%E6%A3%80%E6%9F%A5">2. 查询检查</a></p><p><a href="#3.%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">3. 查询优化</a></p><p><a href="#4.%20%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C">4. 查询执行</a></p><p><a href="#9.2%20%E5%85%B3%E7%B3%BBDBS%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">9.2 关系DBS的查询优化</a></p><p><a href="#9.2.1%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0">9.2.1 查询优化概述</a></p><p><a href="#9.3%20%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96">9.3 代数优化</a></p><p><a href="#9.3.2%20%E6%9F%A5%E8%AF%A2%E6%A0%91%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E4%BC%98%E5%8C%96">9.3.2 查询树的启发式优化</a></p><p><a href="#%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF">第10章 数据库恢复技术</a></p><p><a href="#10.1%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">10.1 事务的基本概念</a></p><p><a href="#1.%E4%BA%8B%E5%8A%A1">1.事务</a></p><p><a href="#2.%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7">2.事务的ACID特性</a></p><p><a href="#10.3%20%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB">10.3 故障的种类</a></p><p><a href="#1.%20%E4%BA%8B%E5%8A%A1%E5%86%85%E9%83%A8%E7%9A%84%E6%95%85%E9%9A%9C">1. 事务内部的故障</a></p><p><a href="#2.%20%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C">2. 系统故障</a></p><p><a href="#3.%20%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C">3. 介质故障</a></p><p><a href="#4.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">4. 计算机病毒</a></p><p><a href="#10.4%20%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF">10.4 恢复的实现技术</a></p><p><a href="#10.4.2%20%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">10.4.2 日志文件</a></p><p><a href="#%E8%AF%95%E9%A2%98:">试题:</a></p><hr><h1 id="第1章 概述">第1章 概述</h1><h2 id="1.1 DBS概述">1.1 DBS概述</h2><h3 id="1.1.1 四个基本概念">1.1.1 四个基本概念</h3><p>数据data：描述事物的<strong>符号记录</strong>。<br>数据库DB：长期存储在计算机内的、有组织的、可共享的大量数据集合。<br>数据库管理系统DBMS：是位于用户与操作系统之间的具有数据定义、数据操纵、数据库的运行管理、数据库的建立和维护功能的一层数据管理软件。<br>数据库系统DBS：在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员<strong>DBA</strong>和用户构成。<br>DDL：数据定义语言(Data Definition Launguage)。<br>DML：数据操纵语言(Data Manipulation Launguage)。  </p><h3 id="1.1.2 数据管理的三个阶段">1.1.2 数据管理的三个阶段</h3><table><thead><tr><th></th><th>人工管理阶段</th><th>文件系统阶段</th><th>数据库系统阶段</th></tr></thead><tbody><tr><td>处理方式</td><td>批处理</td><td>联机实时处理，批处理</td><td>有数据库管理系统</td></tr><tr><td>面向对象</td><td>某一个应用程序</td><td>某一个应用</td><td>现实世界</td></tr><tr><td>数据共享程度</td><td>无共享，冗余度极大</td><td>共享性差，冗余度大</td><td>共享性高，冗余度小</td></tr><tr><td>独立性</td><td>不独立，完全依赖程序</td><td>独立性差</td><td>具有高度的物理独立性和一定的逻辑独立性</td></tr></tbody></table><h3 id="1.1.3 DBS的特点">1.1.3 DBS的特点</h3><p>1. <strong>数据结构化</strong></p><p>2. 数据<strong>共享性高</strong>、冗余度低<strong>且易扩充</strong></p><p>3. 数据独立性高</p><blockquote><p>物理独立性：应用程序与数据库中<strong>数据的物理存储</strong>是相互独立的</p><p>逻辑独立性：应用程序与<strong>数据库的逻辑结构</strong>是相互独立的，数据的逻辑结构改变时用户程序可以不变  </p><p>数据的独立性是由<strong>二级映像决定的</strong></p></blockquote><p>4. 数据由DBMS统一管理和控制</p><h2 id="1.2 数据模型">1.2 数据模型</h2><h3 id="1.2.1 两类数据模型">1.2.1 两类数据模型</h3><blockquote><p>1. 概念模型（信息模型） 按用户的观点对数据和信息建模，用于DB设计</p><p>2. 逻辑和物理模型  逻辑模型用于DBMS的实现 物理模型是对底层的抽象</p></blockquote><h3 id="1.2.2 概念模型">1.2.2 概念模型</h3><p>1. 实体：客观存在并可相互区别的事物</p><p>2. 属性：实体所具有的某一特性称为属性</p><p>3. 码：唯一标识实体的属性集</p><p>4. 实体型：同类实体，比如学生</p><p>5. 实体集：同一类型的集合，比如全体学生</p><p>6. 联系：实体内部联系，或者实体之间的联系，如一对一，一对多和多对多</p><p>ER图：概念模型的表示方法</p><h3 id="1.2.3 数据模型的组成要素">1.2.3 数据模型的组成要素</h3><p>1. 数据结构（静态特性）</p><p>2. 数据操作（动态特性）</p><p>3. 数据的完整性约束条件</p><h3 id="1.2.4 常用的数据模型">1.2.4 常用的数据模型</h3><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li><li>面向对象数据模型</li><li>对象关系数据模型</li><li>半结构化数据模型</li></ul><h3 id="1.2.7 关系模型">1.2.7 关系模型</h3><p>1. 关系模型的数据结构</p><blockquote><ol><li>关系：二维表</li><li>元组：行</li><li>属性：列</li><li>码：表里的某个属性组，它可以唯一确定一个元组</li><li>域：一组具有相同数据类型的集合</li><li>分量：行中的某个值</li><li>关系模式：对关系的描述</li></ol></blockquote><p><strong>关系的每一个分量必须是一个不可分的数据项，即不允许表里有表</strong></p><p>2. 数据操纵和完整性约束</p><p>3. 优缺点</p><blockquote><ol><li>具有严谨的数学基础</li><li>概念单一，数据结构简单、清晰，用户易懂</li><li>数据独立性、安全保密性、简化开发工作</li><li>缺点：查询效率不如格式化数据模型，需要查询优化</li></ol></blockquote><h2 id="1.3 数据库系统的结构">1.3 数据库系统的结构</h2><h3 id="1.3.1 DBS模式的概念">1.3.1 DBS模式的概念</h3><blockquote><p>模式是DB中<strong>全体数据</strong>的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值（实例），模式是相对稳定的，而实例是相对变动的，模式反映的是数据的结构和联系，实例反映的是DB某一时刻的状态</p></blockquote><h3 id="1.3.2 DBS的三级模式结构">1.3.2 DBS的三级模式结构</h3><p>1. 外模式（external schema，用户模式）：用户能看到、使用的<strong>局部</strong>数据的<strong>逻辑结构和特征的描述</strong>，是DB用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式是模式的子集，<strong>根据用户的不同而不同</strong>，一个DB可以有多个外模式。外模式是保障DB安全的有利措施，每个用户只能访问对应外模式中的数据，其余不可见。</p><p>2. 模式（逻辑模式）：DB中<strong>全体数据</strong>的<strong>逻辑结构和特征的描述</strong>，是所有用户的<strong>公共数据视图</strong>；是DB模式结构的<strong>中间层</strong>，不涉及物理存储，与应用程序也无关。<strong>一个DB只有一个模式</strong>。</p><p>3. 内模式（internal schema，存储模式）：一个DB只有一个内模式，是物理结构</p><p><strong>注：</strong></p><blockquote><p>一个关系型DBMS的实例（instance）中可建立多个数据库，<strong>一个DB中可建立多个模式（包括不同级的模式）</strong>，一个模式下通常包括多个table、视图、索引等数据库对象。</p><p>DBMS提供<strong>模式DDL</strong>来定义模式，<strong>外模式DDL</strong>来定义外模式</p></blockquote><h3 id="1.3.3 DB的二级映像功能和数据独立性">1.3.3 DB的二级映像功能和数据独立性</h3><p>为了实现三种模式的联系和转换，DBMS提供了两层映像，正因如此，保证了DBS中的数据有较高的独立性</p><p>1. 外模式&#x2F;模式映像</p><p>对于每一个外模式，DBS都有一个外模式&#x2F;模式映像，它定义了该外模式和模式之间的对应关系，这些映像通常包含在各自外模式的描述中。<strong>当模式改变时</strong>，由数据库管理员对映像做相应改变，可使外模式保持不变，而应用程序是根据外模式编写的，所以也不用改，从而保证了数据和程序的逻辑独立性。</p><p>2. 模式&#x2F;内模式映像</p><p>DB中只有一个模式和一个内模式，所以模式&#x2F;内模式映像是<strong>唯一的。定义了数据全局逻辑结构二号存储结构之间的对应关系。当存储结构改变时</strong>，由数据库管理员对映像做相应改变，可使模式保持不变，从而应用程序不用改，从而保证了数据和程序的物理独立性。</p><p>注：</p><blockquote><p>设计DB模式结构时应首先确定数据库的全局逻辑结构，即模式（P30）</p><p>设计外模式时应充分考虑应用的扩充性（P30）</p></blockquote><h1 id="第2章 关系数据库">第2章 关系数据库</h1><h2 id="2.1 关系数据结构及形式化定义"> 2.1 关系数据结构及形式化定义</h2><h3 id="2.1.1 关系">2.1.1 关系</h3><p>1. 域：一组具有相同数据类型的值的集合； 一个域允许的不同取值的个数成为基数</p><p>2. 笛卡儿积：每个域的基数相乘&#x3D;行数,一行&#x3D;元组，元组每一个值叫分量</p><p>3. 关系：笛卡儿积的<strong>有限集合</strong>，就是一张二维表，<strong>关系&#x3D;表</strong></p><blockquote><ol><li>候选码：每一个属性组的值能够唯一标识一个元组，而子集不行。候选码的诸属性为主属性。若有多个候选码，选其中一个作为主码</li><li>全码，所有属性全是该关系模式的候选码</li><li>关系有三种类型：基本关系（实际存在，实际数据的逻辑表示）、视图表（虚表）、查询表</li></ol></blockquote><p>基本关系具有6条性质：</p><blockquote><p>1. 列是同质的，每个元组的某个分量属于同一个域</p></blockquote><blockquote><p>2. 不同的列可能出自同一域，每一列称为属性，属性必须是不同的属性名</p></blockquote><blockquote><p>3. 列顺序无所谓</p></blockquote><blockquote><p>4. 任意元组候选码不能取相同值</p></blockquote><blockquote><p>5. 行顺序无所谓</p></blockquote><blockquote><p>6. 分量原子值，即不能表中有表</p></blockquote><h3 id="2.1.2 关系模式">2.1.2 关系模式</h3><p>关系模式：关系的描述，应当要刻划出完整性的约束条件</p><p>形式化表示：</p><blockquote><p>R(U,D,DOM,F)</p></blockquote><p><strong>关系实际上就是关系模式在某一时刻的状态或内容。也就是说，关系模式是型，关系是它的值。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。</strong></p><h2 id="2.2 关系操作">2.2 关系操作</h2><p>增删改查</p><p>查又分为：</p><p>基本操作是：选择、投影、并、差、笛卡儿积</p><h2 id="2.3 关系的完整性">2.3 关系的完整性</h2><h3 id="2.3.1 实体的完整性">2.3.1 实体的完整性</h3><p>主码不能为空，若主码有多个，则都不能空</p><h3 id="2.3.2 参照完整性">2.3.2 参照完整性</h3><p>外码</p><p>参照关系(有外码)</p><p>被参照关系（被引用的主码）</p><p>参照和被参照关系可以是同一个</p><p>外码不一定要与相应的主码同名</p><p>对于有F(外码)的R的元组，要么取空（不存在），要么取S（被参照关系）的主码</p><h3 id="2.3.3 用户定义完整性">2.3.3 用户定义完整性</h3><h2 id="2.4 关系代数">2.4 关系代数</h2><table><thead><tr><th></th><th>并</th><th>差</th><th>交</th><th>笛卡儿积</th><th>选择</th><th>投影</th><th>连接</th><th>除</th></tr></thead><tbody><tr><td>符号</td><td>∪</td><td>-</td><td>∩</td><td>x</td><td>σ</td><td>Π</td><td>⋈</td><td>÷</td></tr></tbody></table><h3 id="2.4.1 传统的集合运算">2.4.1 传统的集合运算</h3><blockquote><p>基于行的，和集合运算无区别</p></blockquote><p>1. 并</p><p>2. 差</p><p>3. 交</p><p>4. 笛卡儿积（用R X S表示）</p><h3 id="2.4.2 专门的关系运算">2.4.2 专门的关系运算</h3><p>1. 选择  针对行</p><p>2. 投影  针对列，也可能取消某些行，避免重复</p><p>3. 连接</p><blockquote><p>等值连接：从广义笛卡儿积中选取A、B<strong>属性值</strong>相等的元组（注意相等的不能合并）</p><p>自然连接：特殊的等值连接，将相等的合并了（它要求两个关系中进行比较的<strong>分量</strong>必须是相同的属性组，并且要在结果中把重复的属性去掉）</p><p>非等值连接：从广义笛卡儿积中选择符合条件的</p><p>在连接中被舍弃的元组为悬浮元组</p><p>若不舍弃，则为外连接</p><p>不舍弃左边关系中的，就叫左外连接</p></blockquote><p>4. 除</p><blockquote><p>象集：R中属性组X上的x值的诸元组在Z上分量的集合</p><p>R(X,Y),S(Y,Z),Y属于同一域<br>除的定义：元组在<strong>X</strong>上 分量值 <strong>x</strong> 的象集 <strong>Yx</strong> 包含 <strong>S</strong> 在 <strong>Y</strong> 上投影 的集合</p></blockquote><h1 id="第3章-关系型数据库标准语言SQL"><a href="#第3章-关系型数据库标准语言SQL" class="headerlink" title="第3章 关系型数据库标准语言SQL"></a>第3章 关系型数据库标准语言SQL</h1><h2 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h2><h3 id="3-1-3-SQL的基本概念P78"><a href="#3-1-3-SQL的基本概念P78" class="headerlink" title="3.1.3 SQL的基本概念P78"></a>3.1.3 SQL的基本概念P78</h3><blockquote><p>外模式：包括若干视图和部分基本表，基本表是本身独立存在的表，一个关系就对应一个基本表，一个或多个基本表对应一个存储文件；视图是从一个或多个基本表导出的表，本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放其数据，数据仍存在基本表中，因此视图是虚表，视图上可以再定义视图。</p><p>模式：包括若干基本表</p><p>内模式：包含若干存储文件，<strong>存储文件的逻辑结构组成了关系数据库的内模式</strong>，存储文件的物理结构对用户是隐蔽的</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">首先进入mysql文件夹下的bin目录，然后输入MySQL -u+用户名 -p然后输入密码，AC  musk  spacexjack  密码忘了Yang  。。。 <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> 用户名 identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span>; 授予权限： <span class="hljs-keyword">grant</span> <span class="hljs-keyword">insert</span>,<span class="hljs-keyword">update</span>,<span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> student_course <span class="hljs-keyword">to</span> musk; 撤回权限： <span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> student <span class="hljs-keyword">from</span> musk;//mysql只能一次撤一个对象<br></code></pre></td></tr></table></figure><h2 id="3-3-数据定义"><a href="#3-3-数据定义" class="headerlink" title="3.3 数据定义"></a>3.3 数据定义</h2><h3 id="3-3-1-模式的定义和删除"><a href="#3-3-1-模式的定义和删除" class="headerlink" title="3.3.1 模式的定义和删除"></a>3.3.1 模式的定义和删除</h3><h3 id="3-3-2-基本表的定义、删除与修改"><a href="#3-3-2-基本表的定义、删除与修改" class="headerlink" title="3.3.2 基本表的定义、删除与修改"></a>3.3.2 基本表的定义、删除与修改</h3><p>1. 定义基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(sno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">primary</span>, sname <span class="hljs-type">char</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">unique</span>, <span class="hljs-keyword">foreign</span> key(Cno) <span class="hljs-keyword">references</span> Course(Cno)); 跟在列名后面的是列级完整性约束 单独定义的是表级   <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(<span class="hljs-keyword">primary</span> key(Sno, Cno), Cno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>), Sno <span class="hljs-type">char</span>(<span class="hljs-number">3</span>), grade <span class="hljs-type">smallint</span>); 如果完整性约束条件涉及多个属性列，则必须定义在表级，如上所示<br></code></pre></td></tr></table></figure><p>2. 数据类型</p><p>3. 模式与表</p><p><strong>4. 修改基本表*************************************</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 删除列alter table 表名 drop column 属性名 cascade/restrict    <span class="hljs-comment">//column是列的意思注：后面的条件可不写，默认restrict；restrict是指删除是有条件的，所删除的属性不能被其他表的约束所引用，不能有视图、触发器、存储过程或函数； cascade是指删除没有条件，删除的同时，所有相关的对象都将删除 2. 增加列alter table 表名 add column 属性名 数据类型;如：alter table student add column Sname char(6);//mqsql里column可不写 修改列的数据类型//主码好像改不了,外码似乎也是alter table 表名 change 原列名 现列名 数据类型; 3. 删除主键约束alter table student drop primary key;4. 增加主键约束alter table student add primary key(sno);//注意：mysql一张表里只能有一个主键 5. 设置唯一性约束alter table student add unique（sname）;//注意：主键本身就是唯一的 6.设置外键约束（注意外键一定要是所参考的表（student）的主键，不然报错）alter table student_course add foreign key(sno) references student(sno);  7. 元组上的约束条件 P164    a. 检查约束check //mysql不支持检查约束，但写上不会报错    alter table student_course add constraint check(score &gt;= 0 and score &lt;= 100); 8. 设置默认约束alter table 表名 change 原列名 现列名 数据类型 default 默认值;如：alter table student change entime entime date default &#x27;2002-09-01&#x27;;  9. 删除表drop table stu cascade/restrict;  </span><br></code></pre></td></tr></table></figure><h3 id="3-3-3-索引的建立与删除"><a href="#3-3-3-索引的建立与删除" class="headerlink" title="3.3.3 索引的建立与删除"></a>3.3.3 索引的建立与删除</h3><h2 id="3-4-数据查询"><a href="#3-4-数据查询" class="headerlink" title="3.4 数据查询"></a>3.4 数据查询</h2><p>数据查询是数据库的核心操作</p><h3 id="3-4-1-单表查询"><a href="#3-4-1-单表查询" class="headerlink" title="3.4.1 单表查询"></a>3.4.1 单表查询</h3><p>1. 选择表中的若干列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 查询指定列select 属性列,属性列,··· from 表名;<span class="hljs-comment">//各列的顺序可以和原表不一样2. 查询所有列select * from 表名;3. 查询经过计算的值select Sname,2014-Sage from 表名; 属性列还可以是算术表达式、字符串常量、函数等。如：select sname,&#x27;year of birth&#x27;,2014-sage,LOWER(sdept) from student;//小写字母表示系名 还可以通过指定别名来改变查询结果的列标题，例如有些含有算术表达式、函数、常量的列名就可指定别名如：select sname NAME,&#x27;yaer of birth&#x27; BIRTH,2014-sage BIRTHDAY from student;</span><br></code></pre></td></tr></table></figure><p>2. 选择表中的若干元组（行）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 消除取值重复的行（两个不相同的元组投影到指定列后，可能会变成相同的行）使用distinct消除:select distinct sno from sc; <span class="hljs-number">2.</span> 查询满足条件的元组     a. 比较大小    b. 确定范围    c. 确定集合    d. 字符匹配        select * from student where Sno like <span class="hljs-string">&#x27;12313&#x27;</span>;<span class="hljs-comment">//like等价于=        //如果like后面的匹配串中不含通配符(%和_)，则可用=取代like，用!=或&lt;&gt;取代not like        select * from student where Sname like &#x27;刘%&#x27;;//有通配符必须用like        //通配符%代表任意长度（包括0）的字符串，_表示任意单个字符        select * from student where Sname like &#x27;欧阳_&#x27;;        select * from student where Sname like &#x27;_阳%&#x27;;//第二个字为阳的        select * from student where Sname not like &#x27;杨%&#x27;;                //如果要查询的字符串本身有通配符，要用escape转义符        select Cno,Credit from Course where Cname like &#x27;DB\_Design&#x27; escape&#x27;\&#x27;;        //escape\表示\为换码字符，这样跟在\后面的字符不再具有通配符的含义    e. 涉及空值的查询    f. 多重条件查询</span><br></code></pre></td></tr></table></figure><p>3. order by 子句（排序用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">select Sno,Grade from SC where Cno = <span class="hljs-string">&#x27;3&#x27;</span> order by Grade desc;desc: 降序asc: 升序<br></code></pre></td></tr></table></figure><p>4. 聚集函数</p><blockquote><ol><li>count(*)&#x2F;&#x2F;统计元组个数</li><li>count(distinct 列名)&#x2F;&#x2F;统计一列中值的个数，取消重复值</li><li>sum(distinct 列名)&#x2F;&#x2F;计算一列值的总和</li><li>max(distinct 列名)&#x2F;&#x2F;计算一列中的最大值</li><li>avg(列名)&#x2F;&#x2F;平均值</li></ol><p>当聚集函数遇到空值时，除count(*)，都跳过空值</p><p>where 子句中不能用聚集函数</p></blockquote><p>5. group by子句（分组用）</p><blockquote><p>将查询结果按某一列或多列的值分组，值相等的一组</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-number">1.</span>求各个课程号及相应的选课人数select Cno,count(Sno) from sc group by Cno;  如果分组后还要筛选，用having语句select Cno,count(Sno) from sc group by Cnohaving count(*) &gt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><blockquote><p>where语句和having语句的区别：</p><p>where语句不能用聚集函数，作用于基本表或视图；having短语作用于组，也就是group</p></blockquote><h3 id="3-4-2-连接查询"><a href="#3-4-2-连接查询" class="headerlink" title="3.4.2 连接查询"></a>3.4.2 连接查询</h3><p>1. 等值与非等值连接查询</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">select stu.sno, snamefrom stu,scwhere stu.sno = sc.sno and sc.cno<span class="hljs-string">&#x27;2&#x27;</span>; <span class="hljs-regexp">//</span>sno在两个表都有，所以要加前缀<br></code></pre></td></tr></table></figure><p>2. 自身连接</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">查询每一门课的间接先修课（先修课的先修课）<br></code></pre></td></tr></table></figure><p>3. 外连接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">左外连接<span class="hljs-keyword">select</span> student.sno, sname, ssex, sage, sdept, cno, gradefrom student <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> (student.sno = sc.sno);<br></code></pre></td></tr></table></figure><p>4**. 多表连接**</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">查询每个学生的学号、姓名、选修的课程名、成绩select student.sno, Sname, Cname, Gradefrom student, <span class="hljs-keyword">sc, </span>coursewhere student.sno = <span class="hljs-keyword">sc.sno </span><span class="hljs-keyword">AND </span><span class="hljs-keyword">sc.cno </span>= course.cno;<br></code></pre></td></tr></table></figure><h3 id="3-4-3-嵌套查询（nested-query）凸显结构化"><a href="#3-4-3-嵌套查询（nested-query）凸显结构化" class="headerlink" title="3.4.3 嵌套查询（nested query）凸显结构化"></a>3.4.3 嵌套查询（nested query）凸显结构化</h3><blockquote><p>子查询的select语句不能用order by子句，order by只能对最终查询结果排序</p></blockquote><p>1. <strong>带有IN谓词的子查询</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">查询和刘成在同一个系学习的学生<span class="hljs-keyword">SELECT</span> sname,sno,sdept <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> sdept <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">select</span> sdept <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> sname = <span class="hljs-string">&#x27;刘成&#x27;</span>);  在此例中，IN可以用=替换<br></code></pre></td></tr></table></figure><p>子查询的条件不依赖与父查询，称不相关子查询(相关子查询（相关嵌套查询）反之)</p><p><strong>2. 带有比较运算符的子查询</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">找出每个学生超过他自己选秀课程平均成绩的课程号 <span class="hljs-keyword">SELECT</span> Sno,Cno <span class="hljs-keyword">FROM</span> SC xWHERE Grade &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(Grade)                <span class="hljs-keyword">FROM</span>                <span class="hljs-keyword">WHERE</span> y.Sno = x.Sno);<br></code></pre></td></tr></table></figure><p><strong>3.带有any（some）或all谓词的子查询</strong></p><p><strong>4. 带有exists谓词的子查询</strong></p><h3 id="3-4-4-集合查询"><a href="#3-4-4-集合查询" class="headerlink" title="3.4.4 集合查询"></a>3.4.4 集合查询</h3><h3 id="3-4-5-基于派生表的查询"><a href="#3-4-5-基于派生表的查询" class="headerlink" title="3.4.5 基于派生表的查询"></a>3.4.5 基于派生表的查询</h3><h3 id="3-4-6-select语句的一般格式"><a href="#3-4-6-select语句的一般格式" class="headerlink" title="3.4.6 select语句的一般格式"></a>3.4.6 select语句的一般格式</h3><h2 id="3-5-数据更新"><a href="#3-5-数据更新" class="headerlink" title="3.5 数据更新"></a>3.5 数据更新</h2><h3 id="3-5-1-插入数据"><a href="#3-5-1-插入数据" class="headerlink" title="3.5.1 插入数据"></a>3.5.1 插入数据</h3><p><strong>1. 插入元组</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名（属性列，···，···） <span class="hljs-keyword">values</span>（对应的值，···，···）； 注意：<span class="hljs-number">1.</span> 没有出现的属性列，将自动取空值；但说明了<span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> 的属性列不能取空值，否则出错      <span class="hljs-number">2.</span> 如果没有指明任何属性列， 则新插入的必须在每个属性列上都有值（如果为<span class="hljs-literal">null</span>要显式给出），且顺序要和表的属性列顺序一样      <span class="hljs-number">3.</span>值如果为字符串常数，要用单引号括起来，数字不用      <span class="hljs-number">4.</span> 可以把属性列显式的置为<span class="hljs-literal">NULL</span> 例：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student（Sno，Sname，Ssex） <span class="hljs-keyword">values</span>（<span class="hljs-string">&#x27;29193&#x27;</span>,<span class="hljs-string">&#x27;李明&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>）;   一次同时插入多条数据：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名（属性列，···，···） <span class="hljs-keyword">values</span>（对应的值，···，···），（对应的值<span class="hljs-number">2</span>，···，···），（对应的值<span class="hljs-number">3</span>，···，···），···；<br></code></pre></td></tr></table></figure><p><strong>2. <strong>插</strong>入子查询结果</strong></p><blockquote><p>子查询既可以嵌套在select语句中，也可以用在insert语句中用以生成要插入的数据</p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept_age(sdept, avg_age) <span class="hljs-keyword">select</span> sdept, <span class="hljs-built_in">avg</span>(sage) <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sdept;<br></code></pre></td></tr></table></figure><h3 id="3-5-2-修改数据"><a href="#3-5-2-修改数据" class="headerlink" title="3.5.2 修改数据"></a>3.5.2 修改数据</h3><p>1. 修改某一个元组的值</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">where</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span>；如：<span class="hljs-keyword">update</span> student <span class="hljs-keyword">set</span> Sage = <span class="hljs-number">16</span> <span class="hljs-keyword">where</span> Sno = <span class="hljs-string">&#x27;201215121&#x27;</span>；<br></code></pre></td></tr></table></figure><p>2. 修改多个元组的值</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">update 表名 <span class="hljs-keyword">set</span> Sage <span class="hljs-comment">= Sage + 1</span>；<br></code></pre></td></tr></table></figure><p>3. 带子查询的修改语句</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">update SC <span class="hljs-keyword">set</span> Grade = <span class="hljs-number">0</span> <span class="hljs-function"><span class="hljs-keyword">where</span> Sno <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> Sno <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">where</span> Sdept <span class="hljs-string">&#x27;CS&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-删除数据"><a href="#3-5-3-删除数据" class="headerlink" title="3.5.3 删除数据"></a>3.5.3 删除数据</h3><p>1. 删除一个元组</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span>；<br></code></pre></td></tr></table></figure><p>2. 删除多个元组</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Delphi">delete from 表名；<span class="hljs-comment">//删除所有，该表成为空表</span><br></code></pre></td></tr></table></figure><p>3. 带子查询的删除语句</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">delete <span class="hljs-keyword">from</span> SC <span class="hljs-keyword">where</span> Sno <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> Sno <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">where</span> Sdept = <span class="hljs-string">&#x27;CS&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="3-6-空值的处理"><a href="#3-6-空值的处理" class="headerlink" title="3.6 空值的处理"></a>3.6 空值的处理</h2><h2 id="3-7-视图"><a href="#3-7-视图" class="headerlink" title="3.7 视图"></a>3.7 视图</h2><h3 id="3-7-1-定义视图"><a href="#3-7-1-定义视图" class="headerlink" title="3.7.1 定义视图"></a>3.7.1 定义视图</h3><p>1. 建立视图</p><blockquote><p>with check option 表示对视图操作时要满足视图定义中的条件(比如下例中的sdept&#x3D;’IS‘)</p><p>组成视图的列名要么全部省略，要么全部指定</p><p>以下三种情况必须全部指定：</p><ol><li>某个目标列是函数表达式</li><li>有同名列</li><li>需要更合适的名字</li></ol></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">create view <span class="hljs-constructor">IS_student(<span class="hljs-params">sno</span>,<span class="hljs-params">sname</span>,<span class="hljs-params">sage</span>)</span>asselect sno,sname,sagefrom studentwhere sdept = &#x27;IS&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>若一个视图是从单个基本表导出，且只去掉了某些行列，但保留了主码，称这类视图为行列子集视图</p><p>带虚拟列（派生属性，在基本表中不存在）的视图称为带表达式的视图</p><p>带有聚集函数和group by 子句的查询来定义的视图称为分组视图</p></blockquote><p>2. 删除视图</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> IS_stu <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></table></figure><blockquote><p>cascade表示把由该视图导出的所有视图都删除</p><p>当基本表删除后，视图的定义还在，必须用删除视图语句显式删除</p></blockquote><h3 id="3-7-2-查询视图"><a href="#3-7-2-查询视图" class="headerlink" title="3.7.2 查询视图"></a>3.7.2 查询视图</h3><blockquote><p>视图消解：把视图的查询转换为对基本表的查询</p></blockquote><h3 id="3-7-3-更新视图"><a href="#3-7-3-更新视图" class="headerlink" title="3.7.3 更新视图"></a>3.7.3 更新视图</h3><h3 id="3-7-4-视图的作用"><a href="#3-7-4-视图的作用" class="headerlink" title="3.7.4 视图的作用"></a>3.7.4 视图的作用</h3><h1 id="第4章-数据库安全性"><a href="#第4章-数据库安全性" class="headerlink" title="第4章 数据库安全性"></a>第4章 数据库安全性</h1><h2 id="4-2-DB安全性控制"><a href="#4-2-DB安全性控制" class="headerlink" title="4.2 DB安全性控制"></a>4.2 DB安全性控制</h2><h3 id="4-2-1-用户身份鉴别"><a href="#4-2-1-用户身份鉴别" class="headerlink" title="4.2.1 用户身份鉴别"></a>4.2.1 用户身份鉴别</h3><ol><li>静态口令鉴别   密码</li><li>动态口令鉴别   每次鉴别时都需使用动态产生的新口令登陆</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ol><h3 id="4-2-2-存取控制"><a href="#4-2-2-存取控制" class="headerlink" title="4.2.2 存取控制"></a>4.2.2 存取控制</h3><ol><li>自主存取控制</li><li>强制存取控制  每个数据库对象被标以一定的密级</li></ol><h3 id="4-2-3-自主存取控制方法"><a href="#4-2-3-自主存取控制方法" class="headerlink" title="4.2.3 自主存取控制方法"></a>4.2.3 自主存取控制方法</h3><blockquote><p>用户权限由 数据库对象和操作类型 组成</p></blockquote><h3 id="4-2-4-授权：授予与收回"><a href="#4-2-4-授权：授予与收回" class="headerlink" title="4.2.4 授权：授予与收回"></a>4.2.4 授权：授予与收回</h3><p><strong>1. grant</strong></p><blockquote><p>一些权限：</p><p>基本表和视图：select, insert, update, delete references, all privileges</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">to</span> u1 <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span>;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student,course <span class="hljs-keyword">to</span> u2,u3;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">to</span> <span class="hljs-built_in">public</span>;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">update</span>(Sno),<span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">to</span> u4;<br></code></pre></td></tr></table></figure><p><strong>2. revoke</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">update</span>(Sno) <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">from</span> u4;<span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc <span class="hljs-keyword">from</span> <span class="hljs-built_in">public</span>;<span class="hljs-keyword">revoke</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc <span class="hljs-keyword">from</span> u5 <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></table></figure><h1 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h1><h2 id="5-3-用户定义的完整性"><a href="#5-3-用户定义的完整性" class="headerlink" title="5.3 用户定义的完整性"></a>5.3 用户定义的完整性</h2><h3 id="5-3-1-属性上的约束条件-P163"><a href="#5-3-1-属性上的约束条件-P163" class="headerlink" title="5.3.1 属性上的约束条件(P163)"></a>5.3.1 属性上的约束条件(P163)</h3><p>1. 属性上约束条件的定义</p><blockquote><p>包括：</p><p>1. not null</p><p>2. unique</p><p>3. check</p></blockquote><h3 id="5-3-2-元组上的约束条件的定义"><a href="#5-3-2-元组上的约束条件的定义" class="headerlink" title="5.3.2 元组上的约束条件的定义"></a>5.3.2 元组上的约束条件的定义</h3><p>在创建表时可用check短语定义</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(sno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">primary</span>, sname <span class="hljs-type">char</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">unique</span>, sex <span class="hljs-type">char</span>(<span class="hljs-number">2</span>),<span class="hljs-keyword">foreign key</span>(Cno) <span class="hljs-keyword">references</span> Course(Cno),<span class="hljs-keyword">check</span>(sex = <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">OR</span> Sname <span class="hljs-keyword">not</span> lik<span class="hljs-string">e&#x27;Ms.%&#x27;</span>)); 男性名字不能以Ms.开头<br></code></pre></td></tr></table></figure><h1 id="第7章-数据库设计"><a href="#第7章-数据库设计" class="headerlink" title="第7章 数据库设计"></a>第7章 数据库设计</h1><h2 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h2><h3 id="7-1-3-数据库设计基本步骤"><a href="#7-1-3-数据库设计基本步骤" class="headerlink" title="7.1.3 数据库设计基本步骤"></a>7.1.3 数据库设计基本步骤</h3><p> 需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护</p><h2 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h2><h2 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h2><h3 id="7-4-1-ER图向关系模型的转换"><a href="#7-4-1-ER图向关系模型的转换" class="headerlink" title="7.4.1 ER图向关系模型的转换"></a>7.4.1 ER图向关系模型的转换</h3><h2 id="7-6-DB的实施和维护"><a href="#7-6-DB的实施和维护" class="headerlink" title="7.6 DB的实施和维护"></a>7.6 DB的实施和维护</h2><h3 id="7-6-1-数据载入和应用程序的调试"><a href="#7-6-1-数据载入和应用程序的调试" class="headerlink" title="7.6.1 数据载入和应用程序的调试"></a>7.6.1 数据载入和应用程序的调试</h3><h1 id="第9章-关系查询处理和查询优化"><a href="#第9章-关系查询处理和查询优化" class="headerlink" title="第9章 关系查询处理和查询优化"></a>第9章 关系查询处理和查询优化</h1><h2 id="9-1-关系DBS的查询处理"><a href="#9-1-关系DBS的查询处理" class="headerlink" title="9.1 关系DBS的查询处理"></a>9.1 关系DBS的查询处理</h2><h3 id="1-查询分析"><a href="#1-查询分析" class="headerlink" title="1. 查询分析"></a>1. 查询分析</h3><h3 id="2-查询检查"><a href="#2-查询检查" class="headerlink" title="2. 查询检查"></a>2. 查询检查</h3><h3 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3. 查询优化"></a>3. 查询优化</h3><h3 id="4-查询执行"><a href="#4-查询执行" class="headerlink" title="4. 查询执行"></a>4. 查询执行</h3><h2 id="9-2-关系DBS的查询优化"><a href="#9-2-关系DBS的查询优化" class="headerlink" title="9.2 关系DBS的查询优化"></a>9.2 关系DBS的查询优化</h2><h3 id="9-2-1-查询优化概述"><a href="#9-2-1-查询优化概述" class="headerlink" title="9.2.1 查询优化概述"></a>9.2.1 查询优化概述</h3><blockquote><p>查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较高的效率，而且在于系统能比用户程序的“优化”做的更好，这是因为：</p><p>1. </p></blockquote><h2 id="9-3-代数优化"><a href="#9-3-代数优化" class="headerlink" title="9.3 代数优化"></a>9.3 代数优化</h2><h2 id="9-3-2-查询树的启发式优化"><a href="#9-3-2-查询树的启发式优化" class="headerlink" title="9.3.2 查询树的启发式优化"></a>9.3.2 查询树的启发式优化</h2><blockquote><p>风格恢复</p></blockquote><h1 id="第10章-数据库恢复技术"><a href="#第10章-数据库恢复技术" class="headerlink" title="第10章 数据库恢复技术"></a>第10章 数据库恢复技术</h1><h2 id="10-1-事务的基本概念"><a href="#10-1-事务的基本概念" class="headerlink" title="10.1 事务的基本概念"></a>10.1 事务的基本概念</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h3><blockquote><p>事务：是用户定义的数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</p></blockquote><p>在sql中，定义事务的语句有三条：</p><ol><li>begin transaction 表示开始</li><li>commit 提交</li><li>rollback 撤销</li></ol><h3 id="2-事务的ACID特性"><a href="#2-事务的ACID特性" class="headerlink" title="2.事务的ACID特性"></a>2.事务的ACID特性</h3><ol><li>原子性 atomicity</li><li>一致性 consistency 和原子性密切相关   一致性状态（正常）   中断（不一致） 所以要保证原子性</li><li>隔离性 isolation 并发执行的各个事务之间不能干扰</li><li>持续性 durability 永久性 事务一旦提交，改变就是永久性的，其他操作不能影响其结果</li></ol><blockquote><p>ACID特性可能遭到破坏的因素：</p><p>1. 多个事务并行运行，不同事务的操作交叉执行；</p><p>2. 事务在运行过程中被强行停止。</p></blockquote><h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a>10.3 故障的种类</h2><h3 id="1-事务内部的故障"><a href="#1-事务内部的故障" class="headerlink" title="1. 事务内部的故障"></a>1. 事务内部的故障</h3><p>非预期的，不能有由应用程序处理</p><p>发生后需要  事务撤销</p><h3 id="2-系统故障"><a href="#2-系统故障" class="headerlink" title="2. 系统故障"></a>2. 系统故障</h3><p>断电、死机</p><p>系统重启后，不仅要撤销所有未完成的事务，还要重做所有已提交的事务</p><h3 id="3-介质故障"><a href="#3-介质故障" class="headerlink" title="3. 介质故障"></a>3. 介质故障</h3><p>硬故障 磁盘损坏、磁头碰撞、瞬间强磁场干扰</p><h3 id="4-计算机病毒"><a href="#4-计算机病毒" class="headerlink" title="4. 计算机病毒"></a>4. 计算机病毒</h3><blockquote><p>总结，各类故障对DB的影响有两种：</p><p>1. 数据库本身被破坏</p><p>2. 没破坏，但数据不对了</p><p>恢复的原理：冗余</p></blockquote><h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a>10.4 恢复的实现技术</h2><h3 id="10-4-2-日志文件"><a href="#10-4-2-日志文件" class="headerlink" title="10.4.2 日志文件"></a>10.4.2 日志文件</h3><blockquote><p>用来记录事务对数据库的更新操作的文件</p><p>日志文件的作用：P299</p><p>1. </p></blockquote><p>两种：</p><p>1. 以记录为单位的</p><p>需要记录：</p><blockquote><p>1. 各个事务的开始</p><p>2. ················结束</p><p>3. ················所有更新操作</p><p>一个事务就是一个日志记录</p><p>每个日志记录包括：</p><ol><li></li></ol></blockquote><p>2. 以数据块为单位的</p><h1 id="试题"><a href="#试题" class="headerlink" title="试题:"></a>试题:</h1><p><strong>什么是数据库的再组织和重构造？为什么要进行数据库的再组织和重构造？</strong><br>[参考答案 ] 答：数据库的再组织是指：按原设计要求重新安排存储位置、回收垃圾、减少指针链等， 以提高系统性能。 数据库的重构造则是指部分修改数据库的模式和内模式， 即修改原设计的逻辑和物理结构。数据库的再组织是不修改数<br>据库的模式和内模式的。 进行数据库的再组织和重构造的原因： 数据库运行一段时间后，由于记录不断 增、删、改，会使数据库的物理存储情况变坏，降低了数 据 的 存 取 效 率 ，数 据库 性能 下 降 ， 这 时 DBA 就 要 对 数 据库 进行 重组织。 DBMS一般都提供用于数据重组织的实用程序。数据库应用环境常常发生变化，如增加新的应用或新的实体， 取消了某些应用， 有的实体与实体间的联系也发生了变化等， 使原有的数据库设计不能满足新的需求，需要调整数据库的模式和内模式。这就要进行数据库重构造</p><p><strong>什么是检查点记录？</strong><br>答：检查点记录是一类<strong>新的日志记录</strong>。它的内容包括：（1）<strong>建立检查点时刻</strong>所有正在执行的事务清单；（2）这些事务的<strong>最近</strong>一个<strong>日志</strong>记录的地址。</p><p><strong>关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别进行处理的？</strong><br>答:<br>对于违反实体完整性和用户定义的完整性的操作一般都采用<strong>拒绝执行</strong>的方式进行处理。而对于违反参照完整性的操作，并不都是简单地拒绝执行，有时要根据应用语义执行<strong>一些附加的</strong>操作，以保证数据库的正确性。</p><p><strong>什么是数据库的审计功能，为什么要提供审计功能？</strong><br>答：审计功能是指 DBMS 的<strong>审计模块</strong>在用户对数据库执行操作的同时把所有操作自动记录到系统的审计日志中。因为任何系统的安全保护措施都不是完美无缺的，蓄意盗窃破坏数据的人总可能存在。利用数据库的审计功能， <strong>DBA</strong> 可以<strong>根据审计跟踪的信息</strong>，重现导致数据库现有状况的一系列事件，<strong>找出非法存取数据的</strong>人、时间和内容等。</p><p><strong>哪类视图是可以更新的？哪类视图是不可更新的？各举一例说明。</strong><br>答：基本表的<strong>行列子集视图</strong>一般是可更新的。若视图的属性来自集合函数、表达式，则该视图<strong>肯定是</strong>不可以更新的。</p><p><strong>什么是基本表？什么是视图？两者的区别和联系是什么？</strong><br>答：基本表是本身独立存在的表， 在 sQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图<strong>本身不独立存储在数据库中</strong>，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，<strong>这些数据</strong>仍存放在导出视图的基本表中。 视图在概念上与基本表等同， 用户可以如同基本表那样使用视图，可以在视图上再定义视图</p><p><strong>假设有下面两个关系模式：</strong></p><p>职工（职工号，姓名，年龄，职务，工资，部门号） ，其中职工号为主码；</p><p>部门（部门号，名称，经理名，电话） ，其中部门号为主码。</p><p>用 sQL 语言定义这两个关系模式，要求在模式中完成以下完整性约束条件的定义：</p><p>定义每个模式的<strong>主码</strong>；</p><p>定义<strong>参照完整性</strong>； 定义职工年龄不得超过 60岁。<br>答<br>CREATE TABLE DEPT<br>(Deptno NUMBER(2) <strong>PRIMARY KEY,</strong><br>Deptname VARCHAR(10),<br>Manager VARCHAR(10),<br>PhoneNumber Char(12)<br>);</p><p>CREATE TABLE EMP<br>(Empno NUMBER(4) <strong>PRIMARY KEY,</strong><br>Ename VARCHAR(10),<br>Age NUMBER(2),<br>CHECK ( Aage&lt;&#x3D;60),<br>Job VARCHAR(9),<br>Sal <strong>FLOAT</strong>(6),<br>Deptno NUMBER(2),<br><strong>FOREIGN KEY(Deptno)  REFERENCES DEPT(Deptno));</strong></p><p><strong>什么是数据库中的自主存取控制方法和强制存取控制方法？</strong><br>答：<br>自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。<br>强制存取控制方法：每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。</p><p><strong>试述实现数据库安全性控制的常用方法和技术。</strong><br>答：实现数据库安全性控制的常用方法和技术有：<br>( l  ）<strong>用户标识和鉴别</strong>：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权。<br>( 2 ）<strong>存取控制</strong>：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。例如 CZ 级中的自主存取控制 ( DAC ) , Bl  级中的强制存取控制（ MAC ）。<br>( 3 ）<strong>视图机制</strong>：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。<br>( 4 ）<strong>审计</strong>：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中， DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。<br>( 5 ）<strong>数据加密</strong>：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。</p><blockquote><ol><li>DB具有数据独立性的原因：三级模式结构</li><li>逻辑数据和物理数据的转换由DBMS负责</li><li>在嵌入式 SQL 中，当 SQL 语句中引用宿主语言的程序变量时，程序变量应加前缀：</li><li>在关系代数表达式的查询优化中，不正确的叙述是 尽可能早地执行连接</li><li>下列哪类不属于计算机系统的安全问题 政策安全类</li><li>数据库设计人员和用户之间沟通信息的桥梁是 实体联系图</li><li>并行数据库系统研究一直以三种并行计算结构为基础，分别是 <strong>共享内存结构、共享磁盘结构、无共享资源结构</strong></li><li>RDBMS查询处理可以分为四个阶段，包括 <strong>查询分析、检查、优化、执行</strong></li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构附录</title>
    <link href="/2023/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%99%84%E5%BD%95/"/>
    <url>/2023/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%99%84%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h2><blockquote><p>指针</p></blockquote><ul><li>定义指针时，* 号前面的数据类型，表示的是你所定义的指针要指向的数据类型</li></ul><blockquote><p>顺序表</p></blockquote><ul><li><p>逻辑结构与存储元素的物理结构一致</p></li><li><p>占用一片连续的存储空间，访问顺序表示，可快速算出任何一个元素的存储地址（即找到那个元素），可粗略认为访问每个元素所花费的时间相等（<strong>这种存取元素的方法称为随机存取法</strong>）</p></li><li><p>时间复杂度：查找、插入、删除算法的平均时间复杂度均为O(n)</p></li><li><p>存储密度大，等于1（存储密度&#x3D;结点本身所占存储量&#x2F;结点结构所占存储量）</p></li><li><p>可随机存取表中任一元素</p></li></ul><blockquote><p>链表</p></blockquote><ul><li><p>单链表由头指针唯一确定，因此单链表可用头指针的名字来命名</p></li><li><p>头指针：是指向链表中第一个结点的指针，即指向头结点</p></li><li><p>首元结点：是指链表中存储第一个数据元素的结点</p></li><li><p>头结点：附设在链表寿元结点之前的一个结点，是链表的第一个结点，头指针指向头结点</p></li><li><p>如何表示空表？</p><ul><li>无头结点时，头指针为空时表示空表</li><li>有头结点时，头结点的指针域为空时表示空表</li></ul></li><li><p>设置头结点有什么好处？</p><ul><li><p>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无序进行特殊处理</p></li><li><p>便于空表和非空表的统一处理：在有头结点的情况下，无论链表是否为空，头指针都是指向头结点的非空指针，因此你空表和非空表的处理也就统一</p></li></ul></li><li><p>头结点的数据域放些什么？</p><ul><li>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但是此结点不能计入链表长度值，即计算表长时不能算头结点</li></ul></li><li><p>访问链表时，只能通过头指针进入链表，并且通过每个结点的指针域一次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不相同</p></li><li><p>链表时顺序存取的，顺序表是随机存取的</p></li><li><p>在看到如下代码时，怎么理解？(见注释)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">s-&gt;next = p-&gt;next;<span class="hljs-comment">//把p的指针域的指针（原本指向p后面一个结点的指针）赋值给s的指针域里的指针</span><br>p-&gt;next = s;<span class="hljs-comment">//把指向s结点的指针赋值给p的指针域里的指针</span><br></code></pre></td></tr></table></figure></li><li><p>单链表的查找、插入、删除算法时间效率分析</p><ul><li><p>因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为O(n)</p></li><li><p>插入和删除：因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为O(1)。但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)</p></li><li><p>头插法的时间复杂度是O(n)</p></li><li><p>尾插法的时间复杂度是O(n)</p></li></ul></li></ul><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ul><li><p>typedef</p><ul><li>是C语言关键字，是声明，用来给类型起别名</li><li>格式为：typedef   你要给起别名的数据类型    别名</li></ul></li><li><p>在头文件stdlib.h中</p><ul><li><p>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址</p></li><li><p>sizeof(x)运算，计算变量x的长度</p></li><li><p>free（p）函数，释放指针p所指变量的存储空间，即彻底删除一个变量</p></li></ul></li><li><p>new 类型名 T （初值列表） </p><ul><li>功能： 申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值 </li><li>结果值： <ul><li>成功：T类型的指针，指向新分配的内存 </li><li>失败：0（NULL)</li></ul></li><li>例如：int * p1 &#x3D; new int;或int * p1 &#x3D; new int(10); </li><li>注意：new出来的空间的返回值是一个地址所以只能赋值给指针</li></ul></li><li><p>delete 指针p </p><ul><li>功能： 释放指针p所指向的内存。p必须是new操作的返回值</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找——王卓</title>
    <link href="/2022/10/13/%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第7章-查找"><a href="#第7章-查找" class="headerlink" title="第7章 查找"></a>第7章 查找</h1><h2 id="7-1-查找的基本概念"><a href="#7-1-查找的基本概念" class="headerlink" title="7.1 查找的基本概念"></a>7.1 查找的基本概念</h2><p><strong>查找表</strong>是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着<strong>松散的关系</strong>，因此查找表是一种应用灵便的结构。</p><p><strong>查找</strong>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）</p><ul><li><p><strong>关键字</strong>：用来标识一个数据元素（或记录）的某个数据项的值</p><ul><li><p><strong>主关键字</strong>：可唯一地标识一个记录的关键字是主关键字；</p></li><li><p><strong>次关键字</strong>：反之，用以识别若干记录的关键字是次关键字。</p></li></ul></li></ul><ol><li><p>查找的目的：</p><ul><li><p>查询某个“特定的”数据元素是否在查找表中；</p></li><li><p>检索某个“特定的“数据元素的各种属性；</p></li><li><p>在查找表中插入一个数据元素；</p></li><li><p>删除查找表中的某个数据元素。</p></li></ul></li><li><p>查找的分类</p><ul><li><p><strong>静态查找表</strong>：仅作“查询”（检索）操作的查找表</p></li><li><p><strong>动态查找表</strong>：作“插入”和“删除”操作的查找表</p></li></ul></li><li><p>如何评价查找算法</p><ul><li><p>查找算法的评价指标“：关键字的平均比较次数，也称为<strong>平均查找长度</strong>，（ASL, Average Search Length）。</p></li><li><p>平均查找长度定义</p></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131110029.png"></p><p>4.查找的过程中我们要研究什么？</p><p>查找的方法取决于查找表的结构，即表中数据元素是依何种关系组织在一起的。</p><p>由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时，若无规律可循，只能对集合中的元素一一加以辨认直至找到为止。而这样的“查询”或“检索”是任何计算机应用系统中使用频度都很高的操作，因此设法提高查找表的查找效率，是本章讨论问题的出发点。</p><p>为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的约束关系。</p><h2 id="7-2-线性表的查找"><a href="#7-2-线性表的查找" class="headerlink" title="7.2 线性表的查找"></a>7.2 线性表的查找</h2><h3 id="7-2-1-顺序查找（线性查找）"><a href="#7-2-1-顺序查找（线性查找）" class="headerlink" title="7.2.1 顺序查找（线性查找）"></a>7.2.1 顺序查找（线性查找）</h3><p>应用范围：顺序表或线性链表表示的<strong>静态查找表</strong>；表内元素之间无序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 若成功返回其位置信息，否则返回0</span><br>    <span class="hljs-keyword">for</span>(i = ST.length; i &gt;= <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ST.R[i].key == key) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进：把待查关键字key存入表头（“哨兵”、”监视哨”），从后往前逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    ST.R[<span class="hljs-number">0</span>].key = key;<br>    <span class="hljs-keyword">for</span>(i = ST.length; ST.R[i].key != key; i--);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>当ST.length较大时，此改进能使进行一次查找所需的平均时间几乎减少一半。</p><ul><li><p>时间复杂度：O(n)，查找成功时的平均查找长度为：<code>ASL(n) = (1+2+...+n)/n = (n+1)/2</code>。</p></li><li><p>空间复杂度：一个辅助空间，O(1)。</p></li></ul><p>讨论：</p><ol><li><p>记录的查找概率不相等时如何提高查找效率？</p><p> 查找表存储记录原则按查找概率高低存储：</p><ol><li><p>查找概率越高，比较次数越少；</p></li><li><p>查找概率越低，比较次数较多。</p></li></ol></li><li><p>记录的查找概率无法测定时如何提高查找效率？</p><p> 方法——按查找概率<strong>动态调整</strong>记录顺序：</p><ol><li><p>在每个记录中设一个访问频度域；</p></li><li><p>始终保持记录按非递增有序的次序排列；</p></li><li><p>每次查找后均将刚查到的记录直接移至表头。</p></li></ol></li></ol><p>优点：算法简单，逻辑次序无要求，且不同存储结构均适用。</p><p>缺点：ASL太长，时间效率太低</p><h3 id="7-2-2-折半查找（二分或对分查找）"><a href="#7-2-2-折半查找（二分或对分查找）" class="headerlink" title="7.2.2 折半查找（二分或对分查找）"></a>7.2.2 折半查找（二分或对分查找）</h3><p><strong>折半查找</strong>：每次将待查记录所在区间缩小一半。</p><ul><li><p>折半查找算法：（非递归算法）</p><ul><li><p>设表长为n，low、high和mid分别指向待查元素所在区间的上界、下界和中点，key为给定的要查找的值；</p></li><li><p>初始时，令low&#x3D;1，high&#x3D;n，mid&#x3D;floar((low+high)&#x2F;2)</p></li><li><p>让k与mid指向的记录比较</p><ul><li>若key&#x3D;&#x3D;R[mid].key，查找成功；</li><li>若key&lt;R[mid].key，high&#x3D;mid-1；</li><li>若key&gt;R[mid].key，low&#x3D;mid+1；</li></ul></li><li><p>重复上述操作，直至low&gt;high时，查找失败</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    low = <span class="hljs-number">1</span>; high = ST.length;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)<br>    &#123;<br>        mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(ST.R[mid].key == key) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; ST.R[mid].key)<br>            high = mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>            low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, KeyTable key, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    mid = (low + high) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(key == ST.elem[mid].key) <span class="hljs-keyword">return</span> mid;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; ST.elem[mid].key)<br>        <span class="hljs-built_in">Search_Bin</span>(ST,key, mid<span class="hljs-number">-1</span>, high);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">Search_Bin</span>(ST,key, low, mid+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>假定每个元素的查找概率相等，查找成功时的平均查找长度（ASL），设表长n&#x3D;2^h-1，则h&#x3D;log2(n+1)，查找概率相等为：1&#x2F;n，<code>ASL≈log2(n+1)-1    (n&gt;50)</code>。</p><p>优点：效率比顺序查找高</p><p>缺点：只适用于<strong>有序表</strong>，且限于<strong>顺序存储结构</strong>（对线性链表无效）。</p><h3 id="7-2-3-分块查找（索引顺序查找）"><a href="#7-2-3-分块查找（索引顺序查找）" class="headerlink" title="7.2.3 分块查找（索引顺序查找）"></a>7.2.3 分块查找（索引顺序查找）</h3><p>分块查找条件基础：</p><ol><li><p>将表分成几块，且表有序或者分块有序。若i &lt; j，则第j块中所有记录的关键字均大于第i块中的最大关键字。</p></li><li><p>建立”索引表“（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）。</p></li></ol><p>查找过程：先确定待查记录所在块（顺序或折半查找），再在块内查找（顺序查找）。</p><p>查找效率：ASL &#x3D; LB + LW；即对索引表查找的ASL加上对块内查找的ASL</p><ul><li>图2：分块查找效率<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131111682.png"></li></ul><p>优点：插入和删除较容易，无需进行大量移动</p><p>缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算</p><p>适用情况：如果线性表既要<strong>快速查找</strong>又经常<strong>动态变化</strong>，则可采用分块查找。</p><ul><li>图3：查找方法比较<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131111925.png"></li></ul><h2 id="7-3-树表的查找"><a href="#7-3-树表的查找" class="headerlink" title="7.3 树表的查找"></a>7.3 树表的查找</h2><h3 id="7-3-1-二叉排序树"><a href="#7-3-1-二叉排序树" class="headerlink" title="7.3.1 二叉排序树"></a>7.3.1 二叉排序树</h3><p><strong>二叉排序树</strong>（Binary Sort Tree）又称为二叉搜索树、二叉查找树。</p><ol><li><p>二叉排序树定义：</p><p> 二叉排序树或是空树，或是满足如下性质的二叉树：</p><ol><li><p>若其左子树非空，则左子树上所有结点的值均小于根结点的值；</p></li><li><p>若其右子树非空，则右子树上所有结点的值均大于等于根结点的值；</p></li><li><p>其左右子树本身又各是一棵二叉排序树</p></li></ol></li><li><p>二叉排序树的性质：</p><p> 中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的<strong>递增有序</strong>序列。</p></li><li><p>二叉排序树的操作——查找</p><ul><li><p>若查找的关键字等于根节点，成功。</p></li><li><p>否则：</p><ul><li><p>若小于根节点，查其左子树</p></li><li><p>若大于根节点，查找右子树</p></li></ul></li><li><p>在左右子树上的操作类似</p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-comment">// 二叉排序树的存储结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ElemType</span><br>&#123;<br>    KeyType key;    <span class="hljs-comment">// 关键字项</span><br>    InfoType otherInfo; <span class="hljs-comment">// 其他数据项</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span><br>&#123;<br>    ElemType data;      <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> *lchild, *rchild;        <span class="hljs-comment">// 左右孩子指针</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> BSTNode* BSTree;<br><br><span class="hljs-comment">// 递归查找</span><br><span class="hljs-function">BSTree <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree T, KeyType key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T || key == T-&gt;data.key) <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; T-&gt;data.key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild, key);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>二叉排序树的查找分析</p><p> 二叉排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。</p><p> 比较的关键字次数 &#x3D; 此结点所在层次数；最多的比较次数 &#x3D; 树的深度</p><p> 对于含有n个结点的二叉排序树的平均查找长度和树的形状有关。</p><pre><code class="hljs"> - 最好情况：与折半查找中的判定树相同，O(log2n)； - 最坏情况：退化为单支树（类似于线性列表），树深度为n，ASL = (n+1)/2，O(n)；</code></pre><p> 为了提高形态不均衡的二叉排序树的查找效率，应当进行“平衡化”处理（即<strong>平衡二叉树</strong>），尽量使二叉树的形状均衡！</p></li><li><p>二叉排序树的操作——插入</p><ul><li><p>若二叉排序树为空，则插入结点作为根结点插入到空树中</p></li><li><p>否则，继续在其左、右子树上查找</p><ul><li><p>树中已有，不再插入</p></li><li><p>树中没有</p><ul><li>查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子</li></ul></li></ul></li></ul><p> <strong>插入的元素一定是叶子节点</strong>。</p></li><li><p>二叉排序树的操作——生成</p><p> 从空树出发，经过一系列的查找、插入操作之后，可生成一颗二叉排序树。</p><p> 一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。</p><p> 插入的结点均为叶子结点，故无需移动其他结点。相当于在有序序列上插入记录而无需移动其他记录。但是，<strong>关键字的输入顺序不同，建立的二叉排序树也不同</strong>。</p></li><li><p>二叉排序树的操作——删除</p><p> 从二叉排序树中删除一个结点，不能把以该结点为根的子树者都删除，只能删掉该结点，并且<strong>还应保证删除后所得的二叉树仍然满足二叉排序树的性质不变</strong>。</p><p> 由于中序遍历二叉排序树可以得到一个递增有序的序列。那么，在二叉排序树中删去一个结点相当于删去有序序列中的一个结点。</p><pre><code class="hljs"> - 将因删除结点而断开的二叉链表重新链接起来 - 防止重新链接后树的高度增加</code></pre><ol><li><p>如果删除的结点是叶子结点：直接删除该结点。</p></li><li><p>被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它（结点替换）。</p></li><li><p>本删除的结点既有左子树，也有右子树：可以用其中序的前驱结点替换，然后删除该前驱结点（前驱结点是左子树中最大的结点）；也可以用中序的后继结点，然后删除该后继结点（后继是右子树中最小的结点）。</p></li></ol></li></ol><h3 id="7-3-2-平衡二叉树"><a href="#7-3-2-平衡二叉树" class="headerlink" title="7.3.2 平衡二叉树"></a>7.3.2 平衡二叉树</h3><ol><li><p>平衡二叉树的定义</p><p> <strong>平衡二叉树</strong>（balanced binary tree），又称为AVL树（Adelson-Velskii and Landis）。</p><p> 一棵平衡二叉树或者是空树，或者是具有以下性质的<strong>二叉排序树</strong>：</p><ul><li><p>左子树与右子树的高度之差的绝对值小于等于1；</p></li><li><p>左子树和右子树也是<strong>平衡二叉排序树</strong>。</p></li></ul><p> 左子树与右子树的高度差又称为结点的平衡因子（BF），<code>平衡因子=结点左子树的高度-结点右子树的高度</code>。根据平衡二叉树的定义，平衡二又树上所有结点的平衡因子只能是-1、0，或1。</p></li></ol><p>对于一棵有n个结点的AVL树，其高度保持在O(log2n)数量级，ASL也保持在O(log2n)量级。</p><ol start="2"><li><p>失衡二叉排序树的分析与调整</p><p>当我们在一个平衡二叉排序树上插入一个结点时，有可能导致<strong>失衡</strong>，即出现平衡因子绝对值大于1的结点。</p><p>如果在一个AVL树中插入一个新结点后造成失衡，则必须<strong>重新调整树的结构</strong>，使之回复平衡。</p></li></ol><p>平衡调整的四种类型：LL型、LR型、RL型和RR型</p><ul><li><p>图4：平衡调整的四种类型示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131112212.png"></p></li><li><p>图5：平衡调整的四种类型调整后示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131113075.png"></p></li></ul><p>平衡调整的原则：1）降低高度；2）保持二叉排序树性质</p><ol><li>LL型调整</li></ol><ul><li><p>图6：LL型调整前-后对比示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131113389.png"></p></li><li><p>B结点带左子树一起上升</p></li><li><p>A结点成为B的右孩子</p></li><li><p>原来B结点的右子树作为A的左子树</p></li><li><p>图7：LL型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131114924.png"></p></li></ul><ol start="2"><li>RR型调整</li></ol><ul><li><p>图8：RR型调整前-后对比示意图<br>  <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131115509.png"></p></li><li><p>B结点带右节点一起上升</p></li><li><p>A结点成为B结点的左孩子</p></li><li><p>原来B结点的左子树作为A的右子树</p></li><li><p>图9：RR型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131116899.png"></p></li></ul><ol start="3"><li>LR型调整</li></ol><ul><li><p>图10：LR型调整前-后对比示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131117344.png"></p></li><li><p>C结点穿过A、B结点上升</p></li><li><p>B结点成为C的左孩子，A结点成为C的右孩子</p></li><li><p>原来C结点的左子树作为B的右子树，原来C结点的右子树作为A的左子树</p></li><li><p>图11：LR型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131118813.png"></p></li></ul><ol start="4"><li>RL型调整</li></ol><ul><li><p>图12：RL型调整前示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131118548.png"></p></li><li><p>图13：RL型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131119631.png"></p></li></ul><h2 id="7-4-哈希表的查找（散列表的查找）"><a href="#7-4-哈希表的查找（散列表的查找）" class="headerlink" title="7.4 哈希表的查找（散列表的查找）"></a>7.4 哈希表的查找（散列表的查找）</h2><h3 id="7-4-1-散列表的基本概念"><a href="#7-4-1-散列表的基本概念" class="headerlink" title="7.4.1 散列表的基本概念"></a>7.4.1 散列表的基本概念</h3><p>基本思想：<strong>记录的存储位置与关键字之间的存在对应关系</strong>，对应关系常成为hash函数。</p><p><strong>优点：查找效率高；缺点：空间效率低！</strong></p><p><strong>散列方法（杂凑法）</strong>：选取某个函数，依该函数按关键字<strong>计算元素的存储位置</strong>，并按此存放。查找时，<strong>由同一个函数对给定值k计算地址</strong>，将k与地址单元中元素关键码进行对比，确定查找是否成功。</p><p><strong>散列函数（杂凑函数）</strong>：散列方法中适用的<strong>转换函数</strong>。</p><p><strong>冲突</strong>：不同的关键码映射到同一个散列地址，则称为冲突。</p><h3 id="7-4-2-散列函数的构造方法"><a href="#7-4-2-散列函数的构造方法" class="headerlink" title="7.4.2 散列函数的构造方法"></a>7.4.2 散列函数的构造方法</h3><p>在散列查找方法中，冲突是不可避免的，只能尽可能避免。使用散列表要解决的两个主要为题包括：</p><ol><li><p>构造好的散列函数</p><ul><li><p>所选函数尽可能简单，以便提高转换速度；</p></li><li><p>所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。</p></li></ul></li><li><p>制定一个好的解决冲突的方案</p><ul><li>查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。</li></ul></li></ol><p>构造散列函数考虑的因素：执行速度、关键字的长度、散列表的大小、关键字的分布情况、查找频率。</p><p>根据元素集合的特性构造，<strong>要求一</strong>：n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的<strong>地址空间尽量小</strong>。<strong>要求二</strong>：无论用什么方法存储，目的都是尽量<strong>均匀</strong>地存放元素，以避免冲突。</p><p>常见构造方法包括有：直接定址法、数字分析法、平方取中法、折叠法、<strong>除留余数法</strong>、随机数法。</p><p><strong>直接定址法</strong>：以关键码key的某个线性函数值为散列地址，不会产生冲突。但是要占用连续地址空间，空间效率低。</p><p><strong>除留余数法</strong>：<code>Hash(key) = key mod p(其中p是一个整数)</code>，常见p值取小于表长的质数。</p><h3 id="7-4-3-处理冲突的方法"><a href="#7-4-3-处理冲突的方法" class="headerlink" title="7.4.3 处理冲突的方法"></a>7.4.3 处理冲突的方法</h3><ol><li><p>开放地址法（开地址法）</p><p> 当有冲突时就去寻找<strong>下一个</strong>空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。常见方法包括：<strong>线性探测法</strong>、<strong>二次探测法</strong>、<strong>伪随机探测法</strong>。<code>Hi = (Hash(key) + di) mod m, m是散列表长度, di是增量序列</code></p><p> 线性探测法：<code>di为1, 2, ..., m-1线性序列</code>，一旦冲突，就找下一个地址，直到找到空地址存入。</p><p> 二次探测法：<code>di为1^2, -1^2, 2^2, -2^2， ..., q^2二次序列</code>。</p><p> 伪随机探测法：<code>di为伪随机数序列</code>。</p></li><li><p>链地址法（拉链法）</p><p> 将相同散列地址的记录链成一个单链表，<strong>m个散列地址就设m个单链表</strong>，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。</p><p> 链地址法建立散列表步骤：</p><ol><li><p>取数据元素的关键字key，计算其散列函数值（地址）。若该地址对应的链表为空，则将该元素插入此链表；否则执行步骤2解决冲突。</p></li><li><p>根据选择的冲突处理方法，计算关键字key的下一个存储地址。若该地址对应的链表为不为空，则利用链表的前插法或后插法将该元素插入此链表。</p></li></ol><p> 连地址法的优点：非同义词<strong>不会冲突</strong>，无聚集现象；链表上结点空间动态申请，更适合于表长不确定的情况；</p></li><li><p>再散列法（双散列函数法）</p></li><li><p>建立一个公共溢出区</p></li></ol><h3 id="7-4-4-散列表的查找及性能分析"><a href="#7-4-4-散列表的查找及性能分析" class="headerlink" title="7.4.4 散列表的查找及性能分析"></a>7.4.4 散列表的查找及性能分析</h3><ul><li>图14：散列表查找流程图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131119199.png"></li></ul><p>散列表的查找效率，如果使用平均查找长度ASL来衡量，则ASL取决于：散列函数、处理冲突的方法、散列表的<strong>装填因子</strong>α（<code>α=表中填入的记录数/哈希表的长度</code>）。</p><p>其中，α越大，表中记录的数据越多，说明表装填的越满，发生冲突的可能性越大，查找时比较次数就越多。</p><p>ASL与装填因子α有关，既不是严格的O(1)，也不是O(n)。</p><p><code>ASL≈1+α/2(拉链法);ASL≈1/2*(1+(1/(1-α)))(线性探测法);ASL≈-(1/α)*ln(1-α)(随机探测法)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图——王卓</title>
    <link href="/2022/10/13/%E5%9B%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E5%9B%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第6章-图"><a href="#第6章-图" class="headerlink" title="第6章 图"></a>第6章 图</h1><p>图是一种比线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层中的多个元素（即其孩子结点）相关，但只能和上一层中一个元素（即其双亲结点）相关；而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。在数据结构中，应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构，以及若于图的操作的实现。</p><h2 id="6-1-图的定义和基本术语"><a href="#6-1-图的定义和基本术语" class="headerlink" title="6.1 图的定义和基本术语"></a>6.1 图的定义和基本术语</h2><h3 id="6-1-1-图的定义"><a href="#6-1-1-图的定义" class="headerlink" title="6.1.1 图的定义"></a>6.1.1 图的定义</h3><p>图(Graph)G由两个集合V和E组成，记为G&#x3D;(V,E)：</p><ul><li><p>V(vertex)是顶点的<strong>有穷非空集合</strong>;</p></li><li><p>E(Edge)是V中顶点偶对的<strong>有穷集合</strong>，这些顶点偶对称为<strong>边</strong>。</p></li></ul><p>V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。</p><p>对于图G，若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。</p><p>对于图G，若图中任意两个点之间都有一条边相连，则称为<strong>完全图</strong>。对于n个顶点，则无向完全图有n(n-1)&#x2F;2条边，有向完全图有n(n-1)条边。</p><h3 id="6-1-2-图的基本术语"><a href="#6-1-2-图的基本术语" class="headerlink" title="6.1.2 图的基本术语"></a>6.1.2 图的基本术语</h3><p>用n表示图中顶点数目，用e表示边的数目，下面介绍图结构中的一些基本术语。</p><ol><li><p><strong>无向完全图</strong>和<strong>有向完全图</strong>：对于无向图，若具有n(n- 1)&#x2F;2条边，则称为无向完全图。对于有向图，若具有n(n-1)条弧，则称为有向完全图。</p></li><li><p><strong>稀疏图</strong>和<strong>稠密图</strong>：有很少条边或弧(如e &lt; nlogn)的图称为稀疏图，反之称为稠密图。</p></li><li><p><strong>权</strong>和<strong>网</strong>：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。<strong>这种带权的图通常称为网</strong>。</p></li><li><p><strong>邻接</strong>：描述图中两个顶点之间的关系，有边&#x2F;弧相连的两个顶点，称为两顶点邻接。</p></li><li><p><strong>邻接点</strong>：对于无向图G，如果图的边(v, v’)∈E，则称顶点v和v’互为邻接点，即v和v’相邻接。边(v, v’)<strong>依附于</strong>顶点v和v’，或者说边(v, v’)与顶点v和v’<strong>相关联</strong>。在有向图中，存在<code>&lt;v, v&#39;&gt;</code>，则称<strong>v邻接到v’，v’邻接于v</strong>。</p></li><li><p><strong>度</strong>、<strong>入度</strong>和<strong>出度</strong>：顶点的度是指和v<strong>相关联的边的数目</strong>，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v),顶点v的度为TD(v) &#x3D; ID(v) + OD(v)。</p></li><li><p><strong>路径</strong>和<strong>路径长度</strong>：接续的边构成的顶点序列。在无向图G中，从顶点v到顶点v’的路径是一个顶点序列。如果G是有向图，则路径也是有向的。路径长度是一条路径上经过的边或弧的数目或权值之和。</p></li><li><p><strong>回路</strong>或<strong>环</strong>：第一个顶点和最后一个顶点相同的路径称为回路或环。</p></li><li><p><strong>简单路径</strong>、<strong>简单回路</strong>或<strong>简单环</strong>：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p></li><li><p><strong>连通</strong>、<strong>连通图</strong>和<strong>连通分量</strong>：在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点Vi、Vj，Vi和Vj都是连通的，则称G是连通图。所谓连通分量，指的是无向图中的极大连通子图。其中极大连通子图意思是：<strong>该子图是连通子图，将G的任何不在该子图中的顶点加入，子图不再连通</strong>。</p></li><li><p><strong>强连通图</strong>和<strong>强连通分量</strong>：在有向图G中，如果对于每一对Vi, Vj，从Vi到Vj和从Vj到Vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。</p></li><li><p>极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，该子图不再连通。</p></li><li><p><strong>连通图的生成树</strong>：包含无向图G所有顶点的极小连通图；一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边，这样的连通子图称为连通图的生成树。</p></li><li><p><strong>有向树</strong>和<strong>生成森林</strong>：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p></li></ol><h2 id="6-2-案例引入"><a href="#6-2-案例引入" class="headerlink" title="6.2 案例引入"></a>6.2 案例引入</h2><h2 id="6-3-图的类型定义"><a href="#6-3-图的类型定义" class="headerlink" title="6.3 图的类型定义"></a>6.3 图的类型定义</h2><p>图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。抽象数据类型图的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADTGraph&#123;<br>    数据对象： V是具有相同特性的数据元素的集合，称为顶点集。<br>数据关系：<br>    R = &#123;VR&#125;<br>    VR = &#123;&lt;v, w&gt;|v, w属于V，且<span class="hljs-built_in">P</span>(v, w) &lt;v, w&gt;表示从v到w的弧，谓词<span class="hljs-built_in">P</span>(v, w)定义了弧&lt;v, w&gt;的意义或信息&#125;<br>基本操作：<br>    图的创建、增删改查等。其中重要的包括有构造图、深度优先搜索、广度优先搜索。<br></code></pre></td></tr></table></figure><h2 id="6-4-图的存储结构"><a href="#6-4-图的存储结构" class="headerlink" title="6.4 图的存储结构"></a>6.4 图的存储结构</h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但<strong>可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法（数组表示法）</strong>。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有<strong>邻接表</strong>、<strong>十字链表</strong>和<strong>邻接多重表</strong>，应根据实际需要的不同选择不同的存储结构。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121945.png"></p><h3 id="6-4-1-邻接矩阵"><a href="#6-4-1-邻接矩阵" class="headerlink" title="6.4.1 邻接矩阵"></a>6.4.1 邻接矩阵</h3><ol><li><p>邻接矩阵表示法</p><p> 建立一个<strong>顶点表</strong>(记录哥各个顶点信息)和一个<strong>邻接矩阵</strong>(表示各个顶点之间关系)。</p><p> <strong>邻接矩阵</strong>(<strong>Adjacency Matrix</strong>)是表示顶点之间相邻关系的矩阵。设G(V, E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">A[i][j] = <span class="hljs-number">1</span>; 若&lt;i, j&gt;∈E或者(i, j)∈E<br>A[i][j] = <span class="hljs-number">0</span>; 否则<br></code></pre></td></tr></table></figure><ul><li>分析1：无向图的邻接矩阵是对阵的；</li><li>分析2：顶点i的度&#x3D;第i行(列)中的1的个数；</li><li>分析3：完全图的邻接矩阵中，对焦元素为0，其余为1。</li></ul><p> 有向图的邻接矩阵需考虑边的方向。</p><ul><li>分析1：有向图的邻接矩阵可能是不对称的；</li><li>分析2：顶点的出度&#x3D;第i行元素之和，顶点的入度&#x3D;第i列元素之和，顶点的度&#x3D;第i行元素之和+第i列元素之和。</li></ul><p> 网(即有权图)的邻接矩阵表示法：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">A[i][j] = Wij; 若&lt;vi, vj&gt;或(vi, vj)∈VR<br>A[i][j] = ∞; 无边(弧)<br>其中，Wij表示边上的权值；∞表示计算机允许的、大于所有边上权值的数。<br></code></pre></td></tr></table></figure><p> 用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。其形式说明如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//-----图的邻接矩阵存储表示－－－－－</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt  32767</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum   100         <span class="hljs-comment">// 最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;    <span class="hljs-comment">// 设顶点的数据类型为字符型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;        <span class="hljs-comment">// 假设边的权值类型为整型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    VerTexType  vexs[MVNum];    <span class="hljs-comment">// 顶点表</span><br>    ArcType     arcs[MVNum][MVNum]; <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum; <span class="hljs-comment">// 图的当前点数和边数</span><br>&#125;AMGraph;<br></code></pre></td></tr></table></figure></li><li><p>采用邻接矩阵表示法创建无向网</p><p> 已知一个图的点和边，使用邻接矩阵表示法来创建此图的方法比较简单，下面以一个无向网为例来说明创建图的算法。</p><p> 算法步骤：</p><ol><li>输入总顶点数和总边数。</li><li>依次输入点的信息存入顶点表中。</li><li>初始化邻接矩阵，使每个权值初始化为极大值。</li><li>构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。</li></ol><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(AMGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接矩阵表示法，创建无向网G</span><br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;        <span class="hljs-comment">// 输入总顶点数，总边数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-comment">// 依次输入顶点信息</span><br>        cin &gt;&gt; G.vexs[i];<br>    &#125;<br>    <span class="hljs-comment">// 初始化邻接矩阵，边的权值均置为极大值MaxInt</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; i &lt; G.vexnum; j++)<br>        &#123;<br>            G.arcs[i][j] = MaxInt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 构造邻接矩阵</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++)<br>    &#123;<br>        <span class="hljs-comment">// 输人一条边依附的顶点及权值</span><br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<br>        <span class="hljs-comment">// 确定v1和v2在G中的位置，即顶点数组的下标</span><br>        i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-comment">// 边&lt;v1,v2&gt;的权值为w</span><br>        G.arcs[i][j] = w;<br>        G.arcs[j][i] = G.arcs[i][j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocatVex</span><span class="hljs-params">(AMGraph G, VerTexType u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(u == G.vexs[i])<br>        &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 该算法的时间复杂度是0(n^2)。</p><p> 若要建立无向图，只需对上述算法做两处小的改动：<strong>一是初始化邻接矩阵时，将边的权值均初始化为0；二是构造邻接矩阵时，将权值w改为常量值1即可</strong>。同样，将该算法稍做修改即可建立一个有向网或有向图，即邻接矩阵为非对称矩阵。</p></li><li><p>邻接矩阵表示法的优缺点</p><blockquote><p>优点</p></blockquote><ol><li><p>便于判断两个顶点之间是否有边，即根据A[i][j] &#x3D; 0或1来判断。</p></li><li><p>方便找任意顶点的所有邻接点；</p></li><li><p>便于计算各个顶点的度。对于无向图，邻接矩阵第i行元素之和就是顶点i的度；对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。</p></li></ol><blockquote><p>缺点</p></blockquote><ol><li><p>不便于增加和删除顶点。</p></li><li><p>不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2)</p></li><li><p>空间复杂度高。如果是有向图，n个顶点需要n^2个单元存储边。</p><p> 如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要n(n-1)&#x2F;2个单元即可。</p></li></ol></li></ol><h3 id="6-4-2-邻接表"><a href="#6-4-2-邻接表" class="headerlink" title="6.4.2 邻接表"></a>6.4.2 邻接表</h3><ol><li><p>邻接表表示法</p><p> <strong>邻接表</strong>(<strong>Adjacency List</strong>)是图的一种链式存储结构。在邻接表中，对图中每个顶点vi建立一个单链表，把与vi相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：<strong>表头结点表</strong>和<strong>边表</strong>。</p><ol><li><p><strong>表头结点表</strong>：由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。表头结点包括数据域(data)和链域(firstarc)两部分。其中，数据域用于存储顶点vi的名称或其他有关信息；链域用于指向链表中第一个结点（即与顶点vi邻接的第一个邻接点）。</p></li><li><p><strong>边表</strong>：由表示图中顶点间关系的2n个边链表组成。边链表中边结点包括<strong>邻接点域(adjvex)、数据域(info)和链域(nextarc)三部分</strong>。其中，邻接点域指示与顶点vi邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点vi邻接的下一条边的结点。</p></li></ol><p> 特点：</p><ul><li>邻接表不唯一；</li><li>若<strong>无向图</strong>中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适合存储稀疏图；</li><li><strong>无向图</strong>中顶点vi的度为第i个单链表中的结点数。</li></ul><p> 有向图的邻接表特点：</p><ul><li>顶点vi的出度为第i个单链表中的结点个数</li><li>顶点vi的入读为整个单链表中邻接点域值是i-1的结点个数。</li></ul><p> 反之，逆邻接表记录的是入度，所以找入度易，找出度难。</p><p> <strong>当邻接表的存储结构形成后，图便惟一确定</strong>。</p><p> 根据上述讨论，要定义一个邻接表，需要先定义其存放顶点的头结点和表示边的边结点。图的邻接表存储结构说明如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100           <span class="hljs-comment">// 最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>      <span class="hljs-comment">// 边结点</span><br>&#123;<br>    <span class="hljs-type">int</span> adjvex;             <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>    ArcNode* nextarc;       <span class="hljs-comment">// 指向下一条边的指针</span><br>    OtherInfo info;         <span class="hljs-comment">// 和边相关的信息</span><br>&#125;ArcNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span>        <span class="hljs-comment">// 顶点信息</span><br>&#123;<br>    VerTexType data;<br>    ArcNode *firstarc;      <span class="hljs-comment">// 指向第一条依附于该顶点的边的指针</span><br>&#125;VNode, AdjList[MVNum];     <span class="hljs-comment">// AdjList表示邻接表类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ALGraph</span><br>&#123;<br>    AdjList vertices;       <span class="hljs-comment">// 邻接表数组</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;     <span class="hljs-comment">// 图的当前定点数和边数</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>采用邻接表表示法创建无向图</p><p> 算法思想:</p><ol><li>输入总顶点数和总边数。</li><li>依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。</li><li>创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj对应的两个边链表的头部。</li></ol><blockquote><p>算法实现</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 采用邻接表表示法，创建无向图G</span><br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    <span class="hljs-comment">// 输入总顶点数，总边数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<span class="hljs-comment">// 输入各点，构造表头结点表</span><br>        cin &gt;&gt; G.vertices[i].data;  <span class="hljs-comment">// 输入顶点值</span><br>        G.vertices[i].firstarc = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 初始化各表头结点的指针域为NULL</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++)<br>    &#123;<span class="hljs-comment">// 输入各边，构造邻接表</span><br>        cin &gt;&gt; v1 &gt;&gt; v2;<br>        <span class="hljs-comment">// 确定v1和v2在G中的位置，即顶点在G.vertices中的序号</span><br>        i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        p1 = <span class="hljs-keyword">new</span> ArcNode;   <span class="hljs-comment">// 生成一个新的边结点</span><br>        p1-&gt;adjvex = j;     <span class="hljs-comment">// 邻接点序号为j</span><br>        <span class="hljs-comment">// 将新结点p1插入顶点vi的边表头部</span><br>        p1-&gt;nextarc = G.vertices[i].firstarc;<br>        G.vertices[i].firstarc = p1;<br>        p2 = <span class="hljs-keyword">new</span> ArcNode;   <span class="hljs-comment">// 生成另一个对称的新的边结点</span><br>        p2-&gt;adjvex = i;<br>        <span class="hljs-comment">// 将新结点p2插入顶点vj的边表头部</span><br>        p2-&gt;nextarc = G.vertices[j].firstarc;<br>        G.vertices[j].firstarc = p2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p> 该算法的时间复杂度是O(n + e)。</p><p> 建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号&lt;i,j&gt;，仅需生成一个邻接点序号为j的边表结点，并将其插入到vi；的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。</p></li><li><p>邻接表表示法的优缺点</p><p> 优点：</p><ol><li>便于增加和删除顶点。</li><li>便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n + e)。</li><li>空间效率高。对于一个具有n个顶点e条边的图G，若G是无向图，则在其邻接表表示中有n个顶点表结点和2e个边表结点；若G是有向图，则在它的邻接表表示或逆邻接表表示中均有n个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为O(n + e),适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。</li></ol><p> 缺点：</p><ol><li>不便于判断顶点之间是否有边，要判定vi和vj之间是否有边，就需扫描第i个边表，最坏情况下要耗费O(n)时间。</li><li>不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点vi的度是第i个边表中的结点个数。在有向图的邻接表中，第i个边表上的结点个数是顶点vi的出度，但求vi的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。</li></ol></li><li><p>邻接矩阵与邻接表示法的关系</p><ol><li><p><strong>联系</strong>：邻接表中每个链表对应邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p></li><li><p><strong>区别</strong>：</p><ul><li><p>对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。</p></li><li><p>邻接矩阵的空间复杂度为O(n^2)，而领接表的空间复杂度为O(n+e)；</p></li></ul></li><li><p><strong>用途</strong>：邻接矩阵多用于稠密图；而邻接表多用于稀疏图。</p></li></ol></li></ol><h3 id="6-4-3-十字链表"><a href="#6-4-3-十字链表" class="headerlink" title="6.4.3 十字链表"></a>6.4.3 十字链表</h3><p><strong>十字链表</strong>(<strong>Orthogonal List</strong>)是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。</p><p><strong>有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点</strong>。</p><p>在弧结点中有5个域：其中尾域(tailvex)和头域(headvex)分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink指向弧尾相同的下一条弧，info域指向该弧的相关信息。</p><p>头结点即顶点结点，它由3个域组成：其中data域存储和顶点相关的信息，如顶点的名称等；firstin和firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。</p><h3 id="6-4-4-邻接多重表"><a href="#6-4-4-邻接多重表" class="headerlink" title="6.4.4 邻接多重表"></a>6.4.4 邻接多重表</h3><p><strong>邻接多重表</strong>(<strong>Adjacency Multilist</strong>)是无向图的另一种链式存储结构。</p><p>邻接多重表的结构和十字链表类似。在邻接多重表中，每一条边用一个结点表示。其中，mark为标志域，可用以标记该条边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域。</p><p>每一个顶点也用一个结点表示，其中，data域存储和该顶点相关的信息，firstedge域指示第一条依附于该顶点的边。</p><h2 id="6-5-图的遍历"><a href="#6-5-图的遍历" class="headerlink" title="6.5 图的遍历"></a>6.5 图的遍历</h2><p>和树的遍历类似，图的遍历也是从图中某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。</p><p>为避免重复访问，可设置辅助数组visited[n]，用来标记每个被访问过的顶点。</p><ul><li>初始状态visited[i]为0；</li><li>顶点i被访问，改visited[i]为1，防止被多次访问</li></ul><p>根据搜索路径的方向，通常有两条遍历图的路径：深度优先搜索和广度优先搜索。它们对无向图和有向图都适用。</p><h3 id="6-5-1-深度优先搜索"><a href="#6-5-1-深度优先搜索" class="headerlink" title="6.5.1 深度优先搜索"></a>6.5.1 深度优先搜索</h3><ol><li><p>深度优先搜索遍历的过程</p><p> <strong>深度优先搜索</strong>(<strong>DepthFirst Search, DFS</strong>)遍历类似于树的先序遍历，是树的先序遍历的推广。对于一个连通图，深度优先搜索遍历的过程如下：</p><ol><li><p>从图中某个顶点v出发，访问v。</p></li><li><p>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。</p></li><li><p>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</p></li><li><p>重复步骤(2)和(3),直至图中所有顶点都被访问过，搜索结束。</p></li></ol></li><li><p>深度优先搜索遍历的算法实现</p><p> 显然，深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为”false，一旦某个顶点被访问，则其相应的分量置为”true”。</p><p> 算法6.3 深度优先搜索遍历连通图</p><p> 算法步骤：</p><ol><li><p>从图中某个顶点v出发，访问v，并置visited[v]的值为true。</p></li><li><p>依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历，直到图中所有顶点都被访问过。</p></li></ol> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> visited[MVNum];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(w = <span class="hljs-built_in">FitstAdjVex</span>(G, v); w &gt;= <span class="hljs-number">0</span>; w = <span class="hljs-built_in">NextAdjVex</span>(G, v, w))<br>        <span class="hljs-keyword">if</span>(!visited[w])<br>            <span class="hljs-built_in">DFS</span>(G, w);<br>&#125;<br></code></pre></td></tr></table></figure><p> 算法6.4 深度优先搜索遍历非连通图</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFSTracerse</span><span class="hljs-params">(Graph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v &lt; G.vexnum; ++v)<br>    &#123;<br>        visited[v] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v &lt; G.vexnum; ++v)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!visited[v])<br>            <span class="hljs-built_in">DFS</span>(G, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 算法6.5 采用邻接矩阵表示图的深度优先搜索遍历</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFs</span><span class="hljs-params">(AMGraph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>; w &lt; G.vexnum; w++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((G.arcs[v][w] != <span class="hljs-number">0</span>) &amp;&amp; (!visited[w]))<br>        &#123;<br>            <span class="hljs-built_in">DFS</span>(G, w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在的行，时间复杂度为O(n^2)。</p><p> 算法6.6 采用邻接表表示图的深度优先搜索遍历</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS_AL</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 图G为邻接表类型，从第v个顶点出发深度优先搜索遍历图G</span><br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    p = G.vertices[v].firstarc;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        w = p-&gt;adjvex;      <span class="hljs-comment">// 表示w是v的邻接点</span><br>        <span class="hljs-keyword">if</span>(!visited[w])<br>            <span class="hljs-built_in">DFS</span>(G,w);<br>        p = p-&gt;nextarc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问个头结点的时间，时间复杂度为O(n+e)。</p><p> 因此，<strong>稠密图适于在邻接矩阵上进行深度遍历</strong>，<strong>稀疏图适于在邻接表上进行深度遍历</strong>。</p></li></ol><h3 id="6-5-2-广度优先搜索"><a href="#6-5-2-广度优先搜索" class="headerlink" title="6.5.2 广度优先搜索"></a>6.5.2 广度优先搜索</h3><ol><li><p>广度优先搜索遍历的过程</p><p> <strong>广度优先搜索</strong>(<strong>Breadth First Search, BFS</strong>)遍历类似于树的按层次遍历的过程。广度优先搜索遍历的过程如下：</p><ol><li><p>从图中某个顶点v出发，访问v。</p></li><li><p>依次访问v的各个未曾访问过的邻接点。</p></li><li><p>分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤(3)，直至图中所有已被访问的顶点的邻接点都被访问到。</p></li></ol></li><li><p>广度优先搜索遍历的算法实现</p><p> 算法6.7 广度优先搜索遍历连通图</p><p> 算法步骤：</p><ol><li><p>从图中某个顶点v出发，访问v，并置visited[v]的值为true，然后将v进队。</p></li><li><p>只要队列不空，则重复下述操作：</p><ul><li><p>队头顶点u出队；</p></li><li><p>依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。</p></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">InitQueue</span>(Q);<br>    <span class="hljs-built_in">EnQueue</span>(Q, v);  <span class="hljs-comment">//v入队</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(Q))<br>    &#123;<br>        <span class="hljs-built_in">DeQueue</span>(Q, u);  <span class="hljs-comment">// 队首元素出队并置为u</span><br>        <span class="hljs-keyword">for</span>(w = <span class="hljs-built_in">FirstAdjVex</span>(G, u); w &gt;= <span class="hljs-number">0</span>; <span class="hljs-built_in">NextAdjVex</span>(G, u, w))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[w])<br>            &#123;<br>                cout &lt;&lt; w;<br>                visited[w] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">EnQueue</span>(Q, w);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 遍历图的过程实质上是通过边找邻接点的过程，因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，即当用邻接矩阵存储时，时间复杂度为O(n^2)；用邻接表存储时，时间复杂度为O(n+e)。</p></li></ol><h3 id="6-5-3-DFS与BFS算法效率比较"><a href="#6-5-3-DFS与BFS算法效率比较" class="headerlink" title="6.5.3 DFS与BFS算法效率比较"></a>6.5.3 DFS与BFS算法效率比较</h3><ul><li><p>空间复杂度相同，都是O(n)（借用了堆栈或队列）；</p></li><li><p>时间复杂度只与存储结构、（邻接矩阵或邻接表）有关，而与搜索路径无关。</p></li></ul><h2 id="6-6-图的应用"><a href="#6-6-图的应用" class="headerlink" title="6.6 图的应用"></a>6.6 图的应用</h2><h3 id="6-6-1-最小生成树"><a href="#6-6-1-最小生成树" class="headerlink" title="6.6.1 最小生成树"></a>6.6.1 最小生成树</h3><p>生成树的共同特点：</p><ul><li><p>顶点个数与图的顶点个数相同；</p></li><li><p>是图的极小连通子图，去掉一条边则非连通；</p></li><li><p>一个有n个顶点的连通图的生成树有n-1条边；</p></li><li><p><strong>在生成树中再加一条边必然形成回路</strong>；</p></li><li><p>生成树中的任意两个顶点间的路径是惟一的。</p></li></ul><p>在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的<strong>最小代价生成树</strong>(<strong>Minimum Cost Spanning Tree</strong>)，简称为<strong>最小生成树</strong>。</p><p>构造最小生成树有多种算法，其中多数算法利用了最小生成树的下列一种简称为MST的性质：假设N&#x3D;(V, E)是一个连通网，U是顶点集V的一个非空子集。若(u, v)是一条具有最小权值（代价）的边，其中u∈U，v∈V-U，则必存在一棵包含边(u, v)的最小生成树。</p><p>MST性质解释：</p><p>在生成树的构造过程中，图中n个顶点分属两个集合：</p><ul><li><p>已落在生成树上的顶点集：U</p></li><li><p>尚未落在生成树上的顶点集：V-U</p></li></ul><p>接下来则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。</p><p>普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法是两个利用MST性质构造最小生成树的算法。下面先介绍普里姆算法。</p><ol><li><p>普里姆算法</p><p> 普里姆算法的构造过程：</p><p> 假设N&#x3D;(V,E)是连通网，TE是N上最小生成树中边的集合。</p><ol><li><p>U &#x3D; {u0}(u0∈V), TE &#x3D; {}。</p></li><li><p>在所有u∈U, v∈V- U的边(u,v)∈E中找一条权值最小的边(u0,v0)并入集合TE，同时v0并入U。</p></li><li><p>重复步骤2，直至U &#x3D; V为止。</p></li></ol><p> 此时TE中必有n-1条边，则T&#x3D; (V, TE)为N的最小生成树。</p><p> 普里姆算法的算法实现：</p><p> 假设一个无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，要求输出T的各条边。为实现这个算法需附设一个辅助数组closedge，以记录从U到V-U具有最小权值的边。对每个顶点vi∈V- U，在辅助数组中存在一个相应分量closedge[i-1], 它包括两个域：lowcost和adjvex，其中Iowcost存储最小边上的权值，adjvex存储最小边在U中的那个顶点。显然，closedge[i-1].lowcost &#x3D; Min{ cost(u, vi)|u∈U}，其中cost(u,v)表示赋于边(u,v)的权。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边</span><br><br><span class="hljs-keyword">struct</span><br>&#123;<br>    VerTexType adjvex;      <span class="hljs-comment">// 最小边在U中的那个顶点</span><br>    ArcType lowcost;        <span class="hljs-comment">// 最小边上的权值</span><br>&#125;closedge[MVNum];<br></code></pre></td></tr></table></figure><p> 算法6.8 普里姆算法</p><ol><li><p>首先将初始顶点u加入U中，对其余的每一个顶点Vj，将closedge[j]均初始化为到u的边息。</p></li><li><p>循环n - 1次，做如下处理：</p><ul><li><p>从各组边closedge中选出最小边closedge[k]，输出此边；</p></li><li><p>将k加入U中；</p></li><li><p>更新剩余的每组最小边信息closedge[j]，对于V-U中的边，新增加了一条从k到j的边，如果新边的权值比closedge[i].lowcost小，则将closedge[j].lowcost 更新为新边的权值。</p></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree_Prim</span><span class="hljs-params">(AMGraph G, VerTexType u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边</span><br>    k = <span class="hljs-built_in">LocateVex</span>(G, u);        <span class="hljs-comment">// k为顶点u的下标</span><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(j != k) closedge[j] = &#123;u, G.arcs[k][j]&#125;;<br>        closedge[k].lowcost = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 初始，U=&#123;u&#125;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.vexnum; ++i)<br>        &#123;<br>            <span class="hljs-comment">// 求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边</span><br>            u0 = closedge[k].adjvex;    <span class="hljs-comment">// u0为最小边的一个顶点</span><br>            v0 = G.vexs[k];             <span class="hljs-comment">// v0为最小边的另一个顶点</span><br>            cout &lt;&lt; u0 &lt;&lt; v0;<br>            closedge[k].lowcost = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(G.arcs[k][j] &lt; closedge[j].lowcost)<br>                &#123;<br>                    closedge[j] = &#123;G.vexs[k], G.arcs[k][j]&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>克鲁斯卡尔算法</p><p> 算法步骤：</p><ol><li><p>将数组Edge中的元素按权值从小到大排序。</p></li><li><p>依次查看数组Edge中的边，循环执行以下操作：</p><ul><li><p>依次从排好序的数组Edge中选出一条边(U1,U2)；</p></li><li><p>在Vexset中分别查找V1和V2所在的连通分量vs1和vs2，进行判断：</p><ul><li><p>如果vs1和vs2不等，表明所选的两个顶点分属不同的连通分量，输出此边，并合并vs1和vs2两个连通分量；</p></li><li><p>如果vs1和vs2相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。</p></li></ul></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree_Kruskal</span><span class="hljs-params">(AMGraph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Sort</span>(Edge); <span class="hljs-comment">// 将数组Edge中的元素按权值从小到大排序</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; G.arcnum; i++)<br>    &#123;<br>        v1 = <span class="hljs-built_in">LocateVex</span>(G, Edge[i].Head);    <span class="hljs-comment">// v1为边的始点Head的下标</span><br>        v2 = <span class="hljs-built_in">LocateVex</span>(G, Edge[i].Tail);    <span class="hljs-comment">// v2为边的始点Head的下标</span><br>        vs1 = Vexset[v1];   <span class="hljs-comment">// 获取边Edge[i]的始点所在的连通分量vs1</span><br>        vs2 = Vexset[v2];   <span class="hljs-comment">// 获取边Edge[i]的始点所在的连通分量vs2</span><br>        <span class="hljs-keyword">if</span>(vs1 != vs2)<br>        &#123;<br>            cout &lt;&lt; Edge[i].Head &lt;&lt; Edge[i].Tail;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(Vexset[j] == vs2)<br>                    Vexset[j] = vsl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302141915180.png"></p><h3 id="6-6-2-最短路径"><a href="#6-6-2-最短路径" class="headerlink" title="6.6.2 最短路径"></a>6.6.2 最短路径</h3><p>问题抽象：在有向网中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。</p><p>在带权有向网中，习惯上称路径上的第一个顶点为源点(Source)，最后一个顶点为终点(Destination)。</p><p>针对单源最短路径一用Dijkstra(迪杰断特拉)算法；针对所有顶点间的最短路径一用Floyd(弗洛伊德)算法。</p><ol><li><p>Dijistra算法</p><ol><li><p>初始化：先找出从源点v0到各终点vk的直达路径(v0,vk)，即通过一条弧到达的路径；</p></li><li><p>选择：从这些路径中找出一条长度最短的路径(v0,u)；</p></li><li><p>更新：然后对其余各条路径进行适当调整：</p><p> 若在图中存在弧(u,vk)，且(v0,u)+(u,vk)&lt;(v0,vk)，则以路径(v0,u，vk)代替(v0,vk)。</p></li></ol><p> 在调整后的各条路径中，再找长度最短的路径，依此类推。</p><p> <strong>Dijistra算法：按照长度递增次序产生最短路径。</strong></p><ol><li><p>把V分成两组：</p><p> (1) S：已求出最短路径的顶点的集合；</p><p> (2)T&#x3D;V - S：尚未确定最短路径的顶点解和。</p></li><li><p>将T中顶点按最短路径递增的次序加入到S中</p><p> 保证：a. 从源点v0到S中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。</p><p> b. 每个顶点对应一个距离值：S中顶点：从v0到此顶点的最短路径；T中顶点：从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。</p></li></ol></li><li><p>Floyd算法</p><ol><li><p>初始时设置一个n阶方阵，令其对角线元素为0，若存在弧&lt;vi, vj&gt;，则对应元素为全职，否则为正无穷。</p></li><li><p>逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之；否则，维持原值。所有顶点试探完毕，算法结束。</p></li></ol></li></ol><h3 id="6-6-3-拓扑排序"><a href="#6-6-3-拓扑排序" class="headerlink" title="6.6.3 拓扑排序"></a>6.6.3 拓扑排序</h3><p>拓扑排序针对有向无环图。<strong>有向无环图</strong>：无环的有向图，简称DAG图（Directed Acycline Graph）。</p><p>有向无环图常用来描述一个工程或系统的进行过程。（通常把计划、施工、生产、程序流程等当成是一个工程）一个工程可以分为若干个子工程，只要完成了这些子工程（活动），就可以导致整个工程的完成。</p><p><strong>AOV网</strong>（拓扑排序）：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以<strong>顶点表示活动</strong>，<strong>弧表示活动之间的优先制约关系</strong>，称这种有向图为<strong>顶点表示活动的网</strong>，简称AOV网（Activity On Vertex network）。</p><p><strong>AOE网</strong>（关键路径）：用一个有向图表示一个工程的各子工程及其相互制约的关系，<strong>以弧表示活动</strong>，<strong>以顶点表示活动的开始或结束事件</strong>，称这种有向图为<strong>边表示活动的网</strong>，简称为AOE网（Activity On Edge）。</p><ol><li><p>AOV网的特点</p><ul><li><p>若从i到j有一条有向路径，则i是j的前驱，j是i的后继；</p></li><li><p>若&lt;i, j&gt;是网中有向边，则i是j的直接前驱，j是i的直接后继；</p></li><li><p>AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。</p></li></ul></li><li><p>拓扑排序</p><p> 在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧&lt;i, j&gt;存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为<strong>拓扑有序序列</strong>，相应的拓扑有序排序的算法称为<strong>拓扑排序</strong>。</p><p> 拓扑排序方法：</p><ul><li><p>在有向图中选一个没有前驱的顶点且输出之；</p></li><li><p>从图中删除该顶点和所有以它为尾的弧；</p></li><li><p>重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止。</p></li></ul><p> 检测AOV网中是否存在环：对有向图构造其顶点得拓扑有序序列，若网中所有顶点都在它得拓扑有序序列中，则该AOV网必定不存在环。</p></li><li><p>关键路径</p><p> 把工程计划表示为<strong>边表示活动的网络</strong>，即<strong>AOE网</strong>，用<strong>顶点表示事件</strong>，<strong>弧表示活动</strong>，<strong>弧的权表示活动持续时间</strong>。</p><p> 针对AOE网，主要关心两方面问题：完成整项工程至少需要多少时间；哪些活动是影响工程进度的关键。</p><p> 确定关键路径的4个描述量：ve(vj)表示事件vj的最早发生时间；vl(vj)表示事件vj的最晚发生时间；e(i)表示活动ai的最早开始时间；l(i)表示活动ai的最迟开始时间，则l(i)-e(i)表示完成活动ai的时间余量。</p><p> <strong>关键活动</strong>：关键路径上的活动，即l(i)&#x3D;&#x3D;e(i)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树——王卓</title>
    <link href="/2022/10/13/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第5章-树和二叉树"><a href="#第5章-树和二叉树" class="headerlink" title="第5章 树和二叉树"></a>第5章 树和二叉树</h1><h2 id="5-1-树与二叉树的定义"><a href="#5-1-树与二叉树的定义" class="headerlink" title="5.1 树与二叉树的定义"></a>5.1 树与二叉树的定义</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><p>树(非线性结构)是以分支关系定义的层次结构：结点之间有分支、具有层次关系。</p><blockquote><p>树的定义</p></blockquote><p>树(Tree)是n(n≥0)个结点的<strong>有限集</strong>。</p><ul><li><p>若n&#x3D;0，称为空树；</p><ul><li>若n&gt;0，则它满足如下两个条件：</li></ul><ol><li><p><strong>有且仅有一个</strong>特定的称为根(Root)的结点；</p></li><li><p><strong>其余结点</strong>可分m(m≥0)个互不相交的有限集T1，T2，T3…Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)。</p></li></ol></li></ul><p>树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还可有其他的表示形式：嵌套集合表示<br>（即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）；广义表的形式表示，根作为由子树森林组成的表的名字写在表的左边；凹入表示法（类似书的编目）。</p><h3 id="5-1-2-树的基本术语"><a href="#5-1-2-树的基本术语" class="headerlink" title="5.1.2 树的基本术语"></a>5.1.2 树的基本术语</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121460.png"></p><ol><li><p><strong>根节点</strong>：非空树中无前驱结点的结点；</p></li><li><p><strong>结点</strong>：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支，如图中的A 、B 、C 、D等。</p></li><li><p><strong>结点的度</strong>：结点拥有的子树数称为结点的度。例如，A的度为3，C的度为1，F的度为0。</p></li><li><p><strong>树的度</strong>：树的度是树内各结点度的最大值。图中所示的树的度为3。</p></li><li><p><strong>叶子</strong>：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。</p></li><li><p><strong>非终端结点</strong>：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。</p></li><li><p><strong>父亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的父亲。例如，B的双亲为A，B的孩子有E和F。</p></li><li><p><strong>兄弟</strong>：同一个父亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。</p></li><li><p><strong>祖先</strong>：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。</p></li><li><p><strong>子孙</strong>：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。</p></li><li><p><strong>层次</strong>：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其父亲结点的层次加1。</p></li><li><p><strong>堂兄弟</strong>：父亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。</p></li><li><p><strong>树的深度</strong>：树中结点的最大层次称为<strong>树的深度或高度</strong>。图中所示的树的深度为4。</p></li><li><p><strong>有序树和无序树</strong>：如果将树中结点的各子树从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</p></li><li><p><strong>森林</strong>：是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。</p></li></ol><blockquote><p>树结构和线性结构的比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131122180.png"></p><h3 id="5-1-3-二叉树的定义"><a href="#5-1-3-二叉树的定义" class="headerlink" title="5.1.3 二叉树的定义"></a>5.1.3 二叉树的定义</h3><p>引入二叉树的原因：</p><ul><li><p>二叉树的结构最简单，规律性最强；</p></li><li><p>可以证明，所有树都能转为唯一对应的二叉树，不失一般性。</p></li></ul><p>二叉树是n(n≥0)个结点的有限集，它或者是空集(n&#x3D;0)，或者由一个根结点及<strong>两棵互不相交</strong>的分别称作这个根的左子树和右子树的二又树组成。</p><ol><li><p>每个结点最多有俩孩子，二叉树中不存在度大于2的结点。</p></li><li><p>子树有左右之分，其次序不能颠倒。</p></li><li><p>二叉树可以是空集合，根可以有空的左子树或空的右子树。</p></li></ol><p>二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。</p><p>需要注意的是：<strong>二叉树不是树的特殊情况，与树是两个概念</strong>。</p><p>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要区分，说明它是左子树，还是右子树。</p><p>树中当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</p><p>因此，考虑到二叉树的特点，思考：具有三个结点的二叉树可能有几种不同形态？普通树有几种不同形态？</p><p>二叉树有五种形态；树有两种形态：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123376.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123841.png"></p><blockquote><p>二叉树的5种基本形态</p></blockquote><p>二叉树的5种基本形态包括有：空二叉树、根和空的左右子树、根和左子树、根和右子树、根和左右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131124877.png"></p><p>似于二叉树，因此可以利用二叉树来表示表达式。</p><h2 id="5-3-树和二叉树的抽象数据类型定义"><a href="#5-3-树和二叉树的抽象数据类型定义" class="headerlink" title="5.3 树和二叉树的抽象数据类型定义"></a>5.3 树和二叉树的抽象数据类型定义</h2><p>根据树的结构定义，加上树的一组基本操作就构成了树的抽象数据类型定义。</p><pre><code class="hljs">ADT BinaryTree&#123;    // 数据对象D：    // 数据关系R：    // 基本操作P：&#125;ADT BinaryTree;</code></pre><h2 id="5-4-二叉树的性质和存储结构"><a href="#5-4-二叉树的性质和存储结构" class="headerlink" title="5.4 二叉树的性质和存储结构"></a>5.4 二叉树的性质和存储结构</h2><h3 id="5-4-1-二叉树的性质"><a href="#5-4-1-二叉树的性质" class="headerlink" title="5.4.1 二叉树的性质"></a>5.4.1 二叉树的性质</h3><p>性质1：在二叉树的第i层上至多有2^(i-1)个结点(i≥1)</p><p>性质2：深度为k的二叉树一共至多有2^k-1 个结点(k≥1)</p><p>性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 &#x3D; n2+1。即叶子结点的数目等于度为2的结点数为n2，再加1。</p><blockquote><p>两种特殊形式的二叉树</p></blockquote><ol><li><p>满二叉树</p><p> 满二叉树：深度为k且含有2^k-1个结点的二叉树。</p><p> 特点：</p><ul><li><p>每一层上的结点数都是最大结点数（即每层都满）</p></li><li><p>叶子节点全部在最底层。</p></li></ul><p> 对满二叉树结点位置进行编号，按照从根结点开始，自<strong>上而下，自左而右</strong>进行编号，可以发现每一结点位置都有元素。</p><p> 满二叉树在同样深度的二叉树中<strong>结点个数最多</strong>。</p><p> 满二叉树在同样深度的二叉树中<strong>叶子结点个数最多</strong>。</p></li><li><p>完全二叉树</p><p> 完全二叉树：深度为k的，有n个结点的二叉树，当且仅当其<strong>每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时</strong>，称之为完全二叉树。</p><p> 同理，在满二叉树中，从最后一个结点开始，<strong>连续去掉任意</strong>个结点，即是一棵完全二叉树。</p><p> 完全二叉树的特点是：</p><ul><li><p>叶子结点只可能在层次最大的两层上出现；</p></li><li><p>对任一结点，若其右分支下的子孙(即右子树)的最大层次为i，则其左分支下的子孙(左子树)的最大层次必为i或i+1。</p></li></ul></li></ol><p>性质4：具有n个结点的完全二叉树的深度为⌊log2n⌋ + 1。<br>注：⌊x⌋ 称作x的底，表示不大于x的最大整数</p><p>性质5：如果对一棵有n个结点的完全二叉树(其深度为⌊log2n⌋+ 1)的结点按层序编号(从第1层到第⌊log2n⌋+1层，每层从左到右)，则对任一结点i(1≤i≤n)，有：</p><ol><li><p>如果i&#x3D;1，则结点1是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点⌊i&#x2F;2⌋。</p></li><li><p>如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i。</p></li><li><p>如果2i+1&gt;n，则结点无右孩子；否则其右孩子是结点2i+1。</p></li></ol><p>性质5表明了完全二叉树中<strong>双亲结点编号与孩子结点编号</strong>之间的关系。</p><h3 id="5-4-2-二叉树的存储结构"><a href="#5-4-2-二叉树的存储结构" class="headerlink" title="5.4.2 二叉树的存储结构"></a>5.4.2 二叉树的存储结构</h3><p>二叉树的存储结构主要有顺序存储结构和链式存储结构，其中链式存储结构又分为二叉链表和三叉链表。</p><p>二叉树的顺序存储实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树顺序存储表示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br>Typedef TElemType SqBiTree[MAXSIZE];<br>SqBiTree bt;<br></code></pre></td></tr></table></figure><p>二叉树的顺序存储缺点：存储密度低，适合存储满二叉树和完全二叉树。</p><blockquote><p>二叉树的链式存储结构</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span>&#123;<br>    TElemType data;<br>    BiNode *lchild, *rchild;<br>&#125;BiNode, *BiTree;<br></code></pre></td></tr></table></figure><p>在n个结点的二叉表中，有n+1个空指针域。</p><p>三叉链表即在二叉链表的基础上增加一个指向父节点的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriNode</span>&#123;<br>    TElemType data;<br>    TriNode *lchild, *parent, *rchild;<br>&#125;TriNode, *TriTree;<br></code></pre></td></tr></table></figure><h2 id="5-5-遍历二叉树和线索二叉树"><a href="#5-5-遍历二叉树和线索二叉树" class="headerlink" title="5.5 遍历二叉树和线索二叉树"></a>5.5 遍历二叉树和线索二叉树</h2><h3 id="5-5-1-遍历二叉树"><a href="#5-5-1-遍历二叉树" class="headerlink" title="5.5.1 遍历二叉树"></a>5.5.1 遍历二叉树</h3><ul><li><p>遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。</p></li><li><p>遍历目的：得到树中所有结点的一个线性排列。</p></li><li><p>遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p></li><li><p>遍历方法：规定在先左后右的情况下，主要遍历方法有三种：先序遍历、中序遍历、后序遍历。</p></li></ul><ol><li>三种遍历方法描述如下：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131125028.png"></p><ol><li><p>先序遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>访问根节点；</p></li><li><p>先续遍历左子树；</p></li><li><p>先续遍历右子树。</p></li></ol></li><li><p>中序遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>中序遍历左子树；</p></li><li><p>访问根结点；</p></li><li><p>中序遍历右子树。</p></li></ol></li><li><p>后续遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>后续遍历左子树；</p></li><li><p>后续遍历右子树；</p></li><li><p>访问根结点。</p></li></ol></li><li><p>根据遍历顺序确定二叉树</p><ul><li><p>若二叉树中各结点的值均不同，则二叉树结点的先序序列、中序序列、后序列都是唯一的。</p></li><li><p>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树（一定要有中序序列）</p></li></ul><p> 例题：已知二叉树的先序和中序序列，构造出相应的二叉树：<strong>可以先由先序序列确定根，由中序确定左右子树</strong>。</p><p> 已知中序序列和后序序列，<strong>由后序遍历可知，根结点必在后续序列尾部</strong>。</p></li><li><p>遍历的算法实现——先序遍历</p><p> 二叉树先续遍历算法（递归）</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历算法实现——中序遍历</p><p> 二叉树中序遍历算法（递归）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>遍历算法实现——后序遍历</p><p> 二叉树后序遍历算法（递归）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li><p>遍历算法分析</p><ul><li><p>如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。</p></li><li><p>时间效率：O(n)；每个结点只访问一次</p></li><li><p>空间效率：O(n)；栈占用的最大辅助空间</p></li></ul></li><li><p>遍历二叉树的非递归算法</p><p> 中序遍历非递归算法：二叉树中序遍历的非递归算法的关键在于：<strong>在中序遍历过某节点的整个左子树后，如何找到该接点的根以及右子树</strong>。</p><p> 基本思想：</p><ul><li><p>建立一个空栈S，指针p指向根结点</p></li><li><p>申请一个结点空间q，用来存放栈顶弹出的元素。</p></li><li><p>当p非空或者栈S非空时，循环执行以下操作：</p><ul><li><p>如果p非空，则将p进栈，p指向该结点的左孩子；</p></li><li><p>如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。</p></li></ul></li></ul><p> 中序遍历非递归算法实现：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    BiTree p; <span class="hljs-built_in">InitStack</span>(S); p = T;<br>    <span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 不为空</span><br>            <span class="hljs-built_in">Push</span>(S, p);<br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">Pop</span>(S, q);<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%c&quot;</span>, q-&gt;data);<br>            p = q-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。</code></pre><ol start="8"><li><p>二叉树的层次遍历</p><p> 对于一颗二叉树，从根结点开始，按<strong>从上到下、从左到右</strong>的顺序访问每一个结点。每一个结点仅仅访问一次。</p><p> 算法思路：</p><ul><li><p>将根结点入队；</p></li><li><p>队不为空时循环：从队列中出列一个结点*p，访问它：</p><ul><li><p>若它右左孩子结点，将左孩子结点入队；</p></li><li><p>若它有右孩子结点，将右孩子结点入队。</p></li></ul></li></ul><p> 二叉树层次遍历算法实现：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    BTNode data[MaxSize];   <span class="hljs-comment">// 存放队中元素</span><br>    <span class="hljs-type">int</span> front, rear;        <span class="hljs-comment">// 队头和队尾指针</span><br>&#125;SqQueue;   <span class="hljs-comment">// 顺序循环队列类型</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BTNode *b)</span></span>&#123;<br>    BTNode* p;<br>    SqQueue* qu;<br>    <span class="hljs-built_in">InitQueue</span>(sqQueue); <span class="hljs-comment">// 初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(qu, b);     <span class="hljs-comment">// 根结点指针入队</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;<br>        <span class="hljs-comment">// 队不为空，则循环</span><br>        <span class="hljs-built_in">deQueue</span>(qu, p); <span class="hljs-comment">// 出队结点p</span><br>        cout &lt;&lt; p-&gt;data;<br>        <span class="hljs-keyword">if</span>(p-&gt;lchild != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 有左孩子时将其入队</span><br>            <span class="hljs-built_in">enQueue</span>(qu, p-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;rchild != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 有右孩子时将其入队</span><br>            <span class="hljs-built_in">enQueue</span>(qi, p-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li><p>二叉树遍历算法的应用——二叉树的建立(算法5.3)</p><p> 按照先续遍历序列建立二叉树的二叉链表</p><p> 算法步骤：</p><ul><li><p>扫描字符序列，读入字符，建立二叉树的存储结构；</p></li><li><p>如果ch是一个”#”字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：在建立二叉树的过程中按照二叉树先序方式建立：</p><ul><li><p>申请一个结点空间T；</p></li><li><p>将ch赋给T-&gt;data；</p></li><li><p>递归创建T的左子树</p></li><li><p>递归创建T的右子树</p></li></ul></li></ul><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree&amp; T)</span></span>&#123;<br>    <span class="hljs-comment">// 按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span><br>    cin &gt;&gt; ch;<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&quot;#&quot;</span>) T = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 递归结束，建空树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 递归创建二叉树</span><br>        T = <span class="hljs-keyword">new</span> BiTree; <span class="hljs-comment">// 生成根结点</span><br>        T-&gt;data = ch;   <span class="hljs-comment">// 根结点数据域置为ch</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<span class="hljs-comment">// 递归创建左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<span class="hljs-comment">// 递归创建右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——复制二叉树(算法5.4)</p><p>算法步骤：</p><p>如果是空树，递归结束，否则执行以下操作：</p><ul><li><p>申请一个新结点空间， 复制根结点；</p></li><li><p>递归复制左子树；</p></li><li><p>递归复制右子树。</p></li></ul><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Copy</span><span class="hljs-params">(BiTree T, BiTree&amp; NewT)</span></span>&#123;<br>    <span class="hljs-comment">// 复制一棵和T完全相同的二叉树</span><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 如果是空树，递归结束</span><br>        newT = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        newT = <span class="hljs-keyword">new</span> BoTree;<br>        newT-&gt;data = T-&gt;data;<span class="hljs-comment">// 复制根结点</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;lchild, newT-&gt;lchild);<span class="hljs-comment">// 递归复制左子树</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;rchild, newT-&gt;rchild);<span class="hljs-comment">// 递归复制左子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——计算二叉树的深度(算法5.5)</p><p>如果是空树，递归结束，深度为0，否则执行以下操作：</p><ul><li><p>递归计算左子树的深度记为m；</p></li><li><p>递归计算右子树的深度记为n;</p></li><li><p>如果m大于n，二叉树的深度为m+1，否则为n+1。</p></li></ul><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-comment">// 计算二叉树T的深度</span><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m = <span class="hljs-built_in">Depth</span>(T-&gt;lchild);   <span class="hljs-comment">// 递归计算左子树的深度记为m</span><br>        n = <span class="hljs-built_in">Depth</span>(T-&gt;rchild);   <span class="hljs-comment">// 递归计算右子树的深度记为n</span><br>        <span class="hljs-keyword">if</span>(m &gt; n) <span class="hljs-keyword">return</span>(m+<span class="hljs-number">1</span>);  <span class="hljs-comment">// 二叉树深度为m与n的较大者加1</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">return</span> (n+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。</p></li><li><p>二叉树遍历算法的应用——统计二叉树结点的个数(算法5.6)</p><p>如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上1。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NodeCount</span>(T-&gt;lchild) + <span class="hljs-built_in">NodeCount</span>(T-&gt;rchild) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——统计二叉树叶子结点的个数(补充算法)</p><p>如果是空树，则结点个数为0；否则，结点个数为左子树的叶子结点个数加上右子树的叶子结点个数再加上1。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeafCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-comment">// 如果是叶子节点返回1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCount</span>(T-&gt;lchild) + <span class="hljs-built_in">LeafCount</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-2-线索二叉树"><a href="#5-5-2-线索二叉树" class="headerlink" title="5.5.2 线索二叉树"></a>5.5.2 线索二叉树</h3><ol><li><p>线索二叉树的基本概念</p><p> 遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。</p><p> 但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点<strong>在任一序列中的前驱和后继信息</strong>，这种信息只有在遍历的动态过程中才能得到，为此<strong>引入线索二叉树来保存这些在动态过程中得到的（任一序列中的）有关前驱和后继的信息</strong>。</p><p> 由于有n个结点的二叉链表中必定存在n+1个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息。可做如下规定：若结点有左子树，则其lchild域指示其左孩子，<strong>否则令lchild域指示其前驱</strong>；若结点有右子树，则其rchild域指示其右孩子，<strong>否则令rchild域指示其后继</strong>。同时，为了避免混淆，尚需改变结点结构，增加两个标志域：LTag和RTag，其中标志位为0表示存储的为左&#x2F;右孩子，为1表示存储的为前驱&#x2F;后继。</p><p> 这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树(Threaded Binary Tree)，对二叉树按某种遍历次序使其变为线索二叉树的过程叫<strong>线索化</strong>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树的二叉线索存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span><br>&#123;<br>    TElemType data;<br>    BiThrNode *lchild, *rchild;<br>    <span class="hljs-type">int</span> LTag, RTag;<br>&#125;BiThrNode, *BiThrTree;<br></code></pre></td></tr></table></figure><p> 以下为先序线索二叉树、中序线索二叉树、后序线索二叉树示意图。</p></li></ol><ul><li><p>先序线索二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131126344.png"></p></li><li><p>中序线索二叉树</p></li><li><p>后序线索二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127045.png"></p></li></ul><p>为了方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其<strong>lchild域的指针指向二叉树的根结点</strong>，其<strong>rchild域的指针指向遍历遍历时访问的最后一个结点</strong>；同时，<strong>令二叉树遍历序列中第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点</strong>。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。</p><pre><code class="hljs">即其中LTag = 0，lchild指向根结点；RTag = 1，rchild指向遍历序列中最后一个结点。</code></pre><ol start="2"><li><p>构造线索二叉树</p><p> TODO</p></li></ol><h2 id="5-6-树和森林"><a href="#5-6-树和森林" class="headerlink" title="5.6 树和森林"></a>5.6 树和森林</h2><p>树(Tree)是n(n≥0)个结点的有限集。若n&#x3D;0，称为空树。</p><p>若n&gt;0，当有且仅有一个特定的称为根(root)的结点；其余结点可分为m(m≥0)个互不相交的有限集T1，T2，T3，…，Tm</p><p>森林是m(m≥0)个互不相交的树的集合。</p><h3 id="5-6-1-树的存储结构"><a href="#5-6-1-树的存储结构" class="headerlink" title="5.6.1 树的存储结构"></a>5.6.1 树的存储结构</h3><ol><li><p>双亲表示法</p><p> 这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。</p></li></ol><ul><li>树的双亲表示法<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127885.png"></li></ul><p>双亲表示法特点：找双亲结点容易，找孩子结点难。</p><p>类型描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>    TElemType data;<br>    <span class="hljs-type">int</span> parent; <span class="hljs-comment">// parent结点位置</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTree</span>&#123;<br>    PTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> r, n;   <span class="hljs-comment">// 根结点的位置和节点个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>孩子表示法</p><p> 把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。</p><p> 特点：找孩子容易，找双亲难。</p><p> 类型描述：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 孩子结点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    CTNode* next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> CTNode *ChildPtr;<br><span class="hljs-comment">// 双亲结点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTBox</span>&#123;<br>    TElemType data;<br>    ChildPtr firstChild;    <span class="hljs-comment">// 孩子链表头指针</span><br>&#125;<br><span class="hljs-comment">// 树结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTree</span>&#123;<br>    CTBox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> n, r;<br>&#125;;<br></code></pre></td></tr></table></figure><pre><code class="hljs">可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起，称为带双亲的孩子链表。</code></pre><ol start="3"><li><p>孩子兄弟表示法(二叉树表示法、二叉链表表示法)</p><p> 又称二叉树表示法，或<strong>二叉链表表示法</strong>，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的<strong>第一个孩子结点</strong>和<strong>下一个兄弟结点</strong>，分别命名为firstchild域和nextsibling域。</p><p>  类型描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>&#123;<br>    ElemType data;<br>    CSNode *firstChild, *nextsibling;<br>&#125;;<br><span class="hljs-keyword">typedef</span> CSNode *CSTree;<br></code></pre></td></tr></table></figure><p> 这种存储结构的优点是它和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树的算法来实现对树的操作。因此孩子兄弟表示法是应用较为普遍的一种树的存储表示方法。</p></li></ol><h3 id="5-6-2-森林与二叉树的转换"><a href="#5-6-2-森林与二叉树的转换" class="headerlink" title="5.6.2 森林与二叉树的转换"></a>5.6.2 森林与二叉树的转换</h3><ul><li><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操T。</p></li><li><p>由于树和二叉树都可以用二叉链表作存储结构，则<strong>以二叉链表作媒介</strong>可以导出树与二叉树之间的一个对应关系。</p></li></ul><p>给定一棵树，可以找到唯一的以可二叉树与之对应。这个一一对应的关系说明<strong>森林或树与二叉树可以相互转换</strong>。</p><ol><li><p>将树转换为二叉树</p><ol><li><p>加线：在兄弟之间加一连线；</p></li><li><p>抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系；</p></li><li><p>旋转：以树的根结点为轴心，将整树顺时针转45°</p></li></ol><p> 树变二叉树：<strong>兄弟相连留长子</strong></p></li><li><p>将二叉树转换为树</p><ol><li><p>加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子……沿分支找到的所有右孩子，都p的双亲用线连起来；</p></li><li><p>抹线：抹掉原二叉树中双亲与右孩子之间的连线；</p></li><li><p>调整：将结点按层次排列，形成树结构</p></li></ol><p> 二叉树变树：<strong>左孩右右连双亲，去掉原来右孩线</strong></p></li><li><p>森林转换称二叉树</p><ol><li><p>将各棵树分别转换成二叉树</p></li><li><p>将每棵树的根结点用线相连</p></li><li><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p></li></ol><p> 森林变二叉树：<strong>树变二叉根相连</strong></p></li><li><p>二叉树转换成森林</p><ol><li><p>抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树；</p></li><li><p>还原：将孤立的二叉树还原成树</p></li></ol><p> 二叉树变森林：<strong>去掉全部右孩线，孤立二叉再还原</strong>。</p></li></ol><h3 id="5-6-3-树和森林的遍历"><a href="#5-6-3-树和森林的遍历" class="headerlink" title="5.6.3 树和森林的遍历"></a>5.6.3 树和森林的遍历</h3><ol><li><p>树的遍历（三种方式）</p><ol><li><p>先根(次序)遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。</p></li><li><p>后根(次序)遍历：若树不空，则先依次后根遍历各棵子树，然后再访问根结点。</p></li><li><p>层次遍历：若树不空，则自上而下自左至右访问树中每个结点。</p></li></ol></li><li><p>森林的遍历</p><p> 将森林看作由三部分构成：1、森林中第一棵树的根结点；2.森林中第一棵树的子树森林；3.森林中其它树构成的森林。</p><ol><li><p>先序遍历</p><p> 若森林不为空，则</p><ol><li><p><strong>访问森林中第一棵树的根结点</strong>；</p></li><li><p>先序遍历森林中第一棵树的子树森林；</p></li><li><p>先序遍历森林中（除第一棵树之外）其余树构成的森林。</p></li></ol></li><li><p>中序遍历</p><p> 若森林不为空，则</p><ol><li><p>中序遍历森林中第一棵树的子树森林；</p></li><li><p>访问森林中第一棵树的根结点；</p></li><li><p>中序遍历森林中（除第一棵树之外）其余树构成的森林。</p></li></ol></li></ol></li></ol><h2 id="5-7-哈夫曼树及其应用"><a href="#5-7-哈夫曼树及其应用" class="headerlink" title="5.7 哈夫曼树及其应用"></a>5.7 哈夫曼树及其应用</h2><h3 id="5-7-1-哈夫曼树的基本概念"><a href="#5-7-1-哈夫曼树的基本概念" class="headerlink" title="5.7.1 哈夫曼树的基本概念"></a>5.7.1 哈夫曼树的基本概念</h3><p>哈夫曼(Huffman)树又称<strong>最优树，是一类带权路径长度最短的树</strong>，哈夫曼树的定义，涉及路径、路径长度、权等概念。</p><ul><li><p><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。</p></li><li><p><strong>路径长度</strong>：路径上的<strong>分支数目</strong>称作路径长度。</p></li><li><p><strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。</p><p>  在结点数目相同的二叉树中，<strong>完全二叉树的路径长度最短的二叉树</strong>。但路径长度最短的二叉树不一定就是完全二叉树。</p></li><li><p><strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有<strong>结点权和边权</strong>。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。</p></li><li><p><strong>结点的带权路径长度</strong>：从该结点到树 根之间的<strong>路径长度与结点上权的乘积</strong>。</p></li><li><p><strong>树的带权路径长度</strong>：树中所有<strong>叶子结点</strong>的带权路径长度之和，通常记作WPL。</p></li><li><p><strong>哈夫曼树</strong>：假设有m个权值{w1, W2,…,Wm}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为W；则其中<strong>带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树</strong>。</p></li></ul><p>带权路径最短的树，比较的前提是所有树的度相同，即树的各结点度的最大值，即结点拥有的子树数。</p><p><strong>满二叉树不一定是曼哈夫树</strong>，哈夫曼树中权越大的叶子离根越近，具有相同带权结点的哈夫曼树不唯一。</p><h3 id="5-7-2-哈夫曼树的构造算法"><a href="#5-7-2-哈夫曼树的构造算法" class="headerlink" title="5.7.2 哈夫曼树的构造算法"></a>5.7.2 哈夫曼树的构造算法</h3><ol><li><p>哈夫曼树的构造过程</p><p> 在构造哈夫曼树时，<strong>首先选择权小的</strong>，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的<strong>贪心法</strong>。</p><ol><li><p>根据给定的n个权值{W1, W2, …, Wn}，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。<strong>构造森林全是根</strong>。</p></li><li><p>在森林F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。<strong>选用两小造新树</strong>。</p></li><li><p>在森林F中删除这两棵树，同时将新得到的二叉树加入F中。<strong>删除两小添新人</strong>。</p></li><li><p>重复（2）和（3），直到F只含一棵树为止。这棵树便是哈夫曼树。<strong>重复2、3剩单根</strong>。</p></li></ol><p> 特点：</p><p> 包含n棵树的森林要经过n-1次合并才能形成哈去曼树，共产生n-1新结点，且这n-1个新结点都是具有两个孩子的分支结点。。</p><ul><li><p><strong>包含n个叶子结点的哈夫曼树中共有2n-1个结点</strong>。</p></li><li><p><strong>哈夫曼树的结点的度数为0或2，没有度为1的结点</strong>。</p></li></ul></li><li><p>哈夫曼算法的实现</p><p> 哈夫曼树是一种二叉树，由于哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n-1个结点，可以存储在一个大小为2n-1的一维数组中。树中每个结点还要包含其<strong>双亲信息</strong>和<strong>孩子结点的信息</strong>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> parent, lch, rch;<br>&#125;HTNode, *HuffmanTree;<br></code></pre></td></tr></table></figure><p> 哈夫曼树中共有2n-1个结点不使用0下标，数组大小为2n。将叶子结点集中存储在前面部分1~n个位置，而后面的n-1个位置存储其余非叶子结点。</p><blockquote><p>构造哈夫曼树——算法5.10</p></blockquote><p> 构造哈夫曼树算法的实现可以分成两大部分。</p><ol><li><p>初始化：首先动态申请2n个单元；然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0；最后再循环n次，输入前n个单元中叶子结点的权值。</p></li><li><p>创建树：循环n-1次，通过n-1次的选择、删除与合并来创建哈夫曼树。</p><ul><li><p>选择是从当前森林中选择双亲为0且权值最小的两个树根结点s1和s2；</p></li><li><p>删除是指将结点s1和s2的双亲改为非0；</p></li><li><p>合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个新结点左孩子的下标为s1，右孩子的下标为s2。</p></li></ul></li></ol><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanTree</span><span class="hljs-params">(HuffmanTree HT, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;<br>    HT = <span class="hljs-keyword">new</span> HTNode[m+<span class="hljs-number">1</span>];   <span class="hljs-comment">// 0号单元未用，</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-comment">// 将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0</span><br>        HT[i].lch = <span class="hljs-number">0</span>;<br>        HT[i].rch = <span class="hljs-number">0</span>;<br>        HT[i].parent = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-comment">// 输入前n个元素的weight值</span><br>        cin &gt;&gt; HT[i].weight;<br>    &#125;<br>    <span class="hljs-comment">/*－初始化工作结束，下面开始创建哈夫曼树－*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n+<span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-built_in">Select</span>(HT, i<span class="hljs-number">-1</span>, s1, s2);<br>        <span class="hljs-comment">// 在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点，并返回它们在HT中的序号s1和s2</span><br>        HT[s1].parent = i;<br>        HT[s2].parent = i;<br>        <span class="hljs-comment">// 得到新结点i，从森林中删除s1和s2，将s1和s2的双亲域由0改为i</span><br>        HT[i].lch = s1;<br>        HT[i].rch = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-7-3-哈夫曼编码"><a href="#5-7-3-哈夫曼编码" class="headerlink" title="5.7.3 哈夫曼编码"></a>5.7.3 哈夫曼编码</h3><p>在进行数据压缩时，为了使压缩后的数据文件尽可能短，可采用不定长编码。其基本思想是：为出现次数较多的字符编以较短的编码。为确保对数据文件进行有效的压缩和对压缩文件进行正确的解码，可以利用哈夫曼树来设计二进制编码。</p><p>关键：要设计长度不等的编码，则必须使<strong>任一字符的编码都不是另一个字符的编码的前缀</strong>。上述编码方式又称为前缀编码。</p><p>前缀编码：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。</p><p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p><p>哈夫曼编码的性质：</p><ol><li><p><strong>哈夫曼编码是前缀编码</strong>。</p></li><li><p><strong>哈夫曼编码是最优前缀编码</strong>。</p></li></ol><p>哈夫曼编码实现方法：</p><ol><li><p>统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）。</p></li><li><p>利用哈夫曼树的特点：权越大的叶子离根越近；<strong>将每个字符的概率值作为权值，构造哈夫曼树</strong>。则概率越大的结点，路径越短。</p></li><li><p>在哈夫曼树的每个分支上标上0或1：</p><ul><li><p>结点的左分支标0，右分支标1</p></li><li><p>把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。</p></li></ul></li></ol><p>两个问题：</p><ol><li><p>为什么哈夫曼编码能够保证是前缀编码？。</p><p> 因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p></li><li><p>为什么哈夫曼编码能够保证字符编码总长最短？</p><p> 因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</p></li></ol><blockquote><p>哈夫曼编码的算法实现</p></blockquote><p>在构造哈夫曼树之后，求哈夫曼编码的主要思想是：<strong>依次以叶子为出发点，向上回溯至根结点为止</strong>。回溯时走左分支则生成代码0，走右分支则生成代码1。</p><p>算法步骤：</p><ol><li><p>分配存储n个字符编码的编码表空间HC，长度为n+1；分配临时存储每个字符编码的动态数组空间cd，cd[n-1]置为’\0’。</p></li><li><p>逐个求解n个字符的编码，循环n次，执行以下操作：</p><ul><li><p>设置变量start用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置n-1;</p></li><li><p>设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f用于记录i的双亲结点的下标；</p></li><li><p>从叶子结点向上回溯至根结点，求得字符i的编码，当f没有到达根结点时，循环执行以下操作：</p><ul><li><p>回溯一次start向前指一个位置，即–start;</p></li><li><p>若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在cd[start]中；</p></li><li><p>继续向上回溯，改变c和f的值。</p></li></ul></li><li><p>根据数组cd的字符串长度为第i个字符编码分配空间HC[i]，然后将数组cd中的编码复制到HC[i]中。</p></li></ul></li><li><p>释放临时空间cd。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanCode</span><span class="hljs-params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span><br>    HC = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>*[n+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 分配存储n个字符编码的编码表空间</span><br>    cd = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];           <span class="hljs-comment">// 分配临时存放每个字符编码的动态数组空间</span><br>    cd[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;             <span class="hljs-comment">// 编码结束符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 逐个字符求哈夫曼编码</span><br>    &#123;<br>        start = n<span class="hljs-number">-1</span>;            <span class="hljs-comment">// start开始时指向最后，即编码结束符位置</span><br>        c = i;<br>        f = HT[i].parent;       <span class="hljs-comment">// f指向结点c的双亲结点</span><br>        <span class="hljs-keyword">while</span>(f != <span class="hljs-number">0</span>)           <span class="hljs-comment">// 从叶子节点开始向上回溯，知道根结点</span><br>        &#123;<br>            --start;            <span class="hljs-comment">// 回溯一次start位置向前指一个位置</span><br>            <span class="hljs-keyword">if</span>(HT[f].lch == c)  <span class="hljs-comment">// 结点c是f的左孩子，则生成代码0</span><br>            &#123;<br>                cd[start] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// 结点c是f的右孩子，则生成代码1</span><br>            &#123;<br>                cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            &#125;<br>            c = f;<br>            f = HT[f].parent;   <span class="hljs-comment">// 继续向上回溯</span><br>        &#125;                       <span class="hljs-comment">// 求出第i个字符的编码</span><br>        HC[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n-start];  <span class="hljs-comment">// 为第i个字符编码分配空间</span><br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);<br>    &#125;<br>    <span class="hljs-keyword">delete</span> cd;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>文件的编码和译码</p></blockquote><ol><li><p>编码</p><p> 有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符c，在哈夫曼编码表HC中找到此字符，将字符c转换为编码表中存放的编码串。</p></li><li><p>译码</p><p> 对编码后的文件进行译码的过程必须借助于哈夫曼树。具体过程是：依次读入文件的二进制码，从哈夫曼树的根结点（即HT[m])出发，若当前读入0，则走向左孩子，否则走向右孩子。一旦到达某一叶子HT[i]时便译出相应的字符编码HC[i]。然后重新从根出发继续译码，直至文件结束。</p></li></ol><h2 id="5-8-案例分析与实现"><a href="#5-8-案例分析与实现" class="headerlink" title="5.8 案例分析与实现"></a>5.8 案例分析与实现</h2><h2 id="5-9-习题"><a href="#5-9-习题" class="headerlink" title="5.9 习题"></a>5.9 习题</h2><ol><li><p>利用二叉链表存储树， 则根结点的右指针()。</p><p> A. 指向最左孩子 B. 指向最右孩子 C. 为空 D. 非空</p><p> 解答：C，利用二叉链表存储树时，右指针指向兄弟结点，因为根节点没有兄弟结点，故根结点的右指针为空</p></li><li><p>一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足()。</p><p> A. 所有的结点均无左孩子 B. 所有的结点均无右孩子 C. 只有一个叶子结点 D. 是任意一棵二叉树</p><p> 解答：因为先序遍历结果是“中左右”， 序遍历结果是“左右中”，当没有左子树时，就是“中右”和“右中”；当没有右子树时，就是“中左”和“左中”。则所有的结点均无左孩子或所有的结点均无右孩子均可，所以A、B不能选，又所有的结点均无左孩子与所有的结点均无右孩子时，均只有一个叶子结点，故选C。</p></li><li><p>在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是( )</p><p> A．41 B．82 C．113 D．122</p><p> 解答：考查树结点数的特性。设树中度为i(i&#x3D;0，1，2，3，4)的结点数分别为Ni，树中结点总数为N，则树中各结点的度之和等于N-1，即N&#x3D;1+N1+2N2+3N3+4N4&#x3D;N0+N1+N2+N3+N4。根据题设中的数据，即可得到N0&#x3D;82，即树T的叶结点的个数是82。</p></li></ol><p>算法设计题：</p><ol><li><p>统计二叉树的叶结点个数。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>判别两棵树是否相等。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>交换二叉树每个结点的左孩子和右孩子。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>设计二叉树的双序遍历算法（双序遍历是指对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe4.cpp">算法设计题4</a></p></li><li><p>计算二叉树最大的宽度（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>用按层次顺序遍历二叉树的方法，统计树中度为1的结点数目。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li><li><p>求任意二叉树中第一条最长的路径长度，并输出此路径上各结点的值。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe7.cpp">算法设计题7</a></p></li><li><p>输出二叉树中从每个叶子结点到根结点的路径。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe8.cpp">算法设计题8</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串、数组和广义表——王卓</title>
    <link href="/2022/10/13/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-串、数组和广义表"><a href="#第4章-串、数组和广义表" class="headerlink" title="第4章 串、数组和广义表"></a>第4章 串、数组和广义表</h1><p>字符串一般简称为串。串是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说，<strong>串是一种内容受限的线性表</strong>。</p><p>本章后两部分讨论的多维数组和广义表可以看成是线性表的一种扩充，即线性表的数据元素自身又是一个数据结构。高级语言都支持数组，但在高级语言中，重点介绍数组的使用，而本章重点介绍数组的内部实现，并介绍对于一些特殊的二维数组如何实现压缩存储。最后介绍广义表的基本概念和存储结构。</p><h2 id="4-1-串的定义"><a href="#4-1-串的定义" class="headerlink" title="4.1 串的定义"></a>4.1 串的定义</h2><p><strong>串</strong>(string)(或字符串)是由零个或多个字符组成的有限序列，一般记为：s &#x3D; “a1a2 … an”。</p><p>其中，s是串的名，用双引号括起来的字符序列是串的值；ai(1≤i≤n)可以是字母、数字或其他字符；串中字符的数目n称为串的长度。零个字符的串称为<strong>空串</strong>(null string)，其长度为零。</p><blockquote><p>相关术语</p></blockquote><ul><li><p><strong>子串</strong>：一个串中任意个连续的字符组成的子序列(含空串)称为该串的子串。</p></li><li><p><strong>主串</strong>：包含子串的串相应地称为主串。</p></li><li><p><strong>字符位置</strong>：通常称字符在序列中的序号为该字符在串中的位置。</p></li><li><p><strong>子串的位置</strong>：子串的第一个字符在主串中的位置。</p></li><li><p><strong>空格串</strong>：一个或多个空格组成的串，与空串不同。</p></li><li><p><strong>串相等</strong>：当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。</p></li><li><p>所有的空串都是相等的。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301301652448.png"><br>最后一个位b在d中位置</p><h2 id="4-2-案例的引入"><a href="#4-2-案例的引入" class="headerlink" title="4.2 案例的引入"></a>4.2 案例的引入</h2><h2 id="4-3-串的类型定义、存储结构及其运算"><a href="#4-3-串的类型定义、存储结构及其运算" class="headerlink" title="4.3 串的类型定义、存储结构及其运算"></a>4.3 串的类型定义、存储结构及其运算</h2><h3 id="4-3-1-串的抽象类型定义"><a href="#4-3-1-串的抽象类型定义" class="headerlink" title="4.3.1 串的抽象类型定义"></a>4.3.1 串的抽象类型定义</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301301700866.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT string&#123;<br>    数据对象：<br>    数据关系：<br>    基本操作：<br>        <span class="hljs-number">1.</span> <span class="hljs-built_in">StrAssign</span>(&amp;T, chars);    <span class="hljs-comment">// 串赋值</span><br>        <span class="hljs-number">2.</span> <span class="hljs-built_in">StrCompare</span>(S, T);        <span class="hljs-comment">// 串比较</span><br>        <span class="hljs-number">3.</span> <span class="hljs-built_in">StrLenght</span>(S);            <span class="hljs-comment">// 求串长</span><br>        <span class="hljs-number">4.</span> <span class="hljs-built_in">Concat</span>(&amp;T, S1, S2);      <span class="hljs-comment">// 串连结</span><br>        <span class="hljs-number">5.</span> <span class="hljs-built_in">SubString</span>(&amp;Sub, S, pos, len);    <span class="hljs-comment">// 求子串</span><br>        <span class="hljs-number">6.</span> <span class="hljs-built_in">StrCopy</span>(&amp;T, S);          <span class="hljs-comment">// 串拷贝</span><br>        <span class="hljs-number">7.</span> <span class="hljs-built_in">StrEmpty</span>(S);             <span class="hljs-comment">// 串判空</span><br>        <span class="hljs-number">8.</span> <span class="hljs-built_in">ClearString</span>(&amp;S);         <span class="hljs-comment">// 清空串</span><br>        <span class="hljs-number">9.</span> <span class="hljs-built_in">Index</span>(S, T, pos);        <span class="hljs-comment">// 子串的位置</span><br>        <span class="hljs-number">10.</span> <span class="hljs-built_in">Replace</span>(&amp;S, T, V);      <span class="hljs-comment">// 串替换</span><br>        <span class="hljs-number">11.</span> <span class="hljs-built_in">StrInsert</span>(&amp;S, pos, T);  <span class="hljs-comment">// 子串插入</span><br>        <span class="hljs-number">12.</span> <span class="hljs-built_in">StrDelete</span>(&amp;S, pos, len);    <span class="hljs-comment">// 子串删除</span><br>        <span class="hljs-number">13.</span> <span class="hljs-built_in">DestoryString</span>(&amp;S);      <span class="hljs-comment">// 串销毁</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-串的存储结构"><a href="#4-3-2-串的存储结构" class="headerlink" title="4.3.2 串的存储结构"></a>4.3.2 串的存储结构</h3><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构：<strong>顺序存储和链式存储</strong>。</p><ol><li><p>串的顺序存储结构</p><p> 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SString</span>&#123;<br>    <span class="hljs-type">char</span> ch[MAXLEN+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length;<br>&#125;;<br></code></pre></td></tr></table></figure><p> 其中，MAXLEN表示串的最大长度，ch是存储字符串的一维数组，每个分量存储一个字符，length表示字符串的当前长度。其中，后面算法描述当中所用到的顺序存储的字符串都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用。</p></li><li><p>串的链式存储结构</p><p> 顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。</p></li></ol><ul><li>串值的链表存储方式<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131129962.png"></li></ul><p>如图(a)中所示，结点大小为4，图(b)，结点大小为1。</p><ul><li><p>串的链式存储结构——块链结构</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80    <span class="hljs-comment">// 块的大小可自由定义</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span>&#123;<br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    Chunk* next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LString</span>&#123;<br>    Chunk *head, *tail; <span class="hljs-comment">// 串的头指针和尾指针</span><br>    <span class="hljs-type">int</span> curlen; <span class="hljs-comment">// 串当前的长度</span><br>&#125;;  <span class="hljs-comment">// 字符串的块链结构</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-3-串的模式匹配算法"><a href="#4-3-3-串的模式匹配算法" class="headerlink" title="4.3.3 串的模式匹配算法"></a>4.3.3 串的模式匹配算法</h3><p>子串的定位运算通常称为串的<strong>模式匹配</strong>或<strong>串匹配</strong>。即算法目的：确定主串中所含子串（模式串）第一次出现得位置。</p><p>串的模式匹配设有两个字符串S和T，设S为主串，也称正文串；设T为子串，也称为模式。在主串S中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置。</p><p>算法种类包括有：BF算法、KMP算法。</p><ol><li><p>BF算法</p><p> Brute-Force简称BF算法，亦称简单匹配算法，采用穷举法的思路：从S的每一个字符开始依次与T的字符进行匹配。</p><blockquote><p>算法设计思想</p></blockquote><p> Index(S, T, pos)</p><ol><li><p>将主串的第pos个字符和模式串的第一个字符比较，</p><ul><li><p>若相等，继续逐个比较后续字符；</p></li><li><p>若不等，从主串的下一字符起，重新与模式串的第一个字符比较。</p></li></ul></li><li><p>直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。</p></li><li><p>否则，匹配失败，返回值0</p></li></ol><blockquote><p>算法4.1——BF算法描述</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString S, SString T)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= S.lenght &amp;&amp; j &lt;= T.length)&#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            ++j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 主串、子串指针回溯重新开始下一次匹配</span><br>            i = i - j + <span class="hljs-number">2</span>;<span class="hljs-comment">//可以看成（i-j+1）+1，i-j+1是把i退回到原来的位置，再加一移到后一个位置</span><br>            j = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt;= T.lenght) <span class="hljs-keyword">return</span> i - T.lenght;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 当m远小于n时，算法复杂度为O(n*m)，平均复杂度为O(nm&#x2F;2)。</p></li><li><p>KMP算法</p><p> KMP算法，利用已经部分匹配的结果而加快模式串的滑动速度，且主串S的指针i<strong>不必回溯</strong>！可提速到O(n+m)</p><p> 重点在于定义<code>next[j]</code>函数，表明当模式中第j个字符与主串中相应字符失配时，在模式中需要重新和主串中该字符进行比较的字符的位置。</p></li></ol><ul><li><p>next_j<br>  <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131135247.png"></p><blockquote><p>KMP算法</p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_KMP</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = pos, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; S.length &amp;&amp; j &lt; T.length)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || S.ch[i] == T.ch[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];    <span class="hljs-comment">// i不变，j后退</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt; T.length) <span class="hljs-keyword">return</span> i - T.length;   <span class="hljs-comment">// 匹配成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span>&amp; next[])</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; T.length)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || T.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            next[i] = j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>next计算</p></blockquote><p>  Next值就是字符串s的最长相同前缀和后缀子字符串的长度。</p><p>  默认第一个和第二个字符的next值为0、1。那么从第三个开始依次执行如下操作：</p><p>  找到<strong>当前要求next字符的前一个</strong>（称为这个字符），以它为标准，找到其next对应下标的字符（称为现在字符），<strong>和这个字符做比较</strong>。若相等，那么当前字符的next值就位此字符next<strong>加1</strong>；若不等，继续找现在字符next所指的下一个字符，还是和之前的字符比较，直到找到第一个位置为止，那么next为1。</p><blockquote><p>nextVal计算</p></blockquote><p>  NextVal值就是字符串s的的最长相同且满足后续字符不同的前缀和后缀子字符串的长度。</p><p>  在求出next的值的基础上，求nextval的方法其实很简单。默认第一个nextval的值是0，第二个字符如果和第一个字符相等，那么它的nextval的值就为0，不等就为1。之后遵循如下方法：</p><p>  <strong>找到当前要求nextval值的字符，看它的[next值]下标所指向的字符是否和它相等，相等那么nextval为当前所指下标的nextval值，不相等nextval的值就为本身字符的next值。</strong></p><p>  对next进行修正，改进：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_nextval</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span>&amp; nextval[])</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, nextval[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; T.lenght)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || T.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            ++j;<br>            <span class="hljs-keyword">if</span>(T.ch[i] != T.ch[j]) nextval[i] = j;<br>            <span class="hljs-keyword">else</span> nextval[i] = nextval[j];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = nextval[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-4-数组"><a href="#4-4-数组" class="headerlink" title="4.4 数组"></a>4.4 数组</h2><h3 id="4-4-1-数组定义和特点"><a href="#4-4-1-数组定义和特点" class="headerlink" title="4.4.1 数组定义和特点"></a>4.4.1 数组定义和特点</h3><p>数组：按一定格式排列起来的具有相同类型的数据元素的集合。</p><blockquote><p>一维数组</p></blockquote><p>一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。</p><p>一维数组的逻辑结构：线性结构。定长的线性表。</p><p>声明格式：<code>数据类型 变量名称[长度]</code>；</p><blockquote><p>二维数组</p></blockquote><p>二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组。</p><p>二维数组的逻辑结构：</p><ul><li><p>非线性结构：每一个数据元素既在一个行表中，又在一个列表中。</p></li><li><p>线性结构定长的线性表：该线性表的每个数据元素也是一个定长的线性表。</p></li></ul><p>声明格式：<code>数据类型 变量名称[行数][列数]</code>；</p><blockquote><p>多维数组</p></blockquote><p>三维数组：若二维数组中的元素又是一个一维数组，则称作三维数组。</p><p>n维数组：若n-1维数组中的元素又是一个一维数组结构，则称作n维数组。</p><p>结论：线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。</p><p>数组特点：<strong>结构固定</strong>，定义后，维数和维界不再改变。</p><p>数组基本操作：除了结构的初始化和销毁之外，只有<strong>取元素</strong>和<strong>修改元素值</strong>的操作。</p><h3 id="4-4-2-数组的抽象数据类型定义"><a href="#4-4-2-数组的抽象数据类型定义" class="headerlink" title="4.4.2 数组的抽象数据类型定义"></a>4.4.2 数组的抽象数据类型定义</h3><p>以二维数组为例，二维数组的抽象数据类型的数据对象和数据关系的定义：</p><p>n&#x3D;2（维数为2，二维数组）</p><p>b1：第1维长度（行数）</p><p>b2：第2维长度（列数）</p><p>aj1j2：第1维下标为j1，第2维下标为j2</p><h3 id="4-4-3-数组的顺序存储"><a href="#4-4-3-数组的顺序存储" class="headerlink" title="4.4.3 数组的顺序存储"></a>4.4.3 数组的顺序存储</h3><p>在数组存储过程中，数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。</p><p>针对二维数组，可以以行序为主序(C、PASCAL、JAVA、Basic)；也可以是列序为主序(FORTRAN)。</p><ul><li>n维数组元素地址<br> <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131133589.png"></li></ul><h3 id="4-4-4-特殊矩阵的压缩存储"><a href="#4-4-4-特殊矩阵的压缩存储" class="headerlink" title="4.4.4 特殊矩阵的压缩存储"></a>4.4.4 特殊矩阵的压缩存储</h3><p>矩阵的常规存储：将矩阵描述为一个二维数组。</p><p>矩阵的常规存储的特点：可以对其元素进行随机存取；矩阵运算非常简单；存储的密度为1。</p><p>但是对于不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多。特殊矩阵主要包括<strong>对称矩阵、三角矩阵和对角矩阵</strong>等，以及稀疏矩阵：矩阵中非零元素的个数较少（一般小于5%）</p><p>因此可以采用矩阵压缩存储：为多个相同的非零元素只分配一个存储空间，对零元素不分配空间。</p><ol><li><p>对称矩阵：</p><p> 特点：在nxn的矩阵a中，满足aij &#x3D; aji</p><p> 存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)&#x2F;2个元素空间。</p><p> 对称矩阵可以以行序为主序将元素存放在一个一维数组<code>sa[n(n+1)/2]</code>中，其中aij存放在(i*(i-1)&#x2F;2)+(j-1)位置。</p></li><li><p>三角矩阵</p><p> 特点：特点对角线以下（或者以上）的数据元素（不包括对角线全部为常数c。</p><p> 存储方法：重复元素c共享一个元素存储空间，共占用n(n+1)&#x2F;2+1个元素空间。</p></li><li><p>对角矩阵</p><p> 特点：在nxn的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p><p> 存储方法：可按某个原则（或以行为主，或以对角线的顺序）将其压缩存储到一维数组上。</p></li><li><p>稀疏矩阵存储</p><p> 稀疏矩阵：在mxn的矩阵中，有超过95%的元素位零，非零元素仅不到5%。</p><ul><li><p>三元组法：</p><p>  三元组顺序表，又称为<strong>有序的双下标法</strong></p><p>  压缩存储原则：可通过三元组法来表示稀疏矩阵，三元组：(i, j, aij)。即存各非零元素的值、行列位置和矩阵的行列数。</p><p>  其中，为更为可靠描述，通常会加上总体的描述信息：总行数、总列数、非零元素总个数。</p><p>  优点：非零元在表中按行序有序存储，因此<strong>便于进行依行顺序处理的矩阵运算</strong>。</p><p>  缺点：<strong>不能随机存取</strong>。若按行号存取某一行中的非零元，则需从头开始进行查找。</p></li><li><p>十字链表法</p><p>  稀疏矩阵的链式存储结构：</p><p>  优点：它能够<strong>灵活地插入</strong>因运算而产生的新的非零元素，<strong>删除</strong>因运算而产生的新的零元素，实现矩阵的各种运算。</p><p>  在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了(row, col, value)以外，还要有两个域：</p><ul><li><p>right：用于链接同一行中的下一个非零元素；</p></li><li><p>down：用以链接同一列中的下一个非零元素。</p></li></ul><p>  同时，为了方便元素查找，可为每一行、每一列添加头指针结点。</p></li></ul></li></ol><h2 id="4-5-广义表"><a href="#4-5-广义表" class="headerlink" title="4.5 广义表"></a>4.5 广义表</h2><h3 id="4-5-1-广义表的定义"><a href="#4-5-1-广义表的定义" class="headerlink" title="4.5.1 广义表的定义"></a>4.5.1 广义表的定义</h3><p>广义表是线性表的推广，也称为列表。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。</p><p>广义表(又称列表Lists)是n≥0个元素a0, a1, a2, …, an-1的有限序列，其中每一个ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。</p><p>广义表通常记作：LS&#x3D;(a1, a2, …, an)，其中：LS为表名，n为表的长度，每一个元素ai为表的元素。</p><p>习惯上，一般用大写字母表示广义表，小写字母表示原子。</p><p>表头：若LS非空，则第一个元素a1就是表头，记作head(LS)&#x3D;a1。其中，表头可以是原子，也可以是子表。</p><p>表尾：除表头外的其他元素组成的表。记作tail(LS) &#x3D; (a2,…,an)。其中表尾不是一个元素，而实一个子表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">A = ()  <span class="hljs-comment">// 空表，长度为零</span><br>B = (())    <span class="hljs-comment">// 长度为1，表头、表尾均为()</span><br>C = (a, (b, c)) <span class="hljs-comment">// 长度为2，由原子a和子表(b,c)构成，表头为a；表尾为((b, c))</span><br>D = (x, y, z)   <span class="hljs-comment">// 长度为3，每一项都是原子，表头为x，表尾为(y, z)</span><br>E = (C, D)  <span class="hljs-comment">// 长度为2，每一项都是子表，表头为C，表尾为(D)</span><br>F = (a, F)  <span class="hljs-comment">// 长度为2，第一项为原子，第二项为本身。表头为a；表尾为(F)</span><br></code></pre></td></tr></table></figure><blockquote><p>广义表的性质</p></blockquote><ol><li><p>广义表中的数据元素有相对次序；一个直接前驱和一个直接后继</p></li><li><p><strong>广义表的长度</strong>:定义为最外层所包含元素的个数；</p></li><li><p><strong>广义表的深度</strong>:定义为该广义表展开后所含括号的重数；其中，原子的深度为0，空表的深度为1。A&#x3D;(b,c)的深度为1，B&#x3D;(A,d)的深度为2，C&#x3D;（f，b，h）的深度为3</p></li><li><p>广义表可以为其他广义表共享；</p></li><li><p>广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302011349375.png"></p></li><li><p>广义表是一个多层次的结构，可以用图形象地表示。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302011350760.png"></p></li></ol><blockquote><p>广义表与线性表的区别</p></blockquote><p><strong>广义表可以看成是线性表的推广，线性表是广义表的特例</strong>。</p><p>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</p><p><strong>当二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表</strong>。</p><p>另外，树和有向图也可以用广义表来表示。由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。</p><blockquote><p>广义表的运算</p></blockquote><ol><li><p>取表头GetHead(LS): 取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表。</p></li><li><p>取表尾GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。即<strong>表尾一定是一个广义表</strong>。</p></li></ol><h3 id="4-5-2-广义表的存储"><a href="#4-5-2-广义表的存储" class="headerlink" title="4.5.2 广义表的存储"></a>4.5.2 广义表的存储</h3><p>由 于广义表中的数据元素可以有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构。常用的链式存储结构有两种，<strong>头尾链表的存储结构</strong>和<strong>扩展线性链表的存储结构</strong>。</p><h2 id="4-6-案例分析与实现"><a href="#4-6-案例分析与实现" class="headerlink" title="4.6 案例分析与实现"></a>4.6 案例分析与实现</h2><h2 id="4-7-习题"><a href="#4-7-习题" class="headerlink" title="4.7 习题"></a>4.7 习题</h2><blockquote><p>算法设计题</p></blockquote><ol><li><p>写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符为A<del>Z这26个字母和0</del>9这10个数字）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>写一个递归算法来实现字符串逆序存储，要求不另设串存储空间。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>编写算法，实现下面函数的功能。函数<code>void insert(char*s, char* t, int pos)</code>将字符串t插入到字符串s中，插入位置为pos。假设分配给字符串s的空间足够让字符串t插入。（说明：不得使用任何库函数）</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>已知字符串S1中存放一段英文，写出算法format(s1, s2, s3, n)，将其按给定的长度n格式化成两端对齐的字符串S2，其多余的字符送S3。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe4.cpp">算法设计题4</a></p></li><li><p>设二维数组a[1…m, l…n]含有m x n个整数。</p><ol><li><p>写一个算法判断a中所有元素是否互不相同？输出相关信息(yes&#x2F;no);</p></li><li><p>试分析算法的时间复杂度。</p></li></ol><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>设任意n个整数存放于数组A[1..n]中，试编写算法，将所有正数排在所有负数前面(要求：算法时间复杂度为O(n))。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列——王卓</title>
    <link href="/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><p>栈和队列是两种重要的线性结构。从数据结构角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为<strong>限定性的数据结构</strong>。但从数据类型角度看，它们是和线性表不相同的两类重要的抽象数据类型。</p><h2 id="3-1-栈和队列的定义和特点"><a href="#3-1-栈和队列的定义和特点" class="headerlink" title="3.1 栈和队列的定义和特点"></a>3.1 栈和队列的定义和特点</h2><h3 id="3-1-1-栈的定义和特点"><a href="#3-1-1-栈的定义和特点" class="headerlink" title="3.1.1 栈的定义和特点"></a>3.1.1 栈的定义和特点</h3><p><strong>栈</strong>(<strong>stack</strong>)是限定仅在<strong>表尾进行插入或删除</strong>操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为<strong>栈顶</strong>(<strong>top</strong>)，相应地，表头端称为<strong>栈底</strong>(<strong>bottom</strong>)。不含元素的空表称为<strong>空栈</strong>。</p><p>栈的修改是按后进先出的原则进行的，因此，栈又称为<strong>后进先出</strong>(Last In First Out, LIFO)的线性表。</p><blockquote><p>栈与一般线性表的区别</p></blockquote><p>栈与一般线性表的区别：<strong>仅存在运算规则不同</strong>。</p><p>|一般线性表|栈|<br>|:—|:—:|:—:|<br>|逻辑结构|一对一|一对一|<br>|存储结构|顺序表、链表|顺序表、链表|<br>|运算规则|随机存取|后进先出(LIFO)|</p><h3 id="3-1-2-队列的定义和特点"><a href="#3-1-2-队列的定义和特点" class="headerlink" title="3.1.2 队列的定义和特点"></a>3.1.2 队列的定义和特点</h3><p><strong>队列</strong>(<strong>queue</strong>)是一种<strong>先进先出</strong>(<strong>First In First Out, FIFO</strong>)的线性表。它只允许在表的一端进行插入，而在另一端删除元素。</p><p>在队列中，允许插入的一端称为<strong>队尾</strong>(<strong>rear</strong>)，允许删除的一端则称为<strong>队头</strong>(<strong>front</strong>)。</p><h2 id="3-2-案例引入"><a href="#3-2-案例引入" class="headerlink" title="3.2 案例引入"></a>3.2 案例引入</h2><h3 id="案例3-1-进制转换"><a href="#案例3-1-进制转换" class="headerlink" title="案例3.1 进制转换"></a>案例3.1 进制转换</h3><ul><li>进制转换</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131135382.png"></p><h3 id="案例3-2-括号匹配的检验"><a href="#案例3-2-括号匹配的检验" class="headerlink" title="案例3.2 括号匹配的检验"></a>案例3.2 括号匹配的检验</h3><ul><li><p>假设表达式中允许包含两种括号：圆括号和方括号</p></li><li><p>其嵌套的顺序随意，即：</p><ol><li><p>([ ] ( ))或[ ( [ ] [ ] ) ]为正确格式；</p></li><li><p>[ ( ] )为错误格式；</p></li><li><p>( [ () )或(()])为错误格式。</p></li></ol></li><li><p>括号匹配<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131136898.png"></p></li></ul><h3 id="案例3-3-表达式求值"><a href="#案例3-3-表达式求值" class="headerlink" title="案例3.3 表达式求值"></a>案例3.3 表达式求值</h3><ul><li><p>表达式求值是程序设计语言编译中一个最基本的问题，它的实现需要运用栈。</p></li><li><p>这里介绍的算法是由运算符优先级确定运算顺序的对表达式求值算法——算符优先算法。</p></li><li><p>表达式的组成</p><ul><li><p>操作数(operand)：常数、变量。</p></li><li><p>运算符(operator)：算术运算符、关系运算符和逻辑运算符。</p></li><li><p>界限符(delimiter)：左右括弧和表达式结束符。</p></li></ul></li><li><p>任何一个算术表达式都由<strong>操作数</strong>(常数、变量)、算术<strong>运算符</strong>(+、-、* 、&#x2F;)和界限符(括号、表达式结束符’#’、虚设的表达式起始符’#’)组成。后两者统称为算符。</p></li><li><p>为了实现表达式求值。需要设置两个栈：</p><p>  一个是算符栈OPTR，用于寄存运算符。</p><p>  另一个称为操作数栈OPND，用于寄存运算数和运算结果。</p></li><li><p>求值的处理过程是自左至右扫描表达式的每一个字符</p><ul><li><p>当扫描到的是运算数，则将其压入栈OPND，</p></li><li><p>当扫描到的是运算符时</p><ul><li><p>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTR，继续向后处理</p></li><li><p>若这个运算符比OPTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从栈OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND。</p></li></ul></li><li><p>继续处理当前字符，直到遇到结束符为止。</p></li></ul></li></ul><h3 id="案例3-4-舞伴问题"><a href="#案例3-4-舞伴问题" class="headerlink" title="案例3.4 舞伴问题"></a>案例3.4 舞伴问题</h3><p>假设在舞会上，男士和女士各自排成一队。舞会开始时，依次从男队和女队的队买务出一人配成舞伴。如果两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一算法模拟上述舞伴配对问题。</p><p>显然，先入队的男士或女士先出队配成舞。因此该问题具有典型的先进先出特性，可以用队列作为算法的数据结构。</p><ul><li><p>首先构造两个队列</p></li><li><p>依次将从男元素出队配成舞伴</p></li><li><p>某队为空，则另外一队等待着则是下一舞曲第一个可获得舞伴的人。</p></li></ul><h2 id="3-3-栈的表示和操作的实现"><a href="#3-3-栈的表示和操作的实现" class="headerlink" title="3.3 栈的表示和操作的实现"></a>3.3 栈的表示和操作的实现</h2><h3 id="3-3-1-栈的抽象数据类型的类型定义"><a href="#3-3-1-栈的抽象数据类型的类型定义" class="headerlink" title="3.3.1 栈的抽象数据类型的类型定义"></a>3.3.1 栈的抽象数据类型的类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT Stack&#123;<br>数据对象：<br>    D = &#123;ai | ai ∈ ElemSet, i = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n, n≥<span class="hljs-number">0</span>&#125;<br>数据关系：<br>    R1 = &#123;&lt;ai<span class="hljs-number">-1</span>, ai&gt; | ai<span class="hljs-number">-1</span>, ai∈D, i = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n&#125;<br>    约定an端为栈顶，a1端为栈底<br>基本操作：<br>    初始化、进栈、出栈、取栈顶元素等<br>&#125;ADT Stack<br></code></pre></td></tr></table></figure><ul><li>栈的基本操作<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131137111.png"></li></ul><h3 id="3-3-2-顺序栈的表示和实现"><a href="#3-3-2-顺序栈的表示和实现" class="headerlink" title="3.3.2 顺序栈的表示和实现"></a>3.3.2 顺序栈的表示和实现</h3><p>存储方式：同一般线性表的顺序存储结构完全相同，<strong>利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素</strong>。栈底一般在低地址端。</p><ul><li><p>附设<strong>top指针</strong>，指示栈顶元素在顺序栈中的位置。</p></li><li><p>另设<strong>base指针</strong>，指示栈底元素在顺序栈中的位置。</p></li><li><p>用stacksize表示栈可使用的最大容量。</p></li></ul><p>但是，为了方便操作，通常top指示真正的<strong>栈顶元素之上</strong>的下标地址。</p><p>空栈：base &#x3D;&#x3D; top是栈空标志</p><p>栈满：top - base &#x3D;&#x3D; stacksize</p><ul><li><p>栈满时的处理方法：</p><ol><li><p>报错，返回操作系统</p></li><li><p>分配更大的空间，作为栈的存储空间，将原栈的内容移入新栈</p></li></ol></li></ul><p>使用数组作为顺序栈存储方式的特点：简单、方便、但易产生溢出（数组大小固定）</p><ul><li><p>上溢(overflow)：栈已经满，又要压入元素</p></li><li><p>下溢(underflow)：栈已经空，还要弹出元素</p></li></ul><p>注：上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题处理结束。</p><blockquote><p>顺序栈的表示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqStack</span>&#123;<br>    SElemType *base;    <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;     <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;      <span class="hljs-comment">// 栈可用最大容量</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.1 顺序栈的初始化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造一个空栈</span><br><span class="hljs-function">State <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    S.base = <span class="hljs-keyword">new</span> SElemType[MAXSIZE];<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>    S.top = S.base; <span class="hljs-comment">// 栈顶指针等于栈底指针</span><br>    S.stacksize = MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1 判断顺序栈是否为空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 若栈为空，返回TRUE；否则返回FALSE</span><br><span class="hljs-function">State <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == S.base)<br>        <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法2 求顺序栈的长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> S.top - S.base;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3 清空顺序栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base) S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法4 销毁顺序栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base)&#123;<br>        <span class="hljs-keyword">delete</span> S.base;<br>        S.stacksize = <span class="hljs-number">0</span>;<br>        S.base = S.top = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.2 顺序栈的入栈</p></blockquote><ul><li><p>步骤：</p><ol><li><p>判断是否栈满，若满则出错</p></li><li><p>元素e压入栈顶</p></li><li><p>栈顶指针加1</p></li></ol></li></ul><p><strong>先压入元素，再移动栈顶指针，为什么？</strong><br>我的理解是，你得先通过top指针找到你要把元素压入哪个位置，然后再把top指针上移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top - S.base == S.stacksize)   <span class="hljs-comment">// 栈满</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    *S.top = e;<br>    S.top++;<br>    <span class="hljs-comment">// 两步加起来等同于</span><br>    <span class="hljs-comment">// *S.top++ = e;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.3 顺序栈的出栈</p></blockquote><ul><li><p>步骤：</p><ol><li><p>判断是否栈空，若空则出错</p></li><li><p>获取栈顶元素e</p></li><li><p>栈顶指针减1</p></li></ol></li></ul><p><strong>先移动栈底指针，再取出元素，为什么？</strong><br>我的理解是，你得先移动栈顶指针，才能找到你要取出的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top  == S.base) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//判断是否栈空，若空则出错（下溢）</span><br>    S.top--;<br>    e = *S.top;<br><span class="hljs-comment">// 等同于e = *--S.top;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-链栈的表示和实现"><a href="#3-3-3-链栈的表示和实现" class="headerlink" title="3.3.3 链栈的表示和实现"></a>3.3.3 链栈的表示和实现</h3><p>链栈是运算受限的单链表，只能在链表头部进行操作。定义链栈的结构类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span>&#123;<br>    SElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> *next;<br>&#125;StackNode， *LinkStack;<br>Link Stack S;<span class="hljs-comment">//创建栈S</span><br></code></pre></td></tr></table></figure><p><strong>注意：链栈中指针的方向</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211515685.png"></p><ul><li><p>链表的头指针就是栈顶</p></li><li><p>不需要头结点</p></li><li><p>基本不存在栈满的情况</p></li><li><p>空栈相当于，栈指针指向空</p></li><li><p>插入和删除仅在栈顶处执行</p></li></ul><blockquote><p>算法3.5 链栈的初始化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span></span>&#123;<br>    <span class="hljs-comment">// 构造一个空栈，栈顶指针置为空</span><br>    S = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1 判断链栈是否位空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(LinkList S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE;<br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p>算法3.6 链栈的入栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack &amp;S, SElemType e)</span></span>&#123;<br>    p = <span class="hljs-keyword">new</span> StackNode;  <span class="hljs-comment">// 生成新结点p</span><br>    p-&gt;data = e;    <span class="hljs-comment">// 将新结点数据域置为e</span><br>    p-&gt;next = S;    <span class="hljs-comment">// 将新结点插入栈顶</span><br>    S = p;          <span class="hljs-comment">// 修改栈顶指针</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.7 链栈的出栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    e = S-&gt;data;把数据用e存储<br>    p = S;  <span class="hljs-comment">//存储原来的栈顶指针</span><br>    S = S-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211531419.png"><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211531360.png"></p><blockquote><p>算法3.8 取栈顶的元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> S-&gt;data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-栈与递归"><a href="#3-4-栈与递归" class="headerlink" title="3.4 栈与递归"></a>3.4 栈与递归</h2><ul><li><p>递归的定义</p><ul><li><p>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的；</p></li><li><p>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。</p></li></ul></li><li><p>常用到递归方法的三种情况：</p><ul><li><p>递归定义的数学函数</p></li><li><p>具有递归特性的数据结构</p><ul><li><p>二叉树</p></li><li><p>广义表</p></li></ul></li><li><p>可递归求解的问题</p><ul><li><p>迷宫问题</p></li><li><p>汉诺塔问题</p></li></ul></li></ul></li><li><p>递归问题——用分治法求解</p><ul><li><p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p></li><li><p>用分治法必备的三个条件</p><ol><li><p>能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</p></li><li><p>可以通过上述转换而使得问题简化</p></li><li><p>必须有一个明确的递归出口，或称递归边界</p></li></ol></li><li><p>分治法求解递归问题算法的一般形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">(参数表)</span></span>&#123;<br>    <span class="hljs-comment">// 基本项</span><br>    <span class="hljs-keyword">if</span>(递归结束条件) 可直接求解步骤; <span class="hljs-comment">// 递归边界</span><br>    <span class="hljs-comment">// 归纳项</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">p</span>(较小的参数);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">例如：<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">Fact</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//基本项</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">Fact</span>(n<span class="hljs-number">-1</span>);  <span class="hljs-comment">//归纳项</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>函数调用过程</p><ul><li><p>调用前，系统完成</p><ul><li><p>将实参、返回地址等传递给被调函数</p></li><li><p>为被调函数的局部变量分配存储区</p></li><li><p>将控制转移到被调函数的入口</p></li></ul></li><li><p>调用后，系统完成：</p><ul><li><p>保存被调函数的计算结果</p></li><li><p>释放被调函数的数据区</p></li><li><p>依照被调函数保存的返回地址将控制转移到被调函数</p></li></ul></li></ul></li><li><p>当多个函数构成嵌套调用时</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211610264.png"><br><strong>遵循后调用的先返回</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211630096.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211633233.png"><br>工作记录包括实参，局部变量，返回地址<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211635394.png"></p><ul><li><p>递归的优缺点</p><ul><li><p>优点：结构清晰，程序易读</p></li><li><p>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</p></li></ul></li><li><p>实现递归转非递归</p><ul><li><p>方法1：尾递归、单向递归变为循环结构</p></li><li><p>方法2：自用栈模拟系统的运行时栈</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211642768.png"></p><h2 id="3-5-队列的表示和操作的实现"><a href="#3-5-队列的表示和操作的实现" class="headerlink" title="3.5 队列的表示和操作的实现"></a>3.5 队列的表示和操作的实现</h2><ul><li><p>队列描述</p><ul><li><p><strong>队列</strong>(<strong>Queue</strong>)是仅在表尾进行插入操作，在表头进行删除操作的线性表。</p></li><li><p>表尾即an端，称为队尾；表头即a1端，称为队头；</p></li><li><p>它是一种先进先出(FIFO)的线性表</p></li></ul></li><li><p>队列的常见应用</p><ul><li><p>脱机打印输出：按申请的先后顺序依次输出</p></li><li><p>多用户系统中，多个用户排成队，分时地循坏使用CPU和主存</p></li><li><p>按用户的优先级排成多个队，每个优先级一个队列</p></li><li><p>实时控制系统中，信号俺接受的先后顺序依次处理</p></li></ul></li></ul><h3 id="3-5-1-队列的抽象数据类型定义"><a href="#3-5-1-队列的抽象数据类型定义" class="headerlink" title="3.5.1 队列的抽象数据类型定义"></a>3.5.1 队列的抽象数据类型定义</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211647621.png"></p><h3 id="3-5-2-队列的顺序表示和实现"><a href="#3-5-2-队列的顺序表示和实现" class="headerlink" title="3.5.2 队列的顺序表示和实现"></a>3.5.2 队列的顺序表示和实现</h3><p>队列的物理存储可以用顺序存储结构，也可用链式存储结构。相应地队列的存储方式也分为两种，即<strong>顺序队列</strong>和<strong>链式队列</strong>。</p><p>队列的顺序表示——用一维数组<code>base[MAXQSIZE]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QElemType *base;    <span class="hljs-comment">// 初始化的动态分配存储空间</span><br>    <span class="hljs-type">int</span> front;  <span class="hljs-comment">// 头指针，即队头下标</span><br>    <span class="hljs-type">int</span> rear;   <span class="hljs-comment">// 尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211700806.png"></p><blockquote><p>顺序队列存在的问题</p></blockquote><p>顺序队列的真溢出问题：即front&#x3D;0，rear&#x3D;MAXQSIZE时，队列中存满，为真溢出；</p><p>而当入队、出队操作之后，随着front和rear移动，出现front!&#x3D;0，rear&#x3D;MAXQSIZE时，为假溢出。</p><blockquote><p>顺序队列假上溢解决办法</p></blockquote><ul><li><p>解决假上溢的方法 </p><ol><li><p>将队中元素依次向队头方向移动。缺点：浪费时间。每移动一次，队中元素都要移动。</p></li><li><p>将队空间设想成一个循环的表，即分配给队列的m个存储单元可以循环使用，当rear为maxqsize时，若向量的开始端空着，又可从头使用空着的空间。当front为maxqsize时，也是一样。</p></li></ol></li><li><p>引入循环队列——解决假上溢的问题</p><p>  <code>base[0]</code>接在<code>base[MAXQSIZE-1]</code>之后，若rear+1 &#x3D;&#x3D; M，则rear&#x3D;0；</p><p>  实现方法：利用模运算(mod, %)</p><p>  入队：(尾指针后移一位)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Q.base[Q.rear] = x;<br>Q.rear = (Q.rear+<span class="hljs-number">1</span>) % MAXQSIZE;<br></code></pre></td></tr></table></figure><p>  出队：(头指针后移一位)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">x = Q.base[Q.front];<br>Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE;<br></code></pre></td></tr></table></figure><p>  针对循环队列，判断队空、队满时，front都与rear相等，因此可解决的方案有：</p><ol><li><p>另外设一个标态以区别队空和队满</p></li><li><p>另设一个变量，记录循环队列中当前元素个数</p></li><li><p>少用一个元素空间</p></li></ol></li><li><p>循环队列解决队满时判断方法——少用一个元素空间</p><p>  队空时：front &#x3D;&#x3D; rear</p><p>  队满时：(rear+1)% MAXQSIZE &#x3D;&#x3D; front（为什么判断队满时还要取余，考虑尾指针再加一归零的情况）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211913147.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301231508757.png"></p><blockquote><p>循环队列的类型定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QElemType *base;    <span class="hljs-comment">// 初始化的动态分配存储空间</span><br>    <span class="hljs-type">int</span> front;  <span class="hljs-comment">// 头指针，若队列不为空，指向队列头元素</span><br>    <span class="hljs-type">int</span> rear;   <span class="hljs-comment">// 尾指针，若队列不为空，指向队尾元素的下一个位置</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——队列的初始化(算法3.11)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.base = <span class="hljs-keyword">new</span> QElemType[MAXQSIZE]; <span class="hljs-comment">//分配数组空间</span><br>    <span class="hljs-comment">//等同于Q.base=(QElemType*)malloc(MAXQSIZE*sizeof(QElemType));</span><br>    <span class="hljs-keyword">if</span>(!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>    Q.front = Q.rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——求队列的长度(算法3.12)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>队列中的元素个数&#x3D;(Q.rear - Q.front + MAXQSIZE) % MAXQSIZE</strong></p><blockquote><p>循环队列的操作——循环队列入队(算法3.13)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE == Q.front) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队满</span><br>    Q.base[Q.rear] = e; <span class="hljs-comment">// 新元素加入队尾</span><br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE;   <span class="hljs-comment">// 队尾指针+1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——循环队列出队(算法3.14)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队空</span><br>    e = Q.base[Q.front];    <span class="hljs-comment">// 保存队头元素</span><br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE; <span class="hljs-comment">// 队头指针+1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——取循环队列队头元素(算法3.15)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear != Q.front)&#123; <span class="hljs-comment">// 不为空</span><br>        <span class="hljs-keyword">return</span> Q.base[Q.front]; <span class="hljs-comment">// 返回队头指针元素的值，队头指针不变</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-链队——队列的链式表示和实现"><a href="#3-5-3-链队——队列的链式表示和实现" class="headerlink" title="3.5.3 链队——队列的链式表示和实现"></a>3.5.3 链队——队列的链式表示和实现</h3><p>若用户无法估计所用队列的长度，则宜采用链队列。</p><blockquote><p>链式队列的类型定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span>&#123;<br>    QElemType data;<br>    Qnode *next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> Qnode *QueuePtr;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkQueue</span>&#123;<br>    QueuePtr front; <span class="hljs-comment">// 队头指针</span><br>    QueuePtr rear;  <span class="hljs-comment">// 队尾指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——链队列的初始化(算法3.16)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueuePtr</span>();<br>    Q.rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueuePtr</span>();<br>    Q.front-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——销毁链队列(补充)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(Q.front)&#123;<br>        p = Q.front-&gt;next;<br>        <span class="hljs-built_in">delete</span> (Q.front);<br>        Q.front = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——将元素e入队(算法3.17)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;<br>    p = <span class="hljs-keyword">new</span> QueuePtr;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-built_in">exit</span>(OVERFLOW);  <span class="hljs-comment">// 存储分配失败</span><br>    p-&gt;data = e;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next = p;<br>    Q.rear = p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——链队列的出队(算法3.18)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队空</span><br>    p = Q.front-&gt;next;<br>    e = p-&gt;data;<br>    Q.front-&gt;next = p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear == p) Q.rear = Q.front;<span class="hljs-comment">//此情况为删除的就是尾结点，此时队列为空，所以要使队尾指针等于队头指针</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——求链队列的队头元素(算法3.19)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    e = Q.front-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-习题"><a href="#3-6-习题" class="headerlink" title="3.6 习题"></a>3.6 习题</h2><blockquote><p>选择题</p></blockquote><ol><li><p>设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5和e6依次进入栈s，一个元素出栈后即进入Q，若6个元素出队的序列是e2、e4、e3、e6、e5和e1，则栈S的容量至少应该是()</p><p> A. 2  <strong>B. 3</strong>  C. 4  D. 6</p></li><li><p>若一个栈以向量<code>V[1...n]</code>存储，初始栈顶指针top设为n+1，则元素x进栈的正确操作是()。</p><p> A. <code>top++; V[top]=x;</code> B. <code>V[top]=x; top++;</code> <strong>C.</strong> <code>top--; V[top]= x;</code> D. <code>V[top]=x; top--;</code></p><p> 答案：C；解释：初始栈顶指针top为n+1，说明元素从数组向量的高端地址进栈，又因为元素存储在向量空间<code>V[1...n]</code>中，所以进栈时top指针先下移变为n，之后将元素x存储在<code>V[n]</code>。</p></li></ol><blockquote><p>算法设计题</p></blockquote><ol><li><p>将编号为0和1的两个栈存放于一个数组空间<code>V[m]</code>中，栈底分别处于数组的两端。当第0号栈的栈顶指针<code>top[0]</code>等于-1时该栈为空；当第1号栈的栈顶指针<code>top[1]</code>等于m时，该栈为空。两个栈均从两端向中间增长(见图)。试编写双栈初始化，判断栈空、栈满、进栈和出栈等算法的函数。双栈数据结构的定义如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DblStack</span>&#123;<br>    <span class="hljs-type">int</span> top[<span class="hljs-number">2</span>], bot[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 栈顶和栈底指针</span><br>    SElemType* V;       <span class="hljs-comment">// 栈数组</span><br>    <span class="hljs-type">int</span> m;              <span class="hljs-comment">// 栈最大可容纳元素个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> <img src="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/%E5%8F%8C%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="双栈结构的表示"></p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。试写一个算法判定给定的字符序列是否为回文。（提示：将一半字符入栈）</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>设从键盘输入一整数的序列：a1, a2, a3,…, an，试编写算法实现：用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai &#x3D; -1时，输出栈顶整数并出栈。算法应对异常情况(入栈满等)给出相应的信息。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>从键盘上输入一个后缀表达式，试编写算法计算表达式的值。规定：逆波兰表达式的长度不超过一行，以”$”作为输入结束，操作数之间用空格分隔，操作符只可能有+、-、<em>、／四种运算。例如： 23434 + 2</em>$。</p></li><li><p>假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，称可以操作的序列为合法序列，否则称为非法序列。</p><ul><li>下面所示的序列中哪些是合法的？</li></ul><p> A. IOIIOIOO B. IOOIOIIO C. IIIOIOIO D. IIIOOIOO</p><ul><li>通过对上述的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false(假定被判定的操作序列已存入一维数组中)。</li></ul><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意：不设头指针），试编写相应的置空队列、判断队列是否为空、入队和出队等算法。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li><li><p>假设以数组<code>Q[m]</code>存放循环队列中的元素，同时设置一个标志tag，以tag &#x3D; 0和tag &#x3D; 1来区别在队头指针(front)和队尾指针(rear)相等时，队列状态为“空”还是“满”。试编写与此结构相应的插入(enqueue)和删除(dequeue)算法。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe7.cpp">算法设计题7</a></p></li><li><p>如果允许在循环队列的两端都可以进行插入和删除操作。要求：</p><ul><li><p>写出循环队列的类型定义；</p></li><li><p>写出“从队尾删除”和“从队头插入”的算法。</p></li></ul><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe8.cpp">算法设计题8</a></p></li><li><p>已知Ackermann函数定义如下：Ack(m, n) &#x3D;</p><ul><li><p>n + 1, 当m &#x3D; 0时</p></li><li><p>Ack(m-1, 1), 当m≠0, n&#x3D;0时</p></li><li><p>Ack(m-1, Ack(m, n-1)), 当m≠0, n≠0时</p></li></ul><ol><li><p>写出计算Ack(m, n)的递归算法，并根据此算法给出Ack(2, 1)的计算过程。</p></li><li><p>写出计算Ack(m,n)的非递归算法。</p></li></ol><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe9.cpp">算法设计题9</a></p></li><li><p>已知f为单链表的表头指针，链表中存储的都是整型数据，试写出实现下列运算的递归算法：</p><ol><li><p>求链表中的最大整数；</p></li><li><p>求链表的结点个数；</p></li><li><p>求所有整数的平均值。</p></li></ol><p><a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe10.cpp">算法设计题10</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表——王卓</title>
    <link href="/2022/10/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和特点"><a href="#2-1-线性表的定义和特点" class="headerlink" title="2.1 线性表的定义和特点"></a>2.1 线性表的定义和特点</h2><p><strong>线性表是具有相同特性的数据元素的一个有限序列</strong>。</p><blockquote><p>线性表(Linear List)：</p></blockquote><p>由n(n ≥ 0)个数据元素（结点）a1, a2, … an组成的<strong>有限序列</strong>。</p><ul><li><p>其中数据元素的个数n定义为表的<strong>长度</strong></p></li><li><p>当n&#x3D;0时称为<strong>空表</strong></p></li><li><p>将非空的线性表(n&gt;0)记作：(a1, az, … an)</p></li><li><p>这里的数据元素ai(1≤i≤n)只是一个抽象的符号，其具体含义在不同的情况下可以不同。</p></li></ul><blockquote><p>线性表的逻辑特征</p></blockquote><ul><li><p>在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2；</p></li><li><p>有且仅有一个终端结点an，它没有直接后继，而仅有一个直接前趋an-1；</p></li><li><p>其余的内部结点ai(2≤i≤n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1。</p></li></ul><h2 id="2-2-案例引入"><a href="#2-2-案例引入" class="headerlink" title="2.2 案例引入"></a>2.2 案例引入</h2><blockquote><p>顺序存储结构存在问题</p></blockquote><ul><li><p>存储空间分配不灵活</p></li><li><p>运算的空间复杂度高</p></li></ul><blockquote><p>总结</p></blockquote><ul><li><p>线性表中的数据元素的类型可以为<strong>简单类型</strong>，也可以为<strong>复杂类型</strong></p></li><li><p>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序</p></li><li><p>从具体应用中抽象出共性的<strong>逻辑结构和基本操作</strong>（抽象数据类型），然后实现其<strong>存储结构和基本操作</strong></p></li></ul><h2 id="2-3-线性表的定义"><a href="#2-3-线性表的定义" class="headerlink" title="2.3 线性表的定义"></a>2.3 线性表的定义</h2><blockquote><p>基本操作</p></blockquote><ul><li><p>InitList(&amp;L)</p><ul><li>操作结果：构造一个空的线性表L</li></ul></li><li><p>DestoryList(&amp;L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：销毁线性表L</p></li></ul></li><li><p>ClearList(&amp;L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：将线性表L重置为空表</p></li></ul></li><li><p>ListEmpty(L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若线性表L空表则返回TURE；否则返回FALSE。</p></li></ul></li><li><p>ListLength(L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：返回线性表L中的数据元素个数。</p></li></ul></li><li><p>GetElem(L, i, &amp;e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</p></li><li><p>操作结果：用e返回线性表L中第个数据元素的值。</p></li></ul></li><li><p>LocateElem(L, e, compare())</p><ul><li><p>初始条件：线性表L已存在，compare()是数据元素判定函数</p></li><li><p>操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。</p></li></ul></li><li><p>PriorElem(L, cur_e, &amp;pre_e)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义。</p></li></ul></li><li><p>NextElem(L, cur_e, &amp;next_e)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若cur_e是L的数据元素，且不是第最后个，则用next_e返回它的后继，否则操作失败，next_e无意义。</p></li></ul></li><li><p>ListInsert(&amp;L, i, e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)+1</p></li><li><p>操作结果：在L的第i个位置<strong>之前</strong>插入新的数据元素e，L的长度加一。</p></li></ul></li><li><p>ListDelete(&amp;L, i, &amp;e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</p></li><li><p>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一。</p></li></ul></li><li><p>ListTraverse(&amp;L, visited())   &#x2F;&#x2F; 遍历</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：依次对线性表中每个元素调用visited()。</p></li></ul></li></ul><h2 id="2-4-线性表的顺序表示和实现"><a href="#2-4-线性表的顺序表示和实现" class="headerlink" title="2.4 线性表的顺序表示和实现"></a>2.4 线性表的顺序表示和实现</h2><h3 id="2-4-1-线性表的顺序存储表示"><a href="#2-4-1-线性表的顺序存储表示" class="headerlink" title="2.4.1 线性表的顺序存储表示"></a>2.4.1 线性表的顺序存储表示</h3><p>线性表的顺序表示又称为<strong>顺序存储结构</strong>或<strong>顺序映像</strong>。</p><p>顺序存储定义：把<strong>逻辑上相邻的数据元素</strong>存储在<strong>物理上相邻的存储单元</strong>中的存储结构。</p><p>线形表顺序存储结构占用<strong>一片续的存储空间</strong>。知道某个元素的存储位置就可以计算其他元素的存储位置。</p><blockquote><p>数组静态分配</p></blockquote><p>这段代码就相当于一个模板<br>typedef是用来给数据类型起一个新的名字<br>ElemType是数组的数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 100  <span class="hljs-comment">//线性表存储空间初始分配量</span></span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType data[MaxSize];<br>    <span class="hljs-type">int</span> length;  <span class="hljs-comment">//线性表当前长度</span><br>  &#125; SqList; <span class="hljs-comment">// 顺序表类型</span><br></code></pre></td></tr></table></figure><p>数组存放的是第一个元素的地址，因此也可以写成以下动态分配形式，用指针代替第一个元素地址。</p><blockquote><p>数组动态分配</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 1000  <span class="hljs-comment">//线性表存储空间</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>  ElemType *data;  <span class="hljs-comment">//存储空间的基地址</span><br>  <span class="hljs-type">int</span> length;<br>&#125; SqList; <span class="hljs-comment">// 定义顺序表类型</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">SqList L;  <span class="hljs-comment">//定义变量L，L是SqList这种类型的，L是个线性表</span><br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ElemType) * MaxSize);<br></code></pre></td></tr></table></figure><p>（ElemType*）表示强制类型转换</p><p>在头文件stdlib.h中：</p><p>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址。</p><p>size of(x)运算，计算变量x的长度</p><p>free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量。</p><blockquote><p>补充：C++的动态存储分配</p></blockquote><p>new 类型名T （初值列表）<br>    功能：<br>        申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值<br>    结果值：<br>        成功：T类型的指针，指向新分配的内存<br>        失败：0（NULL)<br>例如：int * p1 &#x3D; new int;或int * p1 &#x3D; new int(10);<br>注意：new出来的空间是一个地址所以只能赋值给指针。</p><p>delete 指针p<br>    功能：<br>        释放指针p所指向的内存。p必须是new操作的返回值</p><blockquote><p>补充：C++的参数传递</p></blockquote><ul><li><p>函数调用时传送给形参表的实参必须与形参三个一致</p><ul><li>类型、个数、顺序</li></ul></li><li><p>参数传递有两种方式</p><ul><li>传值方式</li><li>传地址<ul><li>参数为指针变量</li><li>参数为引用类型</li><li>参数为数组名</li></ul></li></ul></li><li><p>传地址方式–引用类型作参数<br>什么是引用？？？<br>引用：它用来给一个对象提供一个替代的名字</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp;j=i;<br>i=<span class="hljs-number">7</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j;<br>&#125;  <span class="hljs-comment">//j是一个引用类型，代表i的一个替代名i值改变时，j值也跟着改变，所以会输出i=7 j=7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210192252376.png"></p><p>m是对a的引用，n是对b的引用，通过引用变量直接操作实参</p><p>可以这样理解：m和a用的是同一个地址，他们共用同一块空间</p><ul><li>引用类型作形参的三点说明<ul><li>传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化</li><li>引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作，而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值时实参变量的副本。因此当参数传递的<strong>数据量比较大</strong>时，用引用比用一般变量传递参数的时间和空间效率都好</li><li>指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“* 指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用的点出，必须用变量的地址作为实参</li></ul></li></ul><h3 id="2-4-2-顺序表基本操作的实现"><a href="#2-4-2-顺序表基本操作的实现" class="headerlink" title="2.4.2 顺序表基本操作的实现"></a>2.4.2 顺序表基本操作的实现</h3><blockquote><p>线性表L的初始化</p></blockquote><p>Status 是函数的类型，其值是函数结果状态代码，在本例中为int的别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<span class="hljs-comment">// 构造一个空的顺序表L   </span><br>L.elem=<span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">// 为顺序表分配空间</span><br><span class="hljs-keyword">if</span>(!L.elem) <br>    <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 空表长度为0</span><br><span class="hljs-keyword">return</span> OK；<br></code></pre></td></tr></table></figure><blockquote><p>销毁线性表L</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestoryList</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(L.elem) <br>      <span class="hljs-keyword">delete</span> L.elem; <span class="hljs-comment">// 释放存储空间</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>清空线性表L</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 将线性表的长度置为0</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>求线性表的长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> L.length;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>判断线性表是否为空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>顺序表的取值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 取物理位置第i个元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt;= L.length) <span class="hljs-keyword">return</span> ERROR;<br><br>  e = L.elem[i<span class="hljs-number">-1</span>];<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是在主函数定义了变量e，并且通过引用的方式把值已经传给e了，所以不用return e，这样写代码是为了获取状态代码，判断此操作中传入的i值是否可在线性表中取到</p><blockquote><p>顺序表按值查找(顺序查找)</p></blockquote><ul><li><p>在线性表L中查找与指定值e相同的数据元素的位置</p></li><li><p>从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//顺序表的查找（按值查找）</span><br><span class="hljs-comment">//暂且先用最简单的查找方法，从表的一端开始，逐个进行记录的关键字和给定值比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在线性表L中查找值为e的元素，返回其序号（是第几个元素）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;  <span class="hljs-comment">//查找成功，返回序号</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//查找失败，返回0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>平均查找长度ASL(Average Search Length):</p><ul><li><p>为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的<strong>平均查找长度</strong>。</p></li><li><p><strong>数学期望&#x3D;平均查找长度</strong></p></li></ul><blockquote><p>顺序表插入</p></blockquote><p>插入不同位置的算法演示：插入位置在最后、插入位置在中间、插入位置在最前面</p><p>算法思想：</p><ol><li><p>判断插入位置i是否合理</p></li><li><p>判断顺序表的存储空间是否已满，若已满返回ERROR</p></li><li><p>将第n至第i位的元素一次向后移动一个位置，空出第i个位置</p></li><li><p>将要插入的新元素e放入第i个位置</p></li><li><p>表长加1，返回插入成功。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ListInsert_Sq</span>(SqList&amp; L, <span class="hljs-type">int</span> i, ElemType e)<br>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// i值不合法</span><br>  <span class="hljs-keyword">if</span>(L.length == MAXSIZE) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 当前存储已满</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = L.length<span class="hljs-number">-1</span>; j &gt;= i; j--)&#123;<br>    L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<br>  &#125;  <span class="hljs-comment">//把位置i后的元素都后移一个位置</span><br>  L.elem[i<span class="hljs-number">-1</span>] = e;<br>  L.length++;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表插入算法的平均时间复杂度为O(n)。</p><blockquote><p>顺序表的删除算法</p></blockquote><p>算法思想：</p><ol><li><p>判断删除位置i是否合法</p></li><li><p>将欲删除的元素保留在e中</p></li><li><p>将第i+1至第n位的元素依次向前移动一个位置</p></li><li><p>表长减1，删除成功返回OK</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ListInsert_Sq</span>(SqList&amp; L, <span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// i值不合法</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= L.length<span class="hljs-number">-1</span>; j++)&#123;<br>    L.elem[j<span class="hljs-number">-1</span>] = L.elem[j];<br>  &#125;<br>  L.length--;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125; <br><span class="hljs-comment">//注意算法里面的i是位置不是数组下标</span><br></code></pre></td></tr></table></figure><p>顺序表删除算法的平均时间复杂度为O(n)。</p><h3 id="2-4-3-顺序表小结"><a href="#2-4-3-顺序表小结" class="headerlink" title="2.4.3 顺序表小结"></a>2.4.3 顺序表小结</h3><ol><li><p>利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致</p></li><li><p>在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等</p><ul><li>这种存取元素的方法被称为<strong>随机存取法</strong></li></ul></li></ol><blockquote><p>顺序表的操作算法分析</p></blockquote><ul><li><p>时间复杂度</p><ul><li>查找、插入、删除算法的平均时间复杂度为O(n)</li></ul></li><li><p>空间复杂度</p><ul><li>顺序表操作算法的空间复杂度S(n) &#x3D; O(1)，没有占用辅助空间</li></ul></li></ul><blockquote><p>顺序表的优缺点</p></blockquote><ol><li><p>优点</p><ul><li><p>存储密度大（结点本身所占存储量&#x2F;结点结构所占存储量）</p></li><li><p>可以随机存取表中任一元素</p></li></ul></li><li><p>缺点</p><ul><li><p>在插入、删除某一元素时，需要移动大量元素</p></li><li><p>浪费存储空间</p></li><li><p>属于静态存储形式，数据元素的个数不能自由扩充</p></li></ul></li></ol><h2 id="2-5-线性表的链式表示和实现"><a href="#2-5-线性表的链式表示和实现" class="headerlink" title="2.5 线性表的链式表示和实现"></a>2.5 线性表的链式表示和实现</h2><ul><li><p>链式存储结构</p><ul><li>节点在存储器中的位置是任意的，即逻辑上相邻的数据在物理上不一定相邻</li></ul></li><li><p>线性表的链式表示又称为非顺序映像或链式映像。</p></li><li><p>用一组<strong>物理位置任意的存储单元</strong>来存放线性表的数据元素。</p></li></ul><p>单链表由头指针惟一确定，因此单链表可以用头指针的名字来命名。</p><p>各结点由两个域组成：</p><ul><li><p>数据域：存储元素数值数据</p></li><li><p>指针域：存储直接后继结点的存储位置</p></li></ul><blockquote><p>链式存储有关的术语</p></blockquote><ol><li><p>结点：数据元素的存储映像。由数据域和指针域两部分组成</p></li><li><p>链表：n个结点由<strong>指针链</strong>链接而成的一个链表</p></li><li><p>链表类型</p><p> 单链表：结点只有一个指针域的链表；</p><p> 双链表：结点有两个指针域的链表；</p><p> 循环链表：首尾相接的链表；</p></li><li><p>头指针、头结点和首元结点：</p><p> 头指针：是指向链表中第一个结点的指针，即指向头结点</p><p> 首元结点：是指链表中存储第一个数据元素a1的结点</p><p> 头结点：是在链表的首元结点之前附设的一个结点，一个附加结点。</p></li></ol><p><strong>以上三个概念一定要区分好</strong></p><blockquote><p>讨论1：如何表示空表</p></blockquote><ul><li><p>若无头结点时，头指针为空时表示空表</p></li><li><p>有头结点时，当头结点的指针域位空时表示空表</p></li></ul><blockquote><p>讨论2：在链表中设置头结点有什么好处？</p></blockquote><ol><li><p>便于首元结点的处理</p><p> 首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理</p></li><li><p>便于空表和非空表的统一处理</p><p> 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</p></li></ol><blockquote><p>讨论3：头结点的数据域内装的是什么？</p></blockquote><p>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</p><blockquote><p>链表的特点：</p></blockquote><ol><li><p>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻</p></li><li><p>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间<strong>不相同</strong></p></li><li><p><strong>链表是顺序存取的，顺序表是随机存取的</strong></p></li></ol><h3 id="2-5-1-单链表的定义和表示"><a href="#2-5-1-单链表的定义和表示" class="headerlink" title="2.5.1 单链表的定义和表示"></a>2.5.1 单链表的定义和表示</h3><blockquote><p>带头结点的单链表</p></blockquote><p>单链表是由<strong>表头</strong>唯一确定，因此单链表可以用头指针的名字来命名若头指针名是L，则把链表称为表L</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123; <span class="hljs-comment">// 声明结点的类型和指向结点的指针类型</span><br>  ElemType data;  <span class="hljs-comment">// 结点的数据域</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next;    <span class="hljs-comment">// 结点的指针域</span><br>&#125; Lnode, *LinkList; <span class="hljs-comment">// LinkList为指向结构体Lnode的指针类型，LinkList也就是别名</span><br></code></pre></td></tr></table></figure><p>定义链表L：LinkList L;  （指向头结点）</p><p>定义结点指针p：LNode * p等价于LinkList p;（指向中间结点，也就是结点的指针域）</p><h3 id="2-5-2-单链表基本操作的实现"><a href="#2-5-2-单链表基本操作的实现" class="headerlink" title="2.5.2 单链表基本操作的实现"></a>2.5.2 单链表基本操作的实现</h3><blockquote><p>算法2.6——单链表的初始化(带头结点的单链表)</p></blockquote><p>单链表的初始化即构造一个空表。</p><p>算法步骤：</p><ol><li><p>生成新结点作为头结点，用头指针L指向头结点</p></li><li><p>将头结点的指针域置空</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1：判断链表是否为空</p></blockquote><p>空表：链表中无元素，称为空链表(头指针和头结点仍然在)</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123; <span class="hljs-comment">// 若L为空表，则返回1，否则返回0</span><br>  <span class="hljs-keyword">if</span>(L-&gt;next)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法2：单链表的销毁：链表销毁后不存在</p></blockquote><p>算法思路：从头指针开始，依次释放所有结点</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">// 销毁单链表L</span><br>  Lnode *p;<br>  <span class="hljs-keyword">while</span>(L)&#123; <span class="hljs-comment">// 直至L为空</span><br>    p = L;<br>    L = L-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>  &#125;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3：清空链表</p></blockquote><p>链表仍存在，但链表中无元素，成为空链表(头指针和头结点仍然在)</p><p>算法思路：依次释放所有结点，并将头结点指针域设置为空</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">// 将L重置为空表</span><br>  Lnode *p, *q<br>  p = L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p)&#123;<br>    q = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = q;<br>  &#125;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 头结点指针域为空</span><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3：求单链表的表长</p></blockquote><p>算法思路：从首元结点开始，依次计数所有结点</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>&#123; <span class="hljs-comment">// 返回L中数据元素个数</span><br>  LinkList p;<br>  p = L-&gt;next;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(p)&#123; <span class="hljs-comment">// 遍历单链表，统计结点数</span><br>    i++;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.7——取值(取单链表中第i个元素的内容)</p></blockquote><p>算法思路：从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止。因此，<strong>链表不是随机存取结构</strong>。</p><p>算法步骤：</p><ol><li><p>从第一个结点(L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p &#x3D; L-&gt;next;</p></li><li><p>j做计数器，累计当前扫描过的结点数，j初值为1；</p></li><li><p>当p指向扫描到的下一个结点时，计数器j加1；</p></li><li><p>当j &#x3D;&#x3D; i时，p所指的结点就是要找的第i个结点。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-comment">// 获取线性表L中的某个数据元素的内容，通过变量e返回</span><br>  p = L-&gt;next; j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(!p || j &gt; i) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 第i个元素不存在</span><br>  e = p-&gt;data;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找：</p><ul><li><p>按值查找：根据指定数据获取该数据所在的位置（该数据的地址）；</p></li><li><p>按值查找：根据指定数据获取该数据所在位置序号（是第几个元素）</p></li></ul><blockquote><p>算法2.8——按值查找：根据指定数据获取该数据所在的位置（地址）</p></blockquote><p>算法步骤：</p><ol><li><p>从第一个结点起，依次和e相比较</p></li><li><p>如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址；</p></li><li><p>如果查遍整个链表都没有找到其值和e相等的元素，则返回0或NULL。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Lnode* <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 在线性表L中查找值e的数据元素</span><br>  <span class="hljs-comment">// 找到，则返回L中值为e的数据元素的地址，查找失败返回NULL</span><br>  p = L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.8 变化——按值查找：根据指定数据获取该数据所在的位置序号</p></blockquote><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 返回L中值为e的数据元素的位置序号，查找失败返回0</span><br>  p = L-&gt;next; j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>    p = p-&gt;next;<br>    j++;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(p) <span class="hljs-keyword">return</span> j;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.9 插入——在第i个结点前插入值为e的新结点</p></blockquote><p>算法步骤：</p><ol><li><p>首先找到ai-1的存储位置p</p></li><li><p>生成一个数据域为e的新结点s</p></li><li><p>插入新结点：</p><ol><li><p>新结点的指针域指向结点ai</p></li><li><p>结点ai-1的指针域指向新结点</p></li></ol></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;<br>  p = L; j = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 寻找第i-1个结点，p指向i-1结点</span><br>  <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i - <span class="hljs-number">1</span>)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-comment">// /i大于表长+1或者小于1，插入位置非法</span><br>  <span class="hljs-keyword">if</span>(!p || j &gt; i - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <br>  <span class="hljs-comment">// 生成新结点s，将结点s的数据域置为e</span><br>  s = <span class="hljs-keyword">new</span> LNode;<br>  s-&gt;data = e;<br>  <span class="hljs-comment">// 将结点s插入L中</span><br>  s-&gt;next = p-&gt;next;<span class="hljs-comment">//把p的指针域的指针（原本指向p后面一个结点的指针）赋值给s的指针域里的指针</span><br>  p-&gt;next = s;<span class="hljs-comment">//把指向s结点的指针赋值给p的指针域里的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.10 删除——删除第i个结点</p></blockquote><p>算法步骤：</p><ol><li><p>首先找到ai-1的存储位置p，保存要删除的ai的值</p></li><li><p>令p-&gt;next指向ai+1</p></li><li><p>释放结点ai的空间</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// 将线性表L中第i个数据元素删除</span><br>  <span class="hljs-function">Status <span class="hljs-title">ListDelete_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType&amp;e)</span></span>&#123;<br>  p = L; j = <span class="hljs-number">0</span>; <br>  <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="hljs-number">-1</span>)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-comment">// 寻找第i个结点，并令p指向其前驱</span><br>  <span class="hljs-keyword">if</span>(!(p-&gt;next) || j &gt; i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR；<span class="hljs-comment">//删除位置不合理</span><br>  q = p-&gt;next;  <span class="hljs-comment">// 临时保存被删结点的地址以备释放</span><br>  <span class="hljs-comment">//让q指向p后面的一个结点</span><br>  p-&gt;next = q-&gt;next; <span class="hljs-comment">// 改变删除结点前驱结点的指针域</span><br>  <span class="hljs-comment">//让p指向q后面的一个结点，此时q变成了原来要删除的结点，而p跳过了q，指向q后面的一个结点</span><br>  e = q-&gt;data;  <span class="hljs-comment">// 保存删除结点的数据域</span><br>  <span class="hljs-keyword">delete</span> q;     <span class="hljs-comment">// 释放删除结点的空间</span><br>  <span class="hljs-keyword">return</span> OK;<br>&#125; <span class="hljs-comment">// ListDelete_L</span><br></code></pre></td></tr></table></figure><blockquote><p>算法2.11 建立单链表——头插法（倒位序）</p></blockquote><p>头插法：元素插入在链表头部，也叫前插法</p><p>算法步骤：</p><ol><li><p>从一个空表开始，重复读入数据；</p></li><li><p>生成新结点，将读入数据存放到新结点的数据域中</p></li><li><p><strong>从最后一个结点开始</strong>，依次将各结点插入到链表的前端</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142235433.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先建立一个带头结点的单链表</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; --i)&#123;<br>    p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点p</span><br>    cin &gt;&gt; p-&gt;data; <span class="hljs-comment">// 输入元素值</span><br>    p-&gt;next = L-&gt;next;  <span class="hljs-comment">// 插入到表头</span><br>    L-&gt;next = p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.11 建立单链表——尾插法（正位序）</p></blockquote><p>尾查法：元素插入在链表尾部，也叫后插法</p><p>算法步骤：</p><ol><li><p>从一个空表开始，正位序将新结点逐个插入到链表的尾部，尾指针r始终指向链表的尾结点。</p></li><li><p>初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142255418.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>;<br>  r = L;  <span class="hljs-comment">// 尾指针r指向头结点</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点，输入元素值</span><br>    cin &gt;&gt; p-&gt;data;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//新结点指针域先赋值为空</span><br>    r-&gt;next = p;<span class="hljs-comment">//把新的结点插入到链表尾部</span><br>    r = p;<span class="hljs-comment">//更新尾指针</span><br>  &#125;<br>&#125; <span class="hljs-comment">// CreateList_R</span><br></code></pre></td></tr></table></figure><h3 id="2-5-3-单链表的查找、插入、删除算法时间效率分析"><a href="#2-5-3-单链表的查找、插入、删除算法时间效率分析" class="headerlink" title="2.5.3 单链表的查找、插入、删除算法时间效率分析"></a>2.5.3 单链表的查找、插入、删除算法时间效率分析</h3><ol><li><p>因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为O(n)</p></li><li><p>插入和删除：</p><p> 因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为O(1)。</p><p> 但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)</p></li><li><p>头插法的时间复杂度是O(n)</p></li><li><p>尾插法的时间复杂度是O(n)</p></li></ol><h3 id="2-5-4-循环链表"><a href="#2-5-4-循环链表" class="headerlink" title="2.5.4 循环链表"></a>2.5.4 循环链表</h3><p>循环链表：是一种头尾相接的链表（即：表中最后一个结点的指针域指向头结点，整个链表形成一个环）。</p><p>优点：<strong>从表中任一结点出发均可找到表中其他结点</strong>。</p><p>循环链表的空表表示：头指针的指针域指向自己。</p><blockquote><p>注意：</p></blockquote><p>由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p-&gt;next是否为空，而是判断它们<strong>是否等于头指针</strong>。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151549155.png"></p><blockquote><p>头指针表示单循环链表</p></blockquote><p>找a1的时间复杂度：O(1)</p><p>找an的时间复杂度：O(n)</p><p>但考虑到表的操作常常是在表的首尾位置上进行，因此更过的是考虑用<strong>尾指针表示单循环链表</strong></p><blockquote><p>尾指针表示单循环链表</p></blockquote><p>设尾指针为R：</p><p>找a1的时间复杂度：O(1)，a1的存储位置是：R-&gt;next-&gt;next</p><p>找an的时间复杂度：O(1)，an的存储位置是：R</p><blockquote><p>带尾指针循环链表的合并（将Tb合并在Ta之后）</p></blockquote><p>操作步骤：</p><ol><li><p>p存表头结点：p &#x3D; Ta-&gt;next;</p></li><li><p>Tb表头连接到Ta表尾:Ta-&gt;next &#x3D; Tb-&gt;next-&gt;next;</p></li><li><p>释放Tb表头结点:delete Tb-&gt;next;</p></li><li><p>修改指针:Tb-&gt;next &#x3D; p;</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151601055.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span></span>&#123;<br>  <span class="hljs-comment">// 假设Ta、Tb都是非空的单循环链表</span><br>  p = Ta-&gt;next;     <span class="hljs-comment">// 1. p存表头结点</span><br>  Ta-&gt;next = Tb-&gt;next-&gt;next;  <span class="hljs-comment">// Tb表头连接到Ta表尾</span><br>  <span class="hljs-keyword">delete</span> Tb-&gt;next;         <span class="hljs-comment">// 释放Tb表头结点</span><br>  Tb-&gt;next = p;           <span class="hljs-comment">// 修改指针</span><br>  <span class="hljs-keyword">return</span> Tb;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(1)</p><h3 id="2-5-5-双向链表"><a href="#2-5-5-双向链表" class="headerlink" title="2.5.5 双向链表"></a>2.5.5 双向链表</h3><p>双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了有两个方向不同的链，故称为双向链表。</p><p>双向链表结构定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>&#123;<br>  Elemtype data;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *prior, *next;<br>&#125;DuLNode, *DuLinkList;<br></code></pre></td></tr></table></figure><p>双向循环链表:</p><p>和单链的循环表类似，双向链表也可以有循环表</p><ul><li><p>让头结点的前驱指针指向链表的最后一个结点</p></li><li><p>让最后一个结点的后继指针指向头结点。</p></li></ul><p>在双向链表中有些操作（如：ListLength、GetElem等），因仅涉及一个方向的指针，故它们的算法与线性链表的相同。但在插入、删除时，则需同时修改两个方向上的指针，两者的操作的时间复杂度均为O(n)。</p><blockquote><p>算法2.13 双向链表的插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 在带头结点的双向循环链表L中第i个位置之前插入元素e</span><br>  <span class="hljs-keyword">if</span>(!(p = <span class="hljs-built_in">GetElemP_DuL</span>(L, i))) <span class="hljs-keyword">return</span> ERROR;<br>  s = <span class="hljs-keyword">new</span> DuLNode;<br>  s-&gt;data = e;<br>  s-&gt;prior = p-&gt;prior;<br>  p-&gt;prior-&gt;next = s;<br>  s-&gt;next = p;<br>  p-&gt;prior = s;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.14 双向链表的删除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListDelete_DuL</span><span class="hljs-params">(DuLinkList&amp; L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-comment">// 删除带头结点的双向循环链表L的第i个元素，并用e返回。</span><br>  <span class="hljs-keyword">if</span>(!(p = <span class="hljs-built_in">GetElemP_DuL</span>(L, i))) <span class="hljs-keyword">return</span> ERROR;<br>  e = p-&gt;data;<br>  p-&gt;prior-&gt;next = p-&gt;next;<br>  p-&gt;next-&gt;prior = p-&gt;prior;<br>  <span class="hljs-keyword">delete</span> p;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单链表、循环链表和双向链表的时间效率比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131139437.png"></p><h2 id="2-6-顺序表和链式表的比较"><a href="#2-6-顺序表和链式表的比较" class="headerlink" title="2.6 顺序表和链式表的比较"></a>2.6 顺序表和链式表的比较</h2><blockquote><p>链式存储结构的优点：</p></blockquote><ul><li><p>结点空间可以动态申请和释放；</p></li><li><p>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素。</p></li></ul><blockquote><p>链式存储结构的缺点</p></blockquote><ul><li><p>存储密度小：每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大。</p></li><li><p>链式存储结构是非随机存取结构。对任一结点的操作都需要从头指针依指针链查找到该结点，这增加了算法的复杂度。</p></li></ul><blockquote><p>顺序表和链式表的比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131138707.png"></p><h2 id="2-7-线性表的应用"><a href="#2-7-线性表的应用" class="headerlink" title="2.7 线性表的应用"></a>2.7 线性表的应用</h2><p>主要介绍线性表的合并和有序表的合并。</p><blockquote><p>线性表的合并 </p></blockquote><ul><li><p>问题描述：</p><p>假设利用两个线性表La和Lb分别表示两个集合A和B，现要求合一个新的集合A &#x3D; A∪B</p></li><li><p>算法步骤：</p><p>依次取出Lb中的每个元素，执行以下操作：</p><ol><li><p>在La中查找该元素</p></li><li><p>如果找不到，则将其插入La的最后</p></li></ol></li><li><p>算法描述：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(List &amp;La, List Lb)</span></span>&#123;<br>  La_len = <span class="hljs-built_in">ListLength</span>(La);<br>  Lb_len = <span class="hljs-built_in">ListLength</span>(Lb);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; Lb_len; i++)&#123;<br>    <span class="hljs-built_in">GetElem</span>(Lb, i, e);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">LocateElem</span>(La, e))&#123;<br>      <span class="hljs-built_in">ListInsert</span>(&amp;La, ++La_len, e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述算法时间复杂度为O(La_len*Lb_len)。</p><blockquote><p>有序表的合并</p></blockquote><ul><li><p>问题描述：</p><p>已知线性表La和Lb的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素仍按值非递减有序排列。</p></li><li><p>算法步骤：</p><ol><li><p>创建一个空表Lc</p></li><li><p>依次从La或Lb中“摘取”元素值较小的结点插入到Lc表的最后，直至其中一个表变空为止</p></li><li><p>继续将La或Lb其中一个表的剩余结点插入在Lc表的最后</p></li></ol></li></ul><blockquote><p>算法2.16 有序表合并——用顺序表实现</p></blockquote><ul><li>用顺序表实现</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_sq</span><span class="hljs-params">(SqList LA, SqList LB, SqList&amp; LC)</span></span>&#123;<br>  <span class="hljs-comment">// 指针pa和pb的初值分别指向两个表的第一个元素</span><br>  pa = LA.elem;<br>  pb = LB.elem;<br><br>  <span class="hljs-comment">// 新表长度为待合并两表的长度和</span><br>  LC.length = LA.length + LB.length;<br>  <span class="hljs-comment">// 为新表分配空间</span><br>  LC.elem = <span class="hljs-keyword">new</span> ElemType[LC.length];<br>  pc = LC.elem;<br><br>  <span class="hljs-comment">// 找到LA和LB的最后一个元素</span><br>  pa_last = LA.elem + LA.length - <span class="hljs-number">1</span>;<br>  pb_last = LB.elem + LB.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 两个表都非空</span><br>  <span class="hljs-keyword">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)&#123;<br>    <span class="hljs-keyword">if</span>(*pa &lt;= *pb)&#123;<br>      *pc++ = *pa++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      *pc++ = *pb++;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// LB已到达表尾，将LA中剩余元素加入LC</span><br>  <span class="hljs-keyword">while</span>(pa &lt;= pa_last) *pc++ = *pa++;<br><br>  <span class="hljs-comment">// LA已到达表尾，将LB中剩余元素加入LC</span><br>  <span class="hljs-keyword">while</span>(pb &lt;= pb_last) *pc++ = *pb++;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为：O(ListLength(LA)+ListLength(LB))</p><p>空间复杂度为：O(ListLength(LA)+ListLength(LB))</p><blockquote><p>算法2.17 有序表合并——用链表实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_L</span><span class="hljs-params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;<br>  pa = La-&gt;next;<br>  pb = Lb-&gt;next;<br>  <span class="hljs-comment">// pc指针指向头结点</span><br>  pc = Lc = La; <span class="hljs-comment">// 用La的头结点作为Lc的头结点</span><br>  <span class="hljs-keyword">while</span>(pa &amp;&amp; pb)&#123;<br>    <span class="hljs-keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;<br>      pc-&gt;next = pa;<br>      pc = pa;<br>      pa = pa-&gt;next;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      pc-&gt;next = pb;<br>      pc = pb;<br>      pb = pb-&gt;next;<br>    &#125;<br>  &#125;<br>  pc-&gt;next = pa ? pa : pb;  <span class="hljs-comment">// 插入剩余段</span><br>  <span class="hljs-keyword">delete</span> Lb;  <span class="hljs-comment">// 删除Lb的头结点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为：O(ListLength(La)+ListLength(Lb))</p><p>空间复杂度为：O(1)</p><h2 id="2-8-案例分析与实现"><a href="#2-8-案例分析与实现" class="headerlink" title="2.8 案例分析与实现"></a>2.8 案例分析与实现</h2><blockquote><p>案例2.1：一元多项式的运算，实现两个多项式的加、减、乘运算</p></blockquote><p>可用顺序表实现。</p><blockquote><p>案例2.2：稀疏多项式的运算</p></blockquote><p>对于稀疏多项式，可考虑创建一个新的结构体，分别保存指数和系数。</p><p>利用顺序表实现时存在<strong>存储空间分配不灵活、运算得空间复杂度高</strong>等缺点。可考虑利用链式存储结构实现。</p><p>定义新的链表结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span>&#123;<br>  <span class="hljs-type">float</span> coeff;  <span class="hljs-comment">// 系数</span><br>  <span class="hljs-type">int</span> expn;     <span class="hljs-comment">// 指数</span><br>  PNode *next;  <span class="hljs-comment">// 指针域</span><br>&#125;PNode， *Polynomial;<br></code></pre></td></tr></table></figure><ul><li><p>多项式相加</p><ul><li><p>多项式创建——算法步骤</p><ol><li><p>创建一个只有头结点的空链表；</p></li><li><p>根据多项式的项的个数n，循环n次执行以下操作：</p><ul><li><p>生成一个新结点*s；</p></li><li><p>输入多项式当前项的系数和指数赋给新结点*s的数据域；</p></li><li><p>设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点；</p></li><li><p>指针q初始化，指向首元结点；</p></li><li><p>循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点*q；</p></li><li><p>将输入项结点*s插入到结点q之前。</p></li></ul></li></ol></li><li><p>多项式创建——算法描述(头插法)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatePolyn</span><span class="hljs-params">(Polynomial &amp;P, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  <span class="hljs-comment">// 输入m项的系数和指数，建立表示多项式的有序链表P</span><br>  P = <span class="hljs-keyword">new</span> PNode;<br>  P-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先建立一个带头结点的单链表</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;  <span class="hljs-comment">// 依次输入n个非零项</span><br>    s = <span class="hljs-keyword">new</span> PNode;  <span class="hljs-comment">// 生成新结点</span><br>    cin &gt;&gt; s-&gt;coef &gt;&gt; s-&gt;expn;<br>    pre = p;      <span class="hljs-comment">// pre用于保存q的前驱，初值为头结点</span><br>    q = p-&gt;next;  <span class="hljs-comment">// q初始化，指向首元结点</span><br>    <span class="hljs-keyword">while</span>(q &amp;&amp; q-&gt;expn &lt; s-&gt;expn)&#123;  <span class="hljs-comment">// 找到第一个大于输入项指数的项*q</span><br>      pre = q;<br>      q = p-&gt;next;<br>    &#125;<br>    s-&gt;next = q;  <span class="hljs-comment">// 将输入项s插入到q和其前驱结点pre之间</span><br>    pre-&gt;next = s;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多项式相加——算法步骤</p><ol><li><p>指针p1和p2初始化，分别指向Pa和Pb的首元结点。</p></li><li><p>p3指向和多项式的当前结点，初值为Pa的头结点。</p></li><li><p>当指针p1和p2均未到达相应表尾时，则循环比较p1和p2所指结点对应的指值(p1-&gt;expn与p2-&gt;expn)，有下列三种情况：</p><ul><li><p>当p1-&gt;expn &#x3D;&#x3D; p2-&gt;expn时，则将两个结点中的系数相加</p><ul><li><p>若和不为零，则修改p1所指结点的系数值，同时删除p2所指结点</p></li><li><p>若和为零，则删除p1和p2所指结点</p></li></ul></li><li><p>当p1-&gt;expn &lt; p2-&gt;expn时，则应摘取p1所指结点插入到“和多项式”链表中表；</p></li><li><p>当p1-&gt;expn &gt; p2-&gt;expn时，则应摘取p2所指结点插入到“和多项式”链表中表；</p></li></ul></li><li><p>将非空多项式的剩余段浦入到p3所指结点之后</p></li><li><p>释放Pb的头结点。</p></li></ol></li></ul></li></ul><blockquote><p>案例2.3 图书信息管理系统</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构绪论——王卓</title>
    <link href="/2022/10/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-数据结构绪论"><a href="#第一章-数据结构绪论" class="headerlink" title="第一章 数据结构绪论"></a>第一章 数据结构绪论</h1><h2 id="1-1-数据结构的研究内容"><a href="#1-1-数据结构的研究内容" class="headerlink" title="1.1 数据结构的研究内容"></a>1.1 数据结构的研究内容</h2><p>计算机进行数值计算式，首先从具体问题抽象出数学模型，然后设计一个解此数学模型的算法，最后编写程序，进行测试、调试，直到解决问题。</p><p><strong>数据结构</strong>是一门研究<strong>非数值计算</strong>的程序设计中计算机的操作对象（表、树、图等）以及它们之间关系和操作的学科。</p><h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><h3 id="1-2-1-数据、数据元素、数据项和数据对象"><a href="#1-2-1-数据、数据元素、数据项和数据对象" class="headerlink" title="1.2.1 数据、数据元素、数据项和数据对象"></a>1.2.1 数据、数据元素、数据项和数据对象</h3><p><strong>数据</strong>(<strong>Data</strong>)：是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p><strong>数据元素</strong>(<strong>Data Element</strong>)：是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、记录、结点或顶点等。</p><p><strong>数据项</strong>(<strong>Data Item</strong>)：是组成数据元素的、有独立含义的、不可分割的最小单位。</p><p><strong>数据对象</strong>(<strong>Data Object</strong>)：是性质相同的数据元素的集合，是数据的一个子集。不论数据元素集合是无限集（如整数集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生表）的集合，只要集合内元素的性质均相同，都可称之为一个数据对象。</p><blockquote><p>数据元素与数据对象：</p></blockquote><p>数据元素——组成数据的基本单位，与数据的关系是：集合的个体。</p><p>数据对象——性质相同的数据元素的集合，与数据的关系是：集合的子集。</p><h3 id="1-2-2-数据结构"><a href="#1-2-2-数据结构" class="headerlink" title="1.2.2 数据结构"></a>1.2.2 数据结构</h3><p><strong>数据结构</strong>(<strong>Data Structure</strong>)是<strong>相互之间存在一种或多种特定关系</strong>的数据元素的集合。</p><p>换而言之，数据元素之间不是孤立存在的，它们之间存在某种关系，<strong>数据元素相互之间的关系称为结构</strong>(<strong>structure</strong>)。</p><p>数据结构是带结构的数据元素的集合。</p><blockquote><p>数据结构包括以下三个方面的内容：</p></blockquote><ol><li><p>数据元素之间的逻辑关系，也称为<strong>逻辑结构</strong>。</p></li><li><p>数据元素及其关系在计算机构中的表示（又称为映像），称为数据的<strong>物理结构</strong>或数据的<strong>存储结构</strong>。</p></li><li><p>数据的<strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</p></li></ol><blockquote><p>数据结构的两个层次：</p></blockquote><ul><li><p>逻辑结构</p><ul><li>描述描述数据元素之间的逻辑关系</li><li>与数据的存储无关，独立于计算机</li><li>是从具体问题抽象出来的数学模型</li></ul></li><li><p>物理结构(存储结构)</p><ul><li>数据元素及其关系在计算机存储器中的结构（存储方式）</li><li>是数据结构在许算机中的表示</li></ul></li><li><p>逻辑结构与存储结构的关系</p><ul><li>存储结构是逻辑关系的映象与元素本身的映象</li><li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li><li>两者综合起来建立了数据元素之间的结构关系。</li></ul></li></ul><blockquote><p>逻辑结构的种类</p></blockquote><ol><li><p>划分方法一</p><ol><li><p>线性结构：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。例如：线性表、栈、队列、串。</p></li><li><p>非线性结构：一个结点可能有多个直接前趋和直接后继例如：树、图。</p></li></ol></li><li><p>划分方法二——四类基本逻辑结构</p><ol><li><p>集合结构：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。</p></li><li><p>线性结构：结构中的数据元素之间存在着一对一的线性关系。</p></li><li><p>树形结构：结构中的数据元素之间存在着一对多的层次关系。</p></li><li><p>图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。</p></li></ol></li></ol><blockquote><p>存储结构的种类</p></blockquote><p>四种基本的存储结构：顺序存储结构、链式存储结构、索引存储结构、散列存储结构。</p><ul><li><p>顺序存储结构</p><ul><li><p>用一组<strong>连续</strong>的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的<strong>存储位置</strong>来表示。</p></li><li><p>C语言中用数组来实现顺序存储结构</p></li></ul></li><li><p>链式存储结构</p><ul><li><p>用一组<strong>任意</strong>的存储单元存储数据元素，数据元素之间的逻辑关系用<strong>指针</strong>来表示。</p></li><li><p>C语言中用指针来实现链式存储结构</p></li><li><p>存储一个元素的同时，还存储了下一个元素的地址。</p></li></ul></li><li><p>索引存储结构</p><ul><li>在存储节点信息的同时，还建立附加的<strong>索引表</strong>。</li></ul></li><li><p>散列存储结构</p><ul><li>根据结点的关键字直接计算处该结点的存储地址。</li></ul></li></ul><h3 id="1-2-3-数据类型和抽象数据类型"><a href="#1-2-3-数据类型和抽象数据类型" class="headerlink" title="1.2.3 数据类型和抽象数据类型"></a>1.2.3 数据类型和抽象数据类型</h3><p>高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的<strong>取值范围</strong>，以及在这些数值范围上所允许进行的<strong>操作</strong>。</p><blockquote><p>数据类型(Data Type)</p></blockquote><p>数据类型是一组性质相同的<strong>值的集合</strong>以及定义于这个值集合上的<strong>一组操作</strong>的总称。</p><p>数据类型 &#x3D; 值的集合 + 值集合上的一组操作</p><blockquote><p>抽象数据类型(Abstract Data Type, ADT)</p></blockquote><p><strong>指一个数学模型以及定义在此数学模型上的一组操作。</strong></p><ul><li><p>由用户定义，从问题抽象出的<strong>数据模型</strong>（逻辑结构）</p></li><li><p>还包括定义在数据模型上的一组<strong>抽象运算</strong>（相关操作）</p></li><li><p>不考虑计算机内的具体存储结构与运算的具体实现算法</p></li></ul><blockquote><p>抽象数据类型的形式定义</p></blockquote><p>抽象数据类型可用(D, S, P)三元组表示：</p><ul><li><p>D是数据对象</p></li><li><p>S是D上的关系集</p></li><li><p>P是对D的基本操作</p></li></ul><blockquote><p>抽象数据类型(ADT)定义举例：Circle的定义</p></blockquote><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT抽象数据类型名&#123;<br>  Data<br>    数据对象的定义<br>    数据元素之间的逻辑关系定义<br>  Operation<br>    操作<span class="hljs-number">1</span><br>      初始条件<br>      操作结果描述<br>    操作<span class="hljs-number">2</span><br>      ......<br>    操作n<br>      ......<br>&#125;ADT 抽象数据类型名<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT Circle&#123;<br>  数据对象：D=&#123;r, x, y|r, x, y均为实数&#125;<br>  数据关系：R=&#123;&lt;r, x, y&gt;|r是半径, &lt;x, y&gt;是圆心坐标&#125;<br>  基本操作：<br>    <span class="hljs-built_in">Circle</span>(&amp;C, r, x, y)<br>      操作结果：构造一个圆<br>    <span class="hljs-type">double</span> <span class="hljs-built_in">Area</span>(C)<br>      初始条件：圆已存在<br>      操作结果：计算面积<br>&#125;ADT Circle<br></code></pre></td></tr></table></figure><h2 id="1-3-抽象数据类型的表示与实现"><a href="#1-3-抽象数据类型的表示与实现" class="headerlink" title="1.3 抽象数据类型的表示与实现"></a>1.3 抽象数据类型的表示与实现</h2><p>C语言实现抽象数据类型：</p><ul><li><p>用已有数据类型定义描述它的存储结构</p></li><li><p>用函数定义描述它的操作</p></li></ul><blockquote><p>抽象数据类型如何实现</p></blockquote><ul><li><p>抽象数据类型可以通过固有的数据类型（如整型、实型、字符型）来表示和实现。</p><ul><li>即利用处理器中已存在的数据类型来说明新的结构，用已实现的操作来组合新的操作。</li></ul></li></ul><h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><blockquote><p>算法的定义</p></blockquote><p>算法：对特定问题<strong>求解方法和步骤</strong>的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。</p><blockquote><p>算法的描述</p></blockquote><ul><li><p>自然语言</p></li><li><p>流程图</p></li><li><p>伪代码、类语言</p></li><li><p>程序代码</p></li></ul><blockquote><p>算法与程序</p></blockquote><p>程序 &#x3D; 数据结构 + 算法</p><ul><li><p>数据结构通过算法实现操作</p></li><li><p>算法根据数据结构设计程序</p></li></ul><blockquote><p>算法特性</p></blockquote><ul><li><p>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</p></li><li><p>确定性：对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，使算法的执行者或阅读者都能明确其含义及如何执行。</p></li><li><p>可行性：算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。</p></li><li><p>输入：一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。</p></li><li><p>输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。</p></li></ul><blockquote><p>算法设计的要求</p></blockquote><ul><li><p>正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。</p></li><li><p>可读性。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。</p></li><li><p>健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。</p></li><li><p>高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。</p></li></ul><blockquote><p>算法效率</p></blockquote><ul><li><p>时间效率：指的是算法所耗费的时间；</p></li><li><p>空间效率：指的是算法执行过程中所耗费的存储空间。</p></li></ul><p>时间效率和空间效率有时候是矛盾的。</p><blockquote><p>算法事件效率的度量</p></blockquote><ul><li><p>算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。</p></li><li><p>两种度量方法</p><ul><li><p>事后统计</p></li><li><p>事前分析</p></li></ul></li></ul><blockquote><p>事前分析算法</p></blockquote><p>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的<strong>时间</strong>与算法中进行的简单操作<strong>次数乘积</strong>。</p><p>算法运行时间 &#x3D; 一个简单操作所需的时间x简单操作次数</p><blockquote><p>算法时间复杂度的渐进表示法</p></blockquote><p>若有某个辅助函数f(n)，使得n趋近于无穷大时，T(n)&#x2F;f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)&#x3D;O(f(n))，称O(f(n))为<strong>算法的渐进时间复杂度</strong>(O是数量级的符号)，简称<strong>时间复杂度</strong>。</p><blockquote><p>分析算法时间复杂度的基本方法</p></blockquote><ol><li><p>找出<strong>语句频度最大</strong>的那条语句作为<strong>基本语句</strong></p></li><li><p>计算<strong>基本语句</strong>的频度得到问题规模n的某个函数f(n)</p></li><li><p>取其数量级用符号“O”表示</p></li></ol><p>有的情况下，算法中基本操作重复执行的次数还随问题的<strong>输入数据集</strong>不同而不同。</p><blockquote><p>算法时间复杂度</p></blockquote><ul><li><p>最坏时间复杂度：指在最坏情况下，算法的时间复杂度。</p></li><li><p>平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p></li><li><p>最好时间复杂度：指在最好情况下，算法的时间复杂度。</p></li></ul><p>对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度。</p><blockquote><p>算法时间效率的比较</p></blockquote><ul><li><p>当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊</p></li><li><p>时间复杂度按数量级递增顺序为：</p><ul><li><p>常数阶-&gt;对数阶-&gt;线性阶-&gt;线性对数阶-&gt;平方阶-&gt;立方阶-&gt;…-&gt;K次方阶-&gt;指数阶</p></li><li><p>O(1)-&gt;O(logn)-&gt;O(n)-&gt;O(nlogn)-&gt;O(n^2)-&gt;O(n^3)-&gt;…-&gt;O(n^K)-&gt;O(2^n)</p></li></ul></li></ul><blockquote><p>渐进空间复杂度</p></blockquote><p>空间复杂度：算法所需要的存储空间的度量。</p><p>算法要占据的空间：</p><ul><li><p>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</p></li><li><p>算法要使用的辅助空间</p></li></ul><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><blockquote><p>设计好算法的过程</p></blockquote><p>抽象数据类型 &#x3D; 数据的逻辑结构 + 抽象运算</p>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDL设计方法简介</title>
    <link href="/2022/09/30/HDL%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/09/30/HDL%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="HDL-设计与验证流程"><a href="#HDL-设计与验证流程" class="headerlink" title="HDL 设计与验证流程"></a>HDL 设计与验证流程</h2><p>虚线框表示的步骤可以根据项目的复杂度省略，而实线框表示的步骤为必须执行的步骤</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209300912607.png"></p><h3 id="关键设计步骤与概念"><a href="#关键设计步骤与概念" class="headerlink" title="关键设计步骤与概念"></a>关键设计步骤与概念</h3><h4 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h4><ul><li>RTL级：寄存器传输级</li><li>EDA工具：电子辅助设计工具</li></ul><h4 id="系统与功能模块定义"><a href="#系统与功能模块定义" class="headerlink" title="系统与功能模块定义"></a>系统与功能模块定义</h4><p>大型系统的设计与实现，首先要进行详细的系统规划和描述，此时HDL描述侧重整体系统的划分和实现对系统级的仿真侧重于对整个系统的功能和性能指标的考量。功能模块级设计时将系统整体功能划分为可实现的具体功能模块，大致确定模块间的接口，如时钟、读写信号、数据流、控制信号等。在有些情况下，还要根据系统要求，描述每个模块或进程的时序约束。另外在此层次，必须权衡整个系统多种的实现方式的优劣，选出系统性能指标优并且可以高效实现的设计方案</p><h4 id="行为级描述测试激励"><a href="#行为级描述测试激励" class="headerlink" title="行为级描述测试激励"></a>行为级描述测试激励</h4><p>最大特点是必须明确每个模块间的所有接口和边界。此时模块内部的功能已经明确，模块间的所有接口，顶层的输入、输出信号等在行为级已经被清晰地描述出来。</p><h4 id="寄存器传输级"><a href="#寄存器传输级" class="headerlink" title="寄存器传输级"></a>寄存器传输级</h4><p>寄存器传输级指不关注寄存器和组合逻辑的细节，通过描述寄存器到寄存器之间的逻辑功能描述电路的HDL层次。RTL级是比门级更高的抽象层次，一般使用RTL级语言描述硬件电路比门级描述电路简单、高效。寄存器传输级的最大特点是可以直接用综合工具综合为门级网表。RTL设计直接决定着设计的功能和效率</p><h4 id="对RTL级描述进行功能仿真"><a href="#对RTL级描述进行功能仿真" class="headerlink" title="对RTL级描述进行功能仿真"></a>对RTL级描述进行功能仿真</h4><p>一般来说需要对RTL级设计进行功能仿真，仿真的目的为验证RTL级描述是否与设计意图一致。</p><h4 id="逻辑综合（使用RTL级EDA工具）"><a href="#逻辑综合（使用RTL级EDA工具）" class="headerlink" title="逻辑综合（使用RTL级EDA工具）"></a>逻辑综合（使用RTL级EDA工具）</h4><p>RTL级综合指将RTL级HDL语言翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件。最重要的代码设计层次就是RTL级</p><h4 id="门级"><a href="#门级" class="headerlink" title="门级"></a>门级</h4><p>门级描述的特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述了设计的引脚、功能、时钟周期等所有信息。目前直接使用门级描述较少，直接使用门级描述的场合一般是ASIC和FPGA设计中某些面积或时序要求较高的模块</p><h4 id="综合后门级仿真"><a href="#综合后门级仿真" class="headerlink" title="综合后门级仿真"></a>综合后门级仿真</h4><p>综合完成后，如果需要检查综合结果是否与原设计一致，就需要做综合后仿真。<br>在仿真时，把综合生产的标准延时文件反标注到综合仿真模型中去，可估计门延时带来的影响。<br>综合仿真虽然比功能仿真精确一些，但是只能估计门延时，不能估计线延时，仿真结果与布线后的实际情况还有一定的差距，并不十分准确<br>这种仿真的主要目的在于检查综合器的综合结果是否与设计输入一致，如果设计者确信自己表述明确，没有综合歧义发生，则可以省略这一步</p><h4 id="布局规划与布局布线"><a href="#布局规划与布局布线" class="headerlink" title="布局规划与布局布线"></a>布局规划与布局布线</h4><p>综合的门级结果最终要映射到目标库或目标器件</p><h4 id="布局布线后时序仿真与验证"><a href="#布局布线后时序仿真与验证" class="headerlink" title="布局布线后时序仿真与验证"></a>布局布线后时序仿真与验证</h4><p>将最终的布局规划或者布局布线的时延信息反标注到设计网表中，所进行的仿真就叫时序仿真或布局规划与布局布线后仿真，<strong>简称后仿真</strong><br>时序仿真包含的信息最全，所以最准确，能较好反映芯片的实际工作情况<br>一般来说建议进行此步骤，检查设计时序与芯片的实际运行情况是否一致<br>时序仿真主要目的在于发现时序违规</p>]]></content>
    
    
    <categories>
      
      <category>Verilog HDL实用精解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半导体二极管</title>
    <link href="/2022/09/19/%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1/"/>
    <url>/2022/09/19/%E5%8D%8A%E5%AF%BC%E4%BD%93%E4%BA%8C%E6%9E%81%E7%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="常见结构"><a href="#常见结构" class="headerlink" title="常见结构"></a>常见结构</h2><ul><li>二极管的几种外形<ul><li>将PN结用外壳封装起来，并加上电极引线就构成了半导体二极管</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191114072.png"></li></ul></li><li>二极管的几种常见结构<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191116543.png"></li><li>a是点接触型</li><li>b是面接触型</li><li>c是平面型</li></ul></li></ul><h2 id="伏安特性"><a href="#伏安特性" class="headerlink" title="伏安特性"></a>伏安特性</h2><ul><li>二极管的伏安特性<ul><li>伏安特性曲线</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191123558.png"><ul><li>与PN结的区别<ul><li>由于体电阻的存在，相同电压下，电流比PN结小</li><li>反向电流大一些</li></ul></li></ul></li><li>温度的影响<ul><li>温度升高，正向左移，反向下移</li><li>在室温的情况下，每升高1摄氏度，正向电压降2-2.5毫伏，每升高10摄氏度，反向电流增大一倍</li></ul></li><li>应用<ul><li>可做温度传感器</li></ul></li></ul></li></ul><h2 id="二极管的应用"><a href="#二极管的应用" class="headerlink" title="二极管的应用"></a>二极管的应用</h2><ul><li><p>参数</p><ul><li>$I_F$正向导通电流，应该要比工作要求大一些</li><li>$U_R$最高反向工作电压，一般为$U_{BR}$的百分之五十</li><li>$I_R$反向电流，越小反向截止特性越好</li><li>$f_M$最高工作频率，否则二极管的单向导电性会被破坏，电流会在二极管里面的电容出现。</li></ul></li><li><p>二极管的等效电路</p><ul><li>用伏安特性折线化得到的等效电路<ul><li>（均为直流情况下）左为理想二极管，中为理想二级管加电源，正向导通时端电压为常量，右为理想二极管加电源和电阻，正向导通时端电压与电流成线性关系<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209241238831.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261036042.png"></li></ul></li><li>二极管的微变等效电路<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261052851.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261053878.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261053039.png"><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261054083.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261146863.png"></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>龙芯</category>
      
      <category>模拟电子技术基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章-常用半导体器件</title>
    <link href="/2022/09/13/%E5%B8%B8%E7%94%A8%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6--%E6%A8%A1%E7%94%B5/"/>
    <url>/2022/09/13/%E5%B8%B8%E7%94%A8%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6--%E6%A8%A1%E7%94%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="常用半导体"><a href="#常用半导体" class="headerlink" title="常用半导体"></a>常用半导体</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h3><ul><li>半导体<ul><li>概念：导电能力介于导体与绝缘体之间</li><li>本征半导体：纯净的、具有晶体结构的半导体</li></ul></li><li>本征半导体的晶体结构<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131118308.png"></li></ul></li><li>载流子<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131122995.png"></li><li>本征激发<ul><li>速度与温度有关，温度越高，本征激发越快</li></ul></li><li>自由电子</li><li>空穴，注意空穴的移动是相对的，是由于价电子按一定方向填补空穴，导致空穴相对移动</li><li>复合：与本征激发相反的一个运动<ul><li>与载流子浓度有关</li></ul></li></ul></li><li>载流子的浓度（导电性能与什么有关？？–载流子的浓度）<ul><li>温度升高时，本征激发速度加快，载流电子变多，载流子浓度升高，复合加快，最后达到一个动态平衡，本征激发的速度与复合的速度相等</li><li>但是加热并不是一个很好的提高导电性能的方法，加热到70度以上，材料本身就不行了，那么用什么办法来提高导电性能呢？？–杂质半导体</li></ul></li><li>杂质半导体<ul><li>概念：掺入少量的杂质元素</li><li>N型半导体<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131204033.png"></li><li>掺入少量五价元素磷</li><li>五价磷进入，代替硅原子，四个电子形成共价对，还有一个电子很容易就出来，变成自由电子，这就使得半导体内自由电子大大增加</li><li>多子：自由电子，因为很多</li><li>少子：空穴，空穴少</li><li>导电主要靠自由电子，电子带负电，而N型半导体的N就代表negative，代表电子是多子（注意即使这样，半导体还是不带电，因为失去电子的磷离子带正电，正好和磷原子产生的自由电子数目一样，互相抵消）</li><li>此时温度因素对自由电子影响就很小了，温度升高而产生出的自由电子太少了，但是对少子影响很大</li><li>掺入的杂质越多，多子（自由电子）的浓度就越高，导电性能也就越强</li><li>磷原子可提供电子，因此被称为施主原子</li></ul></li><li>P型半导体<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131406422.png"></li><li>P代表Positive，表示多子是带正电的空穴</li><li>掺入少量三价杂质原子，比如硼</li><li>硼原子最外层有三个价电子，当它们与周围的硅原子形成共价键时，就产生了一个“空位”，空位为电中性，当硅原子的外层电子填补此空位时，其共价键中便产生一个空穴，而杂质原子成为不可移动的负离子</li><li>P型半导体，空穴为多子，自由电子为少子，主要靠空穴导电，掺入杂质越多，空穴的浓度就越高，使得导电性能越强</li><li>因为杂质原子中的空位吸收电子，故被称之为受主原子</li></ul></li><li>由以上分析可知，由于掺入的杂质使多子的数目大大增加，从而使多子与少子复合的机会大大增多。因此，对于杂质半导体，多子的浓度越高，少子的浓度就越低。可以认为，多子的浓度约等于所掺杂质原子的浓度，因而它受温度的影响很小，而少子是本征激发形成的，所以尽管其浓度很低，却对温度非常敏感，这将影响半导体器件的性能</li></ul></li></ul><h3 id="PN结的形成"><a href="#PN结的形成" class="headerlink" title="PN结的形成"></a>PN结的形成</h3><ul><li>PN结的形成<ul><li>扩散运动：多子</li><li>空间电荷区：可称为耗尽层，阻挡层，PN结 </li><li>漂移运动：少子在空间电场区的电场力作用下的运动</li><li>对称结、不对称结：不对称结指两边掺杂浓度不一样，浓度高的地方空间电荷区窄，浓度低的地方空间电荷区宽</li></ul></li><li>PN结的单向导电性<ul><li>把PN结外加正向电压<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141201475.png"></li><li>外电场削弱内电场，随着内电场慢慢被削弱，电流猛猛增长，所以要对电流加一个限制，于是电路中有一个限流电阻R，使得电路中电流最大也不会超过U&#x2F;R</li></ul></li><li>PN结外加反向电压<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141208161.png"></li><li>PN结越来越厚，阻碍作用越来越强，最后截止</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141430450.png"></li><li>PN结的电流方程<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141431775.png"></li><li>锗管0.2V-0.3V     硅管0.6-0.7V</li></ul></li><li>PN结的伏安特性<ul><li>正向特性<ul><li>死区</li></ul></li><li>反向特性</li><li>反向击穿<ul><li>雪崩击穿（掺杂浓度低）：温度越高，需要的击穿电压越高</li><li>齐纳击穿（掺杂浓度高）：温度越高，需要的击穿电压越低</li><li>反向击穿，PN结不一定就坏了，反向击穿电压可以通过掺杂浓度控制。如果能控制其不过热，那么它还可以从通过降低反向电压将击穿状态逆回去，但是一旦过热发生二次击穿，那PN结就彻底坏了</li><li>PN结的伏安图中，U（BR）这个地方，电流变化极大，而电压基本不变，利用这一特性可以做出稳压二极管。</li></ul></li></ul></li><li>PN结的电容效应<ul><li>势垒电容：可以做可变电容</li><li>扩散电容：非平衡少子和电压之间的关系</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>龙芯</category>
      
      <category>模拟电子技术基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正逻辑和负逻辑</title>
    <link href="/2022/09/12/%E6%AD%A3%E9%80%BB%E8%BE%91%E5%92%8C%E8%B4%9F%E9%80%BB%E8%BE%91/"/>
    <url>/2022/09/12/%E6%AD%A3%E9%80%BB%E8%BE%91%E5%92%8C%E8%B4%9F%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单逻辑门电路</title>
    <link href="/2022/09/12/%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/"/>
    <url>/2022/09/12/%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191032272.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191034597.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191036993.png"></p><h2 id="二极管与门电路"><a href="#二极管与门电路" class="headerlink" title="二极管与门电路"></a>二极管与门电路</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191410568.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191412395.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191412148.png"></p><h2 id="二极管或门电路"><a href="#二极管或门电路" class="headerlink" title="二极管或门电路"></a>二极管或门电路</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418343.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418004.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418583.png"></p><h2 id="非门电路-反相器"><a href="#非门电路-反相器" class="headerlink" title="非门电路-反相器"></a>非门电路-反相器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191419553.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191419536.png"><br>椭圆处相当于断开</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191420754.png"><br>三极管导通，接地</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半导体器件的开关特性</title>
    <link href="/2022/09/12/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7/"/>
    <url>/2022/09/12/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="半导体器件的开关特性"><a href="#半导体器件的开关特性" class="headerlink" title="半导体器件的开关特性"></a>半导体器件的开关特性</h1><ul><li><p>半导体</p><ul><li>常温下导电性能介于导体和绝缘体之间的材料</li><li>特性：半导体是一种导电性可受控制，范围可从绝缘体至导体之间的材料</li><li>常见的半导体材料：硅、砷化镓、锗</li><li>常见半导体元件：晶体二极管、晶体三极管</li></ul></li><li><p>半导体器件的开关特性</p><ul><li>以开关方式运用 </li><li>运用在开关频率十分高的电路中</li><li>静态特性<ul><li>半导体器件处于导通和截止两种稳定状态下的特性</li></ul></li><li>动态特性<ul><li>半导体器件在导通和截止两种状态转换过程中的特性</li><li>反向恢复时间<ul><li>让电路截止时，不是马上截止的，有一个恢复时间，这个恢复时间越短，电路变化的次数才可能做到越快，决定了元件的性能</li><li>从开通变成截止的时间</li></ul></li><li>开通时间</li><li>从截止变成导通的时间</li></ul></li></ul></li><li><p>晶体二极管的开关特性</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131022934.png"></li><li>静态特性<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121811012.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121811597.png"><ul><li>Vth是门槛电压，当电压等于门槛电压时，管子开始导通；大于门槛电压时，彻底导通</li><li>Vbr是反向击穿电压，随着反向电压增加，反向电流猛增，二极管被击穿</li></ul></li><li>单向导电性</li><li>正向导通</li><li>反向截止<ul><li>正向导通时可能因为电流过大而导致二极管烧坏</li><li>组成实际电路时，通常串接一只电阻R，以限制二极管正向电流</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121818009.png"></li></ul></li></ul></li><li><p>动态特性</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121819846.png"></p><ul><li>加了反向电压后，并不是马上是电路为0，而是一个过程</li><li>ts叫做存储时间</li><li>tt加做渡越时间</li><li>反向恢复时间tre&#x3D;ts+tt</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121823049.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131014962.png"><ul><li>当它的电压相反时，空间电荷区发生变化，使得电流方向互反</li></ul></li><li>还有个概念叫开通时间，相对于反向恢复时间，非常短<ul><li>不需要重点讨论，但需要把物理上原因搞清楚，为什么开通时间很短？模拟电路的知识能搞明白！！！找一本模拟电路的书看看</li><li>截止转为正向导通所需的时间</li><li>主要由外电路参数决定</li><li>加入输入电压后，回路电流几乎是立即达到最大值</li><li>开通时间与反向恢复时间相比很小，可以忽略不计</li></ul></li></ul></li><li><p>晶体三级管的开关特性</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131021557.png"></li><li>三种状态<ul><li>截止、放大、饱和</li></ul></li><li>三极管的静态特性（在截止和饱和这两种稳态下的特性） <ul><li>由基极信号控制的无触点开关，其作用对应与开关的闭合和断开</li></ul></li><li>三级管的动态特性（三极管在饱和与截止两种状态转换过程中的具有的特性）<ul><li>三极管内部存在着电荷的建立与消失过程</li><li>饱和和截止两种状态的转换需要一定的时间才能完成</li></ul></li></ul></li></ul></li><li><p>简单逻辑门电路</p><ul><li>二极管与门电路</li><li>二极管或门电路</li><li>非门电路-反相器</li><li>非门电路-BJT反相器</li></ul></li><li><p>典型TLL与非门电路</p><ul><li>电路结构<ul><li>输入级<ul><li>多发射极T1和电阻R1</li><li>3个输入信号通过的发射结实现与功能</li></ul></li><li>中间级<ul><li>晶体管T2和电阻R2和R3组成</li><li>T2集电极和发射极分别控制T3和T4</li></ul></li></ul></li><li>输出级（推拉式）<br> - 晶体管T3、T4、二极管D4和电阻R4<br> - 优点：提高开关速度和负载能力</li><li>工作原理<ul><li>输入电压为高、输出电压为低</li><li>输入电压有低、输出电压为高</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路的分类（了解即可）</title>
    <link href="/2022/09/12/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <url>/2022/09/12/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h1><ul><li><p>集成电路</p><ul><li>一个电路中所需的晶体管、二极管、电阻、电容和电感等元件及布线互连一起，制作在一小块或几小块半导体晶片或介质基片上</li><li>通过引脚与外部联系</li><li>特点<ul><li>可靠性高</li><li>可维护性好</li><li>功耗低 </li><li>成本低</li><li>大大简化设计和调试过程</li></ul></li></ul></li><li><p>数字集成电路分类</p><ul><li>根据半导体器件进行分类<ul><li>双极型集成电路<ul><li>采用双极型半导体器件作为元件</li><li>速度快、负载能力强，功耗较大、集成度较低</li><li>双极型集成电路又包括：<ul><li>TTL：三极管-三极管电路</li><li>ECL：射极耦合电路</li><li>$I^2$L:集成注入电路</li></ul></li></ul></li><li>单极型集成电路<ul><li>金属-氧化物半导体场效应管作为元件</li><li>结构简单、制造方便、集成度高、功耗低，速度较慢</li></ul></li></ul></li><li>根据集成电路规模的大小进行分类<ul><li>SSI（小规模集成电路）<ul><li>逻辑门小于10门或元件数小于100个</li></ul></li><li>MSI（中规模集成电路）<ul><li>逻辑门10门<del>99门或元件数100个</del>999</li></ul></li><li>LSI（大规模集成电路）<ul><li>逻辑门数为100门<del>9999门或元件数1000个</del>9999个</li></ul></li><li>VLSI（超大规模集成电路）<ul><li>逻辑门数大于10000门或元件数大于100000个</li></ul></li></ul></li><li>根据设计方法和功能定义分类<ul><li>非用户定制电路：标准集成电路<ul><li>特点：生产量大、使用方便、价格便宜</li><li>各种小、中、大规模通用集成电路</li></ul></li><li>全用户定制电路：专用集成电路ASIC<ul><li>为了满足用户特殊应用要求而专门生产的集成电路</li><li>特点：可靠性高、保密性好；设计费用高、销量小</li></ul></li><li>半用户定制电路<ul><li>厂家生产出功能不确定的集成电路，用户对已有的芯片进行功能定义将通用产品专用化</li><li>可编程逻辑器件</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2022/09/11/Git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/11/Git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p>常用命令</p><ul><li>git init<ul><li>初始化，在本地git bash使用此命令后创建.git文件夹，使本地文件夹成为仓库，即每次版本的代码都会在里面</li></ul></li><li>git clone &lt;链接&gt; 将所需要的东西下载到本地，且用此命令下载的是仓库，里面的每次修改也在里面，而直接download zip 只是最新版本</li><li>git add<ul><li>git add 后可跟文件名也可直接git add -A 表示将所有文件送入暂存区</li></ul></li><li>git commit<ul><li>git commit -m “引号里面输入你对提交的信息的描述”    用于提交信息</li></ul></li><li>git checkout &lt;文件名&gt;<ul><li>在工作区中的更改给打回去</li></ul></li><li>git reset HEAD^<ul><li>提交后撤回</li></ul></li><li>git push 推送当前分支的最新提交到远程</li><li>git pull   拉取远程分支最新的提交到本地</li><li>本地远程双向更新先pull后push</li></ul></li><li><p>分支</p><ul><li>git checkout -b  &lt;分支名&gt; 从当前节点新建分支 </li><li>git branch 列举所有分支</li><li>git checkout &lt;分支名&gt; 单纯切换到某个分支</li><li>git branch -D &lt;分支名&gt; 删掉特定的分支</li><li>git merge &lt;分支名&gt; 合并分支</li></ul></li><li><p>远程</p><ul><li>命令git remote add origin <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:Nick-JY&#x2F;Loongson_FirstLogs.git  </li><li>git push origin 本地分支名:远程分支名</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209112251180.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121048470.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121055062.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121128369.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121131666.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121456714.png"></p>]]></content>
    
    
    <categories>
      
      <category>龙芯</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑函数化简</title>
    <link href="/2022/09/11/%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E5%8C%96%E7%AE%80/"/>
    <url>/2022/09/11/%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E5%8C%96%E7%AE%80/</url>
    
    <content type="html"><![CDATA[<h2 id="逻辑函数化简法"><a href="#逻辑函数化简法" class="headerlink" title="逻辑函数化简法"></a>逻辑函数化简法</h2><h3 id="代数化简法"><a href="#代数化简法" class="headerlink" title="代数化简法"></a>代数化简法</h3><ul><li>代数化简法<ul><li>参考离散数学</li></ul></li></ul><h3 id="卡诺图化简法"><a href="#卡诺图化简法" class="headerlink" title="卡诺图化简法"></a>卡诺图化简法</h3><ul><li>卡诺图化简法<ul><li><p>卡诺图是一个平面的方格图，每一个小方格代表一个最小项</p></li><li><p>2变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111007414.png"></p></li><li><p>3变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111013107.png"></p></li><li><p>11和10为什么换了位置呢？–对于01和11只有一个变量不同，同样，对于11和10也只有一个变量不同，对于00和10也只有一个变量不同，这样排列能够让相邻最小项挨在一起</p></li><li><p>4变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111013379.png"></p></li><li><p>卡诺图特点</p><ul><li>n个变量的卡诺图由2的n次方个小方格构成</li><li>几何图形上处在相邻、相对、相重位置的小方格代表的最小项为相邻最小项</li><li>卡诺图中最小项排列方案不是惟一的</li><li>但是任何一种方案都应保证能清楚反映最小项的相邻关系</li><li>相邻关系最小项只有一位相反</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111019097.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111019517.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111020055.png"></li></ul></li><li><p>逻辑函数在卡诺图上的表示</p><ul><li>标准与-或表达式在卡诺图上的表示<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111022838.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111022041.png"></li></ul></li><li>一般与-或表达式的卡诺图<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111024909.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111026972.png"></li><li>AB取11，CD取11，所在行和列填1，A非B非C,再补充填1</li></ul></li></ul></li><li><p>卡诺图上最小项的合并规律</p><ul><li>理论依据：并项定理</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111121375.png"></li><li>两个相邻最小项有一个变量互反，可以合并为一项，消去一个变量</li><li>卡诺图的重要特征：直观、清晰地反映了最小项的相邻关系</li><li>卡诺图化简逻辑函数的基本原理<ul><li>将逻辑依据和图形特征结合起来</li><li>将卡诺图上表征相邻最小项的相邻小方格“圈”在一起进行合并</li><li>达到用一个简单与项代替若干最小项的目的</li><li>用来包围那些能由一个简单与项代替的若干最小项的圈称为“卡诺圈”</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111142393.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111222401.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111223287.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111224274.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111226921.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111228271.png"></li><li>总结<ul><li>卡诺图中小方格的个数必须为$2^m$个，m为小于或等于n的整数</li><li>卡诺图中的$2^m$个小方格含有m个不同变量,（n-m）个相同变量</li><li>卡诺图中的$2^m$个小方格对应的最小项可用（n-m）个变量的“与”项表示，该“与项”由这些最小项中的相同变量构成</li><li>当m&#x3D;n时，卡诺圈包围了整个卡诺图，可用1表示，即n个变量的全部最小项之和为1</li></ul></li></ul></li><li><p>卡诺图化简逻辑函数的步骤</p><ul><li>几个术语<ul><li>蕴涵项：“与-或”表达式中，每个与项被称为该函数的蕴涵项<ul><li>注：在函数卡诺图中，任何一个1方格所对应的最小项或者卡诺圈中的$2^m$各1方格对应的与项都是函数的蕴涵项</li></ul></li><li>质蕴涵项：若函数的一个蕴涵项不是该函数中其他蕴涵项的子集，则称为质蕴涵项，简称为质项<ul><li>在函数卡诺图中，按照最小项合并规律</li><li>如果某个卡诺圈不可能被其他更大的卡诺圈包含</li><li>该卡诺圈所对应的与项为质蕴涵项</li></ul></li><li>必要质蕴涵项：若函数的一个质蕴涵项包含有不被函数的其他任何质蕴涵项所包含的最小项，则此质蕴涵项被称为必要质蕴涵项，简称为必要质项<ul><li>在函数卡诺图中，若某个卡诺圈包含了不可能被任何其他卡诺圈包含的1方格</li><li>该卡诺圈所对应的与项为必要质蕴涵项</li></ul></li></ul></li><li>求逻辑函数最简与-或表达式的一般步骤<ul><li>第一步：作出函数的卡诺图</li><li>第二步：在卡诺图上圈出函数的全部质蕴涵项</li><li>第三步：从全部质蕴涵项中找出所有必要质蕴涵项</li><li>第四步：求函数的最简质蕴涵项集<ul><li>当函数的所有必要质蕴涵项尚不能覆盖卡诺图上的所有1方格时</li><li>从剩余质蕴涵项中找出最简的所需质蕴涵项</li><li>使它和必要质蕴涵项一起构成函数的最小覆盖</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111316319.png"><ul><li>最小项标1，这些最小项就是蕴涵项</li><li>找出质蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111318159.png"></li><li>找出必要质蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111318523.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111319387.png"></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111346588.png"><ul><li>覆盖m10?–找到的必要质蕴涵项所在的卡诺圈应该覆盖所有蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111347349.png"></li><li>两个与-或式的复杂程度相同</li><li>一个函数的最简与-或表达式不一定是唯一的</li></ul></li></ul></li><li>卡诺图化简的原则<ul><li>在覆盖函数中所有最小项前提下，卡诺圈的个数应达到最少</li><li>在满足合并规律的前提下卡诺圈应达到最大</li><li>根据合并的需要，每个最小项可以被多个卡诺圈包围</li></ul></li><li>求逻辑函数最简或-与表达式的一般步骤”两次取反法“<ul><li>情况一：当给定逻辑函数为“与-或”表达式或者标准“与-或表达式”时 <ul><li>作出函数F的卡诺图</li><li>合并卡诺图上的0方格，求出反函数F‘的最简与-或表达式</li><li>对F’的最简与或表达式取反，得到或-与表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111403894.png"></li></ul></li><li>情况二：当给定逻辑函数为或-与表达式或标准或-与表达式时<ul><li>求出函数F的反函数F‘，并作出F’的卡诺图</li><li>合并卡诺图上的1方格，求出F‘最简与或表达式</li><li>对F’的最简与-或表达式取反，得到F的最简或-与表达式</li></ul></li></ul></li></ul></li><li><p>卡诺图化简的优缺点</p><ul><li>优点：方便、直观、容易掌握</li><li>缺点：受到变量个数的约束，当变量个数大于6时，画图以及对图形的识别都变得相当复杂</li></ul></li></ul></li></ul><h3 id="列表化简法"><a href="#列表化简法" class="headerlink" title="列表化简法"></a>列表化简法</h3><ul><li>列表化简法<ul><li>通过约定的表格形式，按照一定规则完成化简过程</li><li>通过找出函数F的全部质蕴涵项，必要质蕴涵项以及最简质蕴涵项集来求得最简表达式</li><li>列表化简法的步骤<ul><li>第一步：将函数表示成“最小项之和”形式，并用二进制码表示每一个最小项</li><li>第二步：做出质蕴涵项产生表，找出函数的全部质蕴涵项</li><li>第三步：做出必要质蕴涵产生表，找出函数的必要质蕴涵项</li><li>第四步：当必要质蕴涵项不能覆盖所有最小项时，借助所需的质蕴涵项产生表，找出函数的最小覆盖</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111456360.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111502526.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111503537.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111503587.png"></li><li>列表化简法特点<ul><li>优点：规律性强，对变量数较多的函数，可经过反复比较、合并，得到最简结果</li><li>适用：计算机处理</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>数字逻辑基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路设计实例</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071712386.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713039.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713450.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713896.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713270.png"></p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714955.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714333.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714011.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714851.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714578.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714124.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071715706.png"></p><h2 id="自启动问题"><a href="#自启动问题" class="headerlink" title="自启动问题"></a>自启动问题</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716529.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716582.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716894.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716984.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717729.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717060.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717475.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717771.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071718045.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071718022.png"></p><p>要讨论在无效状态时，电路输出和状态转移</p><ul><li>讨论<ul><li>电路是否具有自恢复功能<ul><li>电路万一偶然进入无效状态，如果能在输入信号时和时钟脉冲作用下自动进入有效状态，则称为具有自恢复功能，否则称为“挂起”</li><li>存在挂起，必须修正</li></ul></li><li>电路是否会产生错误输出信号<ul><li>电路万一处在无效状态，是否会在输入信号和时钟脉冲作用下产生错误输出信号</li><li>存在错误输出信号，必须修正</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071721689.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071721579.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722229.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722721.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722919.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722408.png"><br>对于无效序列，如果在某种输入情况下，电路可以回到正常序列中去，电路就不存在挂起问题了</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723138.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723171.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723035.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路设计过程</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="同步时序逻辑电路的设计步骤"><a href="#同步时序逻辑电路的设计步骤" class="headerlink" title="同步时序逻辑电路的设计步骤"></a>同步时序逻辑电路的设计步骤</h1><p>用尽可能少的触发器和逻辑门实现预定的逻辑要求</p><ul><li>完全确定同步时序逻辑电路<ul><li>电路在不同输入取值下都有确定的次态和输出</li></ul></li><li>不 完全确定同步时序逻辑电路<ul><li>电路中存在不确定的次态或输出，即某些状态在输入取值下的次态或输出是随意的<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071608587.png"></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071609288.png"></p><ul><li>第一步作原始状态图状态表的首要任务<ul><li>正确反映题意</li><li>是否最简不做要求</li></ul></li></ul><h1 id="原始状态图"><a href="#原始状态图" class="headerlink" title="原始状态图"></a>原始状态图</h1><ul><li>根据对设计要求的文字描述，抽象出电路的输入、输出以及状态之间的关系，形成状态图和状态表</li><li>先画状态图后画状态表</li></ul><h2 id="建立原始状态图步骤"><a href="#建立原始状态图步骤" class="headerlink" title="建立原始状态图步骤"></a>建立原始状态图步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071612910.png"></p><ul><li>确定各时刻电路的输出<ul><li>时序逻辑电路的功能是通过输出对输入的响应来体现的</li><li>在建立原始状态图时，必须确定各时刻的输出值<ul><li>在Moore型电路中，应指明每周状态下对应的输出</li><li>在Mealy型电路中应指明从每一个状态出发，在不同输入作用下的输出值</li></ul></li></ul></li><li>注意：<ul><li>状态数目能否达到最少无关紧要，因为可以再化简</li><li>设计者应把清晰、正确地描述设计要求放在第一位</li><li>一般用字母或数字表示状态</li></ul></li></ul><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616693.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616515.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616857.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617938.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617064.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617070.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617849.png"></p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618569.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618950.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618908.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071619460.png"></p><ul><li>总结<ul><li>一个序列检测器所需要的状态数与要识别的序列长度相关<ul><li>序列越长，需要记忆的代码位数越多，状态数也就越多</li></ul></li><li>Mealy型一般比Moore型所需状态数少</li></ul></li></ul><h2 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071621929.png"></p><p>代码检测器的特点是输入信号是按位分组的，每组的监测过程相同，即一组检测完后，电路回到初始状态，接着进行下一组的监测</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071622810.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071624175.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071624469.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071625568.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071625820.png"></p><h1 id="状态化简"><a href="#状态化简" class="headerlink" title="状态化简"></a>状态化简</h1><p>从原始状态表中消去多余状态，的到一个描述给定的逻辑功能的包含状态数目达到最少的状态表，即最简状态表或最小化状态表</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071628802.png"></p><ul><li>化简方法<ul><li>观察法</li><li>输出分类法</li><li>隐含表法</li></ul></li></ul><p>等效状态：<br>设S和J是完全确定状态表中的两个状态，若对于所有可能的输入序列，分别从S和J出发所得到的输出响应序列完全相同，则称它们是等效的</p><ul><li>等效状态的判断方法<ul><li>输出相同</li><li>次态输入下列情况之一<ul><li>次态相同</li><li>次态交错或为各自的现态</li><li>次态循环或为等效对</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071633310.png"></p><p>等效状态的性质：<br>等效状态具有传递性<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071634046.png"></p><p>等效类</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071634807.png"></p><p>最大等效类：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071635236.png"></p><h2 id="状态化简步骤"><a href="#状态化简步骤" class="headerlink" title="状态化简步骤"></a>状态化简步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636882.png"></p><h3 id="做隐含表"><a href="#做隐含表" class="headerlink" title="做隐含表"></a>做隐含表</h3><p>直角三角形阶梯网格<br>每个方格代表一个状态对</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636855.png"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636466.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636817.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636262.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637536.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637832.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637191.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071638004.png"></p><h1 id="状态编码"><a href="#状态编码" class="headerlink" title="状态编码"></a>状态编码</h1><p>给最小化状态表中用字母或数字表示的状态指定一个二进制代码，形成二进制状态表，也称状态分配，或者状态赋值</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640804.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640753.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640308.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640926.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640003.png"></p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640697.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641903.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641938.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641862.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641772.png"></p><h1 id="确定激励函数和输出函数"><a href="#确定激励函数和输出函数" class="headerlink" title="确定激励函数和输出函数"></a>确定激励函数和输出函数</h1><ul><li>触发器的激励表<ul><li>反映了触发器从现态转移到某种次态时，对输入条件的要求</li><li>把触发器的现态和次态作为自变量，而把触发器的输入作为因变量</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071643187.png"></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>列出激励函数和输出函数的真值表</li><li>用卡诺图化简后写出最简表达式</li><li>熟练时刻直接根据激励函数和输出函数真值表，作出激励函数和输出函数卡诺图化简</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071644897.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645942.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645674.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645148.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646456.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646483.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646182.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646374.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646346.png"><br>回答–确实<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646227.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646762.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071647300.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071647004.png"></p><p>注意：<br>在同步时序逻辑电路的设计中，采用不同的触发器，会导致激励函数不同，使得设计出来的检录的组合电路部分的复杂程度会不同。因此，在具体的设计中，要进行分析、对比，选择合适的存储元件，从而使最终设计的电路最简单</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路分析</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="同步时序逻辑的表格分析法"><a href="#同步时序逻辑的表格分析法" class="headerlink" title="同步时序逻辑的表格分析法"></a>同步时序逻辑的表格分析法</h1><p>分析的关键在于找出电路状态和输出随输入变化而变化的规律，以便确定其逻辑功能</p><h2 id="表格法分析步骤"><a href="#表格法分析步骤" class="headerlink" title="表格法分析步骤"></a>表格法分析步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071547947.png"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071548977.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071548315.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071549737.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550747.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550693.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550446.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550589.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550986.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071551959.png"></p><p>加1计数<br>2位二进制数逆计数器</p><h2 id="作时间图的一般步骤"><a href="#作时间图的一般步骤" class="headerlink" title="作时间图的一般步骤"></a>作时间图的一般步骤</h2><p>在时序逻辑电路分析中，除了状态图和状态表，通常还用到时间图</p><ul><li>作时间图的一般步骤<ul><li>假设电路初始状态，并拟定一典型输入序列</li><li>作出状态和输出响应序列</li><li>根据响应序列画出波形图</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071555605.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071555131.png"></p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071600116.png"></p><p>两个D触发器–相同时钟端，同步时序逻辑逻辑电路<br>三个或非门<br>输入：x<br>输出：z<br>电路的状态：<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602074.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602033.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602708.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602577.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602984.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602048.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071603845.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071603296.png"></p><p>实际问题分析时，可视具体情况灵活运用，根据给定逻辑电路的复杂程度不同，通常可以省去某些步骤，例如列次态真值表或画时间图等</p><h1 id="同步时序逻辑电路的代数分析法"><a href="#同步时序逻辑电路的代数分析法" class="headerlink" title="同步时序逻辑电路的代数分析法"></a>同步时序逻辑电路的代数分析法</h1><h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071557564.png"></p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558378.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558630.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558346.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558844.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071559344.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时序逻辑电路基础</title>
    <link href="/2022/07/27/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/27/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="时序逻辑电路概述"><a href="#时序逻辑电路概述" class="headerlink" title="时序逻辑电路概述"></a>时序逻辑电路概述</h1><ul><li>若逻辑电路在任何时候产生的稳定输出信号不仅与电路该时刻的输入信号有关，还与电路过去的输入信号有关，则称为时序逻辑电路</li></ul><h2 id="时序逻辑电路一般结构"><a href="#时序逻辑电路一般结构" class="headerlink" title="时序逻辑电路一般结构"></a>时序逻辑电路一般结构</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071510178.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051005132.png"><br>这是图左的电路分析</p><ul><li><p>状态</p><ul><li>时序逻辑电路的状态是存储电路对过去输入信号记忆的结果</li><li>随着外部信号的作用而变化</li><li>在对电路功能进行研究时，通常将某一时刻的现状称为现态</li><li>在某一状态下，外部信号发生变化后达到的新的状态称为次态</li></ul></li><li><p>时序逻辑电路的特点</p><ul><li>电路又组合电路和存储电路组成，具有对过去输入进行记忆的功能</li><li>电路中包含反馈回路，通过反馈使电路功能与时序相关</li><li>电路的输出由电路当时的输入和状态共同决定</li></ul></li></ul><h2 id="时序逻辑电路的分类"><a href="#时序逻辑电路的分类" class="headerlink" title="时序逻辑电路的分类"></a>时序逻辑电路的分类</h2><h3 id="按照电路的工作方式分类"><a href="#按照电路的工作方式分类" class="headerlink" title="按照电路的工作方式分类"></a>按照电路的工作方式分类</h3><ul><li><p>同步时序逻辑电路</p><ul><li>电路中有统一的定时信号，存储器件采用时钟控制触发器，电路状态在时钟脉冲控制下同时发生转换</li></ul></li><li><p>异步时序逻辑电路</p><ul><li>电路中没有统一的时钟信号同步，电路输入信号的变化将直接导致电路状态的变化</li></ul></li><li><p>电路状态的改变依赖于输入信号和时钟脉冲信号</p><ul><li>状态变化时间—-取决于时钟信号</li><li>状态如何变化—-取决于输入信号</li><li>每个状态维持时间—-取决于时钟脉冲的周期</li></ul></li></ul><p>研究同步时序逻辑电路时，通常不把同步时钟信号作为输入信号处理，而是将它当成一种默认的时间基准</p><p>同步时序逻辑电路中的现态与次态时针对某个时钟脉冲而言的</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071521085.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071521436.png"></p><ul><li>同步时序逻辑电路对时钟的要求（为了稳定可靠工作）<ul><li>脉冲的宽度—-必须保证触发器可靠翻转</li><li>脉冲的频率—-必须保证前一个脉冲引起的电路响应完全结束后，后一个脉冲才能到来</li></ul></li></ul><h3 id="按照电路输出与输入的依存关系分类"><a href="#按照电路输出与输入的依存关系分类" class="headerlink" title="按照电路输出与输入的依存关系分类"></a>按照电路输出与输入的依存关系分类</h3><ul><li>Mealy型—-时序逻辑电路的输出是电路输入和电路状态的函数</li><li>Moore型—-时序逻辑电路的输出仅仅是电路状态的函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071525968.png"><br>X是输入<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071525889.png"></p><ul><li><p>两者区别</p><ul><li><p>Mealy型电路的输入和输出之间存在直接联系</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051026577.png"></li></ul></li><li><p>Moore型电路则是将全部输入转换为电路状态后再和输出建立联系</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051026338.png"></li></ul></li></ul></li><li><p>Moore型电路的特殊状况</p><ul><li>时序逻辑电路没有专门的外部输入信号，而是以电路状态作为输出</li></ul></li></ul><h3 id="按照电路输入信号形式划分"><a href="#按照电路输入信号形式划分" class="headerlink" title="按照电路输入信号形式划分"></a>按照电路输入信号形式划分</h3><ul><li>脉冲型<ul><li>有相同的间隔</li></ul></li><li>电平型<ul><li>0和1间隔是不等的，是任意的</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071529650.png"></p><h2 id="时序逻辑电路的描述"><a href="#时序逻辑电路的描述" class="headerlink" title="时序逻辑电路的描述"></a>时序逻辑电路的描述</h2><ul><li>逻辑函数表达式<ul><li>输出函数表达式</li><li>激励函数表达式</li><li>次态函数表达式</li></ul></li><li>状态图</li><li>状态表</li><li>时间表</li></ul><h3 id="逻辑函数表达式"><a href="#逻辑函数表达式" class="headerlink" title="逻辑函数表达式"></a>逻辑函数表达式</h3><ul><li>激励函数表达式<ul><li>反映了存储电路的输入与外部的输入和电路状态之间的关系</li></ul></li><li>输出函数表达式<ul><li>反映电路输出与外部输入和状态之间关系</li></ul></li><li>次态函数表达式<ul><li>同步时序电路的次态与激励函数和电路现态之间的关系</li></ul></li></ul><h4 id="Moore型电路"><a href="#Moore型电路" class="headerlink" title="Moore型电路"></a>Moore型电路</h4><h5 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071534670.png"></p><h5 id="个例"><a href="#个例" class="headerlink" title="个例"></a>个例</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071536531.png"></p><h4 id="Mealy型电路"><a href="#Mealy型电路" class="headerlink" title="Mealy型电路"></a>Mealy型电路</h4><h5 id="范式-1"><a href="#范式-1" class="headerlink" title="范式"></a>范式</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071537820.png"></p><h5 id="个例-1"><a href="#个例-1" class="headerlink" title="个例"></a>个例</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071537364.png"></p><h3 id="状态表"><a href="#状态表" class="headerlink" title="状态表"></a>状态表</h3><ul><li>状态转移表</li><li>反映同步时序电路输出、次态与电路输入与现态之间关系的表格</li><li>状态表示同步时序电路分析和实际中常用的工具</li><li>非常清晰给出了同步时序电路在不同输入和现态下的次态和输出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071539807.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071540681.png"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>反映同步时序电路状态转换规律及相应输入、输出取值关系的有向图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071541443.png"></p><ul><li>优点<ul><li>直观、形象</li></ul></li><li>状态图和状态表对比<ul><li>状态表更规范</li><li>状态图更形象</li></ul></li></ul><p>时间图—-表示输入信号、输出信号和电路状态的取值在各时刻的对应关系的波形图，通常又称作为工作波形图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071543391.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>维持阻塞触发器</title>
    <link href="/2022/07/27/%E7%BB%B4%E6%8C%81%E9%98%BB%E5%A1%9E%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E7%BB%B4%E6%8C%81%E9%98%BB%E5%A1%9E%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="维持阻塞触发器"><a href="#维持阻塞触发器" class="headerlink" title="维持阻塞触发器"></a>维持阻塞触发器</h1><h2 id="典型维持阻塞D触发器"><a href="#典型维持阻塞D触发器" class="headerlink" title="典型维持阻塞D触发器"></a>典型维持阻塞D触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271100068.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271100886.png"><br>输入$R_D$ ,$S_D$</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>CP&#x3D;0<ul><li>RS&#x3D;11</li><li>Q不变</li></ul></li><li>CP&#x3D;1<ul><li>D&#x3D;0  Q&#x3D;0</li><li>D&#x3D;1   Q&#x3D;1</li><li>D: 0–&gt;1–&gt;0<ul><li>无空翻</li></ul></li><li>D: 1–&gt;0–&gt;1<ul><li>无空翻</li></ul></li></ul></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>结论<ul><li>CP&#x3D;0<ul><li>RS&#x3D;11</li><li>Q不变</li></ul></li><li>CP&#x3D;1<ul><li>Q&#x3D;D</li><li>无空翻<br>也就是逻辑功能和钟控D触发器一样</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271106444.png"><br>仅仅在时钟脉冲上升沿响应输入变化</p><ul><li>边沿触发器：仅在时钟脉冲的上升或下降的时刻相应输入信号的触发器<ul><li>只在时钟脉冲的边沿进行采样并确定触发器的状态</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031054950.png"></li><li>大大提高了抗干扰性<br>以后没有特殊说明，我们一般采用的就是维持阻塞触发器</li></ul></li></ul><h2 id="触发器的对比"><a href="#触发器的对比" class="headerlink" title="触发器的对比"></a>触发器的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271108435.png"></p><h2 id="TTL集成JK触发器——74LS76"><a href="#TTL集成JK触发器——74LS76" class="headerlink" title="TTL集成JK触发器——74LS76"></a>TTL集成JK触发器——74LS76</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271109582.png"></p><ul><li>集成触发器的性能参数<ul><li>直流参数<ul><li>电源电流</li><li>低电平输入电流</li><li>高电平输入电流</li><li>输出高电平</li><li>输出低电平</li><li>扇出系数</li></ul></li><li>开关参数<ul><li>最高时钟频率</li><li>时钟信号的延迟时间</li><li>直接置0端的延迟</li><li>直接置1端的延迟</li></ul></li></ul></li></ul><p><strong>熟记触发器的功能表、状态表、激励表、次态方程</strong></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主从J-K触发器</title>
    <link href="/2022/07/27/%E4%B8%BB%E4%BB%8EJ-K%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E4%B8%BB%E4%BB%8EJ-K%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="主从JK触发器"><a href="#主从JK触发器" class="headerlink" title="主从JK触发器"></a>主从JK触发器</h1><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031022993.png"><br>由主从RS触发器演变而来<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271052522.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271052718.png"></p><ul><li>优点<ul><li>输入信号J和K无约束</li><li>无空翻</li><li>功能全</li><li>使用方便</li></ul></li><li>缺点<ul><li>存在“一次翻转”问题</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271056877.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271056271.png"><br>t7和t11时刻为什么没有变化呢</p><ul><li>一次翻转：指在时钟脉冲作用（CP&#x3D;1）期间，主触发器的状态只能根据输入信号的变化改变一次<ul><li>主触发器在接收输入信号发生一次翻转之后，状态保持不变，不再受J、K变化的影响</li><li>和空翻不同，一次翻转会导致触发器的状态转移与触发器的逻辑功能不一致，这是不允许的</li></ul></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>造成一次翻转现象的原因是什么呢？<br>是因为我们引入了两个反馈线。<br>而钟控JK触发器也引入了两根反馈线，为什么就没事呢？<br>因为钟控JK触发器钟，J、K发生变化时，触发器的状态会跟着发生变化，因此每次J、K发生变化，反馈回来的都是上次J、K发生变化后的状态<br>而在主从JK触发器里，由于从触发器被锁，因此JK发生变化时，从触发器不能跟着变化，因此，反馈回来的不是JK当前的状态，而是从前的状态<br>当输入端JK出现干扰信号的时候，就可能破幻触发器的正常逻辑功能，为了客服这一缺点，就要求在时钟脉冲作用期间，输入JK的值不能发生变化，这就降低了它的抗干扰能力。<br>而且和主从RS触发器一样，这种对输入端的约束，就失去了主从结构的意义，因此主从JK触发器是不能使用的</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主从R-S触发器</title>
    <link href="/2022/07/27/%E4%B8%BB%E4%BB%8ER-S%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E4%B8%BB%E4%BB%8ER-S%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="主从RS触发器"><a href="#主从RS触发器" class="headerlink" title="主从RS触发器"></a>主从RS触发器</h1><p>为了解决空翻问题引入</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270933441.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270934220.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270935644.png"></p><ul><li>输入端$R_D$：直接置0端<ul><li>$R_D$等于0时，会使得Q等于0</li></ul></li><li>输入端$S_D$：直接置1端<ul><li>$S_D$等于0时，Q就等于1</li></ul></li><li>在正常工作时，它们都不能等于0，因为它一旦等于0，直接置0或者置1了。都等于0，又违背了约束条件，所以正常工作时，一般让它们都为1</li><li>因为它们都为1，对与非门是不起作用的，于是分析的时候可以不看它们</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270942684.png"><br>主触发器的输出是从触发器的输入<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270942377.png"><br>主触发器和从触发器时钟反相</p><ul><li>CP&#x3D;1<ul><li>从触发器锁定</li><li>主触发器响应</li></ul></li><li>CP&#x3D;0<ul><li>主触发器锁定</li><li>从触发器响应</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270948578.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>总结<ul><li>前沿采样</li><li>后沿定局</li><li>状态变化是在时钟脉冲的后沿</li><li>状态变化锁定在一个时间点，而不是一个时间段，过了这个状态，无论它怎么变化，主触发器的状态是被锁定的，因此不会导致从触发器发生变化（就是图中一点的例子），因此无“空翻”<br>对于此触发器而言。它的状态变化是发生在CP的下降沿，因此称它为下降沿触发器<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031013494.png"><br>加了一个小圆圈，加了表示下降沿触发，不加便是上升沿触发</li></ul></li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>主触发器输出</li><li>从触发器输入</li><li>与钟控触发器功能一致</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031015139.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271050266.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271050046.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时钟控制触发器</title>
    <link href="/2022/07/27/%E9%92%9F%E6%8E%A7%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E9%92%9F%E6%8E%A7%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="钟控触发器"><a href="#钟控触发器" class="headerlink" title="钟控触发器"></a>钟控触发器</h1><ul><li>具有时钟脉冲控制的触发器<ul><li>时钟控制触发器</li><li>定时触发器</li><li>clocked flip-flop</li></ul></li><li>工作特点<ul><li>何时转换？<ul><li>由时钟脉冲确定状态转换的时刻</li></ul></li><li>如何转换？<ul><li>由输入信号确定触发器状态转换的方向</li></ul></li></ul></li></ul><h2 id="钟控R-S触发器"><a href="#钟控R-S触发器" class="headerlink" title="钟控R-S触发器"></a>钟控R-S触发器</h2><p>加入两个与非门和一个时钟端CP<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917441.png"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917659.png"></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917694.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918772.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918396.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>钟控R-S触发器受时间脉冲信号控制，只有在CP&#x3D;1时，才会和或非门构成的R-S触发器功能相同。<br>但是它的输入信号仍然存在约束—-引入钟控D触发器</p><h2 id="钟控D触发器"><a href="#钟控D触发器" class="headerlink" title="钟控D触发器"></a>钟控D触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918114.png"><br><strong>在钟控RS触发器的基础上加了一根线，可以这样理解：原来的R变成现在的S’，而S’它等于（CP与D）的非，这样输入就变成一组互补的输入，不存在约束了</strong><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919484.png"></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919524.png"></p><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919432.png"><br>钟控D触发器解除了钟控RS触发器对输入的约束，也就没有约束方程了<br><strong>钟控D触发器在时钟脉冲作用后，它的次态和它输入的值相同，所以我们也叫他锁存器</strong><br>但是它功能比较单一，所以我们引入钟控JK触发器</p><h2 id="钟控J-K触发器"><a href="#钟控J-K触发器" class="headerlink" title="钟控J-K触发器"></a>钟控J-K触发器</h2><p>在钟控RS触发器上进行改造，首先把输入端变成K、J，然后 加入两根反馈线<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021521328.png"></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922866.png"><br>根据R’+S’&#x3D;1推出的最后表达式，恒等于1，所以输入也不存在约束的问题</p><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922796.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922638.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922916.png"></p><h2 id="钟控T触发器"><a href="#钟控T触发器" class="headerlink" title="钟控T触发器"></a>钟控T触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021533308.png"><br>在JK触发器上进行调整，将J端和K端连在一起用一个新的输入端T表示</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270923088.png"></p><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270923617.png"></p><h2 id="总结与补充"><a href="#总结与补充" class="headerlink" title="总结与补充"></a>总结与补充</h2><ul><li>电位控制触发器（上述的钟控触发器均有这些共性，它们都是电位控制触发器）<ul><li>CP&#x3D;0，也就是低电平，触发器保持状态不变</li><li>CP&#x3D;1，也就是高电平，触发器在输入信号作用下发生状态变化</li><li>触发器状态转移被控制在一个约定的时间间隔内，而不是控制在某一时刻</li><li>但是有一个缺陷是会产生空翻现象</li></ul></li></ul><p>空翻：同一个时钟脉冲作用期间触发器状态发生两次或两次以上变化的现象</p><ul><li>空翻原因<ul><li>时钟脉冲作用期间，输入信号直接控制着触发器状态的变化<ul><li>CP&#x3D;1时，输入信号发生变化，触发器状态会跟着变化</li></ul></li><li>时钟宽度控制不够<ul><li>CP为1的时间过长，输入的多次变化得到完全响应，使得一个时钟脉冲作用期间触发器多次翻转</li></ul></li></ul></li></ul><p>空翻将造成状态的不确定和系统工作的混乱，这是不允许的</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路险象</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E9%99%A9%E8%B1%A1/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E9%99%A9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="组合逻辑电路中的险象"><a href="#组合逻辑电路中的险象" class="headerlink" title="组合逻辑电路中的险象"></a>组合逻辑电路中的险象</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>信号经过任何逻辑门和导线都会产生时间延迟<ul><li>当电路所有输入达到稳定状态时，输出并不是立即达到稳定状态</li><li>延迟时间<ul><li>与信号经过的门的级数有关</li><li>与具体逻辑门的时延大小有关</li><li>与导线的长短有关</li></ul></li><li>延迟时间对数字系统是一个有害的因素<ul><li>使得系统操作速度下降</li><li>引出电路中信号的波形参数变坏</li><li>产生竞争险象</li></ul></li></ul></li><li>竞争<ul><li>由于延迟时间的影响，输入信号经过不同路径到达输出端的时间有先有后的现象</li><li>广义理解：多个信号到达某一点有时差的现象</li><li>竞争的类型<ul><li>非临界竞争：不产生错误输出的竞争</li><li>临界竞争：导致错误输出的竞争</li></ul></li></ul></li><li>险象<ul><li>由竞争导致的错误输出信号<ul><li>组合电路中的险象是一种瞬态现象</li><li>表现为在输出端产生不应有的尖脉冲，暂时地破坏正常逻辑关系</li><li>一旦瞬态过程结束，即可恢复正常逻辑关系</li></ul></li><li>险象分类<ul><li>静态险象：输入变化而输出不应发生变化的情况下，输出端产生的短暂错误输出</li><li>动态险象：在输入变化而输出应该发生变化的情况下，输出在变化过程中产生的短暂的错误输出</li><li>按错误输出脉冲信号的极性划分<ul><li>错误输出信号为负脉冲（0型险象）</li><li>错误输出信号为正脉冲（1型险象）</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251227911.png"></li></ul></li></ul></li></ul><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251222912.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251223478.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251223015.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251224198.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251224711.png"></p><h2 id="险象的判断"><a href="#险象的判断" class="headerlink" title="险象的判断"></a>险象的判断</h2><p>卡诺图法和代数法</p><h3 id="代数法"><a href="#代数法" class="headerlink" title="代数法"></a>代数法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210932027.png"></p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221200831.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221200684.png"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201503.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201279.png"></p><h3 id="卡诺图法"><a href="#卡诺图法" class="headerlink" title="卡诺图法"></a>卡诺图法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201026.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221206150.png"></p><p><strong>注意：判断组合逻辑电路中的竞争和险象时，一定不能改变电路的结构，即不对原来的电路做任何的化简、变换等</strong></p><h2 id="险象的消除"><a href="#险象的消除" class="headerlink" title="险象的消除"></a>险象的消除</h2><h3 id="增加冗余项法"><a href="#增加冗余项法" class="headerlink" title="增加冗余项法"></a>增加冗余项法</h3><p>或上冗余的与项<br>与上冗余的或项</p><p>代数法&#x2F;卡诺图法</p><h4 id="例（代数法）"><a href="#例（代数法）" class="headerlink" title="例（代数法）"></a>例（代数法）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630116.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630288.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630070.png"></p><h4 id="卡诺图法-1"><a href="#卡诺图法-1" class="headerlink" title="卡诺图法"></a>卡诺图法</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261631128.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261631075.png"></p><h4 id="例（卡诺图法）"><a href="#例（卡诺图法）" class="headerlink" title="例（卡诺图法）"></a>例（卡诺图法）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261632893.png"></p><p><strong>注意：用增加冗余项的方法消除险象时，一定不能改变电路的功能，即增加冗余项后电路的真值表不会发生改变</strong></p><h3 id="增加惯性延时环节法"><a href="#增加惯性延时环节法" class="headerlink" title="增加惯性延时环节法"></a>增加惯性延时环节法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634006.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634308.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634516.png"></p><h3 id="选通法"><a href="#选通法" class="headerlink" title="选通法"></a>选通法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634582.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261635125.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路设计</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="组合逻辑电路设计"><a href="#组合逻辑电路设计" class="headerlink" title="组合逻辑电路设计"></a>组合逻辑电路设计</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241825036.png"></p><ul><li>分析设计要求</li><li>列出真值表</li><li>得到最简逻辑表达式</li><li>表达式变换</li><li>修正表达式</li><li>得到逻辑电路图</li></ul><h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><ul><li>正确理解要求</li><li>确定电路的输入和输出</li><li>确定函数与变量之间的逻辑关系</li></ul><h3 id="例1：设计三变量“多数表决电路”"><a href="#例1：设计三变量“多数表决电路”" class="headerlink" title="例1：设计三变量“多数表决电路”"></a>例1：设计三变量“多数表决电路”</h3><ul><li>定义：三变量多数表决电路是指三个人对一件事进行表决，根据大家投票的结果来决定这件事的最终结果</li><li>分析<ul><li>输入：A、B、C为代表参加表决的三个成员，0表示反对，1表示赞成</li><li>输出：F：表决结果，0表示决议被否定，1表示决议通过</li><li>逻辑关系：当3个变量中有两个及以上取值为1时，函数F的值为1，其它情况下F的值为0</li></ul></li></ul><h4 id="真值表-逻辑表达式"><a href="#真值表-逻辑表达式" class="headerlink" title="真值表+逻辑表达式"></a>真值表+逻辑表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241830432.png"></p><h4 id="函数化简-器件选择"><a href="#函数化简-器件选择" class="headerlink" title="函数化简+器件选择"></a>函数化简+器件选择</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191632069.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241830926.png"></p><h4 id="逻辑电路图"><a href="#逻辑电路图" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p>用与非门实现<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241831005.png"></p><h3 id="例2：设计一个比较两个三位二进制数是否相等的数值比较器"><a href="#例2：设计一个比较两个三位二进制数是否相等的数值比较器" class="headerlink" title="例2：设计一个比较两个三位二进制数是否相等的数值比较器"></a>例2：设计一个比较两个三位二进制数是否相等的数值比较器</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>输入：<ul><li>A &#x3D; a0a1a2, B &#x3D; b0b1b2</li><li>6个输入变量</li></ul></li><li>输出：<ul><li>F：比较结构</li><li>当A&#x3D;B时，F为1，否则F为0</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241835015.png"></p><h4 id="逻辑电路图-1"><a href="#逻辑电路图-1" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241836396.png"><br>三个异或门和一个或非门</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>真值表法<ul><li>优点：规整、清晰</li><li>缺点：不方便，尤其当变量较多时十分麻烦</li></ul></li><li>分析法<ul><li>通过对设计要求的分析、理解，直接写出逻辑表达式</li></ul></li></ul><h2 id="包含无关条件的组合逻辑电路设计"><a href="#包含无关条件的组合逻辑电路设计" class="headerlink" title="包含无关条件的组合逻辑电路设计"></a>包含无关条件的组合逻辑电路设计</h2><ul><li>无关最小项<ul><li>由于输入变量之间存在的相互制约，问题的某种特殊限定，使得逻辑函数与输入变量的某些取值组合无关，这些取值组合称为无关最小项，也叫无关项，任意项</li><li>描述包含无关条件的逻辑问题的逻辑函数称为包含无关条件的逻辑函数</li></ul></li></ul><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241840396.png"></p><ul><li>分析<ul><li>只能取值：000，001，010，100</li><li>不允许出现：011，101，110，111</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191650832.png"></li><li>包含无关条件的逻辑函数</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201049010.png"></p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201049013.png"></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>输入：4个<br>输出：4个<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201050121.png"></p><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241841489.png"></p><p><strong>如何由真值表求得逻辑函数表达式？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201125808.png"><br>找输出端的1，对应的输入相乘，再把每一个相加，就是逻辑函数表达式<br>或者找输出端的0，对应的输入相加，再把每一项相乘</p><h4 id="表达式化简"><a href="#表达式化简" class="headerlink" title="表达式化简"></a>表达式化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241841445.png"></p><p>左图是普通的卡诺图化简，右图是用d把无关最小项表示了出来，因为它无关，所以取0取1都没关系，为了化简方便，我们给它取1，然后再圈出卡诺圈化简，发现得到的函数表达式简单了不少</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842385.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842972.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842183.png"></p><h4 id="逻辑电路图-2"><a href="#逻辑电路图-2" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842741.png"></p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241843960.png"></p><ul><li>分析<ul><li>输入变量：ABCD</li><li>输出函数：F</li><li>逻辑关系：当ABCD表示的十进制数为合数(4、6、8、9)时，输出F为1，否则F为0</li><li>无关项：0000、0001、0010、1101、1110、1111</li></ul></li></ul><h4 id="真值表-1"><a href="#真值表-1" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241845454.png"></p><h4 id="表达式化简-1"><a href="#表达式化简-1" class="headerlink" title="表达式化简"></a>表达式化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846423.png"></p><h4 id="表达式变换"><a href="#表达式变换" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846951.png"></p><h4 id="逻辑电路图-3"><a href="#逻辑电路图-3" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846105.png"></p><h2 id="多输出函数的组合逻辑电路设计"><a href="#多输出函数的组合逻辑电路设计" class="headerlink" title="多输出函数的组合逻辑电路设计"></a>多输出函数的组合逻辑电路设计</h2><ul><li>由同一组输入变量产生多个输出函数</li><li>应该将多个输出函数当作一个整体考虑，而不应该将其截然分开</li><li>关键：在函数化简时找出各输出函数的公用项，实现对逻辑门的共享</li></ul><h3 id="例子：设计一个全加器"><a href="#例子：设计一个全加器" class="headerlink" title="例子：设计一个全加器"></a>例子：设计一个全加器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241858665.png"></p><ul><li><p>全加器可以用于实现两个n尾数相加<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241903918.png"></p></li><li><p>分析</p><ul><li>输入端：<ul><li>Ai：被加数</li><li>Bi：加数</li><li>Ci-1：来自低位的进位输入</li></ul></li><li>输出端<ul><li>Si：本位和</li><li>Ci：向高位的进位</li></ul></li></ul></li></ul><h4 id="真值表-2"><a href="#真值表-2" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241903645.png"></p><h4 id="函数化简"><a href="#函数化简" class="headerlink" title="函数化简"></a>函数化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241904386.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241904066.png"></p><h4 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905696.png"></p><h4 id="函数化简-1"><a href="#函数化简-1" class="headerlink" title="函数化简"></a>函数化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905944.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905997.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241915420.png"></p><p>多输出组合逻辑电路达到最简的关键是在函数化简时找到各输出函数的公用项，以便在逻辑电路中实现对逻辑门的共享 </p><h4 id="电路图-1"><a href="#电路图-1" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241916670.png"></p><h3 id="例子：设计一个乘法器，用于产生两个2位二进制数相乘的积"><a href="#例子：设计一个乘法器，用于产生两个2位二进制数相乘的积" class="headerlink" title="例子：设计一个乘法器，用于产生两个2位二进制数相乘的积"></a>例子：设计一个乘法器，用于产生两个2位二进制数相乘的积</h3><ul><li>分析<ul><li>输入：A1A0和B1B0</li><li>输出函数：4<ul><li>Max（A1A0）&#x3D; 11  Max（B1B0）&#x3D; 11</li><li>Max（A1A0xB1B0）&#x3D; 1011</li><li>相乘的积为M3M2M1M0</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251015731.png"></p><h4 id="真值表-3"><a href="#真值表-3" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251023898.png"></p><h4 id="表达式变换-1"><a href="#表达式变换-1" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024596.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024133.png"></p><h4 id="电路图-2"><a href="#电路图-2" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024192.png"></p><h4 id="用全加器如何实现？"><a href="#用全加器如何实现？" class="headerlink" title="用全加器如何实现？"></a>用全加器如何实现？</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251025693.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251025509.png"></p><h2 id="无反变量提供的组合逻辑电路设计"><a href="#无反变量提供的组合逻辑电路设计" class="headerlink" title="无反变量提供的组合逻辑电路设计"></a>无反变量提供的组合逻辑电路设计</h2><ul><li>问题提出（为什么有这个东西？）<ul><li>为了减少各部件之间的连线，在某些问题的设计中，不提供反变量</li><li>若直接用非门将原变量转换成相应的反变量，则处理结果往往是不经济的</li><li>通常进行适当的变换，以便在无反变量提供的前提下，尽可能减少非门数量，使逻辑电路尽可能的简化</li></ul></li></ul><h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251031672.png"></p><ul><li>分析<ul><li>F已经是最简的“与-或“表达式，可直接变换成“与非-与非”表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251033415.png"></li></ul></li></ul><h4 id="逻辑电路图-4"><a href="#逻辑电路图-4" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251033919.png"></p><h4 id="对函数F表达式整理变换"><a href="#对函数F表达式整理变换" class="headerlink" title="对函数F表达式整理变换"></a>对函数F表达式整理变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251034854.png"></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251034826.png"></p><h3 id="例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容"><a href="#例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容" class="headerlink" title="例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容"></a>例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251042018.png"></p><ul><li>分析<ul><li>电路输入变量为献血者和受血者血型</li><li>血型共4种 <ul><li>可以用两个变量的4种编码进行区分</li><li>WX表现献血者血型，YZ表示受血者血型</li></ul></li></ul></li></ul><h4 id="血型编码"><a href="#血型编码" class="headerlink" title="血型编码"></a>血型编码</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251046277.png"></p><h4 id="电路输出用F表示"><a href="#电路输出用F表示" class="headerlink" title="电路输出用F表示"></a>电路输出用F表示</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049530.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049491.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049919.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251050103.png"></p><h4 id="逻辑电路图-5"><a href="#逻辑电路图-5" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251050665.png"></p><h4 id="怎么让电路图更简单呢？"><a href="#怎么让电路图更简单呢？" class="headerlink" title="怎么让电路图更简单呢？"></a>怎么让电路图更简单呢？</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844664.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844722.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844771.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845072.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845845.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845235.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路的分类及其分析</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="逻辑电路的分类（按照对电路的记忆）"><a href="#逻辑电路的分类（按照对电路的记忆）" class="headerlink" title="逻辑电路的分类（按照对电路的记忆）"></a>逻辑电路的分类（按照对电路的记忆）</h2><ul><li>组合逻辑电路<ul><li>电路输出仅取决于当时的输入，而与过去的输入情况无关</li><li>可以完成各种复杂的逻辑功能</li><li>是时序逻辑电路的组成部分</li></ul></li><li>时序逻辑电路<ul><li>电路输出不仅取决于当时的输入，而且也与过去的输入情况有关，即与过去的电路状态有关</li></ul></li></ul><h3 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h3><h4 id="一般结构"><a href="#一般结构" class="headerlink" title="一般结构"></a>一般结构</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241715622.png"></p><h4 id="组合逻辑电路特点"><a href="#组合逻辑电路特点" class="headerlink" title="组合逻辑电路特点"></a>组合逻辑电路特点</h4><ul><li>由逻辑门电路组成</li><li>不包含任何记忆元件</li><li>信号是单向传输的，不存在反馈电路</li></ul><h3 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h3><ul><li>若逻辑电路在任何时刻产生的稳定输出信号不仅与电路该时刻的输入信号有关还与电路过去的输入信号有关，则称为时序逻辑电路<ul><li>比如电话，电子密码锁这样的</li></ul></li></ul><h4 id="一般结构-1"><a href="#一般结构-1" class="headerlink" title="一般结构"></a>一般结构</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241732878.png"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>电路由组合电路和存储电路组成，具有对过去输入进行记忆的功能</li><li>电路中包含反馈回路，通过反馈是电路功能与时序相关</li><li>电路的输出由电路当时的输入和状态共同决定</li></ul><h4 id="分类（按照电路的工作方式）"><a href="#分类（按照电路的工作方式）" class="headerlink" title="分类（按照电路的工作方式）"></a>分类（按照电路的工作方式）</h4><ul><li>同步时序逻辑电路<ul><li>电路中有统一的定时信号，存储器件采用时钟控制触发器，电路状态在时钟脉冲控制下同时发生转换</li></ul></li><li>异步时序逻辑电路<ul><li>电路汇总没有统一的时钟信号同步，电路输入信号的变化将直接导致电路状态的变化</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241742394.png"></p><h2 id="组合逻辑电路的分析"><a href="#组合逻辑电路的分析" class="headerlink" title="组合逻辑电路的分析"></a>组合逻辑电路的分析</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>画&#x2F;看逻辑电路图找出电路的输入、输出</li><li>写出输出逻辑函数表达式<ul><li>根据电路逐级写出各门的输出表达式，直至写出整个电路的输出逻辑表达式</li></ul></li><li>表达式化简</li><li>画出真值表</li><li>分析逻辑功能</li><li>改进电路</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241815864.png"></p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241817244.png"></p><p>三个输入A B C<br>一个输出F<br>七个与非门</p><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241817680.png"></p><h4 id="逻辑功能"><a href="#逻辑功能" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p>ABC 的输入相同时，输出为0，输入不同时，输出为1.此电路逻辑功能为三变量非一致电路</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241818293.png"><br>一个非门<br>一个或门<br>四个与非门</p><h4 id="表达式-1"><a href="#表达式-1" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241818421.png"><br>A异或B或上A异或C</p><h4 id="真值表-1"><a href="#真值表-1" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819550.png"></p><h4 id="逻辑功能-1"><a href="#逻辑功能-1" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p>仍是三变量非一致电路</p><h4 id="改进电路"><a href="#改进电路" class="headerlink" title="改进电路"></a>改进电路</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819507.png"></p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>**<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819630.png"></p><h4 id="表达式-2"><a href="#表达式-2" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820248.png"></p><h4 id="真值表-2"><a href="#真值表-2" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820115.png"></p><h4 id="逻辑功能-2"><a href="#逻辑功能-2" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p><strong>半加器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820531.png"></p><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241821866.png"><br>或门和异或门</p><h4 id="表达式-3"><a href="#表达式-3" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822156.png"></p><h4 id="表达式变换"><a href="#表达式变换" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822649.png"></p><h4 id="真值表-3"><a href="#真值表-3" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822587.png"></p><h4 id="逻辑功能-3"><a href="#逻辑功能-3" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p><strong>二进制变补器</strong><br><strong>16变补器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822920.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本概念和基本R-S结构</title>
    <link href="/2022/07/24/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%ACR-S%E7%BB%93%E6%9E%84/"/>
    <url>/2022/07/24/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%ACR-S%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="触发器结构"><a href="#触发器结构" class="headerlink" title="触发器结构"></a>触发器结构</h2><ul><li>有两个互补的输出端Q和“非Q”</li><li>有两个稳定状态1和0<ul><li>1状态：Q&#x3D;1    非Q&#x3D;0</li><li>0状态：Q&#x3D;0   非Q&#x3D;1</li></ul></li><li>输入信号不发生变化时， 触发器状态稳定不变</li><li>在一定输入信号作用下，触发器可以从一个稳定状态转移到另一个稳定状态，输入信号撤销后，保持新的状态不变</li></ul><h2 id="触发器状态"><a href="#触发器状态" class="headerlink" title="触发器状态"></a>触发器状态</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261722903.png"></p><h2 id="触发器常用描述方法"><a href="#触发器常用描述方法" class="headerlink" title="触发器常用描述方法"></a>触发器常用描述方法</h2><ul><li>功能表</li><li>状态表</li><li>状态图</li><li>次态方程</li><li>激励表</li><li>卡诺图</li></ul><h3 id="功能表"><a href="#功能表" class="headerlink" title="功能表"></a>功能表</h3><p>反映了触发器在不同输入下对应的表格</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261725285.png"><br>不定，是说明不允许这种输入</p><h3 id="状态表"><a href="#状态表" class="headerlink" title="状态表"></a>状态表</h3><p>反映了触发器在输入作用下现态和次态之间的转移关系</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261726923.png"></p><h3 id="激励表"><a href="#激励表" class="headerlink" title="激励表"></a>激励表</h3><p>反映了触发器从现态Q转移到某种次态时，对输入信号的要求</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261727016.png"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><ul><li>反映触发器两种状态之间转移关系的有向图 </li><li>圆圈表示稳定状态</li><li>有向线段表示状态转移的方向<ul><li>起点：现态</li><li>终点：次态</li><li>触发条件</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261740349.png"><br>两个稳定状态：0和1</p><h3 id="卡诺图"><a href="#卡诺图" class="headerlink" title="卡诺图"></a>卡诺图</h3><p>根据触发器的功能表或状态表所得到的反映触发器次态和现态以及输入关系的卡诺图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261741176.png"></p><h3 id="次态方程"><a href="#次态方程" class="headerlink" title="次态方程"></a>次态方程</h3><p>反映触发器次态和现态以及输入关系的表达式（常与约束方程一起使用）</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261742329.png"></p><h2 id="基本R-S触发器"><a href="#基本R-S触发器" class="headerlink" title="基本R-S触发器"></a>基本R-S触发器</h2><h3 id="与非门构成的基本R-S触发器"><a href="#与非门构成的基本R-S触发器" class="headerlink" title="与非门构成的基本R-S触发器"></a>与非门构成的基本R-S触发器</h3><p>两个与非门和两根反馈线耦合而成</p><ul><li>直接复位置位触发器</li><li>构成各种功能触发器的基本部件</li><li>R：置0端或者复位端</li><li>S：置1端或置位端</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270834974.png"></p><h4 id="RS-x3D-11"><a href="#RS-x3D-11" class="headerlink" title="RS&#x3D;11"></a>RS&#x3D;11</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270835009.png"></p><h4 id="RS-x3D-01"><a href="#RS-x3D-01" class="headerlink" title="RS&#x3D;01"></a>RS&#x3D;01</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270836978.png"></p><h4 id="RS-x3D-10"><a href="#RS-x3D-10" class="headerlink" title="RS&#x3D;10"></a>RS&#x3D;10</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270837587.png"></p><h4 id="RS-x3D-00"><a href="#RS-x3D-00" class="headerlink" title="RS&#x3D;00"></a>RS&#x3D;00</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270837625.png"></p><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280832129.png"></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><h5 id="功能表-状态表"><a href="#功能表-状态表" class="headerlink" title="功能表+状态表"></a>功能表+状态表</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853274.png"><br>d表示不确定</p><h5 id="激励表-1"><a href="#激励表-1" class="headerlink" title="激励表"></a>激励表</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853981.png"></p><h5 id="次态方程（重要点）"><a href="#次态方程（重要点）" class="headerlink" title="次态方程（重要点）"></a>次态方程（重要点）</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853185.png"></p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>当与非门构成的基本R-S触发器的同一输入端连续出现多个负脉冲信号，仅第一个使触发器状态发生改变</li><li>可以用来消除毛刺</li></ul><h3 id="或非门构成的基本R-S触发器"><a href="#或非门构成的基本R-S触发器" class="headerlink" title="或非门构成的基本R-S触发器"></a>或非门构成的基本R-S触发器</h3><p>两个或非门与两根反馈线耦合而成</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270858725.png"></p><h4 id="RS-x3D-00-1"><a href="#RS-x3D-00-1" class="headerlink" title="RS&#x3D;00"></a>RS&#x3D;00</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270858912.png"></p><h4 id="RS-x3D-01-1"><a href="#RS-x3D-01-1" class="headerlink" title="RS&#x3D;01"></a>RS&#x3D;01</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859900.png"></p><h4 id="RS-x3D-10-1"><a href="#RS-x3D-10-1" class="headerlink" title="RS&#x3D;10"></a>RS&#x3D;10</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859879.png"></p><h4 id="RS-x3D-11-1"><a href="#RS-x3D-11-1" class="headerlink" title="RS&#x3D;11"></a>RS&#x3D;11</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859918.png"></p><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280857367.png"></p><h4 id="描述（重点注意次态方程和约束方程）"><a href="#描述（重点注意次态方程和约束方程）" class="headerlink" title="描述（重点注意次态方程和约束方程）"></a>描述（重点注意次态方程和约束方程）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900970.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900245.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900132.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280903090.png"></p><ul><li><p>与非门构成的，输入端加圈，只有R、S等于0时，才可以改变状态，因此称对低电平有效</p></li><li><p>而或非门构成的，输入端没有加圈只有R、S等于1时，才可以改变状态，因此称对高电平有效</p></li><li><p>优点（两种共有的优点）</p><ul><li>结构简单</li><li>可作为记忆元件独立使用</li><li>被作为各种性能完善的触发器的基本组成部分<ul><li>具有直接复位、置位的功能</li></ul></li></ul></li><li><p>缺点</p><ul><li>R、S之间具有约束关系</li><li>不能进行定时控制</li><li>使用受到一定限制</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径问题</title>
    <link href="/2022/07/24/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/24/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径问题的抽象"><a href="#最短路径问题的抽象" class="headerlink" title="最短路径问题的抽象"></a>最短路径问题的抽象</h1><ul><li><p>在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径</p><ul><li>这条路径就是两点之间的最短路径</li><li>第一个顶点为源点</li><li>最后一个顶点为终点</li></ul></li><li><p>问题分类</p><ul><li>单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径<ul><li>（有向）无权图</li><li>（有向）有权图</li></ul></li><li>多源最短路径问题：求任意两顶点间的最短路径</li></ul></li></ul><h1 id="实现的算法"><a href="#实现的算法" class="headerlink" title="实现的算法"></a>实现的算法</h1><h2 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h2><ul><li>无权图的单源最短路算法<ul><li>按照递增（非递减）的顺序找到各个顶点的最短路</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241414319.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241414328.png"></li></ul></li></ul><h2 id="有权图的单源最短路算法"><a href="#有权图的单源最短路算法" class="headerlink" title="有权图的单源最短路算法"></a>有权图的单源最短路算法</h2><ul><li>有权图的单源最短路算法<ul><li>按照递增的顺序找出到各个顶点的最短路</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241415387.png"></li><li>Dijkstra算法<ul><li>令S&#x3D;{源点s + 已经确定了最短路径的顶点Vi}</li><li>对任意未收录的顶点v，定义dist[v]为s到b的最短路径长度，但该路径仅经过S中的顶点。</li><li>若路径是按照递增（非递减）的顺序生成的，则<ul><li>真正的最短路必须只经过s中的顶点</li><li>每次从未收录的顶点中选一个dist最小的收录（贪心）</li><li>增加一个v进入s，可能影响另外一个w的dist值<ul><li>dist[w] &#x3D; min{ dist[w],dist[v] +&lt;v,w&gt;的权重) }</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241421373.png"></p><ul><li>有权图的单源最短路径算法<ul><li><p>方法一：直接扫描所有为收录顶点</p><ul><li>对于稠密图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425725.png"></li></ul></li><li><p>方法二：将dist存在最小堆中</p><ul><li>对于稀疏图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425297.png"></li></ul></li></ul></li></ul><h2 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h2><ul><li><p>多源最短路算法</p><ul><li><p>方法一：直接将单源最短路算法调用|V|遍</p><ul><li>对于稀疏图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425954.png"></li></ul></li><li><p>方法二：Floyd算法</p><ul><li>对于稠密图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425387.png"></li></ul></li></ul></li><li><p>Floyd算法</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241427841.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241428522.png"></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="邻接表存储-无权图的单源最短路算法"><a href="#邻接表存储-无权图的单源最短路算法" class="headerlink" title="邻接表存储 - 无权图的单源最短路算法"></a>邻接表存储 - 无权图的单源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接表存储 - 无权图的单源最短路算法 */</span> <br><br><span class="hljs-comment">/* dist[]和path[]全部初始化为-1 */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Unweighted</span> <span class="hljs-params">( LGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> path[], Vertex S )</span> <br>&#123;     <br>Queue Q;     <br>Vertex V;     <br>PtrToAdjVNode W;          <br>Q = CreateQueue( Graph-&gt;Nv ); <span class="hljs-comment">/* 创建空队列, MaxSize为外部定义的常数 */</span>     <br>dist[S] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始化源点 */</span>     <br>AddQ (Q, S);     <br><br><span class="hljs-keyword">while</span>( !IsEmpty(Q) )&#123;         <br>V = DeleteQ(Q);         <br><span class="hljs-keyword">for</span> ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="hljs-comment">/* 对V的每个邻接点W-&gt;AdjV */</span>             <span class="hljs-keyword">if</span> ( dist[W-&gt;AdjV]==<span class="hljs-number">-1</span> ) &#123; <span class="hljs-comment">/* 若W-&gt;AdjV未被访问过 */</span>                 <br>        dist[W-&gt;AdjV] = dist[V]+<span class="hljs-number">1</span>; <span class="hljs-comment">/* W-&gt;AdjV到S的距离更新 */</span>     path[W-&gt;AdjV] = V; <span class="hljs-comment">/* 将V记录在S到W-&gt;AdjV的路径上 */</span>       AddQ(Q, W-&gt;AdjV);             <br>&#125;     <br>&#125; <span class="hljs-comment">/* while结束*/</span><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵存储-有权图的单源最短路算法"><a href="#邻接矩阵存储-有权图的单源最短路算法" class="headerlink" title="邻接矩阵存储 - 有权图的单源最短路算法"></a>邻接矩阵存储 - 有权图的单源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储 - 有权图的单源最短路算法 */</span> <br><br>Vertex <span class="hljs-title function_">FindMinDist</span><span class="hljs-params">( MGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> collected[] )</span> <br>&#123; <span class="hljs-comment">/* 返回未被收录顶点中dist最小者 */</span>     <br>Vertex MinV, V;     <br><span class="hljs-type">int</span> MinDist = INFINITY;     <br><br><span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++) &#123;         <span class="hljs-keyword">if</span> ( collected[V]==<span class="hljs-literal">false</span> &amp;&amp; dist[V]&lt;MinDist) &#123;             <span class="hljs-comment">/* 若V未被收录，且dist[V]更小 */</span>             MinDist = dist[V]; <span class="hljs-comment">/* 更新最小距离 */</span>             MinV = V; <span class="hljs-comment">/* 更新对应顶点 */</span>         <br>    &#125;     <br>&#125;     <br><span class="hljs-keyword">if</span> (MinDist &lt; INFINITY) <span class="hljs-comment">/* 若找到最小dist */</span>         <span class="hljs-keyword">return</span> MinV; <span class="hljs-comment">/* 返回对应的顶点下标 */</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">/* 若这样的顶点不存在，返回错误标记 */</span> &#125; <br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Dijkstra</span><span class="hljs-params">( MGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> path[], Vertex S )</span> <br>&#123;     <br>    <span class="hljs-type">int</span> collected[MaxVertexNum];     <br>    Vertex V, W;     <br>    <span class="hljs-comment">/* 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示 */</span>     <span class="hljs-keyword">for</span> ( V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++ ) &#123;         dist[V] = Graph-&gt;G[S][V];         <br>        <span class="hljs-keyword">if</span> ( dist[V]&lt;INFINITY )             <br>        path[V] = S;         <br>        <span class="hljs-keyword">else</span>             <br>        path[V] = <span class="hljs-number">-1</span>;         <br>    collected[V] = <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-comment">/* 先将起点收入集合 */</span>     <br>dist[S] = <span class="hljs-number">0</span>;     <br>collected[S] = <span class="hljs-literal">true</span>;     <br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;         <br><span class="hljs-comment">/* V = 未被收录顶点中dist最小者 */</span>         V = FindMinDist( Graph, dist, collected );         <span class="hljs-keyword">if</span> ( V==ERROR ) <span class="hljs-comment">/* 若这样的V不存在 */</span>             <span class="hljs-keyword">break</span>;      <span class="hljs-comment">/* 算法结束 */</span>         collected[V] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">/* 收录V */</span>         <span class="hljs-keyword">for</span>( W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="hljs-comment">/* 对图中的每个顶点W */</span>             <br><span class="hljs-comment">/* 若W是V的邻接点并且未被收录 */</span>             <span class="hljs-keyword">if</span> ( collected[W]==<span class="hljs-literal">false</span> &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;                 <br><span class="hljs-keyword">if</span> ( Graph-&gt;G[V][W]&lt;<span class="hljs-number">0</span> ) <span class="hljs-comment">/* 若有负边 */</span>                     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 不能正确解决，返回错误标记 */</span>                 <br><span class="hljs-comment">/* 若收录V使得dist[W]变小 */</span>                 <br><span class="hljs-keyword">if</span> ( dist[V]+Graph-&gt;G[V][W] &lt; dist[W] ) &#123;                     dist[W] = dist[V]+Graph-&gt;G[V][W]; <span class="hljs-comment">/* 更新dist[W] */</span>                     path[W] = V; <span class="hljs-comment">/* 更新S到W的路径 */</span>                 &#125;             &#125;     <br>&#125; <span class="hljs-comment">/* while结束*/</span>    <br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br> <span class="hljs-comment">/* 算法执行完毕，返回正确标记 */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵存储-多源最短路算法"><a href="#邻接矩阵存储-多源最短路算法" class="headerlink" title="邻接矩阵存储 - 多源最短路算法"></a>邻接矩阵存储 - 多源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储 - 多源最短路算法 */</span> <br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Floyd</span><span class="hljs-params">( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )</span> <br>&#123;     <br>Vertex i, j, k;     <span class="hljs-comment">/* 初始化 */</span>     <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Nv; i++ )         <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;Graph-&gt;Nv; j++ ) &#123;            <br> D[i][j] = Graph-&gt;G[i][j];             path[i][j] = <span class="hljs-number">-1</span>;         <br> &#125;     <br><span class="hljs-keyword">for</span>( k=<span class="hljs-number">0</span>; k&lt;Graph-&gt;Nv; k++ )         <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Nv; i++ )             <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;Graph-&gt;Nv; j++ )                 <span class="hljs-keyword">if</span>( D[i][k] + D[k][j] &lt; D[i][j] ) &#123;                     D[i][j] = D[i][k] + D[k][j];                     <span class="hljs-keyword">if</span> ( i==j &amp;&amp; D[i][j]&lt;<span class="hljs-number">0</span> ) <span class="hljs-comment">/* 若发现负值圈 */</span>                         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 不能正确解决，返回错误标记 */</span>                     path[i][j] = k;                 &#125;     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br><span class="hljs-comment">/* 算法执行完毕，返回正确标记 */</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡二叉树</title>
    <link href="/2022/07/24/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/07/24/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是平衡二叉树"><a href="#什么是平衡二叉树" class="headerlink" title="什么是平衡二叉树"></a>什么是平衡二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241012577.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241015263.png"><br><strong>判断关键，任一结点左右子树高度差的绝对值是否超过1</strong></p><h2 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h2><h3 id="RR旋转（右单旋）"><a href="#RR旋转（右单旋）" class="headerlink" title="RR旋转（右单旋）"></a>RR旋转（右单旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241018029.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241018405.png"></p><h3 id="LL旋转（左单旋）"><a href="#LL旋转（左单旋）" class="headerlink" title="LL旋转（左单旋）"></a>LL旋转（左单旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241020782.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241021910.png"></p><h3 id="LR旋转（左-右双旋）"><a href="#LR旋转（左-右双旋）" class="headerlink" title="LR旋转（左-右双旋）"></a>LR旋转（左-右双旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241022482.png"><br>中间图的OR表示两种情况：<br>一种情况是C为发现者<br>另一种是$C_L$为发现者<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241025084.png"></p><h3 id="RL旋转（右-左双旋）"><a href="#RL旋转（右-左双旋）" class="headerlink" title="RL旋转（右-左双旋）"></a>RL旋转（右-左双旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241026477.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241026015.png"></p><p>注意：<br><strong>有时插入元素不需要调整结构，但一些平衡因子需要重新计算</strong></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="AVL树的旋转与插入"><a href="#AVL树的旋转与插入" class="headerlink" title="AVL树的旋转与插入"></a>AVL树的旋转与插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span> *<span class="hljs-title">Position</span>;</span> <br><span class="hljs-keyword">typedef</span> Position AVLTree; <span class="hljs-comment">/* AVL树类型 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span>&#123;</span>     <br>ElementType Data; <span class="hljs-comment">/* 结点数据 */</span>     <br>AVLTree Left;     <span class="hljs-comment">/* 指向左子树 */</span>     <br>AVLTree Right;    <span class="hljs-comment">/* 指向右子树 */</span>     <br><span class="hljs-type">int</span> Height;       <span class="hljs-comment">/* 树高 */</span> <br>&#125;; <br><span class="hljs-type">int</span> <span class="hljs-title function_">Max</span> <span class="hljs-params">( <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b )</span> <br>&#123;     <br><span class="hljs-keyword">return</span> a &gt; b ? a : b; <br>&#125;<br>AVLTree <span class="hljs-title function_">SingleLeftRotation</span> <span class="hljs-params">( AVLTree A )</span> <br>&#123; <span class="hljs-comment">/* 注意：A必须有一个左子结点B */</span>   <br>  <span class="hljs-comment">/* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */</span>          AVLTree B = A-&gt;Left;     <br>    A-&gt;Left = B-&gt;Right;     <br>    B-&gt;Right = A;     <br>    A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + <span class="hljs-number">1</span>;     B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + <span class="hljs-number">1</span>;       <span class="hljs-keyword">return</span> B; <br>&#125;<br><br>AVLTree <span class="hljs-title function_">DoubleLeftRightRotation</span> <span class="hljs-params">( AVLTree A )</span> <br>&#123; <span class="hljs-comment">/* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */</span>   <br>  <span class="hljs-comment">/* 将A、B与C做两次单旋，返回新的根结点C */</span>          <br>  <br>  <span class="hljs-comment">/* 将B与C做右单旋，C被返回 */</span>     <br>  A-&gt;Left = SingleRightRotation(A-&gt;Left);     <br>  <span class="hljs-comment">/* 将A与C做左单旋，C被返回 */</span>     <br>  <span class="hljs-keyword">return</span> SingleLeftRotation(A); <br>&#125; <br><br><br>AVLTree <span class="hljs-title function_">Insert</span><span class="hljs-params">( AVLTree T, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 将X插入AVL树T中，并且返回调整后的AVL树 */</span>     <br><span class="hljs-keyword">if</span> ( !T ) &#123; <span class="hljs-comment">/* 若插入空树，则新建包含一个结点的树 */</span>         T = (AVLTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AVLNode));         <br>T-&gt;Data = X;         <br>T-&gt;Height = <span class="hljs-number">0</span>;         <br>T-&gt;Left = T-&gt;Right = <span class="hljs-literal">NULL</span>;     <br>&#125; <span class="hljs-comment">/* if (插入空树) 结束 */</span>     <br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( X &lt; T-&gt;Data ) &#123;         <br><span class="hljs-comment">/* 插入T的左子树 */</span>         <br>T-&gt;Left = Insert( T-&gt;Left, X);         <br><span class="hljs-comment">/* 如果需要左旋 */</span>         <br><span class="hljs-keyword">if</span> ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == <span class="hljs-number">2</span> )             <span class="hljs-keyword">if</span> ( X &lt; T-&gt;Left-&gt;Data )                 T = SingleLeftRotation(T);      <span class="hljs-comment">/* 左单旋 */</span>             <span class="hljs-keyword">else</span>                 T = DoubleLeftRightRotation(T); <span class="hljs-comment">/* 左-右双旋 */</span>     &#125; <span class="hljs-comment">/* else if (插入左子树) 结束 */</span>          <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( X &gt; T-&gt;Data ) &#123;         <br><span class="hljs-comment">/* 插入T的右子树 */</span>         <br>T-&gt;Right = Insert( T-&gt;Right, X );        <br> <span class="hljs-comment">/* 如果需要右旋 */</span>         <br> <span class="hljs-keyword">if</span> ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == <span class="hljs-number">-2</span> )             <br> <span class="hljs-keyword">if</span> ( X &gt; T-&gt;Right-&gt;Data )                 <br> T = SingleRightRotation(T);     <span class="hljs-comment">/* 右单旋 */</span>             <br><span class="hljs-keyword">else</span>                 <br>T = DoubleRightLeftRotation(T); <span class="hljs-comment">/* 右-左双旋 */</span>     <br>&#125; <span class="hljs-comment">/* else if (插入右子树) 结束 */</span>     <br><span class="hljs-comment">/* else X == T-&gt;Data，无须插入 */</span>    <br> <span class="hljs-comment">/* 别忘了更新树高 */</span>     <br> T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + <span class="hljs-number">1</span>;          <br> <span class="hljs-keyword">return</span> T; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2022/07/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/07/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240942238.png"><br>左边小，右边大</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240944509.png"></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240943255.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240945111.png"><br>什么是尾递归？？？<br>就是在最后返回这一步用到了递归<br>而尾递归可用循坏代替，提高效率<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240947234.png"></p><h4 id="查找最大和最小元素"><a href="#查找最大和最小元素" class="headerlink" title="查找最大和最小元素"></a>查找最大和最小元素</h4><p>利用二叉树的性质<br>最大元素一定在树的最右分支的端结点上<br>最小元素一定在树的最左分支的端结点上<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240948853.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240950565.png"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>关键是要找到元素应该插入的位置</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951332.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951767.png"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951648.png"><br>以字母顺序来排<br>JAN为根节点<br>FEB，F在J前面所以放JAN左子树<br>MAR，M比J大放在JAN右子树<br>APR，比JAN小，往左走，比FEB小，继续往左走，就放到了FEB左子树<br>……</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>考虑三种情况</p><h4 id="要删除的是叶结点"><a href="#要删除的是叶结点" class="headerlink" title="要删除的是叶结点"></a>要删除的是叶结点</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240955228.png"><br>删除35，把33的指针置为NULL</p><h4 id="要删除的结点只有一个孩子结点"><a href="#要删除的结点只有一个孩子结点" class="headerlink" title="要删除的结点只有一个孩子结点"></a>要删除的结点只有一个孩子结点</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240956621.png"><br>把41的左子树指针指向35</p><h4 id="要删除的结点有左、右子树"><a href="#要删除的结点有左、右子树" class="headerlink" title="要删除的结点有左、右子树"></a>要删除的结点有左、右子树</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240957122.png"><br>1 把50放到原来41的位置<br>2 把35放到原来41的位置，34接到33上</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241001874.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Insert</span><span class="hljs-params">( BinTree BST, ElementType X )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( !BST )&#123; <span class="hljs-comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span>         BST = (BinTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TNode));         <br>BST-&gt;Data = X;         <br>BST-&gt;Left = BST-&gt;Right = <span class="hljs-literal">NULL</span>;     <br>&#125;    <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 开始找要插入元素的位置 */</span>         <br><span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data )             <br>BST-&gt;Left = Insert( BST-&gt;Left, X );   <span class="hljs-comment">/*递归插入左子树*/</span>         <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data )            <br>BST-&gt;Right = Insert( BST-&gt;Right, X ); <span class="hljs-comment">/*递归插入右子树*/</span>         <br><span class="hljs-comment">/* else X已经存在，什么都不做 */</span>     <br>&#125;     <br><span class="hljs-keyword">return</span> BST; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Delete</span><span class="hljs-params">( BinTree BST, ElementType X )</span>  <br>&#123;      <br>Position Tmp;      <br><span class="hljs-keyword">if</span>( !BST )          <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的元素未找到&quot;</span>);      <br><span class="hljs-keyword">else</span> &#123;         <br><span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data )              <br>BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class="hljs-comment">/* 从左子树递归删除 */</span>         <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data )              <br>BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class="hljs-comment">/* 从右子树递归删除 */</span>         <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* BST就是要删除的结点 */</span>             <br><span class="hljs-comment">/* 如果被删除结点有左右两个子结点 */</span>              <br><span class="hljs-keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;                 <br><span class="hljs-comment">/* 从右子树中找最小的元素填充删除结点 */</span>                 <br>Tmp = FindMin( BST-&gt;Right );                         BST-&gt;Data = Tmp-&gt;Data;                  <br>                        <span class="hljs-comment">/* 从右子树中删除最小元素 */</span>                  <br>                        BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );             <br>                    &#125;             <br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 被删除结点有一个或无子结点 */</span>                            Tmp = BST;                  <br>                           <span class="hljs-keyword">if</span>( !BST-&gt;Left )       <br>                           <span class="hljs-comment">/* 只有右孩子或无子结点 */</span>                               BST = BST-&gt;Right;                   <br>                           <span class="hljs-keyword">else</span>                   <br>                           <span class="hljs-comment">/* 只有左孩子 */</span>                      <br>                              BST = BST-&gt;Left;                 <span class="hljs-built_in">free</span>( Tmp );             <br>                    &#125;         <br>            &#125;     <br>        &#125;     <br>        <span class="hljs-keyword">return</span> BST; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2022/07/24/%E5%9B%BE/"/>
    <url>/2022/07/24/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h2><ul><li>表示“多对多”的关系</li><li>包含<ul><li>一组顶点，通常用V表示顶点集合</li><li>一组边，通常用E表示边的集合<ul><li><p>边是顶点对，（v,w）</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241304379.png"></p></li><li><p>有向边&lt;v,w&gt;表示从v指向w的边(单行线)</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241305424.png"></p></li><li><p>不考虑重边和自回路</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241305953.png"></p></li></ul></li></ul></li></ul><h2 id="抽象数据类型定义"><a href="#抽象数据类型定义" class="headerlink" title="抽象数据类型定义"></a>抽象数据类型定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241306801.png"></p><h2 id="怎么在程序中表示一个图"><a href="#怎么在程序中表示一个图" class="headerlink" title="怎么在程序中表示一个图"></a>怎么在程序中表示一个图</h2><h3 id="用邻接矩阵"><a href="#用邻接矩阵" class="headerlink" title="用邻接矩阵"></a>用邻接矩阵</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241306436.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241307505.png"></p><ul><li>邻接矩阵有什么好处？<ul><li>直观、简单、好理解</li><li>方便检查任意一对顶点间是否存在边</li><li>方便找任一顶点的度（出度、入度）<ul><li>无向图的度：对应行或列非0元素的个数</li><li>有向图的度：对应行非0元素的个数是出度，对应列非0元素的个数是入度</li></ul></li></ul></li><li>邻接矩阵有什么不好？<ul><li>浪费空间<ul><li>存稀疏图（点多边少）有大量无效元素</li><li>但对稠密图还是合算的</li></ul></li><li>浪费时间<ul><li>统计稀疏图中一共有多少边</li></ul></li></ul></li></ul><h3 id="用邻接表"><a href="#用邻接表" class="headerlink" title="用邻接表"></a>用邻接表</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241312979.png"><br><strong>一定要够稀疏才合算</strong></p><ul><li>邻接表<ul><li>方便找任一顶点的所有邻接点</li><li>节约稀疏图的空间<ul><li>需要N个头指针加2E个结点（每个结点至少两个域）</li></ul></li><li>方便计算任一顶点的度？<ul><li>对于无向图：是的</li><li>对于有向图：只能计算出度，需要构造逆邻接表（存储指向自己的边）来方便计算入度</li><li>不方便检查任意一对顶点间是否存在边</li></ul></li></ul></li></ul><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><ul><li>深度优先搜索</li><li>广度优先搜索</li></ul><p>图不连通怎么办？</p><ul><li>连通：如果从v到w存在一条无向路径，则称v和w连通</li><li>路径：从v到w的路径是一系列顶点的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中边数。如果v到w之间的所有顶点都不同，则称简单路径</li><li>回路：起点等于终点的路径</li><li>连通图：图中任意两顶点均相同</li><li>连通分量：无向图的极大连通子图<ul><li>极大顶点数：再加1个顶点就不连通了</li><li>极大边数：包含子图中所有顶点相连的所有边</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241400121.png"></li><li>强连通：有向图中顶点v和w之间存在双向路径，则称v和w是强连通的</li><li>强连通图：有向图中任意两顶点均强连通</li><li>强连通分量：有向图的极大强连通子图</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241402102.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241402099.png"></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="邻接矩阵表示"><a href="#邻接矩阵表示" class="headerlink" title="邻接矩阵表示"></a>邻接矩阵表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 图的邻接矩阵表示法 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100    <span class="hljs-comment">/* 最大顶点数设为100 */</span> #<span class="hljs-keyword">define</span> INFINITY 65535        <span class="hljs-comment">/* ∞设为双字节无符号整数的最大值65535*/</span> </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Vertex;         <span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> WeightType;        <span class="hljs-comment">/* 边的权值设为整型 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> DataType;        <span class="hljs-comment">/* 顶点存储的数据类型设为字符型 */</span> <br><span class="hljs-comment">/* 边的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span>     <br>Vertex V1, V2;      <span class="hljs-comment">/* 有向边&lt;V1, V2&gt; */</span>     <br>WeightType Weight;  <span class="hljs-comment">/* 权重 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToENode Edge;         <br><br><span class="hljs-comment">/* 图结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span>     <br><span class="hljs-type">int</span> Nv;  <span class="hljs-comment">/* 顶点数 */</span>     <br><span class="hljs-type">int</span> Ne;  <span class="hljs-comment">/* 边数   */</span>     <br>WeightType G[MaxVertexNum][MaxVertexNum]; <span class="hljs-comment">/* 邻接矩阵 */</span>     <br>DataType Data[MaxVertexNum];      <span class="hljs-comment">/* 存顶点的数据 */</span>     <br><span class="hljs-comment">/* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToGNode MGraph; <span class="hljs-comment">/* 以邻接矩阵存储的图类型 */</span> <br><br><br>MGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">( <span class="hljs-type">int</span> VertexNum )</span> <br>&#123; <span class="hljs-comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span>     Vertex V, W;     MGraph Graph;          Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode)); <span class="hljs-comment">/* 建立图 */</span>      <br>      Graph-&gt;Nv = VertexNum;     <br>      Graph-&gt;Ne = <span class="hljs-number">0</span>;     <br>      <span class="hljs-comment">/* 初始化邻接矩阵 */</span>     <br>      <span class="hljs-comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span>      <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)          <br>          <span class="hljs-keyword">for</span> (W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++)               Graph-&gt;G[V][W] = INFINITY;                  <span class="hljs-keyword">return</span> Graph;  <br>&#125;         <br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">( MGraph Graph, Edge E )</span> <br>&#123;      <br>    <span class="hljs-comment">/* 插入边 &lt;V1, V2&gt; */</span>      <br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;          <br>    <span class="hljs-comment">/* 若是无向图，还要插入边&lt;V2, V1&gt; */</span>      <br>    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight; <br>&#125; <br><br>MGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span> <br>&#123;     <br>    MGraph Graph;     <br>    Edge E;     <br>    Vertex V;     <br>    <span class="hljs-type">int</span> Nv, i;          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Nv);   <span class="hljs-comment">/* 读入顶点个数 */</span>     Graph = CreateGraph(Nv); <span class="hljs-comment">/* 初始化有Nv个顶点但没有边的图 */</span>           <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));   <span class="hljs-comment">/* 读入边数 */</span>     <span class="hljs-keyword">if</span> ( Graph-&gt;Ne != <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">/* 如果有边 */</span>          E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode)); <span class="hljs-comment">/* 建立边结点 */</span>          <br>    <span class="hljs-comment">/* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span>         <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++) &#123;             <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);              <br>    <span class="hljs-comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span>             InsertEdge( Graph, E );         <br>    &#125;     <br>&#125;      <br><span class="hljs-comment">/* 如果顶点有数据的话，读入数据 */</span>     <br><span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)         <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;(Graph-&gt;Data[V]));     <br><span class="hljs-keyword">return</span> Graph; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="邻接表表示"><a href="#邻接表表示" class="headerlink" title="邻接表表示"></a>邻接表表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 图的邻接表表示法 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100    <span class="hljs-comment">/* 最大顶点数设为100 */</span> typedef int Vertex;         <span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span> typedef int WeightType;        <span class="hljs-comment">/* 边的权值设为整型 */</span> typedef char DataType;        <span class="hljs-comment">/* 顶点存储的数据类型设为字符型 */</span> </span><br><span class="hljs-comment">/* 边的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span>     <br>    Vertex V1, V2;      <span class="hljs-comment">/* 有向边&lt;V1, V2&gt; */</span>     WeightType Weight;  <span class="hljs-comment">/* 权重 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToENode Edge; <br><br><span class="hljs-comment">/* 邻接点的定义 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span> *<span class="hljs-title">PtrToAdjVNode</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span>&#123;</span>     <br>    Vertex AdjV;        <span class="hljs-comment">/* 邻接点下标 */</span>     WeightType Weight;  <span class="hljs-comment">/* 边权重 */</span>     PtrToAdjVNode Next;    <span class="hljs-comment">/* 指向下一个邻接点的指针 */</span> <br>&#125;; <br><br><span class="hljs-comment">/* 顶点表头结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vnode</span>&#123;</span>     <br>    PtrToAdjVNode FirstEdge;<span class="hljs-comment">/* 边表头指针 */</span>     DataType Data;            <span class="hljs-comment">/* 存顶点的数据 */</span>     <br>    <span class="hljs-comment">/* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */</span> &#125; AdjList[MaxVertexNum];    <span class="hljs-comment">/* AdjList是邻接表类型 */</span> <br>    <br>    <br><span class="hljs-comment">/* 图结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span>       <br>    <span class="hljs-type">int</span> Nv;     <span class="hljs-comment">/* 顶点数 */</span>     <br>    <span class="hljs-type">int</span> Ne;     <span class="hljs-comment">/* 边数   */</span>     <br>    AdjList G;  <span class="hljs-comment">/* 邻接表 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToGNode LGraph; <span class="hljs-comment">/* 以邻接表方式存储的图类型 */</span> <br><br><br>LGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">( <span class="hljs-type">int</span> VertexNum )</span> <br>&#123; <span class="hljs-comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span>     <br>    Vertex V;     <br>    LGraph Graph;          Graph = (LGraph)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode) ); <span class="hljs-comment">/* 建立图 */</span>     <br>    <br>    Graph-&gt;Nv = VertexNum;     <br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;     <br>    <span class="hljs-comment">/* 初始化邻接表头指针 */</span>     <br>    <span class="hljs-comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span>        <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)         <br>        Graph-&gt;G[V].FirstEdge = <span class="hljs-literal">NULL</span>;                  <span class="hljs-keyword">return</span> Graph;  <br>&#125;         <br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">( LGraph Graph, Edge E )</span> &#123;     PtrToAdjVNode NewNode;                          <br>      <span class="hljs-comment">/* 插入边 &lt;V1, V2&gt; */</span>     <br>      <span class="hljs-comment">/* 为V2建立新的邻接点 */</span>     NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));     <br>      NewNode-&gt;AdjV = E-&gt;V2;     <br>      NewNode-&gt;Weight = E-&gt;Weight;     <br>      <span class="hljs-comment">/* 将V2插入V1的表头 */</span>     <br>      NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;      <br>      Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;               <br>      <span class="hljs-comment">/* 若是无向图，还要插入边 &lt;V2, V1&gt; */</span>     <br>      <span class="hljs-comment">/* 为V1建立新的邻接点 */</span>     NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));     <br>      NewNode-&gt;AdjV = E-&gt;V1;     <br>      NewNode-&gt;Weight = E-&gt;Weight;     <br>      <span class="hljs-comment">/* 将V1插入V2的表头 */</span>     <br>      NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;     Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode; <br>&#125; <br>LGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span> <br>&#123;     <br>    LGraph Graph;     <br>    Edge E;     <br>    Vertex V;     <br>    <span class="hljs-type">int</span> Nv, i;          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Nv);   <span class="hljs-comment">/* 读入顶点个数 */</span>     Graph = CreateGraph(Nv); <span class="hljs-comment">/* 初始化有Nv个顶点但没有边的图 */</span>           <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));   <span class="hljs-comment">/* 读入边数 */</span>     <span class="hljs-keyword">if</span> ( Graph-&gt;Ne != <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">/* 如果有边 */</span>          E = (Edge)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode) ); <span class="hljs-comment">/* 建立边结点 */</span>          <br>        <span class="hljs-comment">/* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span>         <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++) &#123;             <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);              <span class="hljs-comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span>             <br>        InsertEdge( Graph, E );         <br>        &#125;     <br>    &#125;      <span class="hljs-comment">/* 如果顶点有数据的话，读入数据 */</span>     <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;(Graph-&gt;G[V].Data));     <span class="hljs-keyword">return</span> Graph; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS-邻接表存储"><a href="#DFS-邻接表存储" class="headerlink" title="DFS-邻接表存储"></a>DFS-邻接表存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接表存储的图 - DFS */</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">Visit</span><span class="hljs-params">( Vertex V )</span> <br>&#123;     <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正在访问顶点%d\n&quot;</span>, V); &#125; <br>    <span class="hljs-comment">/* Visited[]为全局变量，已经初始化为false */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">( LGraph Graph, Vertex V, <span class="hljs-type">void</span> (*Visit)(Vertex) )</span> <br>&#123;   <span class="hljs-comment">/* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */</span>     PtrToAdjVNode W;          <br>    Visit( V ); <span class="hljs-comment">/* 访问第V个顶点 */</span>     Visited[V] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记V已访问 */</span>     <br>    <span class="hljs-keyword">for</span>( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="hljs-comment">/* 对V的每个邻接点W-&gt;AdjV */</span>         <br>        <span class="hljs-keyword">if</span> ( !Visited[W-&gt;AdjV] )    <span class="hljs-comment">/* 若W-&gt;AdjV未被访问 */</span>             DFS( Graph, W-&gt;AdjV, Visit );    <span class="hljs-comment">/* 则递归访问之 */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS-邻接矩阵存储"><a href="#BFS-邻接矩阵存储" class="headerlink" title="BFS-邻接矩阵存储"></a>BFS-邻接矩阵存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储的图 - BFS */</span> <br><br><span class="hljs-comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span> <br><span class="hljs-comment">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span> <br><span class="hljs-comment">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">IsEdge</span><span class="hljs-params">( MGraph Graph, Vertex V, Vertex W )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> Graph-&gt;G[V][W]&lt;INFINITY ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <br>&#125; <br><br><span class="hljs-comment">/* Visited[]为全局变量，已经初始化为false */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span> <span class="hljs-params">( MGraph Graph, Vertex S, <span class="hljs-type">void</span> (*Visit)(Vertex) )</span> <br>&#123;   <span class="hljs-comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span>     Queue Q;          <br>    Vertex V, W;     <br>    Q = CreateQueue( MaxSize ); <span class="hljs-comment">/* 创建空队列, MaxSize为外部定义的常数 */</span>     <br>    <span class="hljs-comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span>     Visit( S );     <br>    Visited[S] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记S已访问 */</span>     AddQ(Q, S); <span class="hljs-comment">/* S入队列 */</span>          <span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;         V = DeleteQ(Q);  <span class="hljs-comment">/* 弹出V */</span>         <span class="hljs-keyword">for</span>( W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="hljs-comment">/* 对图中的每个顶点W */</span>             <br>            <span class="hljs-comment">/* 若W是V的邻接点并且未访问过 */</span>             <span class="hljs-keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;                 <span class="hljs-comment">/* 访问顶点W */</span>                 Visit( W );                 Visited[W] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记W已访问 */</span>                 AddQ(Q, W); <span class="hljs-comment">/* W入队列 */</span>             &#125;     &#125; <span class="hljs-comment">/* while结束*/</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合及运算</title>
    <link href="/2022/07/24/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
    <url>/2022/07/24/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h1><ul><li>集合运算：交、并、补、差，判定一个元素是否属于某一集合</li><li>并查集：集合并、查某元素属于什么集合</li><li>并查集问题中集合存储如何实现？<ul><li>用树结构表示集合，树的每个结点代表一个集合元素</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241251680.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241252797.png"></p><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="查找某元素所在集合（用根节点表示）"><a href="#查找某元素所在集合（用根节点表示）" class="headerlink" title="查找某元素所在集合（用根节点表示）"></a>查找某元素所在集合（用根节点表示）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241253516.png"></p><h3 id="集合的并运算"><a href="#集合的并运算" class="headerlink" title="集合的并运算"></a>集合的并运算</h3><ul><li>分别找到X1和X2两个元素所在集合树的根结点</li><li>如果它们不同根，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241254732.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241255267.png"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1000                  <span class="hljs-comment">/* 集合最大元素个数 */</span> typedef int ElementType;           <span class="hljs-comment">/* 默认元素可以用非负整数表示 */</span> typedef int SetName;               <span class="hljs-comment">/* 默认用根结点的下标作为集合名称 */</span> </span><br><span class="hljs-keyword">typedef</span> ElementType SetType[MAXN]; <span class="hljs-comment">/* 假设集合元素下标从0开始 */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType S, SetName Root1, SetName Root2 )</span> <br>&#123; <span class="hljs-comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span>     <br>    <span class="hljs-comment">/* 保证小集合并入大集合 */</span>     <br>    <span class="hljs-keyword">if</span> ( S[Root2] &lt; S[Root1] ) &#123; <br>    <span class="hljs-comment">/* 如果集合2比较大 */</span>         <br>    S[Root2] += S[Root1];     <br>    <span class="hljs-comment">/* 集合1并入集合2  */</span>         <br>    S[Root1] = Root2;     <br>    &#125;     <br>    <span class="hljs-keyword">else</span> &#123;                         <br>    <span class="hljs-comment">/* 如果集合1比较大 */</span>         <br>    S[Root1] += S[Root2];     <br>    <span class="hljs-comment">/* 集合2并入集合1  */</span>         <br>    S[Root2] = Root1;     &#125; &#125; SetName <span class="hljs-title function_">Find</span><span class="hljs-params">( SetType S, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 默认集合元素全部初始化为-1 */</span>     <br>    <span class="hljs-keyword">if</span> ( S[X] &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">/* 找到集合的根 */</span>         <br>    <span class="hljs-keyword">return</span> X;     <br>    <span class="hljs-keyword">else</span>         <br>    <span class="hljs-keyword">return</span> S[X] = Find( S, S[X] ); <span class="hljs-comment">/* 路径压缩 */</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <link href="/2022/07/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <url>/2022/07/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241227734.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241229585.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241229037.png"></p><p><strong>问题来了：如何根据结点不同的查找频率构造更有效的搜索树？</strong></p><h2 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231882.png"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231185.png"></p><h2 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231082.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241233586.png"></p><h2 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241233573.png"></p><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><p>给定一段字符串，如何对字符串进行编码，可以使得该字符串的编码存储空间最少？</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241235132.png"></p><p>怎么进行不等长编码？</p><p>如何避免二义性？<br>用前缀码<br>前缀码：任何字符的编码都不是另一字符编码的前缀<br>这样就可以无二义地解码</p><h2 id="二叉树用于编码"><a href="#二叉树用于编码" class="headerlink" title="二叉树用于编码"></a>二叉树用于编码</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241238663.png"></p><p><strong>怎样构造一棵编码代价最小的二叉树？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241240737.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2022/07/24/%E5%A0%86/"/>
    <url>/2022/07/24/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241122025.png"><br>如何组织优先队列？<br>用一般的数组、链表？<br>有序的数组或者链表？<br>二叉搜索树？AVL树？</p><h3 id="采用数组或链表？"><a href="#采用数组或链表？" class="headerlink" title="采用数组或链表？"></a>采用数组或链表？</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241123470.png"></p><h3 id="采用二叉树？"><a href="#采用二叉树？" class="headerlink" title="采用二叉树？"></a>采用二叉树？</h3><ul><li>采用二叉搜索树？<ul><li>需要树的高度适合，而二叉搜索树，经过删除操作容易歪掉</li></ul></li><li>更应该关注插入还是删除？  <ul><li>更应该关注删除，因为删除操作更难实现</li></ul></li><li>树结点顺序怎么安排？<ul><li>最值放在树根</li></ul></li><li>树结构怎么样？     <ul><li>用完全二叉树，会更加平衡一点</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241125555.png"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241126397.png"><br>判断是不是堆<br>条件一：看它是不是完全二叉树<br>条件二：任一子树的根是不是该子树的最大值或者最小值<br>图中左边两个都不是完全二叉树<br>而右边两个虽然是完全二叉树，但不满足第二个条件</p><h2 id="堆的抽象数据类型描述"><a href="#堆的抽象数据类型描述" class="headerlink" title="堆的抽象数据类型描述"></a>堆的抽象数据类型描述</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241127568.png"></p><h3 id="最大堆的操作"><a href="#最大堆的操作" class="headerlink" title="最大堆的操作"></a>最大堆的操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241219352.png"><br>把MaxData换成小于堆中所有元素的MiniData，同样适合于创建最小堆</p><ul><li>将已存在的N个元素按最大堆的要求存放在一个一维数组中<ul><li>方法一：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为o（N logN）</li><li>方法二：在线性时间复杂度下建立最大堆<ul><li>将N个元素按输入顺序存入，先满足完全二叉树的结构特性</li><li>调整各结点位置，以满足最大堆的有序特性</li></ul></li></ul></li></ul><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221880.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221708.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221259.png"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241222284.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241222831.png"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> *<span class="hljs-title">Heap</span>;</span> <span class="hljs-comment">/* 堆的类型定义 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> &#123;</span>     <br>ElementType *Data; <span class="hljs-comment">/* 存储元素的数组 */</span>     <span class="hljs-type">int</span> Size;          <span class="hljs-comment">/* 堆中当前元素个数 */</span>     <span class="hljs-type">int</span> Capacity;      <span class="hljs-comment">/* 堆的最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> Heap MaxHeap; <span class="hljs-comment">/* 最大堆 */</span> <br><span class="hljs-keyword">typedef</span> Heap MinHeap; <span class="hljs-comment">/* 最小堆 */</span> <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXDATA 1000  <span class="hljs-comment">/* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span> </span><br>MaxHeap <span class="hljs-title function_">CreateHeap</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> <br>&#123; <span class="hljs-comment">/* 创建容量为MaxSize的空的最大堆 */</span><br><br>MaxHeap H = (MaxHeap)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> HNode));     <br>H-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>((MaxSize+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(ElementType));     H-&gt;Size = <span class="hljs-number">0</span>;     <br>    H-&gt;Capacity = MaxSize;     <br>    H-&gt;Data[<span class="hljs-number">0</span>] = MAXDATA; <span class="hljs-comment">/* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/</span>     <span class="hljs-keyword">return</span> H; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> (H-&gt;Size == H-&gt;Capacity); <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( MaxHeap H, ElementType X )</span> <br>&#123;   <span class="hljs-comment">/* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span>     <br><span class="hljs-type">int</span> i;       <br><span class="hljs-keyword">if</span> ( IsFull(H) ) &#123;          <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br>i = ++H-&gt;Size; <span class="hljs-comment">/* i指向插入后堆中的最后一个元素的位置 */</span>     <span class="hljs-keyword">for</span> ( ; H-&gt;Data[i/<span class="hljs-number">2</span>] &lt; X; i/=<span class="hljs-number">2</span> )         <br>H-&gt;Data[i] = H-&gt;Data[i/<span class="hljs-number">2</span>]; <span class="hljs-comment">/* 上滤X */</span>     <br>H-&gt;Data[i] = X; <span class="hljs-comment">/* 将X插入 */</span>     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1 <span class="hljs-comment">/* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span> </span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> (H-&gt;Size == <span class="hljs-number">0</span>); <br>&#125; <br>ElementType <span class="hljs-title function_">DeleteMax</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123; <span class="hljs-comment">/* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span>     <span class="hljs-type">int</span> Parent, Child;     <br>    ElementType MaxItem, X;     <br>    <span class="hljs-keyword">if</span> ( IsEmpty(H) ) &#123;         <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已为空&quot;</span>);         <br>    <span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br>MaxItem = H-&gt;Data[<span class="hljs-number">1</span>]; <span class="hljs-comment">/* 取出根结点存放的最大值 */</span>     <br><span class="hljs-comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span>     <br>X = H-&gt;Data[H-&gt;Size--]; <span class="hljs-comment">/* 注意当前堆的规模要减小 */</span>     <span class="hljs-keyword">for</span>( Parent=<span class="hljs-number">1</span>; Parent*<span class="hljs-number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;         Child = Parent * <span class="hljs-number">2</span>;         <br>    <span class="hljs-keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="hljs-number">1</span>]) )             Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span>         <span class="hljs-keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>         <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>             <br>        H-&gt;Data[Parent] = H-&gt;Data[Child];     &#125;     <br>        H-&gt;Data[Parent] = X;     <span class="hljs-keyword">return</span> MaxItem; &#125;  <br>        <span class="hljs-comment">/*----------- 建造最大堆 -----------*/</span> <span class="hljs-type">void</span> <span class="hljs-title function_">PercDown</span><span class="hljs-params">( MaxHeap H, <span class="hljs-type">int</span> p )</span> <br>&#123; <br>    <span class="hljs-comment">/* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span>     <span class="hljs-type">int</span> Parent, Child;     <br>    ElementType X;     <br>    X = H-&gt;Data[p]; <span class="hljs-comment">/* 取出根结点存放的值 */</span>     <br>    <span class="hljs-keyword">for</span>( Parent=p; Parent*<span class="hljs-number">2</span>&lt;=H-&gt;Size; Parent=Child ) <br>    &#123;         <br>    Child = Parent * <span class="hljs-number">2</span>;         <br>    <span class="hljs-keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="hljs-number">1</span>]) )             Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span>         <span class="hljs-keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>         <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>             <br>    H-&gt;Data[Parent] = H-&gt;Data[Child];     <br>&#125;     <br>H-&gt;Data[Parent] = X; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildHeap</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123; <br><span class="hljs-comment">/* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span>   <br><span class="hljs-comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span>    <br>    <span class="hljs-type">int</span> i;     <span class="hljs-comment">/* 从最后一个结点的父节点开始，到根结点1 */</span>     <span class="hljs-keyword">for</span>( i = H-&gt;Size/<span class="hljs-number">2</span>; i&gt;<span class="hljs-number">0</span>; i-- )         <br>    PercDown( H, i ); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的基本概念及相关</title>
    <link href="/2022/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240856336.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240856794.png"></p><p> 完美二叉树就是除了最后一层，其余每个子树都有左右子树</p><p> 完全二叉树是指按序号位置排列不中断，不空缺，可以少后面的编号，但前面一定不能断开  </p><h2 id="二叉树几个重要性质"><a href="#二叉树几个重要性质" class="headerlink" title="二叉树几个重要性质"></a>二叉树几个重要性质</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240857254.png"></p><p>可用来粗略判断是不是二叉树</p><h2 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240858122.png"></p><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240859721.png"></p><p>依靠数组来实现</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240900427.png"></p><p>一般二叉树的顺序存储结构会造成空间浪费<br>不好！！！</p><h3 id="链表存储"><a href="#链表存储" class="headerlink" title="链表存储"></a>链表存储</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240901673.png"></p><p>仍然是父子兄弟表示法</p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>有先序遍历、中序遍历、后序遍历三种<br>先、中、后都是指向对根的访问<br>先序就是根左右<br>中序就是左根右<br>后序就是左右根</p><h2 id="三种递归调用实现的遍历"><a href="#三种递归调用实现的遍历" class="headerlink" title="三种递归调用实现的遍历"></a>三种递归调用实现的遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907236.png"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907401.png"></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907322.png"></p><h3 id="三种遍历的区分"><a href="#三种遍历的区分" class="headerlink" title="三种遍历的区分"></a>三种遍历的区分</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240909169.png"></p><p>**经过结点的路线一样，只是访问各结点的时机不同</p><h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><p>**基本思路：堆栈</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240912811.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240912008.png"></p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240913587.png"><br>**核心问题是要记住访问的结点，怎么记住？堆栈或队列！！！</p><h4 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240914981.png"><br>A先入队然后出队<br>A的儿子B和C入队<br>B出队，B的儿子D和F入队<br>C出队，C的儿子G和I入队<br>D出队<br>F出队，F的儿子E入队<br>G出队，G的儿子H入队<br>I出队<br>E出队<br>H出队<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240922079.png"></p><h2 id="遍历二叉树的应用"><a href="#遍历二叉树的应用" class="headerlink" title="遍历二叉树的应用"></a>遍历二叉树的应用</h2><h3 id="输出二叉树中的叶子结点"><a href="#输出二叉树中的叶子结点" class="headerlink" title="输出二叉树中的叶子结点"></a>输出二叉树中的叶子结点</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240923837.png"></p><h3 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240923052.png"></p><h3 id="二元运算表达式树及其遍历"><a href="#二元运算表达式树及其遍历" class="headerlink" title="二元运算表达式树及其遍历"></a>二元运算表达式树及其遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240924502.png"></p><p>中序遍历不一定得到中缀表达式<br>因为会受到运算符优先级的影响<br>可以引入括号来解决</p><h3 id="由两种遍历序列确定二叉树"><a href="#由两种遍历序列确定二叉树" class="headerlink" title="由两种遍历序列确定二叉树"></a>由两种遍历序列确定二叉树</h3><p>这两种遍历中必须要有中序遍历，如果只有先序和后序则无法确定</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240925601.png"><br>不断分割<br>先用先序遍历找到根<br>然后去中序序列的找到已知的根<br>进而找到已知根的左子树和右子树的中序序列<br>我们可以得到左子树的元素个数，那么再去先序序列中，往后对应个数的元素就是左子树的先序序列<br>右子树与左子树同理<br>这样就不断循环分割，确定出一颗二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240925919.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span> *<span class="hljs-title">Position</span>;</span> <br><span class="hljs-keyword">typedef</span> Position BinTree; <span class="hljs-comment">/* 二叉树类型 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span>&#123;</span> <br><span class="hljs-comment">/* 树结点定义 */</span>     <br>ElementType Data; <span class="hljs-comment">/* 结点数据 */</span>     <br>BinTree Left;     <span class="hljs-comment">/* 指向左子树 */</span>     <br>BinTree Right;    <span class="hljs-comment">/* 指向右子树 */</span> <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树的四种遍历"><a href="#二叉树的四种遍历" class="headerlink" title="二叉树的四种遍历"></a>二叉树的四种遍历</h3><p>中序、先序、后序、层序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InorderTraversal</span><span class="hljs-params">( BinTree BT )</span> &#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br>InorderTraversal( BT-&gt;Left );         <br><span class="hljs-comment">/* 此处假设对BT结点的访问就是打印数据 */</span>         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data); <span class="hljs-comment">/* 假设数据为整型 */</span>         InorderTraversal( BT-&gt;Right );     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderTraversal</span><span class="hljs-params">( BinTree BT )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data );         <br>PreorderTraversal( BT-&gt;Left );         PreorderTraversal( BT-&gt;Right );     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">PostorderTraversal</span><span class="hljs-params">( BinTree BT )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br>PostorderTraversal( BT-&gt;Left );         PostorderTraversal( BT-&gt;Right );         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data);     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelorderTraversal</span> <span class="hljs-params">( BinTree BT )</span> <br>&#123;      <br>Queue Q;      <br>BinTree T;     <br><span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span>          Q = CreatQueue(); <span class="hljs-comment">/* 创建空队列Q */</span>     <br>AddQ( Q, BT );     <br><span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;         <br>T = DeleteQ( Q );         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;Data); <span class="hljs-comment">/* 访问取出队列的结点 */</span>          <br>    <span class="hljs-keyword">if</span> ( T-&gt;Left )   AddQ( Q, T-&gt;Left );         <br>    <span class="hljs-keyword">if</span> ( T-&gt;Right )  AddQ( Q, T-&gt;Right );     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/07/18/%E9%98%9F%E5%88%97/"/>
    <url>/2022/07/18/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>什么是队列？<ul><li>具有一定操作约束的线性表</li><li>只能在一端插入，而在另一端删除</li><li>数据插入：入队列</li><li>数据删除：出队列</li><li>先来先服务</li><li>先进先出：FIFO</li></ul></li><li>队列的抽象数据类型描述<ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的队列Q$\in$Qyeue,队列元素item$\in$ElementType</li><li>基本操作<ul><li>Queue CreatQueue(int MaxSize)：生成长度为MaxSize的空队列</li><li>int IsFullQ(Queue Q,int MaxSize)：判断队列Q是否已满</li><li>void AddQ(Queue Q, ElementType item)：将数据元素item插入队列Q中</li><li>int IsEmptyQ(Queue Q)：判断队列Q是否为空</li><li>ElementType DeleteQ(Queue Q)：将队头数据元素从队列中删除并返回</li></ul></li></ul></li><li>队列的顺序存储实现<ul><li>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成的顺环队列</li></ul></li><li>队列的链式存储实现<ul><li>可以用一个单链表实现，插入和删除操作分别在链表的两头进行</li><li>注意：队列指针front应在单向链表的开头rear在尾（尾部删除操作找不到前面的元素，所有不能把front放在尾）</li></ul></li><li>应用实例（多项式加法）<ul><li>主要思路：相同指数项系数相加，不同指数项系数进行拷贝</li><li>采用不带头结点的单向链表，按照指数递减的顺序排列各项</li><li>两个指针P1和P2分别指向这两个多项式的第一个结点，不断循环<ul><li>P1指向的项如果指数等于P2指向的项的指数：系数相加，若结果不为0，则作为结果多项式对应项的系数。同时，P1和P2都分别指向下一项<ul><li>P1所指指数大于P2：将P1的当前项存入结果多项式，并使P1指向下一项</li><li>P1所指指数小于P2：将P2的当前项存入结果多项式，并使P2指向下一项</li><li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去</li></ul></li></ul></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span>     Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> &#123;     Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));     Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;     <br>Q-&gt;MaxSize = MaxSize;         <br><span class="hljs-keyword">return</span> Q;      <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span> &#123;     <br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;   Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>&#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear); &#125; <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">if</span> ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span>  <br>&#123;   Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;         <br><span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-comment">/* 队列中的结点 */</span>     <br>ElementType Data;     <br>PtrToNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToNode Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> &#125;; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>); &#125; ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br>Position FrontCell;      <br>ElementType FrontElem;          <br><span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;    FrontCell = Q-&gt;Front;         <br><span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span>                 Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span> <br>            <span class="hljs-keyword">else</span>                                  <br> Q-&gt;Front = Q-&gt;Front-&gt;Next;         <br> FrontElem = FrontCell-&gt;Data;         <br> <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span>         <br> <span class="hljs-keyword">return</span>  FrontElem;     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多项式加法用队列实现"><a href="#多项式加法用队列实现" class="headerlink" title="多项式加法用队列实现"></a>多项式加法用队列实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆栈</title>
    <link href="/2022/07/18/%E5%A0%86%E6%A0%88/"/>
    <url>/2022/07/18/%E5%A0%86%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>中缀表达式：运算符号位于两个运算数之间，如a+b*c-d&#x2F;e</p></li><li><p>后缀表达式：运算符号位于两个运算数之后，如abc*+de&#x2F;-</p></li><li><p>前缀表达式：运算符号位于两个运算数之前，如-+a*bc&#x2F;de</p></li><li><p>前缀表达式怎么求值？？？</p></li><li><p>后缀表达式求值策略：从左往右扫描，逐个处理运算数和运算符号</p><ul><li>遇到运算数怎么办？–把运算数记住</li><li>遇到运算符号怎么办？–把最近记住的两个数拿来做对应的运算</li></ul></li><li><p>这就给我们带来启示，需要有种存储方法，能顺序存储运算数，并在需要时“倒序”输出</p></li><li><p>于是，堆栈的意义也就出来了，先放进去的后拿出来，后放进去的先拿出来运算</p></li><li><p>堆栈的抽象数据类型描述</p><ul><li>具有一定操作约束的线性表</li><li>只在一端（栈顶，Top）做插入、删除</li><li>插入数据：入栈（Push）</li><li>删除数据：出栈（Pop）</li><li>后入先出：Last In First Out(LIFO)</li></ul></li><li><p>堆栈的操作</p><ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的堆栈S $\in$ Stack,堆栈元素item$\in$ ElementType</li><li>Stack CreateStack( int MaxSize )：生成空堆栈，其最大长度为MaxSize</li><li>bool IsFull( Stack S )：判断堆栈S是否已满</li><li>bool Push( Stack S, ElementType item )：将元素item压入堆栈</li><li>bool IsEmpty ( Stack S )：判断堆栈S是否为空</li><li>ElementType Pop( Stack S )：删除并返回栈顶元素</li></ul></li><li><p>栈的顺序储存实现</p><ul><li>xxxxxxxxxx typedef struct HNode <em>Heap; &#x2F;</em> 堆的类型定义 <em>&#x2F; struct HNode {         ElementType <em>Data; &#x2F;</em> 存储元素的数组 <em>&#x2F;     int Size;          &#x2F;</em> 堆中当前元素个数 <em>&#x2F;     int Capacity;      &#x2F;</em> 堆的最大容量 <em>&#x2F; }; typedef Heap MaxHeap; &#x2F;</em> 最大堆 <em>&#x2F; typedef Heap MinHeap; &#x2F;</em> 最小堆 <em>&#x2F; ​#define MAXDATA 1000  &#x2F;</em> 该值应根据具体情况定义为大于堆中所有可能元素的值 <em>&#x2F; MaxHeap CreateHeap( int MaxSize ) { &#x2F;</em> 创建容量为MaxSize的空的最大堆 <em>&#x2F;​MaxHeap H &#x3D; (MaxHeap)malloc(sizeof(struct HNode));     H-&gt;Data &#x3D; (ElementType <em>)malloc((MaxSize+1)<em>sizeof(ElementType));     H-&gt;Size &#x3D; 0;         H-&gt;Capacity &#x3D; MaxSize;         H-&gt;Data[0] &#x3D; MAXDATA; &#x2F;</em> 定义”哨兵”为大于堆中所有可能元素的值</em>&#x2F;     return H; } bool IsFull( MaxHeap H ) {         return (H-&gt;Size &#x3D;&#x3D; H-&gt;Capacity); } bool Insert( MaxHeap H, ElementType X ) {   &#x2F;</em> 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 <em>&#x2F;         int i;           if ( IsFull(H) ) {                  printf(“最大堆已满”);                 return false;         }         i &#x3D; ++H-&gt;Size; &#x2F;</em> i指向插入后堆中的最后一个元素的位置 <em>&#x2F;     for ( ; H-&gt;Data[i&#x2F;2] &lt; X; i&#x2F;&#x3D;2 )                 H-&gt;Data[i] &#x3D; H-&gt;Data[i&#x2F;2]; &#x2F;</em> 上滤X <em>&#x2F;             H-&gt;Data[i] &#x3D; X; &#x2F;</em> 将X插入 <em>&#x2F;             return true;     } #define ERROR -1 &#x2F;</em> 错误标识应根据具体情况定义为堆中不可能出现的元素值 <em>&#x2F; bool IsEmpty( MaxHeap H ) {         return (H-&gt;Size &#x3D;&#x3D; 0); } ElementType DeleteMax( MaxHeap H ) { &#x2F;</em> 从最大堆H中取出键值为最大的元素，并删除一个结点 <em>&#x2F;     int Parent, Child;         ElementType MaxItem, X;         if ( IsEmpty(H) ) {                 printf(“最大堆已为空”);                 return ERROR;         }         MaxItem &#x3D; H-&gt;Data[1]; &#x2F;</em> 取出根结点存放的最大值 <em>&#x2F;         &#x2F;</em> 用最大堆中最后一个元素从根结点开始向上过滤下层结点 <em>&#x2F;         X &#x3D; H-&gt;Data[H-&gt;Size–]; &#x2F;</em> 注意当前堆的规模要减小 <em>&#x2F;     for( Parent&#x3D;1; Parent</em>2&lt;&#x3D;H-&gt;Size; Parent&#x3D;Child ) {         Child &#x3D; Parent * 2;                 if( (Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]<H->Data[Child+1]) )             Child++;  &#x2F;</em> Child指向左右子结点的较大者 <em>&#x2F;         if( X &gt;&#x3D; H-&gt;Data[Child] ) break; &#x2F;</em> 找到了合适位置 <em>&#x2F;         else  &#x2F;</em> 下滤X <em>&#x2F;                         H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];     }                 H-&gt;Data[Parent] &#x3D; X;     return MaxItem; }              &#x2F;</em>———– 建造最大堆 ———–<em>&#x2F; void PercDown( MaxHeap H, int p ) {     &#x2F;</em> 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 <em>&#x2F;     int Parent, Child;         ElementType X;         X &#x3D; H-&gt;Data[p]; &#x2F;</em> 取出根结点存放的值 <em>&#x2F;         for( Parent&#x3D;p; Parent</em>2&lt;&#x3D;H-&gt;Size; Parent&#x3D;Child )     {                 Child &#x3D; Parent * 2;                 if( (Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]<H->Data[Child+1]) )             Child++;  &#x2F;* Child指向左右子结点的较大者 <em>&#x2F;         if( X &gt;&#x3D; H-&gt;Data[Child] ) break; &#x2F;</em> 找到了合适位置 <em>&#x2F;         else  &#x2F;</em> 下滤X <em>&#x2F;                     H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];         }         H-&gt;Data[Parent] &#x3D; X; } void BuildHeap( MaxHeap H ) { &#x2F;</em> 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  <em>&#x2F;   &#x2F;</em> 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 <em>&#x2F;        int i;     &#x2F;</em> 从最后一个结点的父节点开始，到根结点1 *&#x2F;     for( i &#x3D; H-&gt;Size&#x2F;2; i&gt;0; i– )                 PercDown( H, i ); }c</li></ul></li><li><p>堆栈的链式储存实现</p><ul><li>实际上就是一个单链表，叫做链栈。插入和删除操作只能在栈的栈顶进行。栈顶指针只能在链表的开头，不能用结尾做top</li></ul></li><li><p>中缀表达式转化为后缀表达式</p><ul><li>从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理</li><li>运算数直接输出</li><li>左括号压入堆栈</li><li>右括号将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）</li><li>运算符<ul><li>若优先级大于栈顶运算符，就把它压栈</li><li>若优先级小于等于栈顶运算符，就把栈顶运算符弹出并输出，再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈</li></ul></li><li>若各对象处理完毕，就把堆栈中存留的运算符一并输出</li></ul></li><li><p>堆栈的一些其他应用</p><ul><li>函数调用及递归实现</li><li>深度优先搜索</li><li>回溯算法</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3></li></ul><h4 id="堆栈的定义与操作——顺序存储"><a href="#堆栈的定义与操作——顺序存储" class="headerlink" title="堆栈的定义与操作——顺序存储"></a>堆栈的定义与操作——顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> </span><br><span class="hljs-class">&#123;</span>     <br> ElementType *Data; <br> <span class="hljs-comment">/* 存储元素的数组 */</span>     <br> Position Top;      <br> <span class="hljs-comment">/* 栈顶指针 */</span>     <br> <span class="hljs-type">int</span> MaxSize;       <br> <span class="hljs-comment">/* 堆栈最大容量 */</span> &#125;; <br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span> <br> Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> <br> &#123;     <br> Stack S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br> S-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));    <br> S-&gt;Top = <span class="hljs-number">-1</span>;     <br> S-&gt;MaxSize = MaxSize;     <br> <span class="hljs-keyword">return</span> S; <br> &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Stack S )</span> &#123;     <span class="hljs-keyword">return</span> (S-&gt;Top == S-&gt;MaxSize<span class="hljs-number">-1</span>); &#125; <span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span> <br>&#123;     <span class="hljs-keyword">if</span> ( IsFull(S) ) <br>  &#123;   <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;     <br>      <span class="hljs-keyword">else</span> <br>      &#123;         <br>      S-&gt;Data[++(S-&gt;Top)] = X;         <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>      &#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Stack S )</span> &#123;     <span class="hljs-keyword">return</span> (S-&gt;Top == <span class="hljs-number">-1</span>); &#125; ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span><br>&#123;     <span class="hljs-keyword">if</span> ( IsEmpty(S) ) <br>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);         <br> <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* ERROR是ElementType的特殊值，标志错误 */</span>     <br>&#125;     <br>   <span class="hljs-keyword">else</span>          <br>         <span class="hljs-keyword">return</span> ( S-&gt;Data[(S-&gt;Top)--] ); <br> &#125;<br></code></pre></td></tr></table></figure><h4 id="堆栈的定义与操作——链式存储"><a href="#堆栈的定义与操作——链式存储" class="headerlink" title="堆栈的定义与操作——链式存储"></a>堆栈的定义与操作——链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">PtrToSNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span>     <br>ElementType Data;     <br>PtrToSNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToSNode Stack; <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( )</span>  &#123; <br><span class="hljs-comment">/* 构建一个堆栈的头结点，返回该结点指针 */</span>     <br>Stack S;     <br>S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br>S-&gt;Next = <span class="hljs-literal">NULL</span>;     <br><span class="hljs-keyword">return</span> S; &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span> <span class="hljs-params">( Stack S )</span> <br>&#123; <span class="hljs-comment">/* 判断堆栈S是否为空，若是返回true；否则返回false */</span>     <br><span class="hljs-keyword">return</span> ( S-&gt;Next == <span class="hljs-literal">NULL</span> ); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 将元素X压入堆栈S */</span>     <br>PtrToSNode TmpCell;     TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br>TmpCell-&gt;Data = X;     <br>TmpCell-&gt;Next = S-&gt;Next;     <br>S-&gt;Next = TmpCell;     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125; <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span>   <br>&#123; <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span>     <br>PtrToSNode FirstCell;     <br>ElementType TopElem;     <br><span class="hljs-keyword">if</span>( IsEmpty(S) ) <br>        &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);          <br><span class="hljs-keyword">return</span> ERROR;     <br>    &#125;    <br><span class="hljs-keyword">else</span> <br>   &#123;         <br>  FirstCell = S-&gt;Next;          <br>  TopElem = FirstCell-&gt;Data;        <br>   S-&gt;Next = FirstCell-&gt;Next;         <br>   <span class="hljs-built_in">free</span>(FirstCell);         <br>   <span class="hljs-keyword">return</span> TopElem;     <br>   &#125; <br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本概念</title>
    <link href="/2022/07/18/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/07/18/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h1><ul><li>查找<ul><li>静态查找<ul><li>没有插入和删除操作，只有查找</li></ul></li><li>动态查找<ul><li>除查找，还有插入和删除操作</li></ul></li></ul></li></ul><h2 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h2><h4 id="方法一-顺序查找"><a href="#方法一-顺序查找" class="headerlink" title="方法一 顺序查找"></a>方法一 顺序查找</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240828985.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240828985.png"></p><p>哨兵的作用？<br>        可以在数组的最后或者边界上面设置一个值，不需要每次去判断下标的值是不是达到边界，而只要按照循环一般的规则，当碰到放置的值时，循环就会退出来了<br>哨兵的目的？<br>        简化代码，写循环时可以少写一个判断的分支</p><h4 id="方法二-二分查找"><a href="#方法二-二分查找" class="headerlink" title="方法二 二分查找"></a>方法二 二分查找</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240833949.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834711.png"></p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><h6 id="查找成功"><a href="#查找成功" class="headerlink" title="查找成功"></a>查找成功</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834403.png"></p><p>mid&#x3D;(left+right)&#x2F;2,比较后，如果在右半部分，则right不动，left变为mid加一，然后再求mid，直到找到关键字</p><h6 id="查找失败的例子"><a href="#查找失败的例子" class="headerlink" title="查找失败的例子"></a>查找失败的例子</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834592.png"></p><p>最后left大于right则查找失败，所要找的关键字不在所给的范围内</p><h6 id="十一个元素的二分查找判定树"><a href="#十一个元素的二分查找判定树" class="headerlink" title="十一个元素的二分查找判定树"></a>十一个元素的二分查找判定树</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240838860.png"></p><p>二分查找引出二叉树</p><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240840764.png"></p><h3 id="树与非树（什么样的不是树？）"><a href="#树与非树（什么样的不是树？）" class="headerlink" title="树与非树（什么样的不是树？）"></a>树与非树（什么样的不是树？）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240841898.png"><br>左：C和D为A的子树，他们相交了<br>中：E有了B和C两个父亲结点<br>右：多了一条AG边</p><h3 id="树的一些术语"><a href="#树的一些术语" class="headerlink" title="树的一些术语"></a>树的一些术语</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240844812.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240844048.png"><br>    图中A结点的度数为3<br>    图所示树的度为3<br>    图中F为叶结点<br>    图中A在第一层<br>    树的深度为4</p><h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><h4 id="单纯用链表表示"><a href="#单纯用链表表示" class="headerlink" title="单纯用链表表示"></a>单纯用链表表示</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240846604.png"></p><p>这样的形式不够好，每个结点的结构不统一，且很多空间会被浪费</p><h4 id="儿子-兄弟表示法"><a href="#儿子-兄弟表示法" class="headerlink" title="儿子-兄弟表示法"></a>儿子-兄弟表示法</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240847688.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240847052.png"><br>      每个结点结构都一样，且空间浪费不大</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科目二窍门</title>
    <link href="/2022/07/17/%E7%A7%91%E7%9B%AE%E4%BA%8C%E7%AA%8D%E9%97%A8/"/>
    <url>/2022/07/17/%E7%A7%91%E7%9B%AE%E4%BA%8C%E7%AA%8D%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h1><ul><li>驶入弯道前，打转向灯</li><li>然后点对线</li><li>视野里车头与前方黄线三十公分左右，轻拔转向灯，使取消</li><li>视角里看到开门地方一指距离对准黄线尖角，方向盘左打死</li><li>等到点再擦到黄线边缘时，立马回正</li></ul><h1 id="S弯曲线行驶"><a href="#S弯曲线行驶" class="headerlink" title="S弯曲线行驶"></a>S弯曲线行驶</h1><p>S弯的步骤<br>1：看见弯口向弯口打方向，打半圈180度，仪表盘12点钟对弯口中间回正方向盘。<br>2：用左镜架子的点碰左边黄线右边缘进弯。<br>3：看左镜架子最低的点碰右边黄线内边缘向左打一圈+90°方向盘。<br>4：看左镜架子的点离黄线2个拳头宽（一部手机长）的距离回90°方向盘。<br>5：看左镜架子的点碰左边黄线回一圈方向盘。<br>6：看右镜架子最低点离左边黄线一拳距离向右打一圈+90°方向盘。<br>7：看右镜架子的点离左边黄线2只筷子长的距离回90°方向盘。<br>8：握着一圈方向盘就出弯了。</p><h1 id="侧方停车"><a href="#侧方停车" class="headerlink" title="侧方停车"></a>侧方停车</h1><ul><li>1肩膀与参照物平行，向右打一圈。</li><li>2看左后视镜看到三个轮胎回一圈。</li><li>3左后视镜看见左后轮压上黄线向左打死。</li><li>4前进左前角与黄线重合停车。</li><li>5换一档转向灯前进左筋与黄线交接回一圈半。</li><li>6车头三分之二与黄线交接向右打一圈</li></ul><h1 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h1><ul><li>肩膀与线平行，向右打死</li><li>车身到30厘米回半圈</li><li>车身与线平行回一圈</li><li>肩膀于线平行停车</li><li>伸头看左前轮与黄线保持30公分，适当调整</li><li>肩膀过线25厘米，打左一圈加90度</li><li>窗条过黄线上口停车</li><li>倒车，从左后视镜看自己的左后轮压白线10厘米回90度</li><li>如果车轮压不到线左打死</li><li>将轮胎压上线回半圈</li><li>将车尾对上后面一个底座回一圈</li><li>肩膀与黄线平行停车</li><li>车头看不到黄线右打死</li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>学车</category>
      
    </categories>
    
    
    <tags>
      
      <tag>驾照考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游武汉美术馆的一些收获</title>
    <link href="/2022/07/13/%E6%B8%B8%E6%AD%A6%E6%B1%89%E7%BE%8E%E6%9C%AF%E9%A6%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/"/>
    <url>/2022/07/13/%E6%B8%B8%E6%AD%A6%E6%B1%89%E7%BE%8E%E6%9C%AF%E9%A6%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<p>武汉美术馆是我第一次游览的美术馆，这一次游览不仅让我领略了许多美丽，更让我看到了艺术家们深邃的思想</p><p>先从史金淞个展说起， 他用枯木和自己加工的一些材料制造出摩托车，并用落叶点缀。他用不同人所收集的一些铁质材料，比如：螺丝、小刀、废铁，自己熔铸、锻造、磨砺，制造出了一把大刀，小小螺丝也可以变成削铁如泥的刀。他分别用1500摄氏度，和2500摄氏度点燃木炭，相差一千摄氏度的火焰燃烧得各有各的风采。他用捡来的垃圾做成了漂亮的屏风，并赋“如心中有垃圾，花鸟矣垃圾；如心中有花鸟，垃圾矣花鸟”。</p><p>他的作品《铁丝人偶》，铁丝人偶在被设计的宿命中挣扎，于无形的系统中机械舞动，他用缠绕身体的铁丝形成人偶，肉身幻化为线条，让人们不禁思考“什么是人？”“人在此刻何为？”</p><p>看完个展后，去了三楼还有两个作品让我印象十分深刻，一个是卜桦导演的电影作品《LV森林》，一对全身赤裸的女孩，正在窃窃私语，她们耳语着对面水塘里的女人。这些长发女人，全身裸体，搔首弄姿。形如男性生殖器的怪异巨兽，背上驮着户型各异的“空中楼阁”。他们对每个女人品头论足，垂涎欲滴于美貌妖娆的丽人，无视于面貌普通的女人，甚至于鄙视唾弃。同样的，女人们也用相同的方法丈量评判这些巨兽们。她们关注的，无非是巨兽们背上的“空中楼阁”。第一个美女选择了雕栏玉砌的珍楼宝屋，第二个女人选择了面目清秀的“俊男”……剩下的名额越来越少，只剩下又矮又胖的女孩一人。选择“俊男”的女孩来到了极度繁华而又糜烂的世界里，她跟胖女孩炫耀自己是如何的挥金如土。最终，被这一切所冷落的胖女孩，独自一人划着船，观看岸上的女人们过着所谓的幸福的生活。还有一个是黄彦的《活标本》，夸张、怪诞的人形象放在玻璃器皿里，形成了活标本，我望着这一个个标本，竟好像看到了自己。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181240851.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241810.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241202.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242446.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241033.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242507.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242471.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>出去玩</category>
      
    </categories>
    
    
    <tags>
      
      <tag>武汉美术馆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象程序设计</title>
    <link href="/2022/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/07/12/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑基本知识</title>
    <link href="/2022/07/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/07/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-基本知识"><a href="#第一讲-基本知识" class="headerlink" title="第一讲 基本知识"></a>第一讲 基本知识</h1><h2 id="数字信号与系统"><a href="#数字信号与系统" class="headerlink" title="数字信号与系统"></a>数字信号与系统</h2><ul><li>模拟信号：信号的变换在时间上和数值上都是<strong>连续</strong>的</li><li>离散信号（数字信号）：信号的变化在时间上和数值上都是<strong>离散</strong>的，或者说<strong>断续</strong>的</li><li>离散信号的变化可以用不同的数字反映，所以又称为数字信号</li><li>数字系统<ul><li>数字系统是一个能对数字信号进行加工，传递和存储的实体，它由实现各种功能的数字逻辑电路相互连接而成</li><li>比如MP3、手机、数字计算机</li></ul></li><li>模拟信号与数字信号的相互转换<ul><li>A&#x2F;D-模数转换（Analog-Digital）</li><li>D&#x2F;A-数模转换（Digital-Analog）</li></ul></li><li>模拟信号数字化<ul><li>采样</li><li>量化与编码</li></ul></li><li>数字逻辑电路<ul><li>数字电路是用来处理数字信号的电子线路</li><li>由于数字电路的各种电路是通过逻辑运算和逻辑判断来实现的，所以数字电路又称为数字逻辑电路或者逻辑电路</li><li>数字逻辑电路的特点<ul><li>电路的基本工作信号是二值信号</li><li>电路中的半导体器件一般都工作在开、关状态</li><li>电路结构简单、功耗低、便于集成制造和系列化生产、产品价格低廉、使用方便、通用性好</li><li>工作速度快、精度高、功能强、可靠性好</li></ul></li><li>数字逻辑电路的类型（根据一个电路有无记忆功能划分）<ul><li>组合逻辑电路：无记忆功能<ul><li>在任何时刻稳定输出仅取决于该时刻的输入，而与电路的过去无关</li><li>类比行李箱的密码锁</li></ul></li><li>时序逻辑电路：有记忆功能<ul><li>在任何时刻的稳定输出不仅取决于该时刻的输入，而且与过去的输入相关</li><li>类比电话、电子密码锁</li><li>时序逻辑电路按照是否有统一的时钟信号进行同步可分为<ul><li>同步时序逻辑电路</li><li>异步时序逻辑电路</li></ul></li></ul></li></ul></li></ul></li><li>数字系统的层次结构<ul><li>第1级：电子元件，如二极管、三极管、电阻、电容</li><li>第2级：基本逻辑器件，如逻辑门、触发器 （SSI级）</li><li>第3级：逻辑功能部件，如加法器、计数器、乘法器（MSI、LSI级）</li><li>第4级：复杂逻辑功能部件，如微处理器（VLSI级）</li><li>第5级：复杂数字系统，含第2级到第4级的逻辑部件</li></ul></li><li>数字逻辑电路的研究方法<ul><li>两个任务<ul><li>逻辑设计<ul><li>根据提出的逻辑功能，在给定条件下构造出实现预定功能的逻辑电路</li></ul></li><li>逻辑分析 <ul><li>对一个已有的数字逻辑电路，研究它的工作性能和逻辑功能</li></ul></li></ul></li><li>传统方法<ul><li>以逻辑代数作为基本理论，从逻辑抽象到功能实现</li><li>建立在小规模集成电路基础之上</li><li>以技术经济指标作为评价一个设计方案优劣的主要性能指标</li><li>设计时追求的是如何使一个电路达到最简</li></ul></li><li>注意：一个最简的方案并不等于一个最佳的方案</li></ul></li></ul><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><ul><li>原码不能直接进行减法运算<ul><li>当对两个数求和时，如果符号相异，则先比较绝对值大小，然后做减法</li><li>绝对值大的符号是结果的符号</li><li>绝对值的差值是结果的数值位</li><li>用原码进行加减法较为麻烦！！！</li></ul></li><li>怎么解决？？？<ul><li>减法变加法，符号位直接参与运算</li></ul></li><li>反码做加减法运算<ul><li>产生的进位移到末位才等于正确结果</li><li>并且反码也有正0和负0</li><li>这种机器码还是不能很好进行加减法运算</li></ul></li><li>模的概念<ul><li>模指一个计量系统的计数范围</li><li>模实质上是计量系统产生“溢出”的量，它的值在计量系统上表示不出来，计量系统上只能表示出模的余数</li><li>任何有模的计量系统，均可化减法为加法运算</li><li>计算机也可以看成一个计量系统，有一个模</li></ul></li><li>补码的意义<ul><li>计算机中的数据受字长限制，数据的运算属于有模运算</li><li>计算结果直接丢掉进位</li><li>可以将减法转为加法运算</li><li>计算机中可只设置加法器，简化设计、降低成本</li></ul></li></ul><h2 id="几种常用的编码"><a href="#几种常用的编码" class="headerlink" title="几种常用的编码"></a>几种常用的编码</h2><ul><li><p>十进制数的二进制编码（BCD码）</p><ul><li>8421码（有权码）<ul><li>权值 8 4 2 1</li><li>和十进制转化为二进制是一样的</li></ul></li><li>2421码（有权码）<ul><li>权值 2 4 2 1</li></ul></li><li>余3码（无权码）<ul><li>在8421码的基础上加3</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191553202.png"></li></ul></li><li><p>十进制数在机器中的两种表示</p><ul><li>字符串形式<ul><li>一个字节存放一个十进制位</li><li>符号位用8421码中未选用的编码，正号1100，负号1101</li></ul></li><li>压缩的十进制数串<ul><li>一个字节存放两个十进制位</li><li>符号位用8421码中未选用的编码，正号1100，负号1101</li></ul></li></ul></li><li><p>可靠性编码</p><ul><li>减少或者发现代码在形成和传送过程中可能发生的错误</li><li>提高系统的可靠性</li><li>两种可靠性编码<ul><li>奇偶校验码</li><li>格雷码</li></ul></li></ul></li><li><p>奇偶校验</p><ul><li>奇校验：让整个校验码（有效的信息位和校验位）中1的个数为偶数</li><li>偶校验：让整个校验码中1的个数为奇数</li><li>有效信息（被校验的信息）部分可能是奇性（1的个数为奇数），也可能是偶性</li><li>奇偶两种校验都只需配一个校验位，就可以使整个校验码满足指定的奇偶性要求</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191600341.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191600048.png"></li></ul></li><li><p>奇偶校验特点</p><ul><li>一种常见的简单校验，只需1位校验码</li><li>只具有发现错误的能力，不具备对错误定位和纠正错误的能力</li><li>只具有发现一串二进制代码中，同时出现奇数个代码出错的能力</li><li>如果同时发生偶数个代码出错，奇偶校验失效</li></ul></li><li><p>格雷码</p><ul><li>特点：任意两个相邻的数，其格雷码只有一位不同</li><li>作用：避免代码形成和变换过程中产生的错误</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191601819.png"></li></ul></li><li><p>二进制到格雷码的转换</p><ul><li>$G_{n-1}&#x3D;B_{n-1}$ （最高位不变）     $G_i&#x3D;B_{i+1}\bigoplus B_i$</li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191610080.png"></p></li><li><p>字符编码</p><ul><li>ASCII码</li></ul></li></ul><h1 id="第二讲-逻辑代数基础"><a href="#第二讲-逻辑代数基础" class="headerlink" title="第二讲 逻辑代数基础"></a>第二讲 逻辑代数基础</h1><h2 id="逻辑代数的基本概念"><a href="#逻辑代数的基本概念" class="headerlink" title="逻辑代数的基本概念"></a>逻辑代数的基本概念</h2><p><strong>加号表示或（析取），点乘号表示与（合取）</strong></p><ul><li><p>逻辑代数定义</p><ul><li>逻辑代数L是一个封闭的代数系统</li><li>由一个逻辑变量集K，常量0和1，以及或、与、非三种基本运算所构成</li></ul></li><li><p>逻辑代数公理</p><ul><li>交换律</li><li>结合律</li><li>分配律</li><li>0-1律<ul><li>A+0&#x3D;A        A+1&#x3D;1</li><li>A * 0&#x3D;0       A * 1&#x3D;A</li></ul></li><li>互补律<ul><li>对任意逻辑变量A，存在唯一B，使得A+B&#x3D;1,A * B&#x3D;0</li></ul></li></ul></li><li><p>逻辑变量及基本运算</p><ul><li><p>或运算</p><ul><li>实现或运算关系的逻辑电路称为或门</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101159454.png"></li></ul></li><li><p>与运算</p><ul><li>实现与运算关系的逻辑电路称为与门</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101200522.png"></li></ul></li><li><p>非运算</p><ul><li>实现非运算关系的逻辑电路称为非门或者<strong>反相器</strong></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101203717.png"></li></ul></li></ul></li><li><p>逻辑函数</p><ul><li>定义：随自变量变化的因变量</li><li>与普通代数函数概念相比，逻辑函数的特点：<ul><li>逻辑函数和逻辑变量一样，取值只有0和1两种可能</li><li>函数和变量之间的关系由或、与、非三种基本运算决定</li></ul></li></ul></li><li><p>逻辑函数相等</p><ul><li>两个因变量a和b随自变量变化，任何自变量的值对应的a值和b值都相同，则称a和b相等</li><li>判断方法<ul><li>真值表法</li><li>代数法</li></ul></li></ul></li><li><p>逻辑功能的表示法</p><ul><li>逻辑表达式<ul><li>逻辑函数的简写<ul><li>非运算符下可不加括号</li><li>与运算符一般可省略</li><li>既有与又有或，先与后或</li><li>运算优先法则：括号&gt;非&gt;与&gt;异或&gt;或</li><li>与运算和或运算均满足结合律</li></ul></li></ul></li><li>真值表</li><li>卡诺图<ul><li>由表示逻辑变量所有取值组合的小方格构成的平面图</li><li>图形化描述逻辑函数</li></ul></li></ul></li></ul><h2 id="逻辑表达式的形式与转换"><a href="#逻辑表达式的形式与转换" class="headerlink" title="逻辑表达式的形式与转换"></a>逻辑表达式的形式与转换</h2><h3 id="与或-x2F-或与表达式"><a href="#与或-x2F-或与表达式" class="headerlink" title="与或&#x2F;或与表达式"></a>与或&#x2F;或与表达式</h3><ul><li>与-或表达式<ul><li>若干与项进行或运算构成的表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101228547.png"></li></ul></li><li>或-与表达式<ul><li>若干或项进行与运算构成的表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101230829.png"></li></ul></li></ul><h3 id="最小项-x2F-最大项"><a href="#最小项-x2F-最大项" class="headerlink" title="最小项&#x2F;最大项"></a>最小项&#x2F;最大项</h3><ul><li><p>最小项定义</p><ul><li>具有n个变量的函数的“与项”包含全部n个变量（所有变量全都出现）</li><li>每个变量都以原变量或反变量形式出现一次，且仅出现一次 </li><li>该与项被称为最小项，有时称为标准与项</li></ul></li><li><p>最小项数目</p><ul><li>n个变量可以构成2的n次方个最小项</li></ul></li><li><p>简写$m_i$</p><ul><li>i的取值规则<ul><li>按照变量顺序将最小项中的原变量用1表示，反变量用0表示，由此得到一个二进制数，与该二进制数对应的十进制数即下标i的值</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101238970.png"></li><li>A为原变量用1表示，B为反变量用0表示，C为原变量用1表示，得到101，把101看成二进制数，转化为十进制就得到5</li></ul></li></ul></li><li><p>用最小项表示函数</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101243927.png"></li></ul></li><li><p>最小项性质</p><ul><li>任意一个最小项，其相应变量有且仅有一种取值使这个最小项的值为1，最小项不同，使其值为1的变量取值也不同，任何一种变量取值都不可能使两个不同的最小项同时为1<ul><li>在由n个变量构成的任意与项中，最小项是使其值为1的变量取值组合数最少的一种与项 </li><li>上面这点也是最小项名字的由来</li></ul></li><li>相同变量构成的两个不同最小项，相与为0</li><li>n个变量的全部最小项，相或为1</li><li>n个变量构成的最小项有n个相邻最小项<ul><li>相邻最小项：除一个变量相反外，其余变量均相同的最小项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101248868.png"></li></ul></li></ul></li><li><p>最大项定义</p><ul><li>具有n个变量的函数的”或项” 包含全部n个变量</li><li>每个变量都以原变量或反变量形式出现一次，且仅出现一次</li><li>该或项被称为最大项，有时称为标准或项</li></ul></li><li><p>最大项数目</p><ul><li>n个变量可以构成2的n次方个最小项</li></ul></li><li><p>简写$M_i$</p><ul><li>按照变量顺序将最大项中的原变量用0表示，反变量用1表示</li><li>由此得到一个二进制数，与该二进制数对应的十进制数就是下标i的取值</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101254386.png"></li></ul></li><li><p>最大项表示函数</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101319638.png"></li></ul></li><li><p>最大项性质</p><ul><li><p>任意一个最大项，其相应变量有且仅有一种取值使这个最大项的值为0，最大项不同，使其值为0的变量取值也不同</p><ul><li>在由n个变量构成的任意或项中，最大项是使其值为1的变量取值组合数最大的一种或项</li><li>上面这点也是最大项名字的由来</li></ul></li><li><p>相同变量构成的两个不同最大项，相或为1</p></li><li><p>n个变量的全部最大项，相与为0</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101325216.png"></li></ul></li><li><p>n个变量构成的最大项有n个相邻最大项</p><ul><li>相邻最大项：除一个变量相反外，其余变量均相同的最大项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101326271.png"></li></ul></li></ul></li><li><p>最小项和最大项的关系</p><ul><li>在同一个问题中，下标相同的最小项和最大项互为反函数</li><li>相同变量构成的最小项$m_i$和最大项$M_i$之间存在互补关系</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101328075.png"></li></ul></li></ul><h3 id="标准与或-x2F-或与表达式"><a href="#标准与或-x2F-或与表达式" class="headerlink" title="标准与或&#x2F;或与表达式"></a>标准与或&#x2F;或与表达式</h3><ul><li>标准与-或表达式<ul><li>由若干最小项相或构成的逻辑表达式</li><li>最小项表达式</li></ul></li><li>标准或-与表达式<ul><li>由若干最大项相与构成的逻辑表达式</li><li>最大项表达式<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101330732.png"></li></ul></li></ul><h3 id="逻辑函数表达式的转换方法"><a href="#逻辑函数表达式的转换方法" class="headerlink" title="逻辑函数表达式的转换方法"></a>逻辑函数表达式的转换方法</h3><p><strong>定理？？？？（记得补充）</strong></p><ul><li>逻辑函数表达式的转换方法<ul><li>代数转换法<ul><li>求标准与或表达式<ul><li>第一步，将函数表达式变换成一般与-或表达式</li><li>第二步，反复使用 <strong>X&#x3D;X(Y+(-Y))</strong> 即X等于X与上Y或非Y，将表达式中所有非最小项的与项扩展成最小项</li><li>注意：当给出的函数表达式已经是与或表达式，可直接第二步</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110913767.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110914559.png"></li></ul></li><li>求标准或与表达式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110917671.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110918477.png"></li></ul></li></ul></li><li>真值表转换法<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110919193.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110919404.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110928135.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110928485.png"><br> 任何一个逻辑函数的两种标准形式唯一</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>数字逻辑基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2022/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2022/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-基本概念"><a href="#第一讲-基本概念" class="headerlink" title="第一讲 基本概念"></a>第一讲 基本概念</h1><ul><li><p>什么是数据结构？（抽象数据类型的物理实现）</p><ul><li>解决问题方法的效率，和数据的组织方式是直接相关的，与空间的利用效率有关，与算法的巧妙程度相关</li></ul></li><li><p>什么是算法？（一系列解决问题的清晰指令）</p></li><li><p>什么是好的算法？（综合看空间复杂度和时间复杂度）</p></li><li><p>最大子列和的几种算法</p><ul><li>分而治之</li><li>在线处理<ul><li>在线的意思是指每输入一个数据就进行即时处理，在任何一个地方终止输出，算法都可以正确给出当前解</li></ul></li></ul></li></ul><h1 id="第二讲-线性结构"><a href="#第二讲-线性结构" class="headerlink" title="第二讲 线性结构"></a>第二讲 线性结构</h1><h2 id="线性表及其实现"><a href="#线性表及其实现" class="headerlink" title="线性表及其实现"></a>线性表及其实现</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>什么是线性表<ul><li>由同类型数据元素构成有序序列的线性结构<ul><li>表中元素个数称为线性表的长度</li><li>线性表没有元素时，称为空表</li><li>表起始位置称表头，结束位置表尾</li></ul></li></ul></li><li>线性表怎么存储？<ul><li>顺序存储（数组）</li><li>链式存储（链表）</li></ul></li><li>线性表的主要操作<br>- 初始化<br>- 根据位序返回相应元素<br>- 查找<br>- 插入<br>- 删除<br>- 返回线性表长度</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="线性表的定义与操作——顺序表"><a href="#线性表的定义与操作——顺序表" class="headerlink" title="线性表的定义与操作——顺序表"></a>线性表的定义与操作——顺序表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span>     ElementType Data[MAXSIZE];     Position Last; &#125;;<br><br><span class="hljs-comment">/* 初始化 */</span><br>List <span class="hljs-title function_">MakeEmpty</span><span class="hljs-params">()</span> &#123;     List L;     L = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>L-&gt;Last = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> L; &#125; <br><br><br><br><br><span class="hljs-comment">/* 查找 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1 Position Find( List L, ElementType X ) </span><br>&#123; Position i = <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )  <br>       i++;    <br>       <span class="hljs-keyword">if</span> ( i &gt; L-&gt;Last )  <br>         <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* 如果没找到，返回错误信息 */</span>    <br>       <span class="hljs-keyword">else</span><br>         <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">/* 找到后返回的是存储位置 */</span> &#125; <br><br><br><br><br><span class="hljs-comment">/* 插入 */</span> <span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span><br>&#123; <span class="hljs-comment">/* 在L的指定位置P前插入一个新元素X */</span> <br>Position i;    <br><span class="hljs-keyword">if</span> ( L-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>) <br>&#123; <span class="hljs-comment">/* 表空间已满，不能插入 */</span>   <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满&quot;</span>);   <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;       <br><span class="hljs-keyword">if</span> ( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last+<span class="hljs-number">1</span> )<br>&#123; <span class="hljs-comment">/* 检查插入位置的合法性 */</span> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置不合法&quot;</span>);  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;   <br><span class="hljs-keyword">for</span>( i=L-&gt;Last; i&gt;=P; i-- )  <br>L-&gt;Data[i+<span class="hljs-number">1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P及以后的元素顺序向后移动 */</span>  <br>L-&gt;Data[P] = X;  <span class="hljs-comment">/* 新元素插入 */</span>   <br>L-&gt;Last++;       <span class="hljs-comment">/* Last仍指向最后元素 */</span>  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125; <br><br><br><br><br><span class="hljs-comment">/* 删除 */</span> <span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span> <br>&#123; <span class="hljs-comment">/* 从L中删除指定位置P的元素 */</span>  <br>Position i;  <br><span class="hljs-keyword">if</span>( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last ) &#123; <span class="hljs-comment">/* 检查空表及删除位置的合法性 */</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置%d不存在元素&quot;</span>, P ); <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;   <br> <span class="hljs-keyword">for</span>( i=P+<span class="hljs-number">1</span>; i&lt;=L-&gt;Last; i++ ) <br> L-&gt;Data[i<span class="hljs-number">-1</span>] = L-&gt;Data[i]; <br> <span class="hljs-comment">/* 将位置P+1及以后的元素顺序向前移动 */</span> <br>L-&gt;Last--; <span class="hljs-comment">/* Last仍指向最后元素 */</span> <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线性表的定义与操作——链式表"><a href="#线性表的定义与操作——链式表" class="headerlink" title="线性表的定义与操作——链式表"></a>线性表的定义与操作——链式表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">PtrToLNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span>     ElementType Data;     PtrToLNode Next; &#125;; <br>   <span class="hljs-keyword">typedef</span> PtrToLNode Position;<br>   <span class="hljs-keyword">typedef</span> PtrToLNode List; <br>   <span class="hljs-comment">/* 查找 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR NULL Position Find( List L, ElementType X )</span><br>     &#123;     <br>     Position p = L; <span class="hljs-comment">/* p指向L的第1个结点 */</span>     <br>     <span class="hljs-keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )         <br>     p = p-&gt;Next;     <br>     <span class="hljs-comment">/* 下列语句可以用 return p; 替换 */</span>     <br>     <span class="hljs-keyword">if</span> ( p )         <br>      <span class="hljs-keyword">return</span> p;     <br>     <span class="hljs-keyword">else</span>         <br>      <span class="hljs-keyword">return</span> ERROR; &#125; <br><span class="hljs-comment">/* 带头结点的插入 */</span> <span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span> <br>   <span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span> <br>   &#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span>     <br>   Position tmp, pre;     <br>   <span class="hljs-comment">/* 查找P的前一个结点 */</span>             <br>   <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) <br>   ;                 <br>   <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> ) &#123; <br>   <span class="hljs-comment">/* P所指的结点不在L中 */</span>         <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置参数错误\n&quot;</span>);         <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     &#125;     <br>   <span class="hljs-keyword">else</span> &#123; <br>   <span class="hljs-comment">/* 找到了P的前一个结点pre */</span>         <br>   <span class="hljs-comment">/* 在P前插入新结点 */</span>     tmp = (Position)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>   <span class="hljs-comment">/* 申请、填装结点 */</span><br>   tmp-&gt;Data = X;          <br>   tmp-&gt;Next = P;         <br>   pre-&gt;Next = tmp;         <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>    &#125; <br>   &#125; <br>   <span class="hljs-comment">/* 带头结点的删除 */</span> <span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span> <br>   <span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>    &#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span>     <br>    Position pre;     <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>             <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) <br>    ;                 <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> || P==<span class="hljs-literal">NULL</span>)<br>     &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span>         <br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除位置参数错误\n&quot;</span>);         <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     &#125;     <br>     <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span>         <br>     <span class="hljs-comment">/* 将P位置的结点删除 */</span>         <br>     pre-&gt;Next = P-&gt;Next;         <br>     <span class="hljs-built_in">free</span>(P);         <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>       &#125; <br>     &#125;<br></code></pre></td></tr></table></figure><h2 id="广义表与多重链表"><a href="#广义表与多重链表" class="headerlink" title="广义表与多重链表"></a>广义表与多重链表</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>广义表<ul><li>广义表是线性表的推广</li><li>对于线性表而言，n个元素都是基本的单元素</li><li>而广义表中，这些元素不仅可以是单元素也可以是另一个广义表</li></ul></li><li>多重链表（链表中的节点可能同时隶属于多个链）<ul><li>多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域</li><li>但包含两个指针域的链表并不一定是多重链表，比如双向链表不是多重链表</li><li>多重链表用途广泛：树、图这样相对复杂的数据结构可以采用多重链表方式实现存储</li></ul></li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*广义表*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">GList</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br><span class="hljs-type">int</span> Tag;   <span class="hljs-comment">/*标志域：0表示结点是单元素，1表示结点是广义表*/</span><br><span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br><span class="hljs-comment">/*子表指针域Sublist与单元素数据域Data复用，即共用存储空间*/</span><br>ElementType Data;<br>GList Sublist;<br><br>&#125;URegion;<br>GList Next;  <span class="hljs-comment">/*指向后继结点*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>什么是队列？<ul><li>具有一定操作约束的线性表</li><li>只能在一端插入，而在另一端删除</li><li>数据插入：入队列</li><li>数据删除：出队列</li><li>先来先服务</li><li>先进先出：FIFO</li></ul></li><li>队列的抽象数据类型描述<ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的队列Q$\in$Qyeue,队列元素item$\in$ElementType</li><li>基本操作<ul><li>Queue CreatQueue(int MaxSize)：生成长度为MaxSize的空队列</li><li>int IsFullQ(Queue Q,int MaxSize)：判断队列Q是否已满</li><li>void AddQ(Queue Q, ElementType item)：将数据元素item插入队列Q中</li><li>int IsEmptyQ(Queue Q)：判断队列Q是否为空</li><li>ElementType DeleteQ(Queue Q)：将队头数据元素从队列中删除并返回</li></ul></li></ul></li><li>队列的顺序存储实现<ul><li>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成</li><li>顺环队列</li></ul></li><li>队列的链式存储实现<ul><li>可以用一个单链表实现，插入和删除操作分别在链表的两头进行</li><li>注意：队列指针front应在单向链表的开头rear在尾（尾部删除操作找不到前面的元素，所有不能把front放在尾）</li></ul></li><li>应用实例（多项式加法）<ul><li>主要思路：相同指数项系数相加，不同指数项系数进行拷贝</li><li>采用不带头结点的单向链表，按照指数递减的顺序排列各项</li><li>两个指针P1和P2分别指向这两个多项式的第一个结点，不断循环<ul><li>P1指向的项如果指数等于P2指向的项的指数：系数相加，若结果不为0，则作为结果多项式对应项的系数。同时，P1和P2都分别指向下一项<ul><li>P1所指指数大于P2：将P1的当前项存入结果多项式，并使P1指向下一项</li><li>P1所指指数小于P2：将P2的当前项存入结果多项式，并使P2指向下一项</li><li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去</li></ul></li></ul></li></ul></li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span>     Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> &#123;     Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));     Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;     <br>Q-&gt;MaxSize = MaxSize;         <br><span class="hljs-keyword">return</span> Q;      <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span> &#123;     <br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;   Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>&#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear); &#125; <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">if</span> ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span>  <br>&#123;   Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;         <br><span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-comment">/* 队列中的结点 */</span>     <br>ElementType Data;     <br>PtrToNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToNode Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> &#125;; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>); &#125; ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br>Position FrontCell;      <br>ElementType FrontElem;          <br><span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;    FrontCell = Q-&gt;Front;         <br><span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span>                 Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span> <br>            <span class="hljs-keyword">else</span>                                  <br> Q-&gt;Front = Q-&gt;Front-&gt;Next;         <br> FrontElem = FrontCell-&gt;Data;         <br> <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span>         <br> <span class="hljs-keyword">return</span>  FrontElem;     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多项式加法用队列实现"><a href="#多项式加法用队列实现" class="headerlink" title="多项式加法用队列实现"></a>多项式加法用队列实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
