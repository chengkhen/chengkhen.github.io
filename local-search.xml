<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第6章 GNU C编译器扩展语法</title>
    <link href="/2023/07/14/%E7%AC%AC6%E7%AB%A0-GNU-C%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/14/%E7%AC%AC6%E7%AB%A0-GNU-C%E7%BC%96%E8%AF%91%E5%99%A8%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="6-2-指定初始化"><a href="#6-2-指定初始化" class="headerlink" title="6.2 指定初始化"></a>6.2 指定初始化</h1><h2 id="6-2-1指定初始化数组元素"><a href="#6-2-1指定初始化数组元素" class="headerlink" title="6.2.1指定初始化数组元素"></a>6.2.1指定初始化数组元素</h2><ul><li>在GNU C中，通过数组元素索引，我们就可以直接给指定的几个元素赋值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> b[<span class="hljs-number">100</span>] = &#123; [<span class="hljs-number">10</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">30</span>]=<span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><p>在大括号{}中，我们通过[10]数组元素索引，就可以直接给a[10]赋值了。这里有一个细节需要注意，<strong>各个赋值之间用逗号“，”隔开，而不是使用分号“；”</strong></p><ul><li>给数组中某一个索引范围的数组元素初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> b[<span class="hljs-number">100</span>] = &#123;[<span class="hljs-number">10</span> ... <span class="hljs-number">30</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">50</span> ... <span class="hljs-number">60</span>]=<span class="hljs-number">2</span> &#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a[i]);<br>        <span class="hljs-keyword">if</span>( i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的main函数，使用[10…30]表示一个索引范围，相当于给a[10]到a[30]之间的20个数组元素赋值为1。  </p><ul><li>GNU C支持使用…表示范围扩展，这个特性不仅可以使用在数组初始化中，也可以使用在switch-case语句中  ，如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">switch</span>(i)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> ... <span class="hljs-number">8</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;9\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;default!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个程序中，如果当case值为2～8时，都执行相同的case分支，我们就可以通过case 2…8：的形式来简化代码。这里同样有一个细节需要注意，就是…和其两端的数据范围2和8之间也要有空格，<strong>不能写成2…8的形式，否则会报编译错误</strong>  </p><h2 id="6-2-2-指定初始化结构体成员"><a href="#6-2-2-指定初始化结构体成员" class="headerlink" title="6.2.2 指定初始化结构体成员"></a>6.2.2 指定初始化结构体成员</h2><p>在GNU C中我们可以通过结构域来指定初始化某个成员  ，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span>&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">stu1</span>=</span>&#123;<span class="hljs-string">&quot;wit&quot;</span>,<span class="hljs-number">20</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:%d\n&quot;</span>,stu1.name,stu1.age);<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">student</span> <span class="hljs-title">stu2</span>=</span><br>    &#123;<br>        .name = <span class="hljs-string">&quot;wantao&quot;</span>,<br>        .age = <span class="hljs-number">28</span><br>    &#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s:%d\n&quot;</span>,stu2.name,stu2.age);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的程序中，我们定义一个结构体类型student，然后分别定义两个结构体变量stu1和stu2。</p><ul><li>初始化stu1时，我们采用C语言标准的初始化方式，即按照固定顺序直接初始化。</li><li>初始化stu2时，我们采用GNU C的初始化方式，通过结构域名.name和.age，就可以给结构体变量的某一个指定成员直接赋值。</li><li>当结构体的成员很多时，使用第二种初始化方式会更加方便</li></ul><h2 id="6-2-3-Linux内核驱动注册"><a href="#6-2-3-Linux内核驱动注册" class="headerlink" title="6.2.3 Linux内核驱动注册"></a>6.2.3 Linux内核驱动注册</h2><p>在Linux内核驱动中，大量使用GNU C的这种指定初始化方式，通过结构体成员来初始化结构体变量。如在字符驱动程序中，我们经常见到下面这样的初始化  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span><br><span class="hljs-class"><span class="hljs-title">ab3100_otp_operations</span> =</span> <br>&#123;<br>.open        = ab3100_otp_open,<br>.read        = seq_read,<br>.llseek      = seq_lseek,<br>.release     = single_release,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在驱动程序中，我们经常使用file_operations这个结构体来注册我们开发的驱动，然后系统会以回调的方式来执行驱动实现的具体功能，结构体file_operations在Linux内核中的定义如下  ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span><br>    <span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br>    <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br>    <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br>    <span class="hljs-type">ssize_t</span> (*read_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br>    <span class="hljs-type">ssize_t</span> (*write_iter) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-keyword">struct</span> iov_iter *);<br>    <span class="hljs-type">int</span> (*iterate) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dir_context *);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;<br>    <span class="hljs-type">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>    <span class="hljs-type">long</span> (*compat_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>    <span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br>    <span class="hljs-type">int</span> (*mremap)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br>    <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br>    <span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br>    <span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br>    <span class="hljs-type">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span> datasync);<br>    <span class="hljs-type">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br>    <span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br>    <span class="hljs-type">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br>    <span class="hljs-type">ssize_t</span> (*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_unmapped_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br>    <span class="hljs-type">int</span> (*check_flags)(<span class="hljs-type">int</span>);<br>    <span class="hljs-type">int</span> (*flock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br>    <span class="hljs-type">ssize_t</span> (*splice_write)(<span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>    <span class="hljs-type">ssize_t</span> (*splice_read)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-keyword">struct</span> pipe_inode_info *, <span class="hljs-type">size_t</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br>    <span class="hljs-type">int</span> (*setlease)(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">long</span>, <span class="hljs-keyword">struct</span> file_lock **, <span class="hljs-type">void</span> **);<br>    <span class="hljs-type">long</span> (*fallocate)(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">int</span> mode, <span class="hljs-type">loff_t</span> offset, <span class="hljs-type">loff_t</span> len);<br>    <span class="hljs-type">void</span> (*show_fdinfo)(<span class="hljs-keyword">struct</span> seq_file *m, <span class="hljs-keyword">struct</span> file *f);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MMU</span><br>    <span class="hljs-type">unsigned</span> (*mmap_capabilities)(<span class="hljs-keyword">struct</span> file *);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p>结构体file_operations里定义了很多结构体成员，而在这个驱动中，我们只初始化了部分成员变量。通过访问结构体的各个成员域来指定初始化，当结构体成员很多时优势就体现出来了，初始化会更加方便。  </p><h2 id="6-2-4-指定初始化的好处"><a href="#6-2-4-指定初始化的好处" class="headerlink" title="6.2.4 指定初始化的好处"></a>6.2.4 指定初始化的好处</h2><ul><li><p>指定初始化不仅使用灵活，而且还有一个好处，就是代码易于维护。</p></li><li><p>尤其是在Linux内核这种大型项目中，有几万个文件、几千万行的代码，当成百上千个文件都使用file_operations这个结构体类型来定义变量并初始化时，那么一个很大的问题就来了：如果采用C标准按照固定顺序赋值，当file_operations结构体类型发生变化时，如添加了一个成员、删除了一个成员、调整了成员顺序，那么使用该结构体类型定义变量的大量C文件都需要重新调整初始化顺序，牵一发而动全身，想想这有多可怕！</p></li><li><p>我 们 通 过 指 定 初 始 化 方 式 ， 就 可 以 避 免 这 个 问 题 。 无 论file_operations结构体类型如何变化，添加成员也好、删除成员也好、调整成员顺序也好，都不会影响其他文件的使用。</p></li></ul><h1 id="6-3-宏构造“利器”：语句表达式"><a href="#6-3-宏构造“利器”：语句表达式" class="headerlink" title="6.3  宏构造“利器”：语句表达式"></a>6.3  宏构造“利器”：语句表达式</h1><h2 id="6-3-1-表达式、语句和代码块"><a href="#6-3-1-表达式、语句和代码块" class="headerlink" title="6.3.1 表达式、语句和代码块"></a>6.3.1 表达式、语句和代码块</h2><p>表达式就是由一系列<strong>操作符和操作数构成的式子</strong>。操作符可以是C语言标准规定的各种算术运算符、逻辑运算符、赋值运算符、比较运算符。操作数可以是一个常量，也可以是一个变量。表达式也可以没有操作符，单独的一个常量甚至一个字符串，都是一个表达式。下面的字符序列都是表达式  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">2</span>+<span class="hljs-number">3</span><br><span class="hljs-number">2</span><br>i = <span class="hljs-number">2</span> + <span class="hljs-number">3</span><br>i = i++ + <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>表达式一般用来计算数据或实现某种功能的算法。表达式有两个基本属性：值和类型。如上面的表达式2+3，它的值为5。根据操作符的不同，表达式可以分为多种类型，具体如下  ：</p><ul><li>关系表达式</li><li>逻辑表达式</li><li>条件表达式</li><li>赋值表达式</li><li>算术表达式</li></ul><p>语句是构成程序的基本单元，一般形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">表达式;<br>i = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>表达式后面加;就构成了一个基本的语句。编译器在编译程序、解析程序时，不是根据物理行，而是根据分号; 来判断一条语句的结束标记的。如i&#x3D;2+3；这条语句，你写成下面的形式也是可以编译通过的  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">i =<br><span class="hljs-number">2</span> +<br><span class="hljs-number">3</span><br>;<br></code></pre></td></tr></table></figure><p>不同的语句，使用大括号{}括起来，就构成了一个代码块。C语言允许在代码块内定义一个变量，这个变量的作用域也仅限于这个代码块内，因为编译器就是根据{}来管理变量的作用域的，如下面的程序  :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>,i);<br>    &#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">4</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>,i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>,i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">i = <span class="hljs-number">3</span><br>i = <span class="hljs-number">4</span><br>i = <span class="hljs-number">3</span>    <br></code></pre></td></tr></table></figure><h2 id="6-3-2-语句表达式"><a href="#6-3-2-语句表达式" class="headerlink" title="6.3.2 语句表达式"></a>6.3.2 语句表达式</h2><p>GNU C对C语言标准作了扩展，允许<strong>在一个表达式里内嵌语句</strong>，<strong>允许在表达式内部使用局部变量、for循环和goto跳转语句</strong>。这种类型的表达式，我们称为语句表达式。语句表达式的格式如下  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(&#123;表达式<span class="hljs-number">1</span>; 表达式<span class="hljs-number">2</span>; 表达式<span class="hljs-number">3</span>;&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>语句表达式最外面使用小括号()括起来，里面一对大括号{}包起来的是代码块，代码块里允许内嵌各种语句。语句的格式可以是一般表达式，也可以是循环、跳转语句。</p></li><li><p>和一般表达式一样，语句表达式也有自己的值。语句表达式的值为内嵌语句中最后一个表达式的值  </p></li><li><p>下面举个例子，使用语句表达式求值</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    sum =<br>        (&#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>                s = s+i;<br>            s;<br>        &#125;);<br>        <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>,sum);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在上面的程序中，通过语句表达式实现了从1到10的累加求和，因为<strong>语句表达式的值等于最后一个表达式的值</strong>，所以在for循环的后面，要添加一个s；语句表示整个语句表达式的值。</li><li>如果不加这一句，你会发现sum&#x3D;0。或者你将这一行语句改为100；，你会发现最后sum的<br>值就变成了100，这是因为语句表达式的值总等于最后一个表达式的值</li></ul><p>在上面的程序中，我们在语句表达式内定义了局部变量，使用了for循环语句。在语句表达式内，我们同样可以使用goto进行跳转  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    sum =<br>        (&#123;<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>                s = s+i;<br>            <span class="hljs-keyword">goto</span> here;<br>            s;<br>        &#125;);<br>        <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>,sum);<br><br>here:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;here:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %d\n&quot;</span>,sum);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-3-在宏定义中使用语句表达式"><a href="#6-3-3-在宏定义中使用语句表达式" class="headerlink" title="6.3.3 在宏定义中使用语句表达式"></a>6.3.3 在宏定义中使用语句表达式</h2><p>语句表达式的主要用途在于定义功能复杂的宏。使用语句表达式来定义宏，不仅可以实现复杂的功能，还能避免宏定义带来的歧义和漏洞。</p><p>假如你此刻正在面试，面试职位是Linux C语言开发工程师。面试官给你出了一道题：请定义一个宏，求两个数的最大值。别看这么简单的一个考题，面试官就能根据你写的宏，来判断你的C语言功底，决定给不给你offer。  </p><h3 id="合格"><a href="#合格" class="headerlink" title="合格"></a>合格</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x,y) x &gt; y ? x : y</span><br></code></pre></td></tr></table></figure><p>我们写一个程序，验证一下上面定义的宏是否正确  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x,y) x &gt; y ? x : y</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max = %d&quot;</span>,MAX(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max = %d&quot;</span>,MAX(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max = %d&quot;</span>,MAX(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max = %d&quot;</span>,MAX(<span class="hljs-number">1</span>!=<span class="hljs-number">1</span>,<span class="hljs-number">1</span>!=<span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然是测试程序，我们肯定要把各种可能出现的情况都测试一遍。例如，测试第4行语句，当宏的参数是一个表达式，发现实际运行结果为max&#x3D;0，和我们预期结果max&#x3D;1不一样。这是因为，宏展开后，变成如下样子  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max = %d&quot;</span>,<span class="hljs-number">1</span>!=<span class="hljs-number">1</span>&gt;<span class="hljs-number">1</span>!=<span class="hljs-number">2</span>?<span class="hljs-number">1</span>!=<span class="hljs-number">1</span>:<span class="hljs-number">1</span>!=<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>因为比较运算符&gt;的优先级为6，大于！&#x3D;（优先级为7），所以在展开的表达式中，运算顺序发生了改变，结果就和预期不一样了。为了避免这种展开错误，我们可以给宏的参数加一个小括号()，防止展开后表达式的运算顺序发生变化  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x,y) (x) &gt; (y) ? (x) : (y)</span><br></code></pre></td></tr></table></figure><h3 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h3><p>我们再测试一下这个上面修改的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x,y) (x) &gt; (y) ? (x) : (y)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>,<span class="hljs-number">3</span>+MAX(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序中，我们打印表达式3+MAX（1，2）的值，预期结果应该是5，但实际运行结果却是1。宏展开后，我们发现同样有问题  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">3</span> + (<span class="hljs-number">1</span>) &gt; (<span class="hljs-number">2</span>) ? (<span class="hljs-number">1</span>) : (<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>因为运算符+的优先级大于比较运算符&gt;，所以这个表达式就变为4&gt;2？1：2，最后结果为1也就不奇怪了。此时我们应该继续修改宏  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span><br></code></pre></td></tr></table></figure><p>使用小括号将宏定义包起来，这样就避免了当一个表达式同时含有宏定义和其他高优先级运算符时，破坏整个表达式的运算顺序  </p><h3 id="良好"><a href="#良好" class="headerlink" title="良好"></a>良好</h3><p>我们再用下面的代码测试一下上面的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">6</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max = %d&quot;</span>,MAX(i++,j++));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序中，我们定义两个变量i和j，然后比较两个变量的大小，并作自增运算。实际运行结果发现max&#x3D;7，而不是预期结果max&#x3D;6。这是因为变量i和j在宏展开后，做了两次自增运算，导致打印出的i值为7  </p><p>当然，在C语言编程规范里，使用宏时一般是不允许参数变化的。但是万一碰到这种情况，该怎么办呢？这时候，语句表达式就该上场了。我们可以使用语句表达式来定义这个宏，在语句表达式中定义两个临时变量，分别来暂时存储i和j的值，然后使用临时变量进行比较，这样就避免了两次自增、自减问题  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x,y)(&#123;   \</span><br><span class="hljs-meta"></span><br><span class="hljs-type">int</span> _x =  x;                   \<br><br><span class="hljs-type">int</span> _y = y;                    \<br><br>_x &gt; _y ? _x : _y;         \<br><br>&#125;)<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i =<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> j =<span class="hljs-number">6</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d&quot;</span>,MAX(i++,j++));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在语句表达式中，我们定义了2个局部变量_x、_y来存储宏参数x和y的值，然后使用_x和_y来比较大小，这样就避免了i和j带来的2次自增运算问题  </p><h3 id="优秀"><a href="#优秀" class="headerlink" title="优秀"></a>优秀</h3><p>在上面这个宏中，我们定义的两个临时变量数据类型是int型，只能比较两个整型数据。那么对于其他类型的数据，就需要重新定义一个宏了，这样太麻烦了！我们可以基于上面的宏继续修改，让它可以支持任意类型的数据比较大小  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(type,x,y)(&#123; \</span><br><span class="hljs-meta">type _x = x;            \</span><br><span class="hljs-meta">type _y = y;            \</span><br><span class="hljs-meta">_x &gt; _y ? _x : _y;      \</span><br><span class="hljs-meta">&#125;)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">6</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d\n&quot;</span>,MAX(<span class="hljs-type">int</span>, i++, j++));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;max=%d\n&quot;</span>,MAX(<span class="hljs-type">float</span>,<span class="hljs-number">3.14</span>,<span class="hljs-number">3.15</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个宏中，我们添加一个参数type，用来指定临时变量 _x 和 _y 的类型。这样，我们在比较两个数的大小时，只要将2个数据的类型作为参数传给宏，就可以比较任意类型的数据了  </p><h3 id="更加优秀"><a href="#更加优秀" class="headerlink" title="更加优秀"></a>更加优秀</h3><p>在上面的宏定义中，我们增加了一个type类型参数，来适配不同的数据类型我们应该尝试进一步优化，把这个参数也省去。该如何做到呢？使用typeof就可以了，typeof是GNU C新增的一个关键字，用来获取数据类型，我们不用传参进去，让typeof直接获取！    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(type,x,y)(&#123; \</span><br><span class="hljs-meta">typeof(x) _x = (x);     \</span><br><span class="hljs-meta">typeof(y) _y = (y);     \</span><br><span class="hljs-meta">(void) (&amp;_x == &amp;_y);</span><br>_x &gt; _y ? _x : _y;      \<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>在这个宏定义中，我们使用了typeof关键字来自动获取宏的两个参数类型。</p></li><li><p>比较难理解的是（void（&amp;x&#x3D;&#x3D;&amp;y）；这句话，看起来很多余，仔细分析一下，你会发现这条语句很有意思。</p></li><li><p>它的作用有两个：</p><ul><li><p>一是用来给用户提示一个警告，对于不同类型的指针比较，编译器会发出一个警告，提示两种数据的类型不同 </p></li><li><pre><code class="c">warning: comparison of distinct pointer types lacks a cast</code></pre></li><li><p>二是两个数进行比较运算，运算的结果却没有用到，有些编译器可能会给出一个warning，加一个（void）后，就可以消除这个警告</p></li></ul></li></ul><h2 id="6-3-4-内核中的语句表达式"><a href="#6-3-4-内核中的语句表达式" class="headerlink" title="6.3.4 内核中的语句表达式"></a>6.3.4 内核中的语句表达式</h2>]]></content>
    
    
    <categories>
      
      <category>嵌入式C语言自我修养</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正电原子STM32基础篇</title>
    <link href="/2023/07/11/%E6%AD%A3%E7%94%B5%E5%8E%9F%E5%AD%90STM32%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2023/07/11/%E6%AD%A3%E7%94%B5%E5%8E%9F%E5%AD%90STM32%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-单片机简介"><a href="#第一讲-单片机简介" class="headerlink" title="第一讲 单片机简介"></a>第一讲 单片机简介</h1><h2 id="单片机是什么"><a href="#单片机是什么" class="headerlink" title="单片机是什么"></a>单片机是什么</h2><ul><li>单片机：Single-Chip Microcomputer，单片微型计算机，是一种集成电路芯片</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307111036071.png" alt="image-20230711103624987"></p><h1 id="第二讲-Cortex-M系列介绍"><a href="#第二讲-Cortex-M系列介绍" class="headerlink" title="第二讲 Cortex-M系列介绍"></a>第二讲 Cortex-M系列介绍</h1>]]></content>
    
    
    <categories>
      
      <category>STM32学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破防板之矩阵键盘</title>
    <link href="/2023/06/28/%E7%A0%B4%E9%98%B2%E6%9D%BF%E4%B9%8B%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/"/>
    <url>/2023/06/28/%E7%A0%B4%E9%98%B2%E6%9D%BF%E4%B9%8B%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>湖科大计算机网络第六章</title>
    <link href="/2023/06/15/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <url>/2023/06/15/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>湖科大计算机网络第五章</title>
    <link href="/2023/06/15/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <url>/2023/06/15/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>湖科大计算机网络第四章</title>
    <link href="/2023/06/15/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2023/06/15/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库期末</title>
    <link href="/2023/06/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB/"/>
    <url>/2023/06/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h1><ul><li>选择题 2分*5 都是概念</li><li>填空题 1分*10</li><li>简答题 6分*3</li><li>运算题 6分 * 2 + 5分 * 1 共17分</li><li>分析题 3分*4 四小题一大题</li><li>设计题 4道 共18分</li><li>应用题 15分*1 （数据库设计、ER图）</li></ul><h1 id="考试范围"><a href="#考试范围" class="headerlink" title="考试范围"></a>考试范围</h1><ul><li><p>第一章：没有大题</p><ul><li>主要内容：概念（把习题过一遍）1.2.5、1.2.6不考</li><li>2个选择，1个填空</li></ul></li><li><p>第二章：2.4重要 2.5不考</p><ul><li>运算题 一道5分</li><li>设计题 6分 写两个关系表达式</li></ul></li><li><p>第三章：重点</p><ul><li>填空1题、简答2题、设计题都是第三章的</li><li>重点连接查询、嵌套查询</li><li>聚合这些难的不考</li></ul></li><li><p>第四章</p><ul><li>填空2题</li><li>4.1不考，4.2 安全性的控制、用户身份的鉴别 图4.2 安全模型</li><li>4.3存取控制机制、自主存取控制和强制存取控制、授权</li><li>4.4节之后都不考</li><li>授权在范围之内，不多，融在其他地方</li></ul></li><li><p>第五章：无概念，没有单独出题，在其他题里面，触发器没有</p><ul><li>5.5、5.6、5.7没有涉及</li></ul></li><li><p>第六章：难点、重点</p><ul><li>运算1题（6分） 分析（12分 只有第六章） 应用（有几分判断范式等）</li><li>到第三范式就ok了，6.3.7、6.2.8不考</li><li>6.3重要，不考定义，例子要看（求闭包这些），不考证明</li><li>范式、规范化理论、公理系统、求闭包、等价充分必要条件</li><li>求最小函数依赖集不考</li></ul></li><li><p>第七章：主要体系在应用题</p><ul><li>选择题1个</li><li>ER图</li><li>带星号都不看，7.5、7.6不看</li></ul></li><li><p>第九章：基本概念</p><ul><li>填空 2分</li><li>习题要看</li></ul></li><li><p>第十章</p><ul><li>选择 1题、填空1题、简答1题（数据恢复）</li><li>10.6节之后不考</li></ul></li><li><p>第十一章</p><ul><li>选择1题、填空1题、运算6分</li><li>并行的调度</li><li>两段锁协议</li><li>11.7,11.8不看</li></ul></li></ul><h1 id="考点梳理"><a href="#考点梳理" class="headerlink" title="考点梳理"></a>考点梳理</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="概念建立"><a href="#概念建立" class="headerlink" title="概念建立"></a>概念建立</h3><p><strong>通过下面的问题理解知识点，不需要背诵，但是要理解</strong></p><p><strong>考2个选择，1个填空</strong></p><blockquote><p>论述数据、数据库、数据库管理系统、数据系统的概念</p></blockquote><ul><li>数据（DATA）,描述事物的符号记录为数据，数据有多种表现形式，数据的含义称为数据的语义，<strong>数据与其语义是不可分的</strong></li><li>数据库（DB）是<strong>长期储存在计算机内</strong>，<strong>有组织的</strong>、<strong>可共享的</strong>大量数据的集合。数据库中的数据<strong>按一定的数据模型</strong>组织、描述和储存，具有<strong>较小的冗余度</strong>、<strong>较高的数据独立性</strong>和<strong>易扩展性</strong>，并可为各种用户<strong>共享</strong>。概括地讲，数据库数据具有<strong>永久存储</strong>、<strong>有组织</strong>和<strong>可共享</strong>三个基本特点</li><li>数据库管理系统（DBMS）是位于<strong>用户和操作系统之间</strong>的一层数据管理软件。数据库管理系统和操作系统一样<strong>是计算机的基础软件</strong>，也是一个大型复杂的软件系统，主要功能包括：<ul><li><strong>数据定义</strong>：提供数据定义语言（DDL），用户通过它可以方便地对数据库中的数据对象组成与结构进行定义</li><li><strong>数据组织、存储和管理</strong></li><li><strong>数据操纵</strong>功能：提供数据操纵语言（DML)，用户可以使用它操纵数据，如查询、插入、删除和修改等</li><li><strong>数据库的事务管理和运行管理</strong></li><li><strong>数据库的建立和维护功能</strong></li><li>以及一些其他功能</li></ul></li><li>数据库系统（DBS）,由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DBA）组成的存储、管理和维护数据的系统<ul><li>在一般不引起混淆的情况下，人们常常把数据库系统简称为数据库</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306111519129.png" alt="image-20230611151955060"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306111520222.png" alt="image-20230611152051163"></p><blockquote><p>使用数据库系统有什么好处？</p></blockquote><ul><li>使用数据库系统的好处很多，既便于数据的集中管理，控制数据冗余，提高数据的利用率和一致性，又有利于应用程序的开发和维护。</li><li>使用数据库可以大大提高应用开发的效率</li><li>当数据的逻辑结构需要改变时，开发人员不必修改应用程序，或者只需要修改很少的应用程序</li><li>使用数据库可以减轻DBA（数据库管理员）维护系统的负担</li></ul><blockquote><p>论述文件系统与数据库系统的区别与联系</p></blockquote><p><strong>区别：</strong></p><ul><li><strong>文件系统</strong>的数据是面向某一应用的，文件的<strong>共享性差</strong>、<strong>冗余度大</strong>、<strong>独立性差</strong>，文件的记录虽然是有结构的，但是<strong>整体无结构</strong>。所谓“数据面向某个应用”是指数据结构是针对某个应用设计的，只被这个应用程序或应用系统使用，<strong>数据是某个应用的“私有资源”</strong></li><li><strong>数据库系统</strong>中的数据不在仅仅面向某一个应用，而是面向整个组织或企业。数据的<strong>共享性高</strong>、<strong>冗余度小</strong>，具有<strong>高度的物理独立性</strong>和<strong>一定的逻辑独立性</strong>，数据库中的数据用数据模型组织和描述，由数据库管理系统提供数据安全性、完整性、并发控制和恢复能力</li></ul><p><strong>联系：</strong></p><ul><li>文件系统与数据库系统都是计算机系统中管理数据的软件</li><li>文件系统是操作系统的重要组成部分，而DBMS是独立于操作系统的软件。我们不能独立购买一个文件系统，但一般需独立购买DBMS软件产品。DBMS是在操作系统的基础上实现的，数据库中数据的组织和存储是通过操作系统中文件系统来实现的。因此，DBMS的实现与操作系统中的文件系统是紧密相关的。<strong>数据库实现的基础是文件，对数据库的任何操作最终要转化为对文件的操作</strong></li></ul><blockquote><p>举出适合用文件系统而不是数据库系统的例子；再举出适合用数据库系统的应用例子</p></blockquote><ul><li>目前，许多手机上的小型应用都把数据存放在手机操作系统的文件中，如照片、短信和微信等数据。一般来说，<strong>功能比较简单、比较固定</strong>的应用系统<strong>适合用文件系统</strong></li><li>目前，几乎所有<strong>企业或部门</strong>的<strong>信息系统</strong>都以数据库系统为基础，都使用数据库系统。例如，一个工厂的信息系统会包括多个子系统，如库存管理系统、物资采购系统、作业调度系统、设备管理系统和人事管理系统等。数据库系统已成为信息系统已经成为信息系统的基础和核心</li></ul><blockquote><p>论述数据库系统的特点</p></blockquote><ul><li>数据结构化。数据库系统实现<strong>整体数据</strong>的结构化，这是数据库系统与文件系统的<strong>本质区别</strong><ul><li>注意这里“整体”两个字。数据库系统中，数据面向全组织，可以支持许多应用；不仅数据内部是结构化的，而且数据之间是具有联系的，整体是结构化的。</li></ul></li><li>数据共享性高，冗余度低，易扩充。</li><li>数据的独立性高。数据独立性是指<strong>数据和程序相互不依赖</strong>。即数据的逻辑结构或物理结构改变了，程序不会跟着改变。</li><li>数据由DBMS统一管理和控制。数据库的共享是<strong>并发的共享</strong>，即多个用户可以同时存取数据，库中的数据甚至可以同时存取数据库中同一个数据。为此，DBMS必须提供统一控制功能，包括：<ul><li>数据的安全性保护：保护数据以防止不合法的使用造成的数据泄密破坏；</li><li>数据的完整性检查：将数据控制在有效的范围内或保证数据之间满足一定的关系，一定的约束条件</li><li>并发控制：对多用户的并发操作加以控制和协调，保证并发操作的正确性</li><li>数据库恢复：当计算机系统发生硬件故障、软件故障，或者由于操作员的失误以及故意的破坏影响数据库中数据的正确性，甚至造成数据库部分或全部数据的丢失时，能将数据库从错误状态恢复到某一已知的正确状态，亦成为完整状态或一致状态</li></ul></li></ul><p>数据库系统的出现，使信息系统从<strong>以加工数据的程序为中心</strong>转向<strong>围绕共享数据库为中心</strong>的新阶段</p><blockquote><p>DBMS的主要功能有哪些</p></blockquote><ul><li>数据定义功能</li><li>数据组织、存储和管理功能</li><li>数据操纵功能</li><li>数据库的事务管理和运行管理</li><li>数据库的建立和维护功能</li><li>其他功能，如不同数据库之间的互访和互操作功能等</li></ul><blockquote><p>什么是概念模型？论述概念模型的作用</p></blockquote><p>概念模型是现实世界到机器世界的一个中间层次。概念模型用于信息世界的建模，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言</p><blockquote><p>定义并解释概念模型中术语：实体、实体型、实体集、实体间的联系</p></blockquote><ul><li>实体：客观存在并可以相互区分的事务，例如一个职工、一个学生、一个部门、学生的一次选课、教师与院系的工作关系等都是实体</li><li>实体型：同实体名及其属性名集合来抽象和刻画同类实体称为实体型，例如：学生（学号，姓名，性别，出生年月，所在院系，入学时间）就是一个实体型</li><li>实体集：同型实体的集合称为实体集，例如全体学生就是一个实体集</li><li>实体之间的联系：包括实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系；实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型</li></ul><blockquote><p>论述数据模型的概念、数据模型的作用和数据模型的三个要素</p></blockquote><ul><li>数据模型是数据库系统中最重要的概念之一。数据模型是数据库中用来<strong>对现实世界进行抽象</strong>的工具，是数据库中用于提供<strong>信息表示</strong>和<strong>操作手段</strong>的形式构架</li><li>数据模型是数据库系统的基础。任何一个DBMS都<strong>以一个数据模型为基础</strong>，或者说支持某一个数据模型。</li><li>数据模型通常由数据结构、数据操作和完整性约束三部分组成<ul><li>数据结构：描述数据库的组成对象和对象之间的联系，是对系统的<strong>静态特性</strong>的描述</li><li>数据操作：是指对数据库中各种对象的实例进行的操作的集合，包括操作及有关的操作规则，是对系统<strong>动态特性</strong>的描述</li><li>数据的约束条件：是完整性规则的集合，完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定复合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容</li></ul></li></ul><p>注：数据库中模型有不同的层次。根据模型应用的不同目的，可以将模型分成两类或者说两个层次：一个是<strong>概念模型</strong>，是<strong>按用户的观点</strong>来对数据和信息建模，用于<strong>信息世界</strong>的建模，强调语义表达能力，概念简单清晰；二是<strong>数据模型</strong>，是<strong>按计算机系统的观点</strong>对数据建模，<strong>用于机器世界</strong>，人们可以用它定义和操纵数据库中的数据</p><blockquote><p>论述关系模型的概念、定义并解释一下术语：关系、属性、域、元组、码、分量、关系模式</p></blockquote><p>关系模式由关系数据结构、关系操作集合和关系完整性约束三部分组成。在用户观点下，<strong>关系模型</strong>中数据的<strong>逻辑结构</strong>是一张<strong>二维表</strong>，它由行和列组成</p><ul><li><p>关系：一个关系对应通常说的一张表</p></li><li><p>属性：表中的一列即为一个属性</p></li><li><p>域：属性的取值范围</p></li><li><p>元组：表中的一行即为一个元组</p></li><li><p>码：表中的某个属性组，它可以唯一确定一个元组</p></li><li><p>分量：元组中的一个属性值</p></li><li><p>关系模式：对关系的描述，一般表示为</p><p>关系名（属性1，属性2，…，属性n）</p></li></ul><blockquote><p>论述关系数据库的特点</p></blockquote><p>关系数据库是建立在关系数据模型上的，具有下列优点：</p><ul><li>关系模型与非关系模型不同，它具有严格的数学基础</li><li>关系模型的概念单一。所以其数据结构简单、清晰，用户易懂易用</li><li>关系模型的存取路径对用户透明（即用户看不见，不知道），从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作</li></ul><p>当然，关系数据模型也有缺点：</p><ul><li>其中最主要的是，由于存取路径对用户透明，查询效率往往不如非关系数据模型。因此为了提高性能，必须对用户的查询请求进行优化，这就增加了开发关系数据库管理系统软件的难度</li></ul><blockquote><p>论述数据库系统三级模式结构，并说明这种结构的优点是什么</p></blockquote><ul><li>数据库系统的三级模式结构由外模式、模式和内模式组成</li><li>外模式，亦称子模式或用户模式，是数据库用户能够看见和使用的<strong>局部数据的逻辑结构和特征</strong>的描述，是数据库用户数据视图</li><li>模式，亦称逻辑模式，是数据库中全体数据的逻辑结构和特性的描述，是所有用户的公共数据视图。模式描述的是<strong>数据的全局逻辑结构</strong>。<strong>外模式通常是模式的子集</strong></li><li>内模式，亦称存储模式，是数据在<strong>数据库系统内部的表示</strong>，即对数据的<strong>物理结构</strong>和<strong>存储方式</strong>的描述</li><li>为了能够在内部实现这三个抽象层次的联系和转换，数据库系统在这三级模式之间提供了两级映像：外模式&#x2F;模式映像和模式&#x2F;内模式映像。正是这两级映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306112123906.png" alt="image-20230611212320833"></p><blockquote><p>定义并解释术语：数据定义语言和数据操纵语言</p></blockquote><ul><li>数据定义语言：用来定义数据库模式、外模式和内模式的语言</li><li>数据操纵语言：用来对数据库中的数据进行查询、插入、删除和修改的语句</li></ul><blockquote><p>什么叫数据与程序的物理独立性？什么叫数据与程序的逻辑独立性？为什么数据库系统具有数据与程序的独立性</p></blockquote><ul><li>数据与程序的物理独立性：当数据库的<strong>存储结构改变</strong>了，由数据库管理员<strong>对模式&#x2F;内模式映像作相应改变</strong>，可以<strong>使模式保持不变</strong>，从而<strong>应用程序也不必改变</strong>，这就是数据与程序的物理独立性，简称数据的<strong>物理独立性</strong></li><li>数据与程序的逻辑独立性：当数据的逻辑结构即模式改变时，由数据库管理员对各个外模式&#x2F;模式的映像作相应改变，可以使外模式保持不变，从而应用程序不必修改，这就是数据与程序的逻辑独立性，简称数据的逻辑独立性</li><li>DBMS在三级模式之间提供的两级映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性</li></ul><blockquote><p>论述数据库管理员、系统分析员、数据库设计人员、应用程序员的职责</p></blockquote><ul><li>数据库管理员全面负责<strong>管理和控制</strong>数据库系统。具体职责包括：<ul><li>决定数据库的信息内容和结构</li><li>决定数据库的存储结构和存取策略</li><li>定义数据的安全性要求和完整性约束</li><li>监控数据库的使用和运行</li><li>数据库的改进和重组重构</li></ul></li><li>系统分析员负责应用系统的需求分析和规范说明，他要和用户及DBA相结合，确定系统的硬件软件配置，并参与数据库系统的概要设计</li><li>数据库设计人员负责数据库中数据的确定和数据库各级模式的设计。数据库设计人员必须参加用户需求调查和系统分析，然后进行数据库设计</li><li>应用程序员负责设计和编写应用系统的程序模块，并进行调试和安装</li></ul><h3 id="补充习题"><a href="#补充习题" class="headerlink" title="补充习题"></a>补充习题</h3><ul><li>数据库系统的<strong>核心和基础</strong>是：<strong>数据模型</strong></li><li>实现将现实世界抽象为信息世界的是：<strong>概念模型</strong></li><li>数据管理技术经历了若干阶段，其中<strong>人工管理阶段和文件系统阶段相比</strong>，文件系统的一个显著优势是：数据可以长期保存</li><li>能够保证数据库系统中的数据具有较高的<strong>逻辑独立性</strong>的是：<strong>外模式&#x2F;模式映像</strong></li><li>IBM公司的IMS数据库管理系统采用的数据模型是：层次模型</li><li>DBMS是一类系统软件，它是建立在下列哪种系统之上的：<strong>操作系统</strong></li><li>从<strong>逻辑模型到物理模型的转换</strong>一般是由<strong>DBMS</strong>完成的</li><li>长期存储在计算机内，有组织、可共享的大量数据的集合是：数据库（DataBase）</li><li>在数据管理技术发展过程中，需要应用程序管理数据的是：人工管理阶段</li></ul><p>判断：</p><ul><li>在文件系统管理阶段，由文件系统提供数据存取方法，所以数据已达到很强的独立性 —— 错</li><li>通常情况下，外模式是模式的子集 ——对</li><li>数据库管理系统是指在计算机系统中引入数据库后的系统，一般由DB、DBS、应用系统和DBA组成 —— 错（不是数据管理系统，而是数据库系统）</li><li>在数据模型的组成要素中，数据结果是刻画一个数据模型性质最重要的方面，人们通常按照数据结构的类型来命名数据模型 ——对</li><li>数据库系统的三级模式是对数据进行抽象的3个级别，把数据的具体组织留给DBMS管理 —— 对</li></ul><p>填空题</p><ul><li>数据库系统的<strong>逻辑模型</strong>按照计算机的观点对数据建模，主要包括<strong>层次模型</strong>、<strong>网状模型</strong>、<strong>关系模型</strong>、面向对象模型、对象关系模型和半结构化数据模型等</li><li>最经常使用的概念模型是：<strong>E-R模型</strong></li><li>数据独立性是数据库领域的重要概念，包括数据的<strong>物理</strong>独立性和数据的<strong>逻辑</strong>独立性</li><li>数据库系统的三级模式结构是指数据库系统是由<strong>外模式</strong>、<strong>模式</strong>和<strong>内模式</strong>三级构成</li><li>两个实体型之间的联系可以分为三种：<strong>一对一联系</strong>、<strong>一对多联系和多对多联系</strong></li><li>数据库管理系统提供的数据控制方面的功能包括数据的<strong>安全性</strong>保护、数据的<strong>完整性</strong>检查、<strong>并发控制</strong>和数据库恢复</li><li>数据库的三级模式结构中，描述局部数据的逻辑结构和特征的是<strong>外模式</strong></li><li>数据模型的组成要素中描述系统的静态特性和动态特性的分别是<strong>数据结构</strong>和<strong>数据操作</strong></li></ul><h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><p><strong>2.4重要</strong></p><p><strong>运算题 一道5分的，一道设计题 6分 有涉及到关系代数</strong></p><h3 id="2-1-关系数据结构及形式化定义"><a href="#2-1-关系数据结构及形式化定义" class="headerlink" title="2.1 关系数据结构及形式化定义"></a>2.1 关系数据结构及形式化定义</h3><ul><li><p>候选码：若关系的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码</p></li><li><p>主码：若一个关系有多个候选码，则选定其中一个为主码</p></li><li><p>候选码的每个属性称为<strong>主属性</strong>，不包含在任何候选码中的属性称为<strong>非主属性</strong>或<strong>非码属性</strong></p></li><li><p>在最简单的情况下，候选码只包含一个属性，在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为<strong>全码</strong></p></li><li><p>关系模型要求关系必须是规范的，即要求关系必须满足一定的规范条件。这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项（即不允许表中有表）。规范化的关系简称为范式</p></li><li><p>关系的描述称为关系模式，它可以形式化地表示为：R(U,D,DOM,F)</p><ul><li>其中R为关系名</li><li>U为组成该关系的属性名的集合</li><li>D为U中属性所来自的域</li><li>DOM为属性向域的映像集合</li><li>F为属性间数据的依赖关系集合</li></ul></li><li><p>关系模式通常可以简记为R(U)或R(A1,A2,…,An)，R为关系名，A1,A2,…,An为属性名</p></li></ul><h3 id="2-2-基本的关系操作"><a href="#2-2-基本的关系操作" class="headerlink" title="2.2 基本的关系操作"></a>2.2 基本的关系操作</h3><p>常用关系操作包括：查询、插入、删除、修改两大部分</p><p>查询又可分为：选择、投影、连接、除、并、差、交、笛卡尔积等</p><p>其中：<strong>选择、投影、并、差、笛卡尔积是5种基本操作</strong></p><p>关系数据语言可以分为三类：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306112244619.png" alt="image-20230611224408548"></p><h3 id="2-3-关系的完整性"><a href="#2-3-关系的完整性" class="headerlink" title="2.3 关系的完整性"></a>2.3 关系的完整性</h3><p><strong>关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。</strong>其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的<strong>两个不变性</strong>，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束</p><h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><ul><li>实体完整性规则：若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值<ul><li>（1）实体完整性规则是针对基本关系而言的，一个基本表通过对应现实世界的一个实体集。例如学生关系对应学生的集合</li><li>（2）现实世界中的实体是可区分的，它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的</li><li>（3）相应地，关系模型中以主码作为唯一性标识</li><li>（4）主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性</li></ul></li></ul><h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><ul><li>设F是基本关系R的一个或一组属性，但不是关系R的码，$K_S$的基本关系S的主码，如果F与$K_S$相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系<ul><li>显然，目标关系S的主码$K_S$和参照关系R的外码F必须定义在同一个（或同一个组）的域上</li><li>需要指出，外码并不一定与相应的主码同名，不过，在实际应用中为了便于识别，当外码与相应的主码属于不同关系时，往往给它们取相同的名字</li><li>参照完整性规则就是定义外码与主码之间的引用规则</li></ul></li><li>参照完整性规则：若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码$K_S$相对应（基本关系R和S不一定是不同的关系），则对于R中的每个元组在F上的值必须：<ul><li>或者取空值（F的每个属性值均为空值）</li><li>或者等于S中某个元组的主码值</li></ul></li></ul><h4 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h4><ul><li>不同的关系数据库根据其应用环境不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求</li></ul><h3 id="2-4-关系代数"><a href="#2-4-关系代数" class="headerlink" title="2.4 关系代数"></a>2.4 关系代数</h3><ul><li>关系代数按运算符的不同可分为传统的集合运算和专门的关系运算两类<ul><li>传统的集合原酸将关系看成元组的集合，其运算是从关系的“水平”方向，即行的角度来进行</li><li>而专门的关系运算不仅涉及行，而且涉及列</li><li>比较运算符和逻辑运算符是用来辅助专门的关系运算符</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306120925410.png" alt="image-20230612092548326"></p><h4 id="传统集合运算"><a href="#传统集合运算" class="headerlink" title="传统集合运算"></a>传统集合运算</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121022804.png" alt="image-20230612102212717"></p><h5 id="并"><a href="#并" class="headerlink" title="并"></a>并</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121019776.png" alt="image-20230612101912712"></p><h5 id="差"><a href="#差" class="headerlink" title="差"></a>差</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121019999.png" alt="image-20230612101953928"></p><h5 id="交"><a href="#交" class="headerlink" title="交"></a>交</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121020674.png" alt="image-20230612102010600"></p><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121020350.png" alt="image-20230612102051250"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121021794.png" alt="image-20230612102113720"></p><h4 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h4><p>为了叙述上的方便，先引入几个记号：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121024438.png" alt="image-20230612102459321"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121025931.png" alt="image-20230612102515848"></p><p><strong>也就是说几个属性组构成一个关系（即一张二维表），当一个属性组的值给定（假设为x），那么x在R中的象集就是当给定值的属性组的值等于x所对应的其余个属性组的取值构成的集合，就叫做象集</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121035608.png" alt="image-20230612103559549"></p><h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><ul><li>选择又称为限制。它是在关系R中选择满足给定条件的诸元组</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121048063.png" alt="image-20230612104817019"></p><p>其中F为选择条件，它是一个逻辑表达式，取逻辑值“真”或“假”</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121050199.png" alt="image-20230612105047151"></p><p>其中$\theta$表示比较运算符，它可以是大于，大于等于小于，小于等于或&lt;&gt;，X1,Y1等是属性名，或为常量或为简单函数：属性名也可以用它的序号来代替</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121216647.png" alt="image-20230612121605566"></p><p><strong>选择运算实际上是从关系R中选取使逻辑表达式为真的元组，这是从行的角度进行的运算</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121217829.png" alt="image-20230612121746766"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121218206.png" alt="image-20230612121800157"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121218414.png" alt="image-20230612121813356"></p><h5 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h5><ul><li>关系R上的投影是从R中选择出若干属性列组成新的关系</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121220484.png" alt="image-20230612122057446"></p><ul><li>其中A为R重的属性列</li><li>投影操作是从列的角度进行的运算</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121223057.png" alt="image-20230612122328001"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121223772.png" alt="image-20230612122357722"></p><ul><li>投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组，因为取消了某些属性列后，就可能出现重复行，应取消这些完全相同的行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121225873.png" alt="image-20230612122532810"></p><p>Student关系原来有4个元组，而投影结果取消了重复的CS元组，因此只有三个元组</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121226787.png" alt="image-20230612122639744"></p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><ul><li>连接也称$\theta$连接，它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121258942.png" alt="image-20230612125838898"></p><ul><li>其中，A和B分别为R和S上列数相等且可比的属性组，$\theta$是比较运算符。</li><li>$\theta$为“&#x3D;”的连接运算称为等值连接，它是从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121302280.png" alt="image-20230612130204227"></li></ul></li><li>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B，U为R和S的全体属性集合<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121303081.png" alt="image-20230612130354041"></li></ul></li><li>一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是同时从行和列的角度进行运算</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121307972.png" alt="image-20230612130738842"></p><ul><li>两个关系R和S在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃，同样，S中某些元组也可能被舍弃，这些被舍弃的元组称为<strong>悬浮元组</strong>，例如，在上图中（e）的自然连接中，R中的第四个元组，S中的第五个元组都是被舍弃掉的悬浮元组</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121315191.png" alt="image-20230612131531118"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121315314.png" alt="image-20230612131545241"></p><h5 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121316831.png" alt="image-20230612131657748"></p><p>结合例子理解：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121321264.png" alt="image-20230612132134211"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121321060.png" alt="image-20230612132144964"></p><ul><li>（1）进行除法运算，首先必须得有出自相同域的属性组（属性名可以不同，但属性的值，必须出自同一个域）</li><li>（2）对作为被除数的关系（假设为R），找到不是出自相同域的属性组，求找到的属性组的各个属性值的象集</li><li>（3）对作为除数的关系（假设为S），找到出自相同域的属性组，求出自相同域的属性组在S上的投影</li><li>（4）找到（2）中求得的象集中包含了（3）中求到的投影的属性值</li><li>（5）得到（4）中找到的属性值的集合，就是除运算的结果</li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121336591.png" alt="image-20230612133600507"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121336680.png" alt="image-20230612133615618"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121340358.png" alt="image-20230612134044313"></p><p>关系代数中，这些运算经有限次符合后形成的表达式称为<strong>关系代数表达式</strong></p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121344795.png" alt="image-20230612134454707"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121345642.png" alt="image-20230612134509576"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121345971.png" alt="image-20230612134529901"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121346331.png" alt="image-20230612134604277"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121346883.png" alt="image-20230612134612834"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121346820.png" alt="image-20230612134620760"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121346889.png" alt="image-20230612134629835"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121346891.png" alt="image-20230612134640852"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121347476.png" alt="image-20230612134704418"></p><ul><li>关系操作中，操作的对象和结果都是：集合</li></ul><h2 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h2><ul><li>填空1题、简答2题、设计题都是第三章的</li><li>重点连接查询、嵌套查询</li><li>聚合这些难的不考</li></ul><h3 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h3><h4 id="SQL的特点"><a href="#SQL的特点" class="headerlink" title="SQL的特点"></a>SQL的特点</h4><ul><li>综合统一<ul><li>SQL集数据定义语言、数据操纵语言、数据控制语言的功能于一体，语言风格统一，可以独立完成数据库生命周期中的全部活动，包括以下一系列操作要求：<ul><li>定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库</li><li>对数据库中的数据进行查询和更新</li><li>数据库的重构和维护</li><li>数据库安全性、完整性控制，以及事务控制</li><li>嵌入式SQL和动态SQK定义</li></ul></li></ul></li><li>高度非过程化<ul><li>非关系数据模型的数据操纵语言是“面向过程”的语言，用“过程化”语言完成某项请求必须指定存取路径</li><li>而用SQL进行数据操作时，只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成</li><li>大大减轻了用户的负担，而且有利于提高数据独立性</li></ul></li><li>面向集合的操作方式<ul><li>非关系数据模型采用的是面向记录的操作方式，操作对象是一条记录。例如：查询所有平均成绩在80分以上的学生姓名，用户必须一条一条地把满足条件的学生记录找出来。而SQL采用集合操作方式，不仅操作对象、查找对象可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合</li></ul></li><li>以同一种语法结构提供多种使用方式<ul><li>SQL既是独立的语言，又是嵌入式语言。</li><li>作为独立的语言，它能够独立地用于联机交互的使用方式，用户可以在终端键盘上直接键入SQL命令对数据库进行操作</li><li>作为嵌入式语言，SQL语句能够嵌入到高级语言（例如C、C++、Java）程序中，提供程序员设计时使用</li><li>而在两种不同的使用方式下，SQL的语法结构基本上是一致的，这种统一的语法结构，提供了极大的灵活性与方便性</li></ul></li><li>语言简洁、易学易用<ul><li>SQL功能极强，但由于设计巧妙，语言十分简洁，完成核心功能只用9个动词，SQL接近英语口语，因此易于学习和使用</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121533658.png" alt="image-20230612153340580"></li></ul></li></ul><h4 id="SQL的基本概念"><a href="#SQL的基本概念" class="headerlink" title="SQL的基本概念"></a>SQL的基本概念</h4><ul><li><p>支持SQL的关系数据库管理系统同样支持关系数据库三级模式结构。其中外模式包括若干视图和部分基本表，数据库模式包括若干基本表，内模式包括若干存储文件</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121602850.png" alt="image-20230612160225739"></li></ul></li><li><p>基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表，一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中</p></li><li><p>存储文件的逻辑结构组成了关系数据库的内模式，存储文件的物理结构对最终用户是隐蔽的</p></li><li><p>视图是从一个或几个基本表导出的表，它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因此视图是一个虚表。视图在概念上与基本表等同，用户可以在视图上再定义视图</p></li></ul><h3 id="3-2-学生-课程数据库"><a href="#3-2-学生-课程数据库" class="headerlink" title="3.2 学生-课程数据库"></a>3.2 学生-课程数据库</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121632015.png" alt="image-20230612163227940"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121632232.png" alt="image-20230612163250154"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121633265.png" alt="image-20230612163303173"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121633697.png" alt="image-20230612163320620"></p><h3 id="3-3-数据定义"><a href="#3-3-数据定义" class="headerlink" title="3.3 数据定义"></a>3.3 数据定义</h3><ul><li>数据定义语句</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121634372.png" alt="image-20230612163406284"></p><ul><li>SQL标准不提供修改模式定义和修改视图定义的操作，用户如果想修改这些图像，只能先将它们删除然后再重建</li><li>SQL标准也没有提供索引相关的语句，但为了提高查询效率，商用关系数据库管理系统通常都提供了索引机制和相关的语句</li><li>一个关系数据库管理系统的实例（instance）中可以建立多个模式，一个模式下通常包括多少个表、视图和索引等数据对象</li></ul><h4 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121644132.png" alt="image-20230612164417035"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121644570.png" alt="image-20230612164429515"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121644729.png" alt="image-20230612164447670"></p><ul><li>定义模式实际上定义了一个命名空间，在这个空间中可以进一步定义该模式包含的数据库对象，例如基本表、视图、索引等</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121647378.png" alt="image-20230612164724290"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121648027.png" alt="image-20230612164844925"></p><ul><li>在SQL中，删除模式语句如下：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121649006.png" alt="image-20230612164958962"></p><ul><li>其中CASCADE和RESTRICT两者必选其一。选择了CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了RESTRICT（限制），表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时，才能执行DROP SCHEMA语句</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121655072.png" alt="image-20230612165512016"></p><h4 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121656015.png" alt="image-20230612165656942"></p><p>建表的同时通常还可以定义与该表有关的完整性约束条件，这些完整性约束条件被存入系统的数据字典中，当用户操作表中数据时由关系数据库管理系统自动检查该操作是否违背这些完整性约束条件。如果完整性约束条件设计该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121902387.png" alt="image-20230612190220272"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121903896.png" alt="image-20230612190305799"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121905168.png" alt="image-20230612190521086"></p><p>每一个基本表都属于某一个模式，一个模式包含多个基本表，当定义基本表时一般可以有三种方法定义它所属的模式</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121915454.png" alt="image-20230612191540384"></p><ul><li><p>当用户创建基本表（其他数据库对象也一样）时若没有指定模式，系统根据搜索路径来确定该对象所属的模式</p></li><li><p>搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据对象的模式名。若搜索路径中的模式名都不存在，系统将给出错误</p></li><li><p>使用下面的语句可以显示当前的搜索路径：SHOW search_path</p></li><li><p>搜索路径当前的默认值是$user，PUBLIC。其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用PUBLIC模式</p></li><li><p>数据库管理员也可以设置搜索路径，例如：SET search_path TO ”S-T“,PUBLIC</p></li><li><p>然后定义基本表：CREATE TABLE Student（…）;</p></li><li><p>实际结果是建立了S-T.Student基本表。因为关系数据库发现搜索路径中第一个模式名S-T存在，就把该模式作为基本表Student所属的模式</p></li></ul><h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><ul><li>SQL语言用ALTER TABLE语句修改基本表，其一般格式为</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121932860.png" alt="image-20230612193231800"></p><ul><li>其中&lt;表名&gt;是要修改的基本表，ADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件。</li><li>DROP COLUMN子句用于删除表中的列，如果指定了CASCADE语句，则自动删除引用了该列的其他对象，比如视图；如果指定了RESTRICT短语，则如果该列被其他对象引用，RBMS将拒绝删除该列。</li><li>DROP CONSTRAINT子句用于删除指定的完整性约束条件</li><li>ALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121937506.png" alt="image-20230612193753443"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121938933.png" alt="image-20230612193802885"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306121938783.png" alt="image-20230612193813740"></p><h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><p>当某个基本表不再需要时，可以使用DROP TABLE语句删除它，其一般格式为：</p><p>DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]；</p><p>若选择RESTRICT，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如CHECK，FOREIGN KEY等约束），不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除</p><p>若选择CASCADE，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。</p><p>默认情况是RESTRICT</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122006692.png" alt="image-20230612200610646"></p><p>基本表定义一旦被删除，不仅表中的数据和此表的定义将被删除，而且此表上建立的索引、触发器等对象一般也都将被删除。有的关系数据库管理系统还会同时删除在此表上建立的视图。如果欲删除的基本表被其他基本表所引用，则这些表也可能被删除。例如SC表通过外码Sno引用Student，则执行例3.11后Student表被删除，SC也被级联删除。因此执行删除基本表的操作一定要格外小心</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122022376.png" alt="image-20230612202207260"></p><p>注意：不同的数据库产品在遵循SQL标准的基础实现细节和处理策略会与标准有差别</p><h4 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h4><p>当表的数据量比较大时，查询操作会比较耗时。建立索引是加快查询速度的有效手段。数据库索引类似于图书后面的索引，能快速定位到需要查询的内容。用户可以根据应用环境的需要在基本表建立一个或多个索引，以提供多种存取路径，加快查找速度</p><p>数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列（hash）索引、位图索引等。</p><ul><li>顺序文件上的索引是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成</li><li>B+树索引是将索引属性组织称B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。</li><li>散列索引是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。</li><li>位图索引是用位向量记录索引属性中可能出现的值，每个位向量对应一个可能值</li></ul><p>索引虽然能够加速数据库查询，但需要占用一定的存储空间，当基本表更新时，索引要进行相应的维护，这些都会增加数据库的负担，因此要根据实际应用的需要有选择地创建索引</p><p>关系数据库管理系统在执行查询时会自动选择合适的索引作为存取路径，用户不必也不能显式地选择索引。索引是关系数据库管理系统的内部实现技术，属于内模式的范畴</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122052145.png" alt="image-20230612205256043"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122053745.png" alt="image-20230612205320673"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122054291.png" alt="image-20230612205437241"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122054033.png" alt="image-20230612205447980"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122055322.png" alt="image-20230612205505241"></p><h4 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122055013.png" alt="image-20230612205545945"></p><h3 id="3-4-数据查询"><a href="#3-4-数据查询" class="headerlink" title="3.4 数据查询"></a>3.4 数据查询</h3><p>一般格式为：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122056212.png" alt="image-20230612205632156"></p><ul><li><p>整个SELECT语句的含义是，根据WHERE子句的条件表达式从FROM子句指定的基本表、视图或派生表中找到满足条件的元组，再按SELECT子句中的目标列表达式选出元组中的属性值形成结果表</p></li><li><p>如果有GROUP BY子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数，如果GROUP BY子句带HAVING短语，则只有满足指定条件的组才予以输出</p></li><li><p>如果有ORDER BY 子句，则结果表还要按照&lt;列名2&gt;的值的升序或降序排序</p></li><li><p>SELECT语句既可以完成简单的单表查询，也可以完成复杂的连接查询和嵌套查询</p></li></ul><h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122213046.png" alt="image-20230612221303957"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122213406.png" alt="image-20230612221317320"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122213357.png" alt="image-20230612221333273"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122213141.png" alt="image-20230612221359063"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122214084.png" alt="image-20230612221413015"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122214950.png" alt="image-20230612221421889"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122214529.png" alt="image-20230612221447414"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306122215014.png" alt="image-20230612221513916"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130917373.png" alt="image-20230613091725282"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130918690.png" alt="image-20230613091852613"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130919647.png" alt="image-20230613091916568"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130919129.png" alt="image-20230613091928058"></p><h5 id="查询满足条件的元组"><a href="#查询满足条件的元组" class="headerlink" title="查询满足条件的元组"></a>查询满足条件的元组</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130919400.png" alt="image-20230613091952347"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130920963.png" alt="image-20230613092011840"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130921273.png" alt="image-20230613092111217"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130922512.png" alt="image-20230613092216439"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130922891.png" alt="image-20230613092221830"></p><p>这里使用DISTINCT短语，当一个学生有多门课程不及格，他的学号也只列一次</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130923642.png" alt="image-20230613092343571"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130923345.png" alt="image-20230613092354283"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130925373.png" alt="image-20230613092505300"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130925411.png" alt="image-20230613092537361"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130926723.png" alt="image-20230613092617637"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130926759.png" alt="image-20230613092652684"></p><h5 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130928868.png" alt="image-20230613092806752"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130928095.png" alt="image-20230613092835995"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130929332.png" alt="image-20230613092907268"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130929566.png" alt="image-20230613092926491"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130929451.png" alt="image-20230613092936392"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130929652.png" alt="image-20230613092959570"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130930256.png" alt="image-20230613093040160"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130932481.png" alt="image-20230613093209409"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130932187.png" alt="image-20230613093227113"></p><p><strong>这里的“IS”不能用等号（&#x3D;）代替</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130933908.png" alt="image-20230613093322857"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130938134.png" alt="image-20230613093831068"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130938886.png" alt="image-20230613093845799"></p><h5 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130939326.png" alt="image-20230613093915241"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130939981.png" alt="image-20230613093929911"></p><h5 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130939217.png" alt="image-20230613093954101"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130940963.png" alt="image-20230613094007915"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130940866.png" alt="image-20230613094023793"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130940518.png" alt="image-20230613094041460"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130940768.png" alt="image-20230613094054691"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130941144.png" alt="image-20230613094112032"></p><h5 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130941083.png" alt="image-20230613094144998"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130943767.png" alt="image-20230613094304674"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130944017.png" alt="image-20230613094457961"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130945177.png" alt="image-20230613094510076"></p><p><strong>重点关注下面这题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130945388.png" alt="image-20230613094530277"></p><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130946350.png" alt="image-20230613094629266"></p><h5 id="等值与非等值连接"><a href="#等值与非等值连接" class="headerlink" title="等值与非等值连接"></a>等值与非等值连接</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130947901.png" alt="image-20230613094734191"></p><p>查询每个学生及其选修课程的情况</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130949545.png" alt="image-20230613094901406"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130949880.png" alt="image-20230613094934737"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130950023.png" alt="image-20230613095042916"></p><p>如果在SC表Sno上建立了索引的话，就不用每次全表扫描SC表了，而是根据Sno值通过索引找到相应的SC元组。用索引查询SC中满足条件的元组一般会比全表扫描快。若在等值连接中把目标列中重复的属性列去掉则为自然连接</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130953792.png" alt="image-20230613095339691"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130954478.png" alt="image-20230613095413379"></p><h5 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130955023.png" alt="image-20230613095517959"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130955269.png" alt="image-20230613095558137"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130956842.png" alt="image-20230613095641773"></p><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130957178.png" alt="image-20230613095746073"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130958669.png" alt="image-20230613095808573"></p><h5 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306130958696.png" alt="image-20230613095847549"></p><h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131139013.png" alt="image-20230613113939863"></p><h5 id="带有IN谓词的子查询"><a href="#带有IN谓词的子查询" class="headerlink" title="带有IN谓词的子查询"></a>带有IN谓词的子查询</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131139160.png" alt="image-20230613113951090"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131140804.png" alt="image-20230613114005723"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131140239.png" alt="image-20230613114020156"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131142951.png" alt="image-20230613114229877"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131142899.png" alt="image-20230613114210786"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131143439.png" alt="image-20230613114300345"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131143373.png" alt="image-20230613114309311"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131220686.png" alt="image-20230613122014549"></p><h5 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131220954.png" alt="image-20230613122059820"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131222858.png" alt="image-20230613122241730"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131223906.png" alt="image-20230613122316775"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131223298.png" alt="image-20230613122329214"></p><h5 id="带有ANY-SOME-或ALL谓词的子查询"><a href="#带有ANY-SOME-或ALL谓词的子查询" class="headerlink" title="带有ANY(SOME)或ALL谓词的子查询"></a>带有ANY(SOME)或ALL谓词的子查询</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131224360.png" alt="image-20230613122401250"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131224181.png" alt="image-20230613122425064"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131224755.png" alt="image-20230613122442637"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131225776.png" alt="image-20230613122518667"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131225536.png" alt="image-20230613122556452"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131226984.png" alt="image-20230613122612902"></p><h5 id="带有EXIST谓词的子查询"><a href="#带有EXIST谓词的子查询" class="headerlink" title="带有EXIST谓词的子查询"></a>带有EXIST谓词的子查询</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131226412.png" alt="image-20230613122640339"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131227582.png" alt="image-20230613122713457"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131227746.png" alt="image-20230613122741632"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131227894.png" alt="image-20230613122753841"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131228951.png" alt="image-20230613122822882"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131228631.png" alt="image-20230613122849515"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131229393.png" alt="image-20230613122934264"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131229842.png" alt="image-20230613122941788"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131231727.png" alt="image-20230613123151629"></p><h4 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131232194.png" alt="image-20230613123215108"></p><p>[例3.64]查询计算机科学系的学生及年龄不大于19岁的学生</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131233375.png" alt="image-20230613123301263"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131233250.png" alt="image-20230613123325168"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131233529.png" alt="image-20230613123343418"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131233817.png" alt="image-20230613123352756"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131234548.png" alt="image-20230613123404469"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131234857.png" alt="image-20230613123421759"></p><h4 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131235448.png" alt="image-20230613123513358"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131235887.png" alt="image-20230613123530765"></p><h4 id="SELECT语句的一般格式"><a href="#SELECT语句的一般格式" class="headerlink" title="SELECT语句的一般格式"></a>SELECT语句的一般格式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131236602.png" alt="image-20230613123628528"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131236338.png" alt="image-20230613123637253"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131236335.png" alt="image-20230613123645276"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131236636.png" alt="image-20230613123658546"></p><h3 id="3-5-数据跟新"><a href="#3-5-数据跟新" class="headerlink" title="3.5 数据跟新"></a>3.5 数据跟新</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>SQL的数据插入语句INSERT通常由两种形式，一种是插入一个元组，另一种是插入子查询结果。后者可以一次插入多个元组</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131356533.png" alt="image-20230613135618448"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131356313.png" alt="image-20230613135632219"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131357059.png" alt="image-20230613135750958"></p><p><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20230613135728513.png" alt="image-20230613135717690"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131358618.png" alt="image-20230613135804531"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131358514.png" alt="image-20230613135816425"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131358663.png" alt="image-20230613135836551"></p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131359898.png" alt="image-20230613135903814"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131359672.png" alt="image-20230613135911611"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131359569.png" alt="image-20230613135921504"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131359295.png" alt="image-20230613135932212"></p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131359143.png" alt="image-20230613135953052"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131359604.png" alt="image-20230613135959552"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131400265.png" alt="image-20230613140006203"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131400187.png" alt="image-20230613140025105"></p><h3 id="3-6-空值的处理"><a href="#3-6-空值的处理" class="headerlink" title="3.6 空值的处理"></a>3.6 空值的处理</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131401411.png" alt="image-20230613140117330"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131401749.png" alt="image-20230613140148670"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131402808.png" alt="image-20230613140207718"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131402521.png" alt="image-20230613140227439"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131402614.png" alt="image-20230613140242549"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131402473.png" alt="image-20230613140253411"></p><h3 id="3-7-视图"><a href="#3-7-视图" class="headerlink" title="3.7 视图"></a>3.7 视图</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131403112.png" alt="image-20230613140321011"></p><h4 id="建立视图"><a href="#建立视图" class="headerlink" title="建立视图"></a>建立视图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131403283.png" alt="image-20230613140351130"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131404025.png" alt="image-20230613140408937"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131404624.png" alt="image-20230613140433476"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131404877.png" alt="image-20230613140453753"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131405780.png" alt="image-20230613140515686"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131405301.png" alt="image-20230613140524235"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131405199.png" alt="image-20230613140541113"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131405959.png" alt="image-20230613140554859"></p><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131406486.png" alt="image-20230613140626406"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131406642.png" alt="image-20230613140633568"></p><h4 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131407490.png" alt="image-20230613140759367"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131408468.png" alt="image-20230613140835383"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131409619.png" alt="image-20230613140900533"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131409550.png" alt="image-20230613140911472"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131409556.png" alt="image-20230613140934452"></p><h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131410886.png" alt="image-20230613141000774"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131410806.png" alt="image-20230613141019720"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131410369.png" alt="image-20230613141036269"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131410430.png" alt="image-20230613141055342"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131411384.png" alt="image-20230613141133279"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131412526.png" alt="image-20230613141204418"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131412222.png" alt="image-20230613141254146"></p><h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h4><ul><li>简化用户的操作<ul><li>视图机制使用户可以将注意力集中在所关心的数据上，如果这些数据不是直接来自基本表，则可以定义视图使数据库看起来结构简单、清晰，并且可以简化用户的数据查询操作</li><li>用户做对一个虚表的简单查询，而这个虚表怎么来的，用户无须了解</li></ul></li><li>使用户能以多种角度看待同一数据</li><li>对重构数据库提供一定程度的逻辑独立性</li><li>对机密数据提供安全保护</li><li>适当利用视图可以更清晰地表达查询</li></ul><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p>看对应书</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ul><li>填空2题</li><li>4.1不考，4.2 安全性的控制、用户身份的鉴别 图4.2 安全模型</li><li>4.3存取控制机制、自主存取控制和强制存取控制、授权</li><li>4.4节之后都不考</li><li>授权在范围之内，不多，融在其他地方</li></ul><h3 id="4-2-数据库安全性控制"><a href="#4-2-数据库安全性控制" class="headerlink" title="4.2 数据库安全性控制"></a>4.2 数据库安全性控制</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131424735.png" alt="image-20230613142442640"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131426147.png" alt="image-20230613142620023"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131426193.png" alt="image-20230613142648082"></p><h4 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131427116.png" alt="image-20230613142717013"></p><p>用户身份鉴别的方法有很多种，而且在一个系统中往往是多种方法结合，以获得更强的安全性。常用的用户身份鉴别方法有以下几种：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131428500.png" alt="image-20230613142827342"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131428456.png" alt="image-20230613142836372"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131428659.png" alt="image-20230613142849583"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131429676.png" alt="image-20230613142900583"></p><h4 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131429757.png" alt="image-20230613142951641"></p><h4 id="自主存取控制方法"><a href="#自主存取控制方法" class="headerlink" title="自主存取控制方法"></a>自主存取控制方法</h4><p>SQL标准主要通过GRANT和REVOKE语句实现</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131433219.png" alt="image-20230613143344116"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131434147.png" alt="image-20230613143401999"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131434434.png" alt="image-20230613143414329"></p><h4 id="授权与收回"><a href="#授权与收回" class="headerlink" title="授权与收回"></a>授权与收回</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131434305.png" alt="image-20230613143459164"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131435107.png" alt="image-20230613143511026"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131435555.png" alt="image-20230613143517499"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131435694.png" alt="image-20230613143523628"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131435961.png" alt="image-20230613143529899"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131436382.png" alt="image-20230613143603294"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131436635.png" alt="image-20230613143619543"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131436236.png" alt="image-20230613143635168"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131436642.png" alt="image-20230613143643588"></p><p>由上面的例子可以看出，GRANT语句可以一次向一个用户授权，也可以一次向多个用户授权，还可以一次传播多个同类对象的权限，甚至一次可以完成对基本表和属性列这些不同对象的授权</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131438733.png" alt="image-20230613143832621"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131438834.png" alt="image-20230613143852759"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131439327.png" alt="image-20230613143901266"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131439170.png" alt="image-20230613143908117"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131439370.png" alt="image-20230613143929285"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131439041.png" alt="image-20230613143952975"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131440299.png" alt="image-20230613144005205"></p><p>用户可以自主地决定将数据的存取权限授予何人、决定是否也将授权的权限授予别人。因此称这样的存取控制是自主存取控制</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131443435.png" alt="image-20230613144352310"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131444170.png" alt="image-20230613144411049"></p><h4 id="数据库角色"><a href="#数据库角色" class="headerlink" title="数据库角色"></a>数据库角色</h4><p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。因此，可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过程</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131447172.png" alt="image-20230613144741104"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131447858.png" alt="image-20230613144746792"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131448274.png" alt="image-20230613144812159"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131448219.png" alt="image-20230613144821140"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131448000.png" alt="image-20230613144847914"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131448328.png" alt="image-20230613144859265"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131449975.png" alt="image-20230613144908920"></p><h4 id="强制存取控制"><a href="#强制存取控制" class="headerlink" title="强制存取控制"></a>强制存取控制</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131458859.png" alt="image-20230613145858675"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131459157.png" alt="image-20230613145913021"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131459211.png" alt="image-20230613145931064"></p><h3 id="4-3-视图机制"><a href="#4-3-视图机制" class="headerlink" title="4.3 视图机制"></a>4.3 视图机制</h3><p>还可以为不同的用户定义不同的视图，把数据对象限制在一定的范围内，也就是说，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131502909.png" alt="image-20230613150243813"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306131503312.png" alt="image-20230613150342216"></p><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>无概念，没有单独出题，在其他题里面，触发器没有</p><ul><li>5.5、5.6、5.7没有涉及</li></ul><p>看书5.1-5.4即可</p><h2 id="第六章（重点、难点）"><a href="#第六章（重点、难点）" class="headerlink" title="第六章（重点、难点）"></a>第六章（重点、难点）</h2><ul><li>运算1题（6分） 分析（12分 只有第六章） 应用（有几分判断范式等）</li><li>到第三范式就ok了，6.3.7、6.2.8不考</li><li>6.3重要，不考定义，例子要看（求闭包这些），不考证明</li><li>范式、规范化理论、公理系统、求闭包、等价充分必要条件</li><li>求最小函数依赖集不考</li></ul><h3 id="6-1-问题提出"><a href="#6-1-问题提出" class="headerlink" title="6.1 问题提出"></a>6.1 问题提出</h3><ul><li>第一范式（1NF）：每一个分量必须是不可分的数据项。满足了这个条件的关系模式就属于第一范式</li><li>数据依赖：数据依赖是一个关系内部属性与属性之间的一种约束关系。这种约束关系是通过属性间值的相等与否体现出来的数据间相关联系。它是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现</li></ul><h3 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h3><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140924937.png" alt="image-20230614092434836"></p><p>注意：函数依赖不是指关系模式R的某个或某些关系满足的约束条件，而是指R的一切关系均要满足的约束条件</p><ul><li>平凡函数依赖和非平凡函数依赖</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140926030.png" alt="image-20230614092657973"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140927166.png" alt="image-20230614092709076"></p><ul><li>完全函数依赖和部分函数依赖</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140928170.png" alt="image-20230614092825085"></p><ul><li>传递函数依赖</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140933044.png" alt="image-20230614093313981"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140934937.png" alt="image-20230614093450875"></p><h4 id="码"><a href="#码" class="headerlink" title="码"></a>码</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140936630.png" alt="image-20230614093657489"></p><p>超码也就是，将一个候选码再加上一个或几个关系里面其他的属性构成的组合</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140939860.png" alt="image-20230614093913760"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140941173.png" alt="image-20230614094122090"></p><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><ul><li>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级的关系模式的集合，这种过程就叫规范化</li></ul><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140953091.png" alt="image-20230614095325026"></p><p>看书对应部分理解定义</p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306140958090.png" alt="image-20230614095803023"></p><p>即，若R是第三范式，则每一个非主属性既不传递依赖于码，也不部分依赖于码。也就是说，如果R属于3NF，则必有R属于2NF</p><h4 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h4><p>通常认为，BCNF是修正的第三范式，有时也称为扩充的第三范式</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141005898.png" alt="image-20230614100521819"></p><p>由BCNF的定义可得结论，一个满足BCNF的关系模式有：</p><ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有主属性对每一个不包含它的码也是完全函数依赖</li><li>没有任何属性完全依赖于非码的任何一组属性</li></ul><p>由于R属于BCNF，按定义排除了任何属性对码的传递依赖和部分依赖，所以R属于第三范式</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141010068.png" alt="image-20230614101019978"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141010258.png" alt="image-20230614101042144"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141015215.png" alt="image-20230614101527075"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141016344.png" alt="image-20230614101612277"></p><h3 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a>6.3 数据依赖的公理系统</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141018248.png" alt="image-20230614101849139"></p><h4 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141021982.png" alt="image-20230614102109872"></p><p>其中XZ,YZ表示$X \cup Z$,$Y \cup Z$</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141026115.png" alt="image-20230614102608025"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141028193.png" alt="image-20230614102846107"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141027414.png" alt="image-20230614102745354"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141029008.png" alt="image-20230614102901945"></p><p>即将F中X根据Armstrong公理导出的所有函数依赖的集合</p><p><strong>引理6.2，重要方法，Y依赖X能否由F导出，直接求X关于函数依赖集F的闭包，看Y在不在其闭包里</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141030805.png" alt="image-20230614103024745"></p><p><strong>怎么求闭包？？？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141032141.png" alt="image-20230614103249072"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141032940.png" alt="image-20230614103257865"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141056778.png" alt="image-20230614105615634"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141058589.png" alt="image-20230614105839530"></p><h2 id="第七章（主要体现在应用题）"><a href="#第七章（主要体现在应用题）" class="headerlink" title="第七章（主要体现在应用题）"></a>第七章（主要体现在应用题）</h2><ul><li>选择题1个</li><li>ER图</li><li>带星号都不看，7.5、7.6不看</li></ul><h3 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h3><p>数据库设计的特点：</p><ul><li>三分技术，七分管理，十二分基础数据是数据库设计的特点之一</li><li>结构（数据）设计和行为（处理）设计相结合</li></ul><p>数据库设计方法：</p><ul><li>新奥尔良方法</li><li>基于E-R模型的设计方法</li><li>3NF的设计方法</li><li>面向对象的数据库设计方法</li><li>统一建模语言方法等</li></ul><p>数据库设计基本步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141452474.png" alt="image-20230614145201353"></p><ul><li>需求分析<ul><li>进行数据库设计首先必须准确了解与分析用户需求（包括数据与处理）。需求分析是整个设计过程的基础，是最困难和最耗费时间的一步</li></ul></li><li>概念结构设计<ul><li>概念结构设计是整个数据库设计的关键，它通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型</li></ul></li><li>逻辑结构设计<ul><li>逻辑结构设计是将概念结构转换为某个数据库管理系统所支持的数据模型，并对其进行优化</li></ul></li><li>物理结构设计<ul><li>物理结构设计是为逻辑模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）</li></ul></li><li>数据库实施</li><li>数据库运行和维护</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141500598.png" alt="image-20230614150056495"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141501257.png" alt="image-20230614150116152"></p><h3 id="7-2-需求分析"><a href="#7-2-需求分析" class="headerlink" title="7.2 需求分析"></a>7.2 需求分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141504023.png" alt="image-20230614150439935"></p><h4 id="数据字典-1"><a href="#数据字典-1" class="headerlink" title="数据字典"></a>数据字典</h4><ul><li>数据字典是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实和完善的</li><li>数据字典通常包括数据项、数据结构、数据流、数据存储和处理过程几部分。其中数据项是最小组成单位，若干个数据项可以组成一个数据结构。数据字典通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141514518.png" alt="image-20230614151415379"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141514115.png" alt="image-20230614151427020"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141514587.png" alt="image-20230614151435480"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141514433.png" alt="image-20230614151449314"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141515831.png" alt="image-20230614151513694"></p><h2 id="第九章（概念）"><a href="#第九章（概念）" class="headerlink" title="第九章（概念）"></a>第九章（概念）</h2><ul><li>填空 2分</li><li>习题要看</li></ul><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><ul><li>选择 1题、填空1题、简答1题（数据恢复）</li><li>10.6节之后不考</li></ul><h3 id="10-1-事务的基本概念"><a href="#10-1-事务的基本概念" class="headerlink" title="10.1 事务的基本概念"></a>10.1 事务的基本概念</h3><ul><li>所谓事务，是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。例如，在关系数据库中，一个事务可以是一条SQL语句、一组SQL语句或整个程序</li><li>事务和程序是两个概念。一般地讲，一个程序中包含多个事务</li><li>事务的开始与结束可以由用户显式控制。如果用户没有显式地定义事务，则由数据库管理系统按默认规定自动划分事务</li></ul><p>在SQL中，定义事务的语句一般有三条：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141539503.png" alt="image-20230614153947439"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141540491.png" alt="image-20230614154005374"></p><ul><li>事务的ACID特性<ul><li>原子性、一致性、隔离性、持续性</li><li>原子性：事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做</li><li>一致性：<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141541734.png" alt="image-20230614154133947"></li><li>隔离性：一个事务的执行不能被其他事务干扰，即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行各个事务之间不能互相干扰</li><li>持续性：也称永久性，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响</li></ul></li></ul><p>事务是恢复和并发控制的基本单位</p><p>保证事务ACID特性是事务管理的重要任务。事务ACID特性可能遭到破坏的因素有：</p><ul><li>多个事务并行运行时，不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul><p>在第一种情况，数据库管理系统必须保证多个事务的交叉运行不影响这些事务的原子性；在第二种情况下，数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响</p><p>这些就是数据库管理系统重恢复机制和并发控制机制的责任</p><h3 id="10-2-数据库恢复概述"><a href="#10-2-数据库恢复概述" class="headerlink" title="10.2 数据库恢复概述"></a>10.2 数据库恢复概述</h3><p>数据库管理系统必须具有吧数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或者完整状态）的功能，这就是数据库的恢复</p><h3 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a>10.3 故障的种类</h3><h4 id="事务内部的故障"><a href="#事务内部的故障" class="headerlink" title="事务内部的故障"></a>事务内部的故障</h4><p>事务内部的故障有的是可以通过事物程序本身发现的，有的是非预期的，不能由事务程序处理。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141551859.png" alt="image-20230614155145732"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141552017.png" alt="image-20230614155248908"></p><p><strong>事务内部更多的故障是非预期的，是不能由应用程序处理的</strong>，如运算溢出、并发事务发生死锁而被选中撤销该事物、违反了某些完整性限制而被终止等。后续的事务故障仅指这类非预期的故障</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141602180.png" alt="image-20230614160210088"></p><h4 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h4><p>系统故障是指造成系统停止运转的任何事件，使得系统要重新启动。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141605714.png" alt="image-20230614160524577"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141605850.png" alt="image-20230614160556744"></p><h4 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141607365.png" alt="image-20230614160711271"></p><h4 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141607112.png" alt="image-20230614160757037"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>各类故障对数据库的影响有两种可能性</p><ul><li>一是数据库本身被破坏</li><li>二是数据库没有被破坏，但数据可能不正确，这是由于事务的运行被非正常终止造成的</li></ul><p><strong>恢复的基本原理</strong>十分简单，一个词概括就是，<strong>冗余</strong>。这就是说，数据库中任何一部分被破坏或不正确的数据可以根据存储在系统别处的冗余数据来重建。尽管恢复的基本原理很简单，但实现技术的细节却相当复杂</p><h3 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a>10.4 恢复的实现技术</h3><p>恢复机制的两个关键问题：</p><ul><li>如何建立冗余数据</li><li>如何利用这些冗余数据实现数据库恢复</li></ul><p>建立冗余数据最常用的技术是<strong>数据转储</strong>和<strong>登记日志文件（logging）</strong>。通常在一个数据库系统中，这两种方法是一起使用的</p><h4 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141616264.png" alt="image-20230614161617152"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141616178.png" alt="image-20230614161657031"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141618908.png" alt="image-20230614161834757"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141620769.png" alt="image-20230614162025712"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141621835.png" alt="image-20230614162116739"></p><h4 id="登记日志文件"><a href="#登记日志文件" class="headerlink" title="登记日志文件"></a>登记日志文件</h4><blockquote><p>日志文件格式</p></blockquote><p>日志文件是用来记录事务对数据库更新操作的文件。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141622619.png" alt="image-20230614162232535"></p><p>对于以记录为单位的日志文件，日志文件中需要登记的内容包括：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141625193.png" alt="image-20230614162554120"></p><p>这里的每个事务的开始标记、每个事务的结束标记和每个更新操作均作为日志文件中的一个日志记录</p><p>每个日志记录的内容主要包括：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141627873.png" alt="image-20230614162712797"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141628235.png" alt="image-20230614162812161"></p><blockquote><p>日志文件的作用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141741259.png" alt="image-20230614174151092"></p><blockquote><p>登记日志文件</p></blockquote><p>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则</p><ul><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141934695.png" alt="image-20230614193439478"></p><h3 id="10-5-恢复策略"><a href="#10-5-恢复策略" class="headerlink" title="10.5 恢复策略"></a>10.5 恢复策略</h3><h5 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141938081.png" alt="image-20230614193857924"></p><h4 id="系统故障的恢复"><a href="#系统故障的恢复" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141940842.png" alt="image-20230614194034733"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141940339.png" alt="image-20230614194047215"></p><h4 id="介质故障的恢复"><a href="#介质故障的恢复" class="headerlink" title="介质故障的恢复"></a>介质故障的恢复</h4><p>发送介质故障后，磁盘上的物理数据和日志文件被破坏，这是最严重的一种故障，恢复方法是重装数据库，然后重做已完成的事务</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306141943410.png" alt="image-20230614194326239"></p><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><ul><li>选择1题、填空1题、运算6分</li><li>并行的调度</li><li>两段锁协议</li><li>11.7,11.8不看</li></ul><p>看书</p>]]></content>
    
    
    <categories>
      
      <category>大二下复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网复习</title>
    <link href="/2023/06/10/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/10/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h1><p>选择、名词解释、简答、计算、综合</p><h1 id="考试范围"><a href="#考试范围" class="headerlink" title="考试范围"></a>考试范围</h1><ul><li>1.6 网络性能指标；1.7 网络体系结构</li><li>2.3 物理层下面的几个传输媒体； 2.4信道复用技术</li><li>3.1 数据链路层的几个共同问题； 3.3 使用广播信道的数据链路层；3.4 扩展的以太网</li><li>4.1 网络层的几个概念； 4.2 IP协议； 4.3 IP层转发分组；4.5 IPv6； 4.6 路由协议； 4.8 vpn和NAT；4.9 MPLS</li><li>5.*(第五章全部)</li><li>6.1 DNS；6.3 WWW；6.6 DHCP</li><li>9.1WLAN</li></ul>]]></content>
    
    
    <categories>
      
      <category>大二下复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>湖科大计算机网络第三章</title>
    <link href="/2023/06/07/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2023/06/07/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="3-1-数据链路层概述"><a href="#3-1-数据链路层概述" class="headerlink" title="3.1 数据链路层概述"></a>3.1 数据链路层概述</h1><h2 id="链路、数据链路和帧"><a href="#链路、数据链路和帧" class="headerlink" title="链路、数据链路和帧"></a>链路、数据链路和帧</h2><ul><li>链路是指从一个节点到相邻节点的一段物理线路（有线或者无线），而<strong>中间没有任何其他的交换节点</strong></li><li>数据链路是基于链路的，当在一条链路上传送数据时，除需要链路本身，还需要一些必要的通信协议来控制这些数据的传输，把实现这些协议的硬件和软件加到链路上，就构成了数据链路</li><li>计算机中的网络适配器（俗称<strong>网卡</strong>）和其相应的<strong>软件驱动程序</strong>就实现了这些协议。<strong>一般的网络适配器都包含了物理层和数据链路层这两层的功能</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271910670.png" alt="image-20230627191024612"></p><ul><li>帧是数据链路层对等实体之间在水平方向进行<strong>逻辑</strong>通信的协议数据单元PDU</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271911525.png" alt="image-20230627191117477"></p><h1 id="3-2-数据链路层的三个重要问题"><a href="#3-2-数据链路层的三个重要问题" class="headerlink" title="3.2 数据链路层的三个重要问题"></a>3.2 数据链路层的三个重要问题</h1><h2 id="封装成帧和透明传输"><a href="#封装成帧和透明传输" class="headerlink" title="封装成帧和透明传输"></a>封装成帧和透明传输</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271914764.png" alt="image-20230627191438673"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271914179.png" alt="image-20230627191453112"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271916302.png" alt="image-20230627191600228"></p><p>接收方的数据链路层，根据帧定界符就能从一连串比特流中识别出一个个帧</p><p>然而如果在帧的数据载荷部分, 恰好出现了与帧首部和尾部中的标志字段取值相同的数据, 在不采取其他措施的情况下, 接收方的数据链路层会出现帧定界的错误</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271917025.png" alt="image-20230627191722988"></p><p>如果不解决上述问题，数据链路层就会对上层交付的协议数据单元pdu的内容有所限制, 即pdu中不能包含帧定界符, 显然这样的数据链路层没有什么应用价值。</p><p>如果能够采取措施, 使得数据链路层对上层交付的pdu的内容没有任何限制, 就好像数据链路层不存在一样, 就称其为透明传输</p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271940695.png" alt="image-20230627194037636"></p><p>发送方的数据链路层采用某种检错技术，根据帧的内容计算出一个检错码，放在帧的尾部</p><p>帧尾部用来存放检错码的字段称为帧检验序列FCS</p><p>接收方取出帧尾部的检错码，采用和发送方同样的检错技术，检测帧中是否有误码</p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><ul><li>不可靠传输服务：直接丢弃有误码的帧</li><li>可靠传输服务：通过某种机制，实现发送方发送什么，接收方最终都能正确收到<ul><li>例如，接收方的数据链路层收到有误码的帧后，就通知发送方进行重传</li></ul></li></ul><h1 id="3-2-1-封装成帧和透明传输"><a href="#3-2-1-封装成帧和透明传输" class="headerlink" title="3.2.1 封装成帧和透明传输"></a>3.2.1 封装成帧和透明传输</h1><ul><li>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧<ul><li>帧头和帧尾中包含有重要的控制信息</li><li>帧头和帧尾的作用之一就是帧定界</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271959267.png" alt="image-20230627195942179"></p><p>需要说明的是，并不是每一种数据链路层协议的帧都包含有帧定界标志</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306272003069.png" alt="image-20230627200332008"></p><p>例如这是以太网版本二的mac格式, 在其帧头和帧尾中并没有包含帧定界标志, 那么接收方又是如何从物理层交付的比特流中, 提取出一个个的以太网帧呢？</p><p>实际上以太网的数据链路层封装好MAC帧后, 将其交付给物理层, 物理层会在mac帧前面添加八字节的前导码, 然后再将比特流转换成电信号, 发送前导码中的前七个字节为前同步码, 作用是使接收方的时钟同步之后的一字节，为帧开始定界符, 表明其后面紧跟着的就是mac帧, 另外以太网还规定了帧间间隔时间为96比特的发送时间, 因此mac帧并不需要帧结束定界符</p><p>需要说明的是, 帧间间隔还有其他作用</p><ul><li><p>透明传输是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样 </p><ul><li>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306280936211.png" alt="image-20230628093558108"></li><li>在发送帧前，先扫描数据部分，每发现一个帧定界符，就在其前插入一个转义字符</li></ul></li><li>面向比特的物理链路使用比特填充的方法实现透明传输<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306280938579.png" alt="image-20230628093815518"></li><li>在发送前可以采用零比特填充法对数据部分进行扫描, 每五个连续的比特一后面就插入一个比特零, 这样就确保了帧定界在整个帧中的唯一性</li></ul></li></ul></li><li><p>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些</p></li><li><p>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU</p></li></ul><h1 id="3-2-2-差错检测"><a href="#3-2-2-差错检测" class="headerlink" title="3.2.2 差错检测"></a>3.2.2 差错检测</h1><h1 id="3-2-3（1）可靠传输-可靠传输的基本概念"><a href="#3-2-3（1）可靠传输-可靠传输的基本概念" class="headerlink" title="3.2.3（1）可靠传输-可靠传输的基本概念"></a>3.2.3（1）可靠传输-可靠传输的基本概念</h1><h1 id="3-2-3（2）-可靠传输-停止-等待协议"><a href="#3-2-3（2）-可靠传输-停止-等待协议" class="headerlink" title="3.2.3（2） 可靠传输-停止-等待协议"></a>3.2.3（2） 可靠传输-停止-等待协议</h1><h1 id="3-2-3（3）-可靠传输-回退N帧协议"><a href="#3-2-3（3）-可靠传输-回退N帧协议" class="headerlink" title="3.2.3（3） 可靠传输-回退N帧协议"></a>3.2.3（3） 可靠传输-回退N帧协议</h1><h1 id="3-2-3（4）-可靠传输-选择重传协议"><a href="#3-2-3（4）-可靠传输-选择重传协议" class="headerlink" title="3.2.3（4） 可靠传输-选择重传协议"></a>3.2.3（4） 可靠传输-选择重传协议</h1><h1 id="3-3-点对点协议PPP"><a href="#3-3-点对点协议PPP" class="headerlink" title="3.3 点对点协议PPP"></a>3.3 点对点协议PPP</h1><h1 id="3-4-共享式以太网"><a href="#3-4-共享式以太网" class="headerlink" title="3.4 共享式以太网"></a>3.4 共享式以太网</h1><h1 id="3-4-1网络适配器和MAC地址"><a href="#3-4-1网络适配器和MAC地址" class="headerlink" title="3.4.1网络适配器和MAC地址"></a>3.4.1网络适配器和MAC地址</h1><h1 id="3-4-2（1）-CSMA-CD协议的基本原理"><a href="#3-4-2（1）-CSMA-CD协议的基本原理" class="headerlink" title="3.4.2（1） CSMA_CD协议的基本原理"></a>3.4.2（1） CSMA_CD协议的基本原理</h1><h1 id="3-4-2（2）-共享式以太网的争用期、最小帧长和最大帧长"><a href="#3-4-2（2）-共享式以太网的争用期、最小帧长和最大帧长" class="headerlink" title="3.4.2（2） 共享式以太网的争用期、最小帧长和最大帧长"></a>3.4.2（2） 共享式以太网的争用期、最小帧长和最大帧长</h1><h1 id="3-4-2-（3）共享式以太网的退避算法和信道利用率"><a href="#3-4-2-（3）共享式以太网的退避算法和信道利用率" class="headerlink" title="3.4.2 （3）共享式以太网的退避算法和信道利用率"></a>3.4.2 （3）共享式以太网的退避算法和信道利用率</h1><h1 id="3-4-3-使用集线器的共享式以太网"><a href="#3-4-3-使用集线器的共享式以太网" class="headerlink" title="3.4.3 使用集线器的共享式以太网"></a>3.4.3 使用集线器的共享式以太网</h1><h1 id="3-4-4-在物理层扩展以太网"><a href="#3-4-4-在物理层扩展以太网" class="headerlink" title="3.4.4 在物理层扩展以太网"></a>3.4.4 在物理层扩展以太网</h1><h1 id="3-4-5-在数据链路层扩展以太网（1）-–-网桥的主要结构和基本工作原理"><a href="#3-4-5-在数据链路层扩展以太网（1）-–-网桥的主要结构和基本工作原理" class="headerlink" title="3.4.5 在数据链路层扩展以太网（1） – 网桥的主要结构和基本工作原理"></a>3.4.5 在数据链路层扩展以太网（1） – 网桥的主要结构和基本工作原理</h1><h1 id="3-4-5-在数据链路层扩展以太网（2）–透明网桥的自学习和转发帧的过程以及生成树协议STP"><a href="#3-4-5-在数据链路层扩展以太网（2）–透明网桥的自学习和转发帧的过程以及生成树协议STP" class="headerlink" title="3.4.5 在数据链路层扩展以太网（2）–透明网桥的自学习和转发帧的过程以及生成树协议STP"></a>3.4.5 在数据链路层扩展以太网（2）–透明网桥的自学习和转发帧的过程以及生成树协议STP</h1><h1 id="3-5-交换式以太网"><a href="#3-5-交换式以太网" class="headerlink" title="3.5 交换式以太网"></a>3.5 交换式以太网</h1><h1 id="3-5-1-以太网交换机"><a href="#3-5-1-以太网交换机" class="headerlink" title="3.5.1 以太网交换机"></a>3.5.1 以太网交换机</h1><h1 id="3-5-2-共享式以太网和交换式以太网的对比"><a href="#3-5-2-共享式以太网和交换式以太网的对比" class="headerlink" title="3.5.2 共享式以太网和交换式以太网的对比"></a>3.5.2 共享式以太网和交换式以太网的对比</h1><h1 id="3-6-以太网的MAC帧格式"><a href="#3-6-以太网的MAC帧格式" class="headerlink" title="3.6 以太网的MAC帧格式"></a>3.6 以太网的MAC帧格式</h1><h1 id="3-7-1-虚拟局域网VLAN概述"><a href="#3-7-1-虚拟局域网VLAN概述" class="headerlink" title="3.7.1 虚拟局域网VLAN概述"></a>3.7.1 虚拟局域网VLAN概述</h1><h1 id="3-7-2-虚拟局域网VLAN的实现机制"><a href="#3-7-2-虚拟局域网VLAN的实现机制" class="headerlink" title="3.7.2 虚拟局域网VLAN的实现机制"></a>3.7.2 虚拟局域网VLAN的实现机制</h1><h1 id="3-8-以太网的发展"><a href="#3-8-以太网的发展" class="headerlink" title="3.8 以太网的发展"></a>3.8 以太网的发展</h1><h1 id="3-9-1-802-11无线局域网的组成"><a href="#3-9-1-802-11无线局域网的组成" class="headerlink" title="3.9.1  802.11无线局域网的组成"></a>3.9.1  802.11无线局域网的组成</h1><h1 id="3-9-2-802-11无线局域网的物理层"><a href="#3-9-2-802-11无线局域网的物理层" class="headerlink" title="3.9.2  802.11无线局域网的物理层"></a>3.9.2  802.11无线局域网的物理层</h1><h1 id="3-9-3-（1）-802-11无线局域网的数据链路层——使用CSMA-x2F-CA协议"><a href="#3-9-3-（1）-802-11无线局域网的数据链路层——使用CSMA-x2F-CA协议" class="headerlink" title="3.9.3 （1）  802.11无线局域网的数据链路层——使用CSMA&#x2F;CA协议"></a>3.9.3 （1）  802.11无线局域网的数据链路层——使用CSMA&#x2F;CA协议</h1><h1 id="3-9-3-（2）802-11无线局域网的数据链路层——CSMA-x2F-CA协议的基本工作原理"><a href="#3-9-3-（2）802-11无线局域网的数据链路层——CSMA-x2F-CA协议的基本工作原理" class="headerlink" title="3.9.3  （2）802.11无线局域网的数据链路层——CSMA&#x2F;CA协议的基本工作原理"></a>3.9.3  （2）802.11无线局域网的数据链路层——CSMA&#x2F;CA协议的基本工作原理</h1><h1 id="3-9-4-802-11无线局域网的MAC帧"><a href="#3-9-4-802-11无线局域网的MAC帧" class="headerlink" title="3.9.4 802.11无线局域网的MAC帧"></a>3.9.4 802.11无线局域网的MAC帧</h1>]]></content>
    
    
    <categories>
      
      <category>计网湖科大</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>湖科大计算机网络第二章</title>
    <link href="/2023/06/07/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2023/06/07/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h1><ul><li><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流</p></li><li><p>物理层为数据链路层屏蔽了各种传输媒体的差异, 使数据链路层只需要考虑如何完成本层的协议和服务, 而不必考虑网络具体使用的传输媒体是什么</p></li></ul><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><ul><li>导引型传输媒体<ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li></ul></li><li>非导引型传输媒体<ul><li>微波通信（2~40GHz）</li></ul></li></ul><h2 id="物理层协议的主要任务"><a href="#物理层协议的主要任务" class="headerlink" title="物理层协议的主要任务"></a>物理层协议的主要任务</h2><ul><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置</li><li>电气特性：指明在接口电缆各条线上出现的电压的范围</li><li>功能特性：指出某条线上出现的某一电平的电压表示何种意义</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序</li></ul><h1 id="2-2-物理层下面的传输媒体"><a href="#2-2-物理层下面的传输媒体" class="headerlink" title="2.2 物理层下面的传输媒体"></a>2.2 物理层下面的传输媒体</h1><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071440430.png" alt="image-20230607144051367"></p><h2 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071441026.png" alt="image-20230607144113993"></p><ul><li>基带同轴电缆（50$\Omega$）<ul><li>数字传输，过去用于局域网</li></ul></li><li>宽带同轴电缆（75$\Omega$）<ul><li>模拟传输，目前主要用于有线电视</li></ul></li></ul><p>同轴电缆价格较贵, 且布线不够灵活和方便, 随着集线器的出现，在局域网领域，双绞线取代了同轴电缆</p><h2 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071456745.png" alt="image-20230607145650699"></p><p><strong>绞合的作用:</strong></p><ul><li>抵御部分来自外界的电磁波干扰</li><li>减少相邻导线的电磁干扰</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071458622.png" alt="image-20230607145808585"></p><h2 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071500090.png" alt="image-20230607150009052"></p><ul><li><p>纤芯直径</p><ul><li>多模光纤：50微米，62.5微米</li><li>单模光纤：9微米</li></ul></li><li><p>包层直径：125微米</p></li><li><p>工作波长</p><ul><li>0.85微米（衰减较大）</li><li>1.30微米（衰减较小）</li></ul></li><li><p>光纤的优点</p><ul><li>通信信容量非常大</li><li>传输损耗小, 在远距离传输时更加经济</li><li>抗雷电和电磁干扰性能好, 这在有大电流脉冲干扰的环境下尤为重要, </li><li>无串音干扰, 保密性好, 不易被窃听</li><li>体积小, 重量轻</li></ul></li><li><p>光纤的缺点</p><ul><li>割接需要专用的设备</li><li>光电接口价格较贵</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071506460.png" alt="image-20230607150606404"></p><ul><li>光在纤芯中传输的方式是不断地全反射</li><li>当入射角大于某一临界角度后就可以产生全反射，因此可以存在很多不同入射角度的光纤在一条光纤中进行传输，这种光纤称为多模光纤</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071554946.png" alt="image-20230607155443862"></p><ul><li>由于色散，光在多模光纤中传输一定距离后必然产生信号失真</li><li>因此，多模光纤只适合近距离传输（建筑物内）</li><li>发送光源：发光二极管；接收检测：光电二极管</li></ul><p>光纤的直径减小到只有一个光的波长, 则光纤就像一根波导那样, 它可使光线一直向前传播, 而不会产生多次反射, 这样的光纤成为单模光纤</p><p><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20230607155919585.png" alt="image-20230607155919585"></p><ul><li>没有模式色散，在1.31微米波长附加材料色散和波导色散大小相等，符号相反，两者正好抵消</li><li>单模光纤适合长距离传输且衰减小，但其制造成本高，对光源要求高</li><li>发送光源：激光发生器；接收检测：激光检波器</li></ul><h2 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071607821.png" alt="image-20230607160756763"></p><p>如果要构建家庭高性能局域网, 采用电力线作为传输媒体是不能满足要求的, 对于装修时没有进行网络布线的家庭, 可以采用这种方式, 对于一些采用独立房间进行办公的企业来说, 每间办公室的电脑数量不多, 而又不希望跨办公室进行布线, 也可以采取这种方式, 每个办公室只需根据需求在电源插座上插入一个或多个电力猫即可</p><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071611109.png" alt="image-20230607161116044"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071613808.png" alt="image-20230607161336760"></p><h2 id="红外线"><a href="#红外线" class="headerlink" title="红外线"></a>红外线</h2><ul><li>点对点无线传输</li><li>直线传输，中间不能有障碍物，传输距离短</li><li>传输速率低</li></ul><h2 id="可见光"><a href="#可见光" class="headerlink" title="可见光"></a>可见光</h2><ul><li>LIFI</li></ul><h1 id="2-3-传输方式"><a href="#2-3-传输方式" class="headerlink" title="2.3 传输方式"></a>2.3 传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><ul><li>串行传输是指数据是一个比特一个比特依次发送的, 因此在发送端和接收端之间只需要一条数据传输线路即可</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071625384.png" alt="image-20230607162557346"></p><ul><li>并行传输时是指一次发送n个比特, 而不是一个比特, 为此在发送端和接收端之间需要有n条传输线路</li><li>并行传输的优点是速度为串行传输的n倍, 但也存在一个严重的缺点，即成本高</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071627740.png" alt="image-20230607162750701"></p><p><strong>计算机网络中，数据在传输线路上的传输采用的是串行传输</strong></p><p><strong>计算机内部的数据传输常采用并行数据传输，例如cpu与内存之间通过总线进行数据传输, 常见的数据总线宽度有8位, 16位, 32位和64位</strong></p><h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071631198.png" alt="image-20230607163131155"></p><p>采用同步传输方式，数据块以稳定的比特流的形式传输, 字节之间没有间隔, 接收端在每个比特信号的中间时刻进行检测, 以判别接收到的是比特零还是比特一, 由于不同设备的时钟频率存在一定差异, 不可能做到完全相同, 在传输大量数据的过程中, 所产生的判别时刻的累积误差, 会导致接收端对比特信号的判别错位, 因此需要采取方法是收发双方的时钟保持同步</p><ul><li>实现收发双方时钟同步的方法<ul><li>外同步：在收发双方之间添加一条单独的时钟信号线</li><li>外同步：发送端将时钟同步信号编码到发送数据中一起传输（例如曼彻斯特编码）</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071636294.png" alt="image-20230607163613257"></p><p>采用异步传输方式时, 以字节为独立的传输单位, 字节之间的时间间隔不是固定的, 接收端仅在每个字节的起始处, 对字节内的比特实现同步, 为此通常要在每个字节前后分别加上起始位和结束位</p><ul><li>这里异步是指字节之间异步, 也就是字节之间的时间间隔不固定</li><li>但字节中的每个比特仍然要同步, 也就是各比特的持续时间是相同的</li></ul><h2 id="单工、半双工以及全双工通信"><a href="#单工、半双工以及全双工通信" class="headerlink" title="单工、半双工以及全双工通信"></a>单工、半双工以及全双工通信</h2><ul><li><p>单向通信（单工）：通信双方只有一个数据传输方向，例如无线电广播</p></li><li><p>双向交替通信（半双工）：通信双方可以相互传输数据, 但不能同时进行, 例如对讲机采用的就是这种通信方式</p></li><li><p>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息, 例如电话采用的就是这种通信方式</p></li></ul><p>单向通信只需要一条清道, 而双向交替通信或双向同时通信则都需要两条信道, 每个方向各一条</p><h1 id="2-4-编码与调制"><a href="#2-4-编码与调制" class="headerlink" title="2.4 编码与调制"></a>2.4 编码与调制</h1><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072038735.png" alt="image-20230607203857649"></p><ul><li>码元：在使用时间域的波形表示数字信号时, 代表不同离散数值的基本波形称为码元，简单来说, 码元就是构成信号的一段波形</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072051820.png" alt="image-20230607205144776"></p><p><strong>传输媒体与信道的关系</strong></p><ul><li>传输媒体和信道不能直接划等号</li><li>对于单工传输，传输媒体中只包含一个信道，要么是发送短信，要么是接收信道</li><li>对于半双工和全双工传输，传输媒体中要包含两个信道，一个是发送信道，另一个是接收信道，如果使用信道复用技术，一条传输媒体还可以包含多个信道</li></ul><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><blockquote><p>不归零编码</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072101708.png" alt="image-20230607210138666"></p><p>正电平表示比特一, 负电平表示比特零，所谓不归零，就是指在整个码元时间内，电平不会出现零电平</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072101802.png" alt="image-20230607210109751"></p><p><strong>如何判断出这是两个码元, 而这是三个码元</strong></p><ul><li>这需要发送方的发送与接收方的接收做到严格的同步, 这就需要额外一根传输线来传输时钟信号</li><li>接收方按时钟信号的节拍来逐个接收码元, 然而对于计算机网络, 宁愿利用这个传输线来传输数据信号, 而不是传输时钟信号</li><li>因此由于不归零编码存在同步问题, 计算机网络中的数据传输不采用这类编码</li></ul><blockquote><p>归零编码</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072109611.png" alt="image-20230607210943554"></p><ul><li><p>很明显每个码元传输结束后, 信号都要归零, 所以接收方只要在信号归零后进行采样即可, 不需要单独的时钟信号</p></li><li><p>实际上归零编码相当于把时钟信号用归零方式编码在了数据之内, 这称为自同步信号, 但是归零编码中大部分的数据带宽都用来传输归零而浪费掉了</p></li><li><p>也就是说归零编码的优点是自同步, 但缺点是编码效率低</p></li></ul><blockquote><p>曼彻斯特编码</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072116683.png" alt="image-20230607211610610"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072111123.png" alt="image-20230607211133074"></p><ul><li>在每个码元时间的中间时刻, 信号都会发生跳变</li><li>例如负跳变表示比特一正跳变表示比特零</li><li>码元中间时刻的跳变, 既表示时钟, 又表示数据</li><li>传统以太网使用的就是曼彻斯特编码</li></ul><blockquote><p>差分曼彻斯特编码</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072113205.png" alt="image-20230607211338147"></p><ul><li>在每个码元时间的中间时刻信号都会发生跳变</li><li>与曼彻斯特编码不同, 跳变仅表示时钟</li><li>而用码元开始处电平是否发生变化来表示数据</li></ul><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072146816.png" alt="image-20230607214658744"></p><p>解析：</p><ul><li>10BaseT以太网使用的是曼彻斯特编码</li><li>每个码元在中间时刻跳变，按此特点找出每个码元</li><li>正跳变表示1还是0，负跳变表示0或1，可自行假设</li></ul><p>正确答案为A</p><h3 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072158259.png" alt="image-20230607215843185"></p><ul><li><p>带传输的数字基带信号, 也就是来自信源的原始数字信号, 我们要使用模拟信号来传输, 因此需要将数字基带信号通过调制方法调制成可以在模拟信道中传输的模拟信号, </p></li><li><p>调幅所产生的模拟信号, 无载波输出表示比特零, 有载波输出表示比特一</p></li><li><p>调频所产生的模拟信号, 频率f1的波形表示比特零，频率f2 的波形表示比特,</p></li><li><p>调向所产生的模拟信号, 初相位0度的波形表示比特零，初相位180度的波形表示比特一</p></li></ul><p> 很明显使用基本调制方法, 一个码元只能表示或者说包含一个比特信息, 那么<strong>如何能使一个码元包含更多的比特呢</strong>, 可以采用混合调制的方法, 因为频率和相位是相关的, 也就是说频率是相位随时间的变化率, 所以一次只能调制频率和相位两个中的一个, 通常情况下, 相位和振幅可以结合起来一起调制, 称为正交振幅调制QAM</p><blockquote><p>混合调制举例——正交振幅调制QAM</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072210605.png" alt="image-20230607220649343"></p><ul><li>QAM-16<ul><li>12种相位</li><li>每种相位有1或2中振幅可选</li><li>可以调制初16种码元（波形），每种码元可以对应4个比特</li><li>码元与四个比特的对应关系采用格雷码<ul><li>任意两个相邻码元只有一个比特不同</li></ul></li></ul></li></ul><p>为什么采用格雷码？</p><p>假设a b c d e是接收端接收到的五个码元, 这五个码元原本都是表示四个比特零的, 由于传输过程中产生失真, 导致他们在星座图中并未落在理想的位置, 接收端会将码元abc解调为0000, 这是正确的, 将马原地解调为0001, 有一个错位, 将码元e且调为1111，4位全错, 这就说明每个马原与四个比特的对应关系, 不能随便定义</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306072210089.png" alt="image-20230607221037040"></p><h1 id="2-5-信道的极限容量"><a href="#2-5-信道的极限容量" class="headerlink" title="2.5 信道的极限容量"></a>2.5 信道的极限容量</h1><p> <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306092235393.png" alt="image-20230609223430503"></p><ul><li><p>一个数字信号，当它通过实际的信道后，波形会失真，失真不严重时，还能识别出它是0还是1</p></li><li><p>当失真严重时，在输出端就很难判断信号在什么时候是0，在什么时候是1，波形失去了码元之间清晰的界限，这种现象叫做码间串扰</p></li><li><p>产生失真的原因主要有</p><ul><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰传输媒体质量等</li></ul></li></ul><blockquote><p>奈氏准则（1924年）</p></blockquote><ul><li>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元的传输速率是有上限的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306092250511.png" alt="image-20230609225024443"></p><ul><li>调幅、调频、调像这三种基本调制方法，属于二元调制，只能产生两种不同的码元，也就是两种不同的基本波形，因此每个码元只能携带一比特的信息量</li><li>而混合调制属于多元调制，例如QM16可以调制出16种不同的码元，因此每个码元可以携带4bit的信息量</li></ul><p><strong>思考：只要采用更好的调制方法, 让码元可以携带更多的比特, 岂不是可以无限制的提高信息的传输速率吗？</strong></p><p>——答案是否定的。信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比, 因为信道中的噪声也会影响接收端对码元的识别, 并且噪声功率相对信号功率越大, 影响就越大</p><blockquote><p>香农公式：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率</p></blockquote><p>$$C&#x3D;W * {log}_2 (1+ \frac {S}{N})$$ </p><ul><li>C：信道的极限信息传输速率（单位：bit&#x2F;s）</li><li>W：信道带宽（单位：Hz）</li><li>S：信道内所传信号的平均功率</li><li>N：信道内高斯噪声功率</li><li>S&#x2F;N：信噪比，使用分贝（dB）作为度量单位</li><li>信噪比（dB） &#x3D; $10 * log_{10}(\frac {S}{N})$  (dB)</li></ul><p><strong>从香农公式可以看出</strong></p><ul><li>信道带宽或信道中信噪比越大, 信息的极限传输速率就越高</li><li>需要说明的是, 在实际信道上能够达到的信息传输速率, 要比该公式的极限传输速率低不少, 这是因为在实际信道中, 信号还要受到其他一些损伤, 例如各种脉冲干扰, 信号在传输中的衰减和失真等, 这些因素在香农公式中并未考虑</li></ul><blockquote><p>综合奈氏准则和香农公式来看</p></blockquote><ul><li>信道带宽一定的情况下, 根据奈氏准则和香农公式，要想提高信息的传输速率, 就必须采用多元制,（更好的调制方法）并努力提高信道中的信噪比</li><li>自从香农公式发表以后, 各种新的信号处理和调制方法就不断出现, 其目的都是为了尽可能的接近香农公式所给出的传输速率极限</li></ul><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306100853184.png" alt="image-20230610085310041"></p><ul><li>从香农公式可知, 信噪比和频率带宽都会影响信道数据传输速率</li><li>从奈氏准则可知, 调制速度也就是码元传输速度和码元所携带的比特数量, 都会影响信道数据传输速率, 而信号的传播速度不影响数据传输速率</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101312858.png" alt="image-20230610131258776"></p><ul><li>根据奈氏准则可知，该通信链路的最高码元传输速率 &#x3D; 2 * 3k &#x3D; 6k （Baud）&#x3D;6k （码元&#x2F;秒）<ul><li>为什么用的是理想低通信道的最大传输速率公式，而不是理想带桶信道的最大传输速率公式？</li><li>因为题目问的是该通信链路在理想情况下，最大的数据传输速率</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306100907767.png" alt="image-20230610090739716"></li></ul></li><li>采用4个相位，每个相位4种振幅的QAM调制技术，可以调制出4 * 4 &#x3D; 16 个不同的基本波形（码元）；采用二进制对这十六个不同的码元进行编码，需要进行4个bit（$log_216 &#x3D; 4$）。换句话说，每个码元可以携带的信息量。为4比特</li><li>综合上面两点，可知，该通信链路的最大传输速率 &#x3D; 6k（码元&#x2F;秒）* 4（比特&#x2F;码元）&#x3D;24k（比特&#x2F;秒）&#x3D;24kbs</li><li>不管题目给出的调制技术多么“牛”或对于我们而言有多陌生，这都不会影响我们解题，我们只需关心这种调制技术可以调制出多少个不同的基本波形（码元）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101319578.png" alt="image-20230610131917520"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101320995.png" alt="image-20230610132056937"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101322714.png" alt="image-20230610132237659"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101322464.png" alt="image-20230610132248411"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101323232.png" alt="image-20230610132337189"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101324351.png" alt="image-20230610132445296"></p><h1 id="2-6-信道复用技术"><a href="#2-6-信道复用技术" class="headerlink" title="2.6 信道复用技术"></a>2.6 信道复用技术</h1><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101402490.png" alt="image-20230610140250417"></p><ul><li>复用就是在一条传输媒体上同时传输多路用户的信号</li><li>当一条传输媒体的传输容量大于多条信道传输的总容量时，就可以通过复用技术，在这条传输媒体上建立多条通信信道，以便充分利用传输媒体的带宽</li><li>尽管实现信道复用会增加通信成本（需要复用器、分用器以及费用较高的大容量共享信道），但如果复用的信道数量较大，还是比较划算的</li></ul><blockquote><p> 常用的信道复用技术</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101408438.png" alt="image-20230610140827376"></p><h3 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h3><p>频分复用的所有<strong>用户</strong>同时占用<strong>不同的频带</strong>资源发送数据</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101409123.png" alt="image-20230610140947063"></p><ul><li>将传输媒体的总频带划分成多个子频带, 每个子频带作为一个通信子信道, 每对用户使用其中的一个子信道进行通信, 各子信道之间需要留出隔离频带, 以免造成子信道间的干扰</li></ul><h3 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h3><p>时分复用的所有用户<strong>在不同的时间占用同样的频带</strong>进行通信</p><p>将时间划分为一段段等长的时隙, 每一个时分复用的用户在其<strong>相应时隙内独占</strong>传输媒体的资源进行通信, 如图所示, 时分复用的各用户所对应的时隙就构成了时分复用帧即TDM帧。在使用时分复用技术进行通信的过程中, 每个时分复用的用户所占用的时隙是周期性出现的, 其周期就是TDM帧的长度<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101427599.png" alt="image-20230610142717529"></p><p><strong>注意：TDM帧实际上是一段固定长度的时间，它与数据链路层对等实体间逻辑通信的“帧”，是完全不同的概念</strong></p><h3 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h3><ul><li>波分复用就是光的频分复用FDM</li><li>根据频分复用的设计思想，可在一根光纤上<strong>同时传输多个频率, 或者说波长相近的光载波信号</strong>, 实现基于光纤的频分复用技术</li><li>目前可以在一根光纤上复用80路或更多路的光载波信号, 因此这种复用技术也称为<strong>密集波分复用DWDM</strong></li><li>铺设光缆的工程耗资巨大, 应尽量在一根光缆中放入尽可能多的光纤, 然后对每一根光纤使用密集波分复用技术<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101457698.png" alt="image-20230610145715652"></li></ul></li></ul><p>波分复用的具体实现技术非常复杂，但基本物理原理简单，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101455407.png" alt="image-20230610145517345"></p><h3 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h3><ul><li><p>码分复用，常称为码分多址(CDMA)，它是扩频通信技术的基础上发展起来的一种无线通信技术</p></li><li><p>与FDM和TDM不同，CDMA的每个用户可以在相同的时间使用相同的频带进行通信</p></li><li><p>CDMA最初用于军事通信, 这种系统发送的信号有很强的抗干扰能力, 其频谱类似于白噪声, 不易被敌人发现</p></li><li><p>随着技术的进步, CDMA设备的价格和体积都大幅度下降, 因而现在已广泛用于民用的移动通信中</p></li><li><p>CDMA将每个比特时间划分为m个更短的时间片, 称为码片, m的取值通常为64或128, 为了简单起见, 在后续的举例中, 我们假设m的取值为8</p></li><li><p>CDMA中的每个站点都被指派一个唯一的m比特码片序列</p><ul><li>某个站要发送比特1，则发送它自己的m比特码片序列</li><li>某个站要发送比特0，则发送它自己的m比特码片序列的反码</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101503307.png" alt="image-20230610150349242"></li></ul></li><li><p>如果有两个或多个站同时发送数据, 则信道中的信号就是这些站各自所发送一系列码片序列或码片序列反码的叠加, 为了从信道中分离出每个站的信号, 给每个站指派码片序列时, 必须遵循以下规则：</p><ul><li>分配给每个站的码片序列必须各不相同, 实际常采用伪随机码序列</li><li>分配给每个站的码片序列必须相互正交, 即各码片序列相应的码片向量之间的规格化内积为0</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101507294.png" alt="image-20230610150753246"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101509505.png" alt="image-20230610150901449"></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101510415.png" alt="image-20230610151001377"></p><p>该式的含义是：任何站的码片向量与其他各站码片反码的向量的规格化内积为0</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101510692.png" alt="image-20230610151051652"></p><p>该式的含义是：任何站的码片向量与该站自身码片向量的规格化内积为1</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101511681.png" alt="image-20230610151129642"></p><p>该式的含义是：任何站的码片向量与该站自身码片反码的向量的规格化内积为-1</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101512051.png" alt="image-20230610151253994"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101514683.png" alt="image-20230610151435624"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101515853.png" alt="image-20230610151521796"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101515101.png" alt="image-20230610151543052"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101516473.png" alt="image-20230610151601417"></p><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101516718.png" alt="image-20230610151648674"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306101517957.png" alt="image-20230610151736907"></p>]]></content>
    
    
    <categories>
      
      <category>计网湖科大</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>湖科大计算机网络第一章</title>
    <link href="/2023/05/29/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/05/29/%E6%B9%96%E7%A7%91%E5%A4%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h1><h2 id="网络、互联网与因特网的区别与关系"><a href="#网络、互联网与因特网的区别与关系" class="headerlink" title="网络、互联网与因特网的区别与关系"></a>网络、互联网与因特网的区别与关系</h2><ul><li><p>若干节点和链路互联形成网络</p></li><li><p>若干网络通过路由器互联形成互联网</p></li><li><p>因特网是当今世界上最大的互联网</p></li></ul><h3 id="intnet-vs-Internet"><a href="#intnet-vs-Internet" class="headerlink" title="intnet vs Internet"></a>intnet vs Internet</h3><blockquote><p>intnet</p></blockquote><ul><li><p>通用名词</p></li><li><p>互联网</p></li><li><p>任意通信协议</p></li></ul><blockquote><p>Internet</p></blockquote><ul><li>专有名词</li><li>因特网</li><li>TCP&#x2F;IP协议族</li></ul><h2 id="因特网简介"><a href="#因特网简介" class="headerlink" title="因特网简介"></a>因特网简介</h2><h3 id="因特网发展三个阶段"><a href="#因特网发展三个阶段" class="headerlink" title="因特网发展三个阶段"></a>因特网发展三个阶段</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292148425.png" alt="image-20230529214829332"></p><h3 id="因特网已发展为基于ISP的多层次结构的互连网络"><a href="#因特网已发展为基于ISP的多层次结构的互连网络" class="headerlink" title="因特网已发展为基于ISP的多层次结构的互连网络"></a>因特网已发展为基于ISP的多层次结构的互连网络</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292151514.png" alt="image-20230529215156452"></p><p>已经接入因特网的用户也可以成为一个ISP，只需要购买相关设备，如：调制解调器、路由器等</p><h3 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h3><ul><li>因特网标准化工作时面向公众的，其任何一个建议标准在成为因特网标准之前都以RFC技术文档的形式在因特网上发表</li><li>RFC的意思是请求评论，任何人都可以从因特网上免费下载RFC文档，并随时对某个RFC文档发表意见和建议</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292157751.png" alt="image-20230529215728689"></p><h3 id="因特网的管理机构"><a href="#因特网的管理机构" class="headerlink" title="因特网的管理机构"></a>因特网的管理机构</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292158161.png" alt="image-20230529215801115"></p><h3 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292159608.png" alt="image-20230529215920553"></p><p>功能上简单地将其划分为两部分：核心部分, 边缘部分</p><ul><li>因特网的边缘部分由连接在因特网上的台式电脑服务器, 笔记本电脑, 平板电脑, 智能手机, 智能手表, 网络摄像头以及网络打印机等用户设备构成, 这些用户设备常称为主机, 由用户直接使用, 为用户直接提供各式各样的网络应用</li><li>因特网的核心部分由大量异构型网络和连接这些网络的路由器构成, 因特网的核心部分为其边缘部分提供联通性和数据交换等服务, 在网络核心部分起特殊作用的是路由器, 它是一种专用计算机, 但我们不称它为主机, 路由器是实现分组交换的关键构件, 其任务是转发收到的分组, 这是网络核心部分最重要的功能</li></ul><h1 id="1-3-电路交换、分组交换和报文交换"><a href="#1-3-电路交换、分组交换和报文交换" class="headerlink" title="1.3 电路交换、分组交换和报文交换"></a>1.3 电路交换、分组交换和报文交换</h1><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电话交换机接通电话线的方式就是电路交换</p><p>使用电路交换进行通信，需要进行<strong>建立连接</strong>、<strong>通话</strong>、<strong>释放连接</strong>三个阶段</p><ul><li>建立连接, 也就是分配通信资源, 例如在使用电路交换打电话之前, 主叫方必须首先进行拨号, 以请求建立连接, 当被叫方听到电话交换机送来的振铃音, 并摘机后, 从主叫方到被叫方就建立了一条专用的物理通路, 简称为连接, 这条连接为通话双方提供了通信资源,</li><li>主叫方和被叫方现在可以基于已建立的连接进行通话了, 在整个通话期间, 通话双方始终占用着连接, 通信资源, 不会被其他用户占用, </li><li>通话完毕, 挂机后从主叫方到被叫方的这条专用物理通路被交换机释放, 将双方所占用的通信资源归还给电信网</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292205193.png" alt="image-20230529220527126"></p><p><strong>计算机间的数据传输适合电路交换吗？</strong></p><p>计算机之间的数据传送是突发式的, 当使用电路交换来传送计算机数据时, 其线路的传输效率一般都会很低, 线路上真正用来传送数据的时间往往不到10%甚至1%，因此计算机网络通常采用分组交换(也就是说建立连接和释放连接的时间占了大头，效率太低)</p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292213721.png" alt="image-20230529221352661"></p><p>路由器R1到R5 就是分组交换网中的交换节点</p><p>主机H1到H5 , 通过分组交换网进行通信</p><p>假设主机H1的用户要给主机H3 的用户发送一条消息, 通常我们把表示消息的整块数据称为一个报文, 较长的报文, 一般不适宜直接传输, 如果报文太长, 则对交换节点的缓存容量有很大的需求, 在错误处理方面也会比较低效, 因此需要将较长的报文划分成若干个较小的等长数据段, 在每个数据段前面添加一些有必要的控制信息组成的首部, 这样就构造出了一个个分组</p><p><strong>思考：添加首部的作用是什么？</strong></p><p>首部起着非常关键的作用, 首部中包含了分组的目的地址, 否则分组传输路径中的各交换节点就不知道如何转发分组了, 原主机将分组发送到分组交换网中, 分组交换网中的交换节点收到一个分组后, 先将其缓存下来, 然后从其首部中提取出目的地址, 按照目的地址查找自己的转发表, 找到相应的转发接口后, 将分组转发出去, 把分组交给下一个交换节点, 经过多个交换节点的存储转发后, 分组最终被转发到目的主机</p><h3 id="分组交换实例（H1到H3）"><a href="#分组交换实例（H1到H3）" class="headerlink" title="分组交换实例（H1到H3）"></a>分组交换实例（H1到H3）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292221565.png" alt="image-20230529222122484"></p><p>主机H1将分组逐个发送给与其直接相连的路由器R1 , 此时H1到R1的链路被占用, 而分组交换网中的其他链路并未被当前通信的双方占用</p><p>路由器R1对收到的分组进行存储转发, 假设R1根据分组首部中的目的地址, 查找自己的转发表的结果是下一跳为路由器R2 , 则R1转发分组给R2 </p><p>当分组正在R1与R2之间的链路上传送时, 仅占用R1与R2 这段链路, 而不会占用分组交换网中的其他资源, 路由器R2对收到的分组进行存储转发, 假设根据查表结果, 应转发给路由器R3 </p><p>路由器R3 对收到的分组进行存储转发, 将它们转发给主机H3 ,</p><p>在上述分组交换过程中：</p><ul><li>发送方所要完成的任务是构造分组和发送分组</li><li>交换节点所要完成的任务是缓存分组和转发分组, 简称为存储转发</li><li>接收方所要完成的任务是接收分组并还原成报文</li></ul><h2 id="分组交换优缺点"><a href="#分组交换优缺点" class="headerlink" title="分组交换优缺点"></a>分组交换优缺点</h2><p>优点：</p><ul><li>分组交换没有建立连接和释放连接的过程</li><li>分组传输过程中逐渐占用通信链路, 相比于采用电路交换传送突发式的计算机数据, 分组交换有较高的通信线路利用率</li><li>交换节点可以为每一个分组独立选择转发路由, 使得网络有很好的生存性</li></ul><p>缺点：</p><ul><li>分组首部带来了额外的传输开销</li><li>交换节点存储转发分组时会造成一定的时延</li><li>无法确保通信时端到端的通信资源全部可用, 在通信量较大时, 可能造成网络拥塞</li><li>分组可能出现失序和丢失等问题</li></ul><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><ul><li>报文交换是分组交换的前身</li><li>在报文交换中，报文被整个地发送, 而不是拆分成若干个分组进行发送</li><li>交换节点将报文整体接收完成后才能查找转发表, 将整个报文转发到下一个节点</li><li>因此报文交换比分组交换带来的转发时间要长很多, 需要交换节点具有的缓存空间也大很多</li></ul><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305292230608.png" alt="image-20230529223057550"></p><ul><li>假设原主机和目的主机之间有两个交换节点, 纵坐标为时间</li><li>对于电路交换通信之前, 首先要建立连接, 成功建立连接之后, 就可以使用已建立的连接进行数据传送, 数据传送结束后需要释放连接, 将双方所占用的通信资源归还给电信网, </li><li>对于报文交换无需首先建立连接, 可以随时发送报文, 通信结束后也无需释放连接, 数据传送单元为整个报文传送路径中的交换节点, 只有在完整接收到整个报文后, 才能对其进行查表转发, 将整个报文发送到下一个节点</li><li>对于分组交换可以随时发送分组, 而不需要事先建立连接, 构成原始报文的一个个分组, 依次在各交换节点上存储转发, 各交换节点在转发分组的同时, 还缓存接收到的分组</li><li>当使用电路交换时, 一旦建立连接, 中间的各交换节点就是直通形式的数据可以直达终点</li><li>当使用报文交换时, 整个报文需要在各交换节点上存储转发, 由于不限制报文的大小, 因此需要各交换节点都具有较大的缓存空间</li><li>使用分组交换时, 构成原始报文的一个个分组, 在各交换节点上存储, 转发相比报文交换减少了转发时延, 还可以避免过长的报文长时间占用链路, 同时也有利于进行差错控制</li></ul><p>综上所述</p><ul><li>若要连续传送大量的数据, 并且数据传送时间远大于建立连接的时间, 则使用电路交换可以有较高的传输效率, 然而计算机的数据传送往往是突发式的, 采用电路交换通信线路的利用率会很低</li><li>报文交换和分组交换都不需要建立连接, 即预先分配通信资源, 在传送计算机的突发数据时, 可以提高通信线路的利用率</li><li>将报文构造成若干个更小的分组, 进行分组交换, 比将整个报文进行报文交换的时延要小, 并且还可以避免太长的报文长时间占用链路, 还有利于差错控制, 同时具有更好的灵活性</li></ul><h1 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h1><h2 id="现阶段计算机网络一个较好的定义"><a href="#现阶段计算机网络一个较好的定义" class="headerlink" title="现阶段计算机网络一个较好的定义"></a>现阶段计算机网络一个较好的定义</h2><ul><li>计算机网络主要是由一些通用的可编程的硬件互联而成的, 而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号） 这些可编程的硬件能够用来传送多种不同类型的数据, 并能支持广泛的和日益增长的应用<ul><li>注意<strong>可编程的硬件</strong>，表明这种硬件一定包含有中央处理单元CPU，所以计算机网络所连接的硬件，并不限于一般的计算机，还包括智能手机、具有网络功能的传感器，以及智能家电等</li><li>计算机网络并非只是用来传送数据，而是能够基于数据传送，进而实现各种各样的应用</li></ul></li></ul><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><blockquote><p>按交换方式分类</p></blockquote><p><strong>电路交换、分组交换、报文交换</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301032129.png" alt="image-20230530103242058"></p><blockquote><p>按使用者分类</p></blockquote><ul><li>公用网：通常是由电信公司出资建造的大型网络, 公众只要按照电信公司的规定缴纳费用, 就可以使用这种网络</li><li>专用网：由某个部门为满足本单位特殊业务的需要而建造的网络, 例如军队铁路, 电力银行等部门的专用网, 这种网络不向本单位以外的人提供服务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301033944.png" alt="image-20230530103324878"></p><blockquote><p>按传输介质分类</p></blockquote><ul><li>有线网络：包括双绞线网络、光纤网络</li><li>无线网络：WiFi</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301034981.png" alt="image-20230530103440932"></p><blockquote><p>按覆盖范围分类</p></blockquote><ul><li>广域网（WAN）：几十到几千千米，可以覆盖一个国家地区, 甚至横跨几个洲，是因特网的核心部分，为因特网核心路由器提供远距离高速连接</li><li>城域网（MAN）：5到50千米，可以跨越几个街区, 甚至整个城市, 城域网通常作为城市骨干网, 互联大量机构企业以及校园局域网</li><li>局域网（LAN）：1千米左右，例如一个学生宿舍, 一栋楼或一个校园。局域网通常由微型计算机或工作站, 通过速率为十兆比特每秒以上的高速电路相连, 在过去一个企业或学校往往只拥有一个局域网, 而现在局域网已被广泛的应用, 一个企业或学校可能就会有多个互联的局域网, 这样的网络常称为校园网或企业网</li><li>个域网（PAN）：10米，把属于个人使用的笔记本电脑, 键盘, 鼠标, 耳机以及打印机等电子设备, 用wifi或蓝牙等无线技术连接起来的网络, 因此也常称为无线个域网（WPAN）</li></ul><blockquote><p>按拓扑结构分类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301044856.png" alt="image-20230530104419797"></p><ul><li>总线型：使用单根传输线把计算机连接起来, 其优点是建网容易、增减节点方便、节省线路, 缺点是重负载时通信效率不高, 总线任意一处出现故障则全网瘫痪</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301047615.png" alt="image-20230530104751576"></p><ul><li>星型网络：每个计算机都以单独的线路与中央设备相连, 中央设备早期是计算机, 后来是集线器, 现在一般是交换机或路由器。这种网络拓扑的优点是便于网络的集中控制和管理, 缺点是成本高, 中央设备对故障敏感</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301051320.png" alt="image-20230530105151276"></p><ul><li>环型网络：所有计算机的网络接口都连接成一个环, 最典型的例子是令牌环局域网, 环可以是单环, 也可以是双环, 环中信号是单向传输的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301055549.png" alt="image-20230530105510511"></p><ul><li>网状型：每个节点至少有两条路径与其他节点相连, 多用在广域网中, 其优点是可靠性高, 缺点是控制复杂, 线路成本高</li></ul><p><strong>说明：</strong>以上四种基本的网络拓扑还可以互联为更复杂的网络</p><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><ul><li>比特（bit，记为小写b）是计算机中数据量的基本单位，一个比特就是二进制数字中的一个1或0</li><li>数据量数据上的常用单位有字节（Byte，记为大写B）, 千字节（KB）, 兆字节（MB）, 吉字节（GB），太字节（TB）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301117686.png" alt="image-20230530111737626"></p><ul><li><p>速率是指指数据的传输速率（即每秒传送多少个比特）, 也称为数据率（Data Rate）或比特率（Bit Rate）</p></li><li><p>速率的基本单位是比特&#x2F;秒（bit&#x2F;s，可简记为b&#x2F;s，有时也可记为bps，即bit per second）。速率的常用单位有千比特每秒（kb&#x2F;s或kbps）, 兆比特每秒（Mb&#x2F;s或Mbps）, 吉比特每秒（Gb&#x2F;s或Gbps）, 太比特每秒（Tb&#x2F;s或Tbps）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301123175.png" alt="image-20230530112313126"></p><ul><li>数据量单位中的K、M、G、T的数值分别为$2^{10}$、$2^{20}$、$2^{30}$、$2^{40}$</li><li>速率单位中的k、M、G、T的数值分别为${10}^{3}$、${10}^{6}$、${10}^{9}$、${10}^{12}$。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301139131.png" alt="image-20230530113942056"></p><blockquote><p>练习：有一个待发送的数据块，大小为100MB，网卡的发送速率为100Mbps，则网卡发送完该数据块需要多长时间？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301146953.png" alt="image-20230530114615892"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><blockquote><p>带宽在模拟信号中的意义</p></blockquote><ul><li>某个信号所包含的各种不同频率成分所占据的<strong>频率范围</strong></li><li>单位：Hz（kHz，MHz，GHz）</li></ul><blockquote><p>带宽在计算机网络中的意义</p></blockquote><ul><li><p>用来表示网络的<strong>通信线路所能传送数据的能力</strong>，即在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong></p></li><li><p>单位：b&#x2F;s （kb&#x2F;s  Mb&#x2F;s  Gb&#x2F;s  Tb&#x2F;s）</p></li></ul><p>数据传送速率&#x3D;min{主机接口速率，线路带宽，交换机或路由器接口速率}</p><p>也就是有木桶效应</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301257444.png" alt="image-20230530125730363"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><ul><li>吞吐量是指在<strong>单位时间内通过某个网络或接口的实际数据量</strong>, 吞吐量常被用于对实际网络的测量, 以便获知到底有多少数据量通过了网络</li><li>吞吐量<strong>受网络带宽的限制</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301302042.png" alt="image-20230530130256972"></p><p>假设某用户接入因特网的带宽为100Mb&#x2F;s, 该用户同时进行：观看网络视频, 浏览网页, 以及给文件服务器上传文件</p><p>这三个网络应用：播放网络视频的下载速率为20Mb&#x2F;s，访问网页的下载速率为600kb&#x2F;s，向文件服务器上传文件的上传速率1Mb&#x2F;s</p><p>则网络吞吐量就是下载速率和上传速率的总和</p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><ul><li>时延是指数据从网络的一端传送到另一端所耗费的时间, 也称为延迟或迟延, 数据可由一个或多个分组、甚至是一个比特构成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301311224.png" alt="image-20230530131139159"></p><ul><li><p>发送时延：原主机将分组发往传输线路花费的时间就叫做发送时延</p><ul><li>发送时延的计算公式为分组长度除以发送速率</li></ul></li><li><p>传播时延：代表分组的电信号在链路上传播所花费的时间就叫做传播时延</p><ul><li>传播时延的计算公式为信道长度除以信号传播速率</li></ul></li><li><p>排队时延：当分组进入路由器后, 会在路由器的输入队列中排队缓存并等待处理, 在路由器确定了分组的转发接口号, 分组会在输出队列中排队缓存, 并等待转发分组, 在路由器的输入队列和输出队列中，排队缓存所耗费的时间就是排队时延</p><ul><li>在分组从原主机传送到目的主机的过程中, 分组往往要经过多个路由器的转发, 分组在每个路由器上产生的排队时间的长短, 往往取决于网络当时的通信量和路由器的自身性能, 由于网络的通信量随时间变化很大, 各路由器的性能也可能并不完全相同, 因此排队时延一般无法用一个简单的公式进行计算, 另外当网络通信量很大时, 可能会造成路由器的队列溢出, 使分组丢失, 这相当于排队时延无穷大</li></ul></li><li><p>处理时延：路由器从自己的输入队列中取出排队缓存并等待处理的分组后, 会进行一系列处理工作, 例如检查分组的首部是否误码, 提取分组首部中的目的地址，为分组查找相应的转发接口, 以及修改分组首部中的部分内容, 例如生存时间等, 路由器对分组进行这一系列处理工作, 所耗费的时间就是处理时延</p><ul><li>与排队时延类似, 处理时间一般也无法用一个简单的公式进行计算</li></ul></li><li><p>对于本地分组经过路由器的转发传输到物理主机, 这又会耗费一个路由器的发送时延, 以及代表该分组的电信号在另一段链路上传播所耗费的传播时延</p></li></ul><p><strong>注意：</strong>为什么只有发送时延没有接收时延，因为发送和接收时同时进行的，计算时，只需计算一个就行，否则就加入了多余的时间</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301335867.png" alt="image-20230530133543794"></p><blockquote><p> 分析时延的图解方法</p></blockquote><p>主机A给主机B发送一个分组</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301341580.png" alt="image-20230530134155517"></p><p>主机A给主机B发送三个分组</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301342775.png" alt="image-20230530134249710"></p><p>主机A给主机B通过两个路由器发送四个分组</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301343795.png" alt="image-20230530134350717"></p><blockquote><p>真题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301402238.png" alt="image-20230530140218182"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301401217.png" alt="image-20230530140153150"></p><p>时延是发送时延占主导还是传播时延占主导？？？——具体情况具体分析</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301403328.png" alt="image-20230530140345275"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305301404866.png" alt="image-20230530140404808"></p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311030255.png" alt="image-20230531103003189"></p><ul><li><p>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特</p></li><li><p>链路的时延带宽积又称为以比特为单位的链路长度</p></li></ul><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><ul><li>许多时候，因特网上的信息是双向交互，我们有时很需要知道双向交互一次的时间，这就是往返时间RTT(Round-Trip Time)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311041561.png" alt="image-20230531104152484"></p><p>上图中卫星链路的时延较大，因为传播距离太长</p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>利用率分为信道利用率和网络利用率</p><ul><li>信道利用率用来表示某信道有百分之多少的时间是被利用的（有数据通过）</li><li>网络利用率是全网的信道利用率的加权平均<ul><li>根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加</li><li>因此，信道利用率并非越高越好</li><li>如果$D_0$表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D、$D_0$、和利用率U之间的关系</li></ul></li></ul><p>$$<br>D&#x3D;\frac{D_0}{1-U}<br>$$<br>根据公式画出下图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311045961.png" alt="image-20230531104546914"></p><ul><li><p>当网络利用率达到50%时，时延就要加倍</p></li><li><p>当网络的利用率超过50%时，时延急剧增大</p></li><li><p>当网络利用率接近100%时，时延就趋近于无穷大</p></li><li><p>因此，一些拥有较大主干网的ISP通常会控制他们的信道利用率不超过50%，如果超过了，就要准备扩容，增大线路的带宽</p></li><li><p>也不能是信道利用率太低，这会使宝贵的通信资源被白白浪费，应该使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在一个合理的范围内</p></li></ul><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><ul><li><p>丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率</p></li><li><p>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等</p></li><li><p>丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往不关心这个指标，因为他们通常意识不到网络丢包</p></li><li><p>分组丢失主要有两种情况：</p><ul><li>分组在传输过程中出现<strong>误码</strong>，被结点丢弃</li><li>分组到达一台队列已满的分组交换机时被丢弃，再通信量较大时就可能造成网络拥塞</li></ul></li><li><p>丢包率反映了网络的拥塞情况</p><ul><li>无拥塞时，路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%到4%</li><li>严重拥塞时路径丢包率为5%到15%</li></ul></li></ul><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h2><blockquote><p>OSI体系结构</p></blockquote><p>从下往上依次是：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311144528.png" alt="image-20230531114417433"></p><blockquote><p>TCP&#x2F;IP体系结构</p></blockquote><p>从下往上依次是网络接口层, 网际层, 运输层, 应用层, 它是事实上的国际标准</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311155303.png" alt="image-20230531115522237"></p><p>对比这两个体系结构可以看出, TCP&#x2F;IP体系结构相当于将OSI体系结构的物理层和数据链路层, 合并为了网络接口层, 并去掉了会话层和表示层, 另外由于TCP&#x2F;IP在网络层使用的协议是IP协议, IP协议的中文意思是网际协议, 因此TCP&#x2F;IP体系结构的网络层常称为网际层</p><ul><li><p>TCP&#x2F;IP体系结构的网络接口层并没有规定什么具体的内容, 这样做的目的是可以互联全世界各种不同的网络接口，因此本质上TCP&#x2F;IP体系结构只有上面的三层</p></li><li><p>IP协议是TCP&#x2F;IP体系结构网基层的核心协议，IP协议可以将不同的网络接口进行互联, 并向其上的TCP协议和UDP协议提供网络互联服务</p></li><li><p>TCP和UDP是TCP&#x2F;IP体系结构运输层的两个重要协议,TCP协议在享受IP协议提供的网络互联服务的基础上, 可向应用层的相应协议提供可靠传输的服务, UDP协议在享受IP协议提供的网络互联服务的基础上, 可向应用层的相应协议提供不可靠传输的服务</p></li><li><p>TCP&#x2F;IP体系结构的应用层包含了大量的应用层协议, 例如HTTP  SMTP  DNS  RTP等</p></li><li><p>IP协议作为TCP&#x2F;IP体系结构中的核心协议, 一方面负责互联不同的网络接口, 也就是ip over everything, 另一方面为各种网络应用提供服务, 也就是everything over ip, 在TCP&#x2F;IP体系结构中包含有大量的协议, IP协议和TCP协议是其中非常重要的两个协议, 因此用TCP和IP这两个协议来表示整个协议大家族，常称为TCP&#x2F;IP协议族</p></li></ul><blockquote><p>原理体系结构</p></blockquote><p>在学习计算机网络原理时, 往往采取折中的办法, 也就是综合OSI和TCP&#x2F;IP的优点, 采用一种五层协议的原理体系结构</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311210501.png" alt="image-20230531121035434"></p><h2 id="计算机网络体系结构分层的必要性"><a href="#计算机网络体系结构分层的必要性" class="headerlink" title="计算机网络体系结构分层的必要性"></a>计算机网络体系结构分层的必要性</h2><p>分层可将庞大而复杂的问题转化为若干较小的局部问题, 而这些较小的局部问题就比较容易研究和处理</p><p>下面按照由简单到复杂的顺序, 看看实现计算机网络要面临哪些主要问题, 以及如何将这些问题划分到相应的层次，层层处理</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>两台计算机通过一条网线连接起来，会遇到什么问题？</p><ul><li>采用怎样的传输媒体（介质）——常见的有双绞线</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311347830.png" alt="image-20230531134735756"></p><ul><li>采用怎样的物理接口——例如：RJ45以太网接口</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311348022.png" alt="image-20230531134836971"></p><ul><li>使用怎样的信号表示比特0和1——高电平表示1，低电平表示0</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311349142.png" alt="image-20230531134936093"></p><p><strong>说明：</strong></p><p>1.严格来说, 传输媒体并不属于物理层, 它并不包含在体系结构之中</p><p>2.计算机网络中传输的信号并不是我们举例的方波信号, 我们之所以举例成方波信号, 是为了让初学者容易理解, 在学习本身就不容易理解的概念, 抽象的计算机网络体系结构时, 不让其他技术细节再给大家造成学习障碍</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311358635.png" alt="image-20230531135859575"></p><p>主机A B C D E通过总线互联构成了一个总线型网络，会遇到什么问题？</p><ul><li>如何标识网络中的各主机（主机遍址问题，例如MAC地址）</li><li>目的主机如何从信号所表示的一连串比特流中区分出地址和数据，也就是需要解决分组的封装格式问题</li><li>如何协调各主机争用总线</li></ul><p><strong>说明：</strong>这种总线型网络早已淘汰，现在常用的是使用以太网交换机, 将多台主机互联形成的交换式以太网</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311521491.png" alt="image-20230531152108401"></p><ul><li><p>如何标识各网络以及各网络中的各主机（网络和主机共同编址的问题，例如IP地址）</p></li><li><p>路由器如何转发分组，如何进行路由选择</p></li></ul><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311534802.png" alt="image-20230531153419734"></p><ul><li>如何解决进程之间基于网络的通信问题</li><li>出现传输错误，如何处理</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li>通过应用进程间的交互来完成特定的网络应用——如：支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311746660.png" alt="image-20230531174651566"></p><h2 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311918877.png" alt="image-20230531191844815"></p><ul><li>应用层构造一个HTTP请求报文，应用层将HTTP请求报文交付给运输层处理</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311918740.png" alt="image-20230531191815673"></p><ul><li>运输层给HTTP请求报文添加一个TCP首部，使之成为TCP报文段</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311917702.png" alt="image-20230531191758633"></p><ul><li>网络层给TCP报文段添加一个IP首部，使之成为IP数据报</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311917814.png" alt="image-20230531191726735"></p><ul><li>数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧。该首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收；尾部的作用是让目的主机检查所接收到的帧是否有误码</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311921238.png" alt="image-20230531192102164"></p><ul><li>物理层将帧看作比特流， 由于网络N1是以太网，因此物理层还会给该比特流签名添加前导码，其作用是让目的主机做好接收帧的准备，物理层将添加有前导码的比特流，变换成相应的信号发送到传输媒体</li></ul><h3 id="主机处理"><a href="#主机处理" class="headerlink" title="主机处理"></a>主机处理</h3><p>应用层构造一个HTTP请求报文，应用层将HTTP请求报文交付给运输层处理</p><p>运输层给HTTP请求报文添加一个TCP首部，使之成为TCP报文段</p><p>网络层给TCP报文段添加一个IP首部，使之成为IP数据报</p><p>数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧。该首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收；尾部的作用是让目的主机检查所接收到的帧是否有误码</p><p>物理层将帧看作比特流， 由于网络N1是以太网，因此物理层还会给该比特流签名添加前导码，其作用是让目的主机做好接收帧的准备，物理层将添加有前导码的比特流，变换成相应的信号发送到传输媒体 </p><h3 id="路由器转发"><a href="#路由器转发" class="headerlink" title="路由器转发"></a>路由器转发</h3><p>信号通过传输媒体到达路由器</p><p>物理层，将信号看作比特流，然后去掉前导码后，将其交付给数据链路层，这实际上交付的是帧</p><p>数据链路层将帧的首部和尾部去掉后，将其交付给网络层，这实际上交付的是IP数据报</p><p>网络层解析IP数据报的首部，从中提取出目的网络地址，然后查找自身的路由表，确定转发端口，以便进行转发</p><p>网络层将IP数据报交付给数据链路层，数据链路层给IP数据报添加一个首部和一个尾部，使之成为帧，数据链路层将帧交付给物理层</p><p>数据链路层将帧交付给物理层，物理层将帧看作是比特流，由于网络N2是以太网，因此物理层还会给该比特流前面添加前导码，物理层将添加有前导码的比特流变换成相应的信号发送到传输媒体</p><p>信号通过传输媒体到达Web服务器</p><h3 id="Web服务器处理"><a href="#Web服务器处理" class="headerlink" title="Web服务器处理"></a>Web服务器处理</h3><p>物理层将信号变为比特流，然后去掉前导码后，将其交付给数据链路层，实际上交付的是帧</p><p>数据链路层将帧的首部和尾部去掉后，将其交付给网络层，这实际上交付的是IP数据报</p><p>网络层将IP数据部的首部去掉后将其交付给运输层，这实际上交付的TCP报文段</p><p>运输层将TCP报文段的首部去掉后，将其交付给应用层，这实际上交付的是HTTP报文</p><p>应用层对HTTP报文进行解析，然后给主机发回HTTP响应报文</p><h3 id="给主机发回HTTP响应报文"><a href="#给主机发回HTTP响应报文" class="headerlink" title="给主机发回HTTP响应报文"></a>给主机发回HTTP响应报文</h3><p>HTTP响应报文需要在Web服务器层层封装，然后通过物理层变换成相应的信号</p><p>再通过传输媒体传输到路由器</p><p>路由器转发该响应报文给主机</p><p>主机通过物理层将收到的信号转换为比特流</p><p>之后，通过逐层解封，最终取出HTTP响应报文</p><h2 id="计算机网络体系结构中的专用术语"><a href="#计算机网络体系结构中的专用术语" class="headerlink" title="计算机网络体系结构中的专用术语"></a>计算机网络体系结构中的专用术语</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul><li>实体：任何可发送或接收信息的硬件或软件进程</li><li>对等实体：收发双方相同层次中的实体</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311932453.png" alt="image-20230531193243371"></p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>协议：控制两个对等实体进行逻辑通信的规则的集合</li></ul><p><strong>注意：</strong>之所以称为逻辑通信，是因为这种通信其实并不存在，它只是我们假设出来的一种通信，目的在于方便我们单独研究体系结构某一层，而不考虑其他层</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311934515.png" alt="image-20230531193403441"></p><ul><li>协议三要素：语法、语义、同步<ul><li>语法：定义所交换信息的格式（定义了所交换信息由哪些字段及何种顺序构成），没必要记住每种分组的格式，只要能看懂他们的格式说明就可以了 </li><li>语义：定义通信双方所要完成的操作</li><li>同步：定义收发双方的时序关系，<strong>注意，并不是指始终频率同步</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311942842.png" alt="image-20230531194233782"></p><p>上图：TCP采用三报文握手建立连接的过程, 要想进行运输层TCP实体间的逻辑冲进, 首先必须建立连接, 从连接建立的过程就可以看出, TCP客户端和TCP服务器之间的时序关系以及各自的状态转换, 只有双方建立连接后才能进行TCP数据传输</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><ul><li><p>协议的控制下, 两个对等实体间的逻辑通信, 使得本层能够向上一层提供服务</p><ul><li>例如物理层对等实体在物理层协议的控制下, 向数据链路层提供服务</li></ul></li><li><p>要实现本层协议, 还需要使用下面一层所提供的服务</p><ul><li>例如数据链路层对等实体享受物理层提供的服务, 并在数据链路层协议的控制下进行逻辑通信, 给网络层提供服务, 网络层对等实体享受数据链路层提供的服务, 并在网络层协议的控制下进行逻辑通信, 给运输层提供服务, 运输层对等实体享受网络层提供的服务, 并在运输层协议的控制下进行逻辑通信, 给应用层提供服务, 应用层对等实体享受运输层提供的服务, 并在应用层协议的控制下进行逻辑通信给其上层, 也就是用户提供服务</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305311948112.png" alt="image-20230531194840036"></p><ul><li><p><strong>很明显:协议是水平的，服务是垂直的</strong></p></li><li><p><strong>特别注意：实体看得见下层所提供的服务, 但并不知道实现该服务的具体协议, 换句话说, 下层的协议对上层的实体是透明的</strong></p></li><li><p>服务访问点：相邻两层的实体交换信息的逻辑接口, 用于区分不同的服务类型</p><ul><li>例如数据链路层的服务访问点，为帧的”类型“字段</li><li>网络层的服务访问点为IP数据报首部中的“协议字段”</li><li>运输层的服务访问点为“端口号”</li></ul></li><li><p>服务原语</p><ul><li>上层要使用下层所提供的服务, 必须通过与下层交换一些命令，这些命令称为服务原语</li></ul></li><li><p>协议数据单元PDU：对等层次之间传送的数据包称为该层的协议数据单元</p><ul><li>例如物理层对等实体逻辑通信的数据包称为比特流</li><li>数据链路层, 对等实体逻辑通信的数据包称为帧</li><li>网络层, 对等实体逻辑通信的数据包称为分组, 如果使用IP协议, 也称为IP数据报</li><li>运输层对等实体逻辑通信的数据包, 一般根据协议而定, 例如使用TCP协议, 则称为TCP报文段, 使用UDP协议则称为UDP用户数据报</li><li>应用层对等实体逻辑通信的数据包, 一般称为应用报文</li><li>上述各层数据包可以统称为协议数据单元，PDU</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305312002932.png" alt="image-20230531200213850"></p><ul><li><p>服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元</p></li><li><p>多个SDU可以合成一个PDU；一个SDU也可划分为几个PDU</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计网湖科大</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络自顶向下第一章</title>
    <link href="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>注：第一章是最抽象的一章，拥有大量概念和从未见过的专有名词，初次阅读看不懂没有关系，后续章节会详细展开，第一章旨在让读者构建计算机网络知识体系的框架</strong></p><h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="1-1-什么是因特网？"><a href="#1-1-什么是因特网？" class="headerlink" title="1.1 什么是因特网？"></a>1.1 什么是因特网？</h2><p>回答什么是因特网这一问题</p><p>有两种回答方式：</p><ul><li>其一，我们能够描述因特网的具体构成，即构成因特网的基本硬件和软件组件</li><li>我们能够根据为分布式应用提供服务的联网基础设施来描述因特网</li></ul><p>先从描述因特网具体构成开始：</p><h3 id="1-1-1-具体构成描述"><a href="#1-1-1-具体构成描述" class="headerlink" title="1.1.1 具体构成描述"></a>1.1.1 具体构成描述</h3><blockquote><p>端系统</p></blockquote><p>因特网是一个互联了遍及全世界的数以亿计的计算设备的网络</p><p>这些设备有传统的桌面PC、Linux工作站以及所谓的服务器</p><p>以及非传统的因特网端系统（如便携机、智能手机、平板、电视、游戏机、汽车……）</p><p>所有这些设备都称为<strong>主机</strong>或<strong>端系统</strong></p><p>端系统通过通信链路和分组交换机连接到一起</p><blockquote><p>通信链路</p></blockquote><ul><li><p>通信链路有许多类型，它们由不推塔类型的物理媒体组成，包括同轴电缆、铜线、光纤和无线电频谱</p></li><li><p>不同的链路能够以不同的速率传输数据，链路的传输速率以比特&#x2F;秒度量（bit&#x2F;s ，或bps）</p></li></ul><blockquote><p>分组交换机</p></blockquote><ul><li>分组：当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包，用计算机网络的术语来说称为分组</li></ul><p>分组通过网络发送到目的端系统，在那里被装配成初始数据</p><p>分组交换机从它的一条入通信链路接受到达的分组，并从它的一条出通信链路转发该分组</p><ul><li>两种最著名的分组交换机：路由器和链路层交换机</li></ul><p>链路层交换机通常用于接入网中，路由器通常用于网络核心中</p><ul><li>路径：从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径</li></ul><blockquote><p>因特网服务提供商（ISP）</p></blockquote><p>端系统通过ISP接入因特网</p><p>每个ISP是一个由多个分组交换机和多段通信链路构成的网络</p><p>因特网将端系统彼此互联，因为端系统提供接入的ISP也必须互联。低层的ISP通过国家的、国际的高层ISP互联起来</p><blockquote><p>协议</p></blockquote><p>端系统、分组交换机、和其他因特网部件都需要运行一系列协议，协议控制因特网中信息的接收和发送</p><p>TCP（传输控制协议）和IP（网际协议）是因特网中两个最为重要的协议</p><p>IP协议定义了在路由器和端系统之间发送和接收分组的方式</p><p>因特网的主要协议统称为TCP&#x2F;IP</p><h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><p>从为应用程序提供服务的基础设施的角度来描述因特网</p><p>这些应用程序包括电子邮件、web冲浪、即时讯息、社交网络、IP语音、流式视频、分布式游戏、对等（P2P）文件共享、因特网电视、远程注册等</p><p>这些应用程序称为分布式应用程序，因为它们设计多态相互交换数据的端系统</p><p>运行在一个端系统上的应用程序怎样才能指令因特网向运行在另一个端系统上的软件发送数据呢？</p><ul><li>与因特网相连的端系统提供了一个应用程序编程接口（API）</li><li>该API规定了运行在一个端系统上的软件请求因特网基础设施项运行在另一个端系统上的特定目的地软件交付数据的方式</li><li>因特网API是一套发送软件必须遵循的规则集合</li></ul><h3 id="1-1-3-什么是协议"><a href="#1-1-3-什么是协议" class="headerlink" title="1.1.3 什么是协议"></a>1.1.3 什么是协议</h3><p>报文的交换以及发送和接收这些报文时所采取的动作是定义一个协议的关键元素：</p><ul><li>一个协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和&#x2F;或接收一条报文或其他事件所采取的动作</li></ul><h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>端系统之所以被称为端系统是因为它们位于因特网的边缘</p><p>端系统也称主机，因为它们容纳（即运行）应用程序。</p><p>在本书中，主机&#x3D;端系统</p><p>主机有时被进一步分为两类：客户和服务器</p><ul><li>客户非正式地等同于桌面PC、移动PC和智能手机等</li><li>服务器非正式地等同于更为强大的机器，用于存储和发布Web页面、流视频、中继电子邮件等</li></ul><p>今天，大部分提供搜索结果、电子邮件、Web页面和视频的服务器都属于大型<strong>数据中心</strong>，许多数据中心都有10万台以上的服务器</p><h3 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h3><ul><li><p>接入网：将端系统连接到其<strong>边缘路由器</strong>的物理链路</p></li><li><p>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器</p></li></ul><h4 id="家庭接入：DSL、电缆、FTTH、拨号和卫星"><a href="#家庭接入：DSL、电缆、FTTH、拨号和卫星" class="headerlink" title="家庭接入：DSL、电缆、FTTH、拨号和卫星"></a>家庭接入：DSL、电缆、FTTH、拨号和卫星</h4><blockquote><p>DSL接入</p></blockquote><p>宽带住宅接入有两种最流行的类型：数字用户线（DSL）和电缆</p><p>住户通常从提供本地电话接入的本地电话公司处获得DSL因特网接入 ，因此，当使用DSL时，用户的本地电话公司也是它的ISP</p><p>每个用户的DSL调制解调器使用现有的电话线与位于本地电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）来交换数据</p><p>家庭的DSL调制解调器得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局，来自许多家庭的模拟信号在DSLAM处被转换会数字形式</p><p>家庭电话线同时承载了数据和传统的电话信号，它们编码为不同的频率：</p><ul><li>高速下行通道，位于50kHz到1MHz频段</li><li>中速上行通道，位于4kHz到50kHz频段</li><li>普通的双向电话信道，位于0到4kHz频段</li></ul><p>这种方法使单根DSL线路就像有3根单独的线路，因此一个电话呼叫和一个因特网连接能够同时共享DSL链路。</p><p>在用户一侧，一个分屏器把到达家庭的数据信号和电话信号分隔开来，并将数据信号转发给DSL调制解调器</p><p>在本地电话公司一侧，在本地中心局中，DSLAM把数据和电话信号分隔开，并将数据送往因特网中</p><p>数百甚至上千个家庭与同一个DSLAM相连</p><blockquote><p>电缆因特网接入</p></blockquote><p>电缆因特网接入，利用了有线电视公司现有的有线电视基础设施</p><p>电缆因特网接入需要特殊的调制解调器，称为电缆调制解调器，如同DSL调制解调器，电缆调制解调器通常是一个外部设备通过一个以太网端口连接到家庭PC</p><p>电缆因特网接入的一个重要特征是共享广播媒体。特别是由发送的每个分组向下行经每段链路到每个家庭，每个家庭发送的每个分组经上行信道向头端传输。</p><p>因此，如果几个用户同时经下行信道下载一个视频文件，每个用户接收视频文件的实际速率将大大地域电缆总计的下行速率</p><p>而另一方面，如果仅有很少的活跃用户进行Web冲浪，则每个用户都可以以下行速率的全部速率接收Web网页，因为用户们将很少在完全相同的时刻请求网页。</p><p>因为上行信道也是共享的，需要一个分布式多路访问协议来协调传输和避免碰撞</p><blockquote><p>光纤到户（FTTH）</p></blockquote><p>顾名思义，从本地中心局直接到家庭提供了一条光纤路径</p><h4 id="企业（和家庭）接入：以太网和WIFI"><a href="#企业（和家庭）接入：以太网和WIFI" class="headerlink" title="企业（和家庭）接入：以太网和WIFI"></a>企业（和家庭）接入：以太网和WIFI</h4><p>以太网用户使用双绞铜线与一台以太网交换机相连</p><p>使用以太网接入，用户通常以100Mbps速率接入以太网交换机，而服务器可能具有1Gbps甚至10Gbps的接入速率</p><p>在无线LAN环境中，无线用户从&#x2F;到一个接入点发送&#x2F;接收分组，该接入点与企业网连接（很肯包括有线以太网），该企业网再与有线因特网相连</p><p>一个无线LAN用户通常必须位于接入点的几十米的范围内</p><h4 id="广域无线接入：3G和LTE"><a href="#广域无线接入：3G和LTE" class="headerlink" title="广域无线接入：3G和LTE"></a>广域无线接入：3G和LTE</h4><p>智能手机等设备越来越多地用来在移动中访问互联网，这些设备应用了与移动电话相同的基础设施，通过蜂窝网提供商运营的基站来发送接收分组</p><p>与WIFI不同的是，一个用户仅需要位于基站的数万米（而不是几十米）范围内</p><h3 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h3>]]></content>
    
    
    <categories>
      
      <category>计网中科大郑烇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络自顶向下第三章</title>
    <link href="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计网中科大郑烇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库设计自学</title>
    <link href="/2023/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%AD%A6/"/>
    <url>/2023/05/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库需求与ER建模"><a href="#数据库需求与ER建模" class="headerlink" title="数据库需求与ER建模"></a>数据库需求与ER建模</h1><h2 id="ER建模基本构件"><a href="#ER建模基本构件" class="headerlink" title="ER建模基本构件"></a>ER建模基本构件</h2><ul><li><p>ER建模后得到的ER图是整个数据库的蓝图</p></li><li><p>实体和联系是ER图的两个基本构件</p></li><li><p>此次学习采用陈氏ER符号体系的修改版本</p></li></ul><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><ul><li><p>实体可以表示现实世界中的众多概念，如人、地点、对象、事件、项目等。</p></li><li><p>例如，一个零售公司的ER图可能包含顾客、商店、产品和交易额四个实体</p></li><li><p>ER图用矩形代表实体，实体名写在矩形里，同一个ER图中的不同实体应该有不同名字</p></li><li><p>每个实体包含多个<strong>实体实例&#x2F;实体成员</strong>，如实体CUSTOMER可能包含JOE,SUE,PAT等实例</p></li><li><p>实体本身需要画在ER图中，实体实例不需要表示在ER图中，会被记录到根据该ER图所创建的数据库之中</p></li></ul><h2 id="属性（唯一和非唯一）"><a href="#属性（唯一和非唯一）" class="headerlink" title="属性（唯一和非唯一）"></a>属性（唯一和非唯一）</h2><ul><li>ER图中每一个实体都有属性</li><li>实体的一个属性描述该实体的一种特征</li><li>实体属性表示每个实例需要记录的细节</li><li>例如，对实体CUSTOMER可以记录下下属性：编号、姓名、生日、性别</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211640744.png" alt="image-20230521164049678"></p><ul><li>唯一属性是指可以唯一标识实体实例的属性</li><li>通常来说，一个实体至少要有一个唯一属性</li><li>ER图中的唯一属性都带有下划线</li></ul><h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><ul><li>ER图中每个实体必须通过联系至少与一个其他实体相关联</li><li>在ER图中联系表示为一个菱形，菱形与所有参与该联系的实体进行连线</li></ul><blockquote><p>基数约束</p></blockquote><p>基数约束用于表示实体可以有多少实例与另一实体的实例存在联系</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211645368.png" alt="image-20230521164507323"></p><p>每个基数约束包含以下两个部分：</p><ul><li>最大基数——靠近实体一端的基数约束部分</li><li>最小基数&#x2F;参与——原理实体一端的基数约束部分</li></ul><p>最大基数可以是：一个（表示为”|”）或多个（表示为”-&gt;”）</p><p>最小基数可以是：可选的（表示为”0”）或强制的（表示为”|”）</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211648283.png" alt="image-20230521164809225"></p><p><strong>注意：</strong>解释ER图中联系的合理方法，是利用矩形——菱形——基数约束——矩形规则分别从相反方向分两次来考虑这个关系</p><p>例如，联系Reports To就可以解释成：</p><ul><li>一个方向：矩形（职员)——菱形（做报告）——基数约束（有且仅有一个）——矩形（部门）</li><li>另一个方向：矩形（部门）——菱形（接受报告）——基数约束（从0到多个）——矩形（职员）</li></ul><h2 id="联系类型（最大基数侧）"><a href="#联系类型（最大基数侧）" class="headerlink" title="联系类型（最大基数侧）"></a>联系类型（最大基数侧）</h2><p>不考虑最小基数，仅考虑最大基数，则联系共有以下几种情况：</p><ul><li>一对一联系（1：1）</li><li>一对多联系（1：M）</li><li>多对多联系（M：N）</li></ul><p>下图省略了最小基数</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211653508.png" alt="image-20230521165345455"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305211654558.png" alt="image-20230521165433480"></p><h2 id="联系和联系实例"><a href="#联系和联系实例" class="headerlink" title="联系和联系实例"></a>联系和联系实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305212301779.png" alt="image-20230521230110613"></p><ul><li>如图，当一个实体的实例通过联系与另一个实体的实例相关联时，一个联系实例就产生了</li><li>像实体和实体实例的情况一样，联系本身会被画进ER图，联系实例则不需要表示在ER图中，但会被记录到根据该ER图所创建的数据库中</li></ul><h2 id="联系属性"><a href="#联系属性" class="headerlink" title="联系属性"></a>联系属性</h2><p>许多情况下，多对多联系有自己的属性，这些属性就是联系属性</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305212338356.png" alt="image-20230521233807185"></p><p>图中最后一条需求表明，一个学生在不同的校园组织中可以有多个不同的职能。若将职能（Function）作为实体STUDENT的一个或多个属性，则无法知道某个职能是该学生在哪个社会组织中的职能。若将职能作为ORGANIZAATION的一个或多个属性，又无法知道某个职能是该学生在哪个社会组织中的职能，若将职能作为ORFANIZATION的一个或多个属性，又无法知道该社会组织的某职能具体由哪个学生来担任。</p><p>因此，职能属性唯一恰当的位置时作为BelongsTo联系的属性</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305212341848.png" alt="image-20230521234154719"></p><p>接下来讨论1：1联系与1：M联系是否也可以拥有属性，结合上面两个ER图给出答案，这两个图的需求如下：</p><ul><li>数据库记录学生和学院信息</li><li>对每个学生记录其姓名和唯一学号</li><li>对每个学院记录其唯一名称和位置</li><li>每个学生必须且只能加入一个学院</li><li>每个学院有多个学生</li><li>对每个学生记录其注册进入学院的日期</li></ul><p>图2-12的上半部分给出了1：M联系的属性。下半部分基于同样的需求，但将学生的注册日期作为实体STUDENT的属性StudentCollSdate，而不是作为联系Attends的属性DateStarted，由于一个学生只能加入一个学院，因此该学生加入该学院的日期可以作为STUDENT实体本身的一个属性，如本例所述，1：M联系的一个属性可转化为在该联系中最大基数为1的实体属性（本例中的STUDENT）。更一般地讲，联系属性可以转化为在该联系中最大基数为1的实体属性。</p><p><strong>因此，1：M或1：1联系的属性都不是必要的，相反，对一些M：N联系来说，属性是必要的</strong></p><h2 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h2><ul><li>复合属性是若干属性的组合</li><li>图2-14中，属性CUSTFULLNAME由两个部分组成：属性CustFName和属性CusrLName</li><li>复合属性用于表示由若干单个属性组成的属性集合拥有新含义的情况</li><li><strong>注意：</strong>CustFullName不是实体CUSTOMER的额外属性，它仅仅表示将名字和姓氏结合起来以后所得到的完整的顾客姓名</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220924232.png" alt="image-20230522092453170"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220927029.png" alt="image-20230522092746962"></p><h2 id="复合的唯一属性"><a href="#复合的唯一属性" class="headerlink" title="复合的唯一属性"></a>复合的唯一属性</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220928407.png" alt="image-20230522092809363"></p><p>图2-17中，教学楼（Building）、房间号（RoomNumebr）、座位数（Numeber of seats）、是实体CLASSROOM的三个属性，但它们都不唯一</p><p>CLASSROOM实体的需求表示如下：</p><ul><li>同一栋教学楼中可以有多个教室</li><li>可以有多个教室拥有相同的房间号（如A教学楼的111房间与B教学楼的111房间）</li><li>可以有多个监视拥有相同的座位数</li></ul><p>由于三个属性都不唯一，而教学楼和房间号两个属性的结合却是唯一，因此，这两个属性组成的复合属性可以作为唯一属性</p><h2 id="多个唯一属性（候选码）"><a href="#多个唯一属性（候选码）" class="headerlink" title="多个唯一属性（候选码）"></a>多个唯一属性（候选码）</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220935289.png" alt="image-20230522093515243"></p><ul><li>图2-18给出的实体同时拥有多个唯一属性，这里的每个唯一属性就叫做一个候选码</li><li>候选的意义在于：这些属性都可以作为构建整个数据库时主要区别属性（或称主码）的备选</li></ul><h2 id="多值属性"><a href="#多值属性" class="headerlink" title="多值属性"></a>多值属性</h2><ul><li><p>多值属性用于实体实例的统一属性可以有多个不同取值的情况</p></li><li><p>图2-20给出一个有多只属性的实体例子</p></li><li><p>表示多值属性的椭圆外画有双线</p></li><li><p>图2-20的情景：对于每个职员，需要记录若干个联系电话，某职员可能有两个联系电话，而有些职员可能有多于两个的联系电话</p></li><li><p>但如果对每个职员都记录两个联系电话，则不需要使用多值属性，只要分别使用两个单值属性就可以了</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220938059.png" alt="image-20230522093859015"></p><h2 id="派生属性"><a href="#派生属性" class="headerlink" title="派生属性"></a>派生属性</h2><ul><li>派生属性是非永久存于数据库的属性，派生属性的值可以从别的属性值或其他数据（如当前日期）派生出来</li><li>图2-22给出一个含派生属性的例子</li><li>派生属性用虚线的椭圆标识，属性Opening-Date作为一个常规属性会存于最终的数据库中，YearsInBuiness作为一个派生属性不会存于数据库中，而是从商店的OpeningDate及当前日期中派生出来</li><li>如果Yearbusiness是一个常规属性，其值将存于数据库中且需要人工更新，否则数据库将出现错误信息，而将YearsInBusiness作为派生属性后，就可以确保数据库以后将属性作为一个公式，用于得到正确的当前YearsInBusiness的属性值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305220956559.png" alt="image-20230522095637513"></p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><ul><li>对每个实例，实体的大部分属性都有相应的取值，但有的属性也可能没有取值，这些属性就是可选属性</li></ul><p>图2-24给出一个可选属性的例子，表示了如下需求：</p><ul><li>对每个职员记录其唯一的编号（employee ID）及其薪水（salary）和年终奖（annual bonus），但并非所有职员都有年终奖</li></ul><p>在属性名后加一个带括号的大写字母O来表示可选属性</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221006226.png" alt="image-20230522100607185"></p><h2 id="联系中最小基数和最大基数确切值"><a href="#联系中最小基数和最大基数确切值" class="headerlink" title="联系中最小基数和最大基数确切值"></a>联系中最小基数和最大基数确切值</h2><p>在某些情况下，联系中的最小基数和最大基数确切值时事先知道的。本学习材料中，用圆括号括起来的一对数表示最小基数和最大基数，括号内的第一个数表示最小基数，第二个数表示最大基数</p><p>图2-26所示，对于联系EnrollsIN，需求如下：</p><ul><li>每名学生必须选择最少2门最多6门课程，且一门课程要有最少5名最多40名学生</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221015156.png" alt="image-20230522101504108"></p><p>本书中，当需要用圆括号括起来的数对表示最小和最大基数时，即使它们中的一个是不确定的值，我们仍需要将两个值（最小值和最大值）都表示出来，如图2-27所示，对于联系EnrollsIN，需求如下：</p><ul><li>每名学生最多选择6门课程，也可以不选任何课程。一门课程必须要有至少5名学生，选课人数没有上限</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221024889.png" alt="image-20230522102422828"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221025030.png" alt="image-20230522102520979"></p><h2 id="一元联系和联系的角色"><a href="#一元联系和联系的角色" class="headerlink" title="一元联系和联系的角色"></a>一元联系和联系的角色</h2><ul><li><p>联系的度：表示有多少个实体参与到该联系中</p></li><li><p>度为1的联系也称为一元联系或者递归联系</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305221027353.png" alt="image-20230522102755311"></p><p>图2-28展示三个一元联系例子</p><p>例A需求：</p><ul><li>一个客户可以推荐多个客户，也可以不推荐任何客户，每个客户可以由另一个客户推荐或者没有被任何客户推荐</li></ul><p>例B需求：</p><ul><li>一个雇员可以指导许多雇员，也可以不指导任何雇员。一个雇员可以被多个雇员指导，也可也不被任何雇员指导</li></ul><p>例C需求：</p><ul><li>在一个赠送礼物活动数据库中，每个人只能向另一个人赠送礼物，每一个人也只能收到另一个人的礼物</li></ul><p>在ER图中，联系角色可以表达额外的语义信息。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能复习</title>
    <link href="/2023/05/18/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/18/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>题型： 选择题（单多选  5题）<br>            简答题  (4题）<br>            知识表示（在第二章   4题）<br>            计算题   （1题， 贝叶斯）<br>            归结证明  （2题）<br>            归结求解   （2题）</strong></p><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="智能的特性"><a href="#智能的特性" class="headerlink" title="智能的特性"></a>智能的特性</h2><ul><li><p>智能具有感知能力,感知是智能活动的必要条件</p></li><li><p>智能具有记忆和思维能力，记忆和思维是人有智能的根本原因</p><ul><li><p>三种思维模式：</p></li><li><p>逻辑思维，容易形式化</p></li><li><p>形象思维，主要依靠直觉，形式化困难</p></li><li><p>顿悟思维，具有不定期的突发性</p></li></ul></li><li><p>智能具有学习能力、自适应能力及行为能力</p></li></ul><h2 id="人工智能的定义"><a href="#人工智能的定义" class="headerlink" title="人工智能的定义"></a>人工智能的定义</h2><p>人工智能是用人工的方法在计算机上实现智能；或者是人类智能在计算机上的模拟，或者是人们使机器具有类似于人的智能</p><h2 id="人工智能的研究目标"><a href="#人工智能的研究目标" class="headerlink" title="人工智能的研究目标"></a>人工智能的研究目标</h2><p>研究人工智能主要有两条途径：</p><ul><li>一条是心理学家、生理学家们认为大脑是智能活动的物质基础，要揭示人类智能的奥秘，就必须弄清楚大脑的结构，也就是要从大脑的神经元模型着手研究，搞清大脑信息处理过程的机理，概括来说就是<strong>创立“信息处理的智能理论”作为实现人工智能的长远期研究目标</strong></li><li>第二条是计算机科学家们提出的从模拟人脑功能的角度来实现人工智能，也就是将通过计算机程序的运行，从效果上达到和人类智能行为活动过程相类似作为研究目标，概括来说就是<strong>解决智能机器或系统为工程目标的有关原理和技术作为实现人工智能的近期目标</strong></li></ul><h2 id="人工智能的发展简史（孕育期、形成期、发展期的重要事件）"><a href="#人工智能的发展简史（孕育期、形成期、发展期的重要事件）" class="headerlink" title="人工智能的发展简史（孕育期、形成期、发展期的重要事件）"></a>人工智能的发展简史（孕育期、形成期、发展期的重要事件）</h2><p>从历史发展来看，大致分为孕育时期、形成时期及发展时期3个阶段</p><blockquote><p>孕育时期（1956年前）</p></blockquote><ul><li><strong>亚里士多德的三段论</strong></li><li><strong>英国哲学家培根提出归纳法</strong></li><li>莱布尼茨加法器</li><li><strong>布尔命题逻辑</strong></li><li>弗雷治提出用机械推理的符号表示系统从而发明谓词逻辑</li><li>20世纪30年代和40年代智能界发现两件重要事情：数理逻辑和关于计算的新思想</li><li>1946年第一台电子数字计算机ENIAC</li></ul><blockquote><p>形成时期（1956-1969）</p></blockquote><ul><li><strong>1956年举行人类历史上第一次人工智能的研讨会，正式采用“人工智能”专业术语，标志着人工智能学科的诞生</strong></li><li>编制出一个称为逻辑理论机的属性定理证明程序</li><li>模式识别程序</li><li>香农等人研制出通用问题求解程序GPS</li><li><strong>1965年鲁滨逊提出了归结原理</strong></li><li><strong>1969年成立的国际人工智能联合会议是人工智能史上一个重要的里程碑</strong></li></ul><blockquote><p>发展时期（1970年以后）</p></blockquote><p>遇到挫折</p><ul><li>1970年第一个专家系统</li><li>从20世纪80年代中期开始，有关人工神经元网络的研究取得了突破性进展</li></ul><h2 id="人工智能的研究方法（三大学派）"><a href="#人工智能的研究方法（三大学派）" class="headerlink" title="人工智能的研究方法（三大学派）"></a>人工智能的研究方法（三大学派）</h2><ul><li>符号主义学派</li><li>行为主义学派</li><li>联结主义学派</li></ul><h2 id="人工智能的研究内容（知识表示、机器感知、机器思维、机器学习、机器行为）"><a href="#人工智能的研究内容（知识表示、机器感知、机器思维、机器学习、机器行为）" class="headerlink" title="人工智能的研究内容（知识表示、机器感知、机器思维、机器学习、机器行为）"></a>人工智能的研究内容（知识表示、机器感知、机器思维、机器学习、机器行为）</h2><ul><li><strong>知识表示</strong>：就是将人类知识形式化或模型化，即对知识的一种描述，或者说是一组约定，一种计算机可以接受的用于描述知识的数据结构<ul><li>知识表示方法：符号表示法和连接机制表示法</li></ul></li><li><strong>机器感知：</strong>就是机器具有类似人的感知能力，以机器视觉和机器听觉为主</li><li><strong>机器思维：</strong>是指通过对感知得来的外部信息及机器内部的各种工作信息进行有目的的处理，机器思维是人工智能研究中<strong>最重要、最关键</strong>的部分</li><li><strong>机器学习</strong>：人类具有获取新知识，学习新机器，并在实践中不断完善、改进的能力，机器学习就是让计算机具有这种能力</li><li><strong>机器行为：</strong>与人的行为能力相对应，主要是计算机的表达能力</li></ul><h2 id="人工智能的基本技术"><a href="#人工智能的基本技术" class="headerlink" title="人工智能的基本技术"></a>人工智能的基本技术</h2><ul><li>推理技术</li><li>搜索技术</li><li>归纳技术</li><li>联想技术</li></ul><h2 id="人工智能的主要研究领域"><a href="#人工智能的主要研究领域" class="headerlink" title="人工智能的主要研究领域"></a>人工智能的主要研究领域</h2><ul><li><p>专家系统：一种具有特定领域内大量知识与经验的程序系统，它应用于人工智能技术，模拟人类专家求解问题的思维过程求解领域内的各种问题</p></li><li><p>模式识别</p></li><li><p>机器人学</p></li><li><p>自动定理证明</p></li><li><p>自然语言理解</p></li><li><p>博弈</p></li><li><p>智能检索</p></li><li><p>自动程序设计</p></li><li><p>组合调度问题</p></li><li><p>软计算</p></li><li><p>分布式人工智能</p></li><li><p>数据挖掘</p></li></ul><h1 id="第二章-知识和知识表示"><a href="#第二章-知识和知识表示" class="headerlink" title="第二章 知识和知识表示"></a>第二章 知识和知识表示</h1><h2 id="知识的定义和特点"><a href="#知识的定义和特点" class="headerlink" title="知识的定义和特点"></a>知识的定义和特点</h2><ul><li><p>知识的定义：</p><ul><li>把相关的信息关联在一起形成的信息结构称为知识</li><li>知识是人们在长期的生活及社会实践中，科学研究及试验中积累起来的对客观世界的认识与经验，人们把实践中获得的信息关联在一起，就获得了知识</li></ul></li><li><p>知识的特点：</p><ul><li>相对正确性</li><li>不确定性</li><li>可表示性</li><li>可利用性</li></ul></li></ul><h2 id="知识的分类"><a href="#知识的分类" class="headerlink" title="知识的分类"></a>知识的分类</h2><ul><li>事实性知识，描述一般性事实，比如上海有几千万人口</li><li>过程性知识，描述做某件事的过程，比如如何去救火</li><li>行为性知识，不直接给出事实本身，只给出它在某方面的行为，比如微分方程刻画了一个函数的行为，但是并没有给出这个函数本身</li><li>实例性知识，只给出一些实例，关于事物的知识隐藏在这些实例大批的观察数据里</li><li>类比性知识，只给出它与其他事物的某些相似之处，比喻，心如刀绞</li><li>元知识：有关知识的知识，如何使用知识的知识</li></ul><h2 id="知识表示的定义和分类"><a href="#知识表示的定义和分类" class="headerlink" title="知识表示的定义和分类"></a>知识表示的定义和分类</h2><ul><li><p>知识表示：知识表示方法是研究用机器表示知识的可行性、有效性的一般方法，是一种数据结构和控制结构的同一体，既考虑知识的存储又考虑知识的使用。</p></li><li><p>知识表示的分类：</p><ul><li>陈述性知识表示：主要用来表示事实性知识</li><li>过程性知识表示：主要用来描述规则性知识和控制结构知识</li></ul></li></ul><h2 id="一阶谓词表示法表示知识的方法"><a href="#一阶谓词表示法表示知识的方法" class="headerlink" title="一阶谓词表示法表示知识的方法"></a>一阶谓词表示法表示知识的方法</h2><p>知识的谓词逻辑表示：</p><ul><li>谓词逻辑的基本组成部分是谓词符号、变量符号、函数符号和常量符号，并用括号，逗号隔开表示论域的关系</li><li>一般用大写字母串表示谓词符号，小写字母串表示函数符号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061605396.png" alt="image-20230606160509256"></p><p>一阶谓词表示法的优点：</p><ul><li>严密性</li><li>自然性</li><li>通用性</li><li>知识易达性</li><li>易于实现</li></ul><p>一阶逻辑谓词表示法的缺点：</p><ul><li>效率低</li><li>灵活性差</li><li>组合爆炸</li></ul><h2 id="产生式系统的组成及推理方式"><a href="#产生式系统的组成及推理方式" class="headerlink" title="产生式系统的组成及推理方式"></a>产生式系统的组成及推理方式</h2><blockquote><p>产生式系统有哪几部分组成，分别起什么作用？推理方向可分为哪些</p></blockquote><ul><li>产生式系统由三部分组成：规则库 综合数据库 控制系统</li><li>规则库：管理和存储产生式集合</li><li>综合数据库：用于存放问题求解过程中当前信息的数据结构，如问题的初始状态、原始证据、推理中得到的中间结果及最终结论</li><li>控制系统又称为推理机，它由一组程序组成，负责整个产生式系统的运行，实现对问题的求解，它驱动和控制整个系统的运行，负责产生式规则的前件的匹配测试、规则的调度与选取、规则体的解释和执行</li><li>产生式系统的推理机按推理方向可分为：正向推理、逆向推理、双向推理（混合推理）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061627820.png" alt="image-20230606162720743"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061627375.png" alt="image-20230606162735311"></p><p>产生式表示法的优点：</p><ul><li>清晰性</li><li>模块性</li><li>自然性</li><li>有效性</li></ul><p>缺点：</p><ul><li>效率不高</li><li>不能表达结构性的知识</li></ul><h2 id="框架表示法表示知识的方法"><a href="#框架表示法表示知识的方法" class="headerlink" title="框架表示法表示知识的方法"></a>框架表示法表示知识的方法</h2><p>框架是表示某一类情景的结构化的一种数据结构，框架有描述事物的各个方面的槽组成，每个槽可有若干个侧面，一个槽用于描述所讨论对象的某一方面的属性，一个侧面用于描述相应属性的一个方面</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061633655.png" alt="image-20230606163302587"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061633422.png" alt="image-20230606163313366"></p><p>对象间的联系是通过在一个框架的某个槽值中填入另一个框架的名字来实现的常用的，用来表示对象间关系的槽名</p><p>ISA槽：is a 是一个，是一种……</p><p>AKO槽：a kind of</p><p>Instance槽：AKO槽的逆关系</p><p>Part-of槽</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061637238.png" alt="image-20230606163723166"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061637102.png" alt="image-20230606163733056"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061638279.png" alt="image-20230606163803226"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071135546.png" alt="image-20230607113503399"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071135256.png" alt="image-20230607113534179"></p><p>框架表示的优点：</p><ul><li>继承性</li><li>结构化</li><li>自然性</li></ul><p>缺点：</p><ul><li>不善于表达过程性的知识</li></ul><h2 id="语义网络表示法的概念、结构和表示知识的方法"><a href="#语义网络表示法的概念、结构和表示知识的方法" class="headerlink" title="语义网络表示法的概念、结构和表示知识的方法"></a>语义网络表示法的概念、结构和表示知识的方法</h2><ul><li>语义网络是一种通过概念及其语义联系来表示知识的有向图，结点和弧必须带有标注</li><li>语义网络一般由最基本语义单元组成，即语义基元，用三元组来表示：<strong>（结点1，弧，结点2）</strong></li><li>把多个语义基元用相应的语义联系关联在一起时，就形成了语义网络</li></ul><p><strong>基本语义联系：</strong></p><ul><li>类属关系：<ul><li>AKO(A-Kind-of)：一个事物是另一个事物的一种类型</li><li>AMO(A-Member-of)：一个事物是另一个事物的成员</li><li>ISA(Is-a)：表示一个事物是另一个事物的实例</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071148978.png" alt="image-20230607114801915"></p><ul><li>包含关系<ul><li>Part-of</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071148673.png" alt="image-20230607114831625"></p><ul><li>属性关系<ul><li>Have：一个结点具有另一个结点所描述的属性</li><li>Can：表示一个结点能做另一个结点的事情</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071149626.png" alt="image-20230607114931578"></p><ul><li>时间关系<ul><li>Before</li><li>After</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071150815.png" alt="image-20230607115027768"></p><ul><li>位置关系<ul><li>Located-on：一物体在另一物体之上</li><li>Located-at：一物体在某一位置</li><li>Located-under：一物体在另一物体之下</li><li>Located-inside：一物体在另一物体之中</li><li>Located-outside：一个物体在另一物体之外</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071154887.png" alt="image-20230607115414832"></p><ul><li>相近关系<ul><li>Similar-to：一事物与另一事物相似</li><li>Near-to：一事物与另一事物接近</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071155669.png" alt="image-20230607115530626"></p><ul><li>因果关系<ul><li>If-then：如果   那么</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071157922.png" alt="image-20230607115715869"></p><ul><li>组成关系<ul><li>Composed-of</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071158153.png" alt="image-20230607115806103"></p><blockquote><p> 事实性知识表示</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071159379.png" alt="image-20230607115907330"></p><blockquote><p> 情况的表示</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071159264.png" alt="image-20230607115945217"></p><blockquote><p> 动作的表示</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071200801.png" alt="image-20230607120026744"></p><blockquote><p>事件的表示</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071201321.png" alt="image-20230607120110264"></p><blockquote><p>合取与析取的表示</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071202926.png" alt="image-20230607120203857"></p><blockquote><p>存在量词与全称量词的表示</p></blockquote><p><strong>每个学生都学习了一门外语</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071203017.png" alt="image-20230607120344959"></p><ul><li>图中GS是一个概念结点，表示整个概念空间结点</li><li>g是一个实例结点，代表GS中的某个具体的子空间</li><li>s是一个全称变量，表示任意一个学生</li><li>r是一个存在变量表示某一次学习</li><li>p也是存在变量，表示某一门外语</li><li>s、r、p及其语义构成一个子空间，表示对每一个学生s，都存在一次学习事件r和一门外语p</li><li>弧F表示它代表的具体子空间</li><li>弧$\forall$指出s是一个全称变量，在g所代表的子空间中有多少个全称变量，就需要从g引出多少条这样的弧</li><li>在这种表示法中，子空间中的所有非全称变量的结点都是全称变量的函数，否则应该放在子空间的外面，也就是说如果说是结点是具体的某一个东西，就要放在外面，当是变量，是抽象的，就放里面</li></ul><p><strong>语义网络知识表示举例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071213577.png" alt="image-20230607121357514"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071214153.png" alt="image-20230607121408094"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071214251.png" alt="image-20230607121441192"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306071214243.png" alt="image-20230607121425186"></p><p>语义网络表示法的优点：</p><ul><li>结构性</li><li>联想性</li><li>自然性</li></ul><p>缺点：</p><ul><li><p>非严格性</p></li><li><p>处理上的复杂性</p></li></ul><p>面向对象的基本特征：</p><ul><li>模块性</li><li>继承性</li><li>封装性</li><li>多态性</li><li>易维护性</li><li>便于增量的设计</li></ul><h1 id="第三章-经典逻辑推理"><a href="#第三章-经典逻辑推理" class="headerlink" title="第三章 经典逻辑推理"></a>第三章 经典逻辑推理</h1><h2 id="推理的定义"><a href="#推理的定义" class="headerlink" title="推理的定义"></a>推理的定义</h2><ul><li>从已知事实出发，运用已掌握的知识，找出其中蕴含的事实，或归纳出新的事实，这一过程称为推理</li></ul><h2 id="确定性推理和分类"><a href="#确定性推理和分类" class="headerlink" title="确定性推理和分类"></a>确定性推理和分类</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306061644701.png" alt="image-20230606164453646"></p><h2 id="推理逻辑"><a href="#推理逻辑" class="headerlink" title="推理逻辑"></a>推理逻辑</h2><h3 id="演绎推理"><a href="#演绎推理" class="headerlink" title="演绎推理"></a>演绎推理</h3><ul><li><p>演绎推理通常是指全称判断推导出特称判断的过程，即由一般性知识推出适合于某一具体情况的结论</p></li><li><p>三段论：大前提，小前提，结论</p></li><li><p>大前提是指一般性知识或假设</p></li><li><p>小前提是指所研究的具体情况</p></li><li><p>只要大前提和小前提是正确的，那么由它们推导出来的结论就是正确的</p></li></ul><h3 id="归纳推理"><a href="#归纳推理" class="headerlink" title="归纳推理"></a>归纳推理</h3><ul><li>归纳推理是从足够多的事例中归纳出一般性结论的推理过程，是一种从个别到一般的推理</li><li>归纳推理分为：完全归纳推理和不完全归纳推理</li></ul><h3 id="类比推理"><a href="#类比推理" class="headerlink" title="类比推理"></a>类比推理</h3><ul><li>类比推理是根据两个或两类对象在某些属性上相同，推断出它们在另外的属性上也相同的一种推理</li></ul><h3 id="默认推理"><a href="#默认推理" class="headerlink" title="默认推理"></a>默认推理</h3><ul><li>默认推理又称为缺省推理，它是在知识不完全的情况下假设某些条件成立所进行的推理</li></ul><h2 id="模式匹配的定义和分类"><a href="#模式匹配的定义和分类" class="headerlink" title="模式匹配的定义和分类"></a>模式匹配的定义和分类</h2><ul><li>模式匹配是指对两个知识模式的比较与耦合，即检查这两个知识是否完全一致或近似一致</li><li>模式匹配可分为确定性匹配与不确定性匹配</li><li>确定性匹配：两个知识模式完全一致或经过模式代换后完全一致</li><li>不确定性匹配：两个知识模式不完全一致，但从整体上看，它的相似程度落在规定区间内</li></ul><h2 id="逻辑基础"><a href="#逻辑基础" class="headerlink" title="逻辑基础"></a>逻辑基础</h2><h3 id="谓词相关"><a href="#谓词相关" class="headerlink" title="谓词相关"></a>谓词相关</h3><ul><li><p>如果谓词公式P对非空个体域D上任一解释都取真值T，则称P在D上是永真的，如果P在任何非空个体域上均永真，则称P永真</p></li><li><p>如果谓词公式P对非空个体域D上至少存在一种解释，使得在此解释下取真值T，则称P在D上是可满足的</p></li><li><p>如果谓词公式P对非空个体域D上任一解释都取真值F，则称P在D上是永假的，如果P在任何非空个体域上均永假，则称P永假</p></li><li><p>前束范式</p></li></ul><p><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20230520220652414.png" alt="image-20230520220652414"></p><ul><li>Skolem范式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202208444.png" alt="image-20230520220736134"></p><h3 id="等价公式"><a href="#等价公式" class="headerlink" title="等价公式"></a>等价公式</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181606818.png" alt="image-20230518160610749"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181606323.png" alt="image-20230518160618291"></p><h3 id="永真蕴含式"><a href="#永真蕴含式" class="headerlink" title="永真蕴含式"></a>永真蕴含式</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181608797.png" alt="image-20230518160818726"></p><h3 id="代换"><a href="#代换" class="headerlink" title="代换"></a>代换</h3><p>代换可以简单理解为在一个谓词公式中用项替换变元</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181618926.png" alt="image-20230518161826867"></p><blockquote><p>例子</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181623949.png" alt="image-20230518162330903"></p><p>代换的目的是使某些变元被另外的变元、常数或者函数取代，让它不再在公式中出现</p><p>代换可以作用在谓词公式上，也可以作用在项上</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181629605.png" alt="image-20230518162941561"></p><h4 id="题型一、求代换的复合"><a href="#题型一、求代换的复合" class="headerlink" title="题型一、求代换的复合"></a>题型一、求代换的复合</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181638865.png" alt="image-20230518163858814"></p><p>生成代换时，把$t_i$$\lambda$项中$t_i$里面可用$\lambda$里面代换的代换掉</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181639941.png" alt="image-20230518163908904"></p><p>第一步生成代换，f(y)λ&#x2F;x，就在$\lambda$里找到可以代换f(y)里的，也就是b代换y，其他照写</p><h3 id="合一"><a href="#合一" class="headerlink" title="合一"></a>合一</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181710262.png" alt="image-20230518171011217"></p><blockquote><p>最一般合一</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181711051.png" alt="image-20230518171120001"></p><p>也就是说，在一个公式集里，唯一的最一般合一，对其它的任意一个合一，都可以找到一个代换，使得最一般合一和找到的代换的合成等于该合一</p><h4 id="题型二、求最一般合一"><a href="#题型二、求最一般合一" class="headerlink" title="题型二、求最一般合一"></a>题型二、求最一般合一</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181713566.png" alt="image-20230518171311514"></p><p>差异集求法</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181713134.png" alt="image-20230518171348085"></p><p>范例</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181715933.png" alt="image-20230518171510887"></p><p>判断是否可合一</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305181726600.png" alt="image-20230518172624552"></p><p>如果差异集中不存在变元，则公式集不可合一</p><p>如果差异集中变元出现在项中，则公式集不可合一</p><h2 id="冲突消解策略（P78）"><a href="#冲突消解策略（P78）" class="headerlink" title="冲突消解策略（P78）"></a>冲突消解策略（P78）</h2><p>在推理过程中，是不断将综合数据库中的知识与知识库中的知识相匹配的过程，匹配会发生冲突，比如正向推理中，多个前提条件都与已知事实匹配成功，多个已知事实与同一条规则匹配成功；逆向推理中，多条产生式的结论都与一假设匹配成功，多条产生式规则的结论与多个假设匹配成功</p><p>冲突消解策略就是发生冲突时，如何消解冲突的方法，主要任务就是选择出一对一的匹配，遵循以下原则</p><ul><li>按就近原则排序</li><li>按已知事实的新鲜性排序（后生成事实比先生成的事实具有更大的优先性）</li><li>按匹配度排序</li><li>按领域问题特点排序</li><li>按上下文限制排序</li><li>按条件个数排序</li><li>按规则的次序排序</li></ul><h2 id="自然演绎推理"><a href="#自然演绎推理" class="headerlink" title="自然演绎推理"></a>自然演绎推理</h2><blockquote><p>推理的三个规则</p></blockquote><ul><li>P规则，在推理的任何步骤上都可以引入前提</li><li>T规则，如果前面步骤中有一个或多个公式永真蕴含公式S，则可以把S引入推理过程中</li><li>CP规则，如果能从R和前提集合中推导出S，则可以从前提集合推导出R–&gt;S</li></ul><h2 id="归结演绎推理"><a href="#归结演绎推理" class="headerlink" title="归结演绎推理"></a>归结演绎推理</h2><h3 id="字句集及其化简"><a href="#字句集及其化简" class="headerlink" title="字句集及其化简"></a>字句集及其化简</h3><ul><li><p>不含有任何连接词的谓词公式称为原子谓词公式</p></li><li><p>原子谓词公式及其否定统称为文字</p></li><li><p>任何文字的析取式称为子句</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202216649.png" alt="image-20230520221629604"></p><ul><li>不包含任何文字的子句称为空子句</li></ul><p>由于空子句不含有任何文字，它不能被任何解释满足，所以空子句是永假式，是不可满足的。空子句一般记为NIL</p><ul><li>由子句或空子句构成的集合称为子句集</li></ul><p><strong>子句集怎么化简？</strong></p><p>步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202219321.png" alt="image-20230520221919262"></p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202219693.png" alt="image-20230520221955638"></p><p>重点关注：怎么消去存在量词，怎么消去全称量词</p><h3 id="Robinson归结原理（最重要）"><a href="#Robinson归结原理（最重要）" class="headerlink" title="Robinson归结原理（最重要）"></a>Robinson归结原理（最重要）</h3><h4 id="概念建立"><a href="#概念建立" class="headerlink" title="概念建立"></a>概念建立</h4><p>鲁滨孙归结原理的基本思想是：检查子句集S中是否能归结或包含空子句，若能归结出空子句，则S不可满足；若不包含空子句，则S可以满足。</p><ul><li>$P$是原子谓词公式，则成$P$和$\neg P$  为互补文字</li><li><strong>归结</strong>：设$C_1$和$C_2$是子句集中的任意两个子句，如果$C_1$的文字与$C_2$中的文字$L_2$互补，那么从$C_1$和$C_2$中分别消去$L_1$和$L_2$，并将两个子句中余下的部分析取，构成了新子句$C_{12}$，则称这一过程为归结，称$C_{12}$为$C_1$与$C_2$的归结式，称$C_1$与$C_2$为$C_{12}$的亲本子句</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081113651.png" alt="image-20230608111327546"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081114009.png" alt="image-20230608111402952"></p><p><strong>归结式是其亲本子句的逻辑结论</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081114375.png" alt="image-20230608111455303"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081115381.png" alt="image-20230608111558327"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081116351.png" alt="image-20230608111616280"></p><p><strong>以上两个推理表明：</strong>在证明子句集S的不可满足性时，只要选择子句进行归结，并将归结式加入子句集S，或者用归结式取代亲本子句，得到新的子句集$S^{‘}$若经过归结能够归结出空子句，则说明原子句集S不可满足</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081119345.png" alt="image-20230608111951268"></p><h4 id="如何求谓词逻辑中的归结式"><a href="#如何求谓词逻辑中的归结式" class="headerlink" title="如何求谓词逻辑中的归结式"></a>如何求谓词逻辑中的归结式</h4><ul><li>谓词逻辑中的归结原理：谓词逻辑中子句含有变元，需对变元进行合一和置换后才能进行归结</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081125920.png" alt="image-20230608112554851"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081126426.png" alt="image-20230608112635361"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081127685.png" alt="image-20230608112743626"></p><p><strong>归结过程中，特别注意以下问题：</strong>（一定要重点关注这些注意点）</p><ul><li>(1) 确保每个子句有不同的变元名，以免在归结的过程中产生不便或错误</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081130391.png" alt="image-20230608113001312"></p><ul><li>(2) 如果参加归结的子句内部含有可合一的文字时，则在归结之前先对这些文字进行合一</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081133724.png" alt="image-20230608113351640"></p><ul><li>(3) 在求归结式时，若两个子句中有两对可互补的文字，不能同时消去，否则会产生错误</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081135573.png" alt="image-20230608113558499"></p><h4 id="应用归结原理证明问题（重点题型）"><a href="#应用归结原理证明问题（重点题型）" class="headerlink" title="应用归结原理证明问题（重点题型）"></a>应用归结原理证明问题（重点题型）</h4><p>对于给定的一个谓词公式集F，要证明谓词公式集F能导出目标公式G</p><p>做题步骤如下：</p><ul><li>否定结论$G$，得到$\neg G$</li><li>将前提条件F和$\neg G$化为子句集S</li><li>应用归结原理，反复对子句集S进行归结，若能归结出空子句，则证明子句集S的不可满足性。从而证明了公式$F \rightarrow G$为真</li></ul><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081142135.png" alt="image-20230608114231081"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081142261.png" alt="image-20230608114241184"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081145660.png" alt="image-20230608114514573"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081145805.png" alt="image-20230608114529738"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081145162.png" alt="image-20230608114552113"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081146154.png" alt="image-20230608114604091"></p><h4 id="利用归结原理求解问题（重点定义）"><a href="#利用归结原理求解问题（重点定义）" class="headerlink" title="利用归结原理求解问题（重点定义）"></a>利用归结原理求解问题（重点定义）</h4><p>方法是定义一个新的谓词ANSWER，加到目标公式的否定中，把形成的子句加入子句集中进行归结，具体步骤如下：</p><ul><li>（1）把已知前提条件用谓词公式表示出来，并且化为子句集S</li><li>（2）把待求解的问题用谓词公式表示出来，然后将其否定，并与谓词公式ANSWER构成析取式。ANSWER是一个为了求解问题而专设的谓词，并且其变元必须与谓词公式中的变元一致</li><li>（3）把(2)中的析取式化为子句集，并且将该子句集并入到子句集$S$中。得到子句集$S^{‘}$</li><li>（4）对子句集$S^{‘}$应用归结原理进行归结</li><li>（5）若得到归结式ANSWER，则答案就在ANSWER中</li></ul><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081153424.png" alt="image-20230608115346323"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081154472.png" alt="image-20230608115408378"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081154043.png" alt="image-20230608115439929"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081155363.png" alt="image-20230608115500273"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081155170.png" alt="image-20230608115521084"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081156037.png" alt="image-20230608115612940"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081156439.png" alt="image-20230608115623371"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081156127.png" alt="image-20230608115634054"></p><h2 id="归结策略"><a href="#归结策略" class="headerlink" title="归结策略"></a>归结策略</h2><p><strong>归结策略的完备性是指：若子句集是不可满足的，则一定存在着一个从子句集到空子句的归结过程</strong></p><p>归结策略有：</p><ul><li><p>删除策略(删除子句集中一些无用的子句)</p><ul><li>纯文字删除法 <ul><li>如果某文字$L$在子句集中不存在与之互补的文字$\neg L$，则成该文字为纯文字，显然，归结时纯文字不能被删除，所以包含纯文字子句对归结式无意义的，可将它从子句集删除</li></ul></li><li>重言式删除法<ul><li>若一个谓词公式的真值永为真，则该命题为重言式或永真式。如果某个子句中同时含有互补文字对时，则称该子句为重言式（因为永真），因为子句集中子句之间的关系是合取，所以删除一个永真式，不影响子句集的不可满足性。</li></ul></li><li>包孕删除法<ul><li>设有子句$C_1$和$C_2$,如果存在一个代换$\sigma$，使得$C_1 \sigma \subseteq C_2$，则称$C_1$包孕与$C_2$，把子句集中包孕的子句$C_1$删除后，不会影响子句集的不可满足性，因而可从子句集中删除</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081210971.png" alt="image-20230608121001885"></li></ul></li></ul></li><li><p>限制策略</p><ul><li>支持集策略<ul><li>每次归结时，参加归结的子句至少有一个是由目标子句否定所得的子句或是它的后裔</li></ul></li><li>线性输入策略<ul><li>要求参加归结的两个子句中必须至少有一个是初始子句集中的子句</li><li>优点：可限制归结式的数量、方法简单、高效</li><li>缺点：不完备，子句集是不可满足时，用线性输入策略却可能无法归结出空子句</li></ul></li><li>单文字子句策略<ul><li>一个子句中只包含一个文字，称为单文字子句。单文字子句策略要求参加归结的两个子句中至少有一个是单文字子句</li><li>不完备，初始子句集中不含有单文字子句时，使用该策略的推理就无法进行下去</li></ul></li><li>祖先过滤策略<ul><li>见下文</li></ul></li></ul></li></ul><p>限制策略中，支持集策略，祖先过滤策略是完备的</p><p>支持集策略是指每个归结式，其母式子句至少有一个是目标公式的否定及其后代</p><p>祖先过滤策略是当两个子句C1和C2进行归结时，只要满足下面两个条件之一就可以进行：</p><ul><li>$C_1$和$C_2$中至少有一个是初始子句集中的子句</li><li>如果两个子句都不是初始子句集中的子句，则一个是另一个的祖先</li></ul><blockquote><p>例子</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081415281.png" alt="image-20230608141548204"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081415525.png" alt="image-20230608141555464"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081416700.png" alt="image-20230608141609646"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081416059.png" alt="image-20230608141621005"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081417607.png" alt="image-20230608141723545"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306081416620.png" alt="image-20230608141655557"></p><h1 id="第四章-不确定性推理"><a href="#第四章-不确定性推理" class="headerlink" title="第四章 不确定性推理"></a>第四章 不确定性推理</h1><h2 id="不确定性推理定义"><a href="#不确定性推理定义" class="headerlink" title="不确定性推理定义"></a>不确定性推理定义</h2><ul><li>不确定性推理是指那种建立在不确定性知识和证据的基础上的推理。它是从不确定性的初始证据出发，通过运用不确定性的知识，最终推出具有一定程度的不确定性但却是合理或者近乎合理的结论的思维过程。</li></ul><h2 id="组合证据的不确定性计算方法"><a href="#组合证据的不确定性计算方法" class="headerlink" title="组合证据的不确定性计算方法"></a>组合证据的不确定性计算方法</h2><ul><li><p>数值（E-&gt;H,f(H,E)），表示相应知识的不确定性程度，称为知识或规则的<strong>静态强度</strong>，静态强度可以是相应知识在应用中成功的概率，也可以是该条知识的可信程度或其他</p></li><li><p>(命题E，C(E))表示证据E为真的程度，证据的不确定性通常也用一个数值表示，它代表相应证据的不确定性程度，称之为<strong>动态强度</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062155948.png" alt="image-20230606215513877"></p><p><strong>注意：对f(H,E)可以理解为当前提E为真时，对结论H为真的一种影响程度，C(E)可理解为E为真的程度</strong></p><p>知识的不确定性度量f(H,E)，需要定义在下述3个典型情况下的取值：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062201721.png" alt="image-20230606220112651"></p><h2 id="不确定性推理方法分类"><a href="#不确定性推理方法分类" class="headerlink" title="不确定性推理方法分类"></a>不确定性推理方法分类</h2><h3 id="模型方法"><a href="#模型方法" class="headerlink" title="模型方法"></a>模型方法</h3><ul><li>在推理一级上扩展确定性推理，其特点是把不确定的证据和不确定的知识分别与某种度量标准对应起来，并且给出更新结论不确定性算法</li><li>一般来说，这类方法与控制策略无关，即无论使用和何种控制策略，推理的结果都是惟一的</li></ul><p>模型方法又分为数值方法和非数值方法：</p><ul><li>数值方法是对不确定性的一种定量表示和处理方法</li><li>非数值方法是指数值方法之外的其他处理不确定性的方法</li></ul><p>对于数值方法，按其所依据的理论有可分为两类：</p><ul><li>一类是依据概率论的有关理论发展起来的方法，称为基于概率的方法</li><li>另一类是依据模糊理论发展起来的方法，称为模糊推理</li></ul><h3 id="控制方法"><a href="#控制方法" class="headerlink" title="控制方法"></a>控制方法</h3><ul><li>在控制策略一级处理不确定性，其特点是通过识别领域中引起不确定性的某些特征及相应的控制策略来限制或减少不确定性对系统产生的影响</li><li>这类方法没有处理不确定性的统一模型，其效果极大地依赖于控制策略</li><li>目前用到的控制方法主要有相关性制导回溯、机缘控制和启发式搜索等</li></ul><h3 id="概率方法"><a href="#概率方法" class="headerlink" title="概率方法"></a>概率方法</h3><p>纯粹用概率模型来表示和处理不确定性的方法称为纯概率方法或概率方法，纯概率方法虽然有严密的理论证据，但它通常要求给出事件的先验概率和条件概率，而这些数据不易获得，因此其应用受到了限制。为了解决这个问题，人们又在概率论的基础上发展起来一些新的方法及理论：</p><ul><li>主观Bayes方法：它是对Bayes公式修正后形成的一种不确定推理方法，为概率论在不确定推理中的应用提供了一条路径</li><li>可信度方法：它以确定性理论为基础，方法简单、易用</li><li>证据理论：它通过定义信任函数、似然函数，把知道和不知道区别开。这些函数满足比概率函数的公理要弱的公理，因此概率函数是信任函数的一个子集</li></ul><blockquote><p>Bayes定理</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062238568.png" alt="image-20230606223851497"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062239637.png" alt="image-20230606223925566"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062239529.png" alt="image-20230606223940449"></p><h2 id="逆概率方法求解不确定推理问题（重点题型）"><a href="#逆概率方法求解不确定推理问题（重点题型）" class="headerlink" title="逆概率方法求解不确定推理问题（重点题型）"></a>逆概率方法求解不确定推理问题（重点题型）</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062241563.png" alt="image-20230606224138465"></p><p>结合下面例题理解：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062242936.png" alt="image-20230606224213862"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062252020.png" alt="image-20230606225232903"></p><p>结合例子理解：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306062253905.png" alt="image-20230606225304840"></p><p>逆概率方法的优缺点：</p><ul><li>优点：具有较强的理论背景和良好的数学特征，当证据及结论彼此独立时计算的复杂度比较低</li><li>其缺点是求得结果需要的数据还是较难获得，另外Bayes公式的应用条件是很严格的，它要求各事件相互独立等，如若证据间存在依赖关系，就不能直接使用这个方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>大二下复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C51之点亮LED灯</title>
    <link href="/2023/05/17/C51%E4%B9%8B%E5%AE%9E%E7%8E%B0LED%E7%81%AF%E6%98%8E%E4%BA%AE/"/>
    <url>/2023/05/17/C51%E4%B9%8B%E5%AE%9E%E7%8E%B0LED%E7%81%AF%E6%98%8E%E4%BA%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="首要问题"><a href="#首要问题" class="headerlink" title="首要问题"></a>首要问题</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171640961.png" alt="image-20230517164032899"></p><ul><li><p>首先找到单片机上LED灯元件的位置，发现在74HC573上，74HC573是典型的锁存器芯片</p></li><li><p>D0<del>D7为数据输入，Q0</del>Q7为数据输出。Output Enable（OE）为输出使能端， Latch Enable（LE）为锁存使能端</p></li><li><p>OE为高电平时，无论LE与D端为何种电平状态，其输出都为高阻态，此时芯片处于不可控状态。所以在设计电路是我们直接将Output Enable接地，也就是74HC573一直处于输出使能状态</p></li><li><p>当OE为低电平，且LE为高电平时，D与Q同时为H或L。当LE为低电平时，无论D为何种电平，Q都保持上一次的数据状态。</p></li><li><p>即LE为高电平时，锁存器解锁，接受输入并原样输出，LE为低电平时，锁存器上锁，输出保持上一次的数据状态不变</p></li><li><p>而在此51单片机上想要使LED灯亮，首先要给74HC573解锁，要给74HC573解锁，也就是要让LE端为高电平，在此单片机上，也就是要Y4C为高电平（需求一）</p></li><li><p>然后使输出端为低电平，即为0，也就是要输入端为0，也就是P0寄存器的相应位要为0（需求二）</p></li></ul><h2 id="解决需求"><a href="#解决需求" class="headerlink" title="解决需求"></a>解决需求</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171746507.png" alt="image-20230517174652454"></p><ul><li>此图是Y4C的来源，怎么让Y4C为高电平呢？</li><li>74HC02是四路二输入或非门即Y&#x3D;(A或B)的非,要使Y4C为高电平，首先跳线选23，使得WR接地，为低电平，因此，Y4也应为低电平</li></ul><p>对此处J13做一下说明</p><ul><li>该开发板有两种编程模式，由J13这个跳线控制，当2-3短接的时候，是I&#x2F;O编程；当2-1短接的时候，编程模式为MM编程(存储器映射)。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305202122160.png" alt="image-20230520212216044"></p><p>怎么样使Y4为低电平？</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305172147649.png" alt="image-20230517214709590"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305172152262.png" alt="image-20230517215224207"></p><ul><li>为了使Y4为低电平，要使38译码器输入为011，也就是把P2^5 , P2^6, P2^7设置为001</li></ul><h2 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC15F2K60S2.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_led.h&quot;</span></span><br><br><span class="hljs-comment">//下面的sbit只有在操作某一个位时，才需前缀</span><br>sbit LED_0 = P0^<span class="hljs-number">0</span>;<br>sbit LED_1 = P0^<span class="hljs-number">1</span>;<br>sbit LED_2 = P0^<span class="hljs-number">2</span>;<br>sbit LED_3 = P0^<span class="hljs-number">3</span>;<br>sbit LED_4 = P0^<span class="hljs-number">4</span>;<br>sbit LED_5 = P0^<span class="hljs-number">5</span>;<br>sbit LED_6 = P0^<span class="hljs-number">6</span>;<br>sbit LED_7 = P0^<span class="hljs-number">7</span>;<br><br><span class="hljs-comment">//使P0=1111 1110，打开led_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">open_led_0</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  unlock_74HC573();  <br>P0 = <span class="hljs-number">0xfe</span>;<br>&#125;<br><br><br><span class="hljs-comment">//解锁74hc573锁存器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock_74HC573</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    P25 = <span class="hljs-number">0</span>;<br>  P26 = <span class="hljs-number">0</span>;<br>  P27 = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>open_led_0();<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;STC15F2K60S2.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_led.h&quot;</span></span><br><br><br><br><span class="hljs-comment">//使P0=1111 1110，打开led_0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">open_led_0</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  unlock_74HC573();  <br>P0 = <span class="hljs-number">0xfe</span>;<br>&#125;<br><br><br><span class="hljs-comment">//解锁74HC573锁存器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock_74HC573</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    P25 = <span class="hljs-number">0</span>;<br>P26 = <span class="hljs-number">0</span>;<br>P27 = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//锁上74HC573锁存器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_74HC573</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    P2 &amp;= <span class="hljs-number">0x1f</span>;<br>&#125;<br><br><span class="hljs-comment">//关闭所有led灯</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">close_led</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    unlock_74HC573();  <br>  P0 = <span class="hljs-number">0xff</span>;<br>  lock_74HC573();<br>&#125;<br><br><span class="hljs-comment">//延时函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Delay1000ms</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j, k;<br><br>_nop_();<br><span class="hljs-comment">/*_使用_nop_()函数（可理解为软件延时）时，必须在开头添加头文件#include&lt;intrins.h&gt;</span><br><span class="hljs-comment">_nop_()函数相当于一个空操作（可以理解为NOP空操作指令）*/</span><br>i = <span class="hljs-number">8</span>;<br>j = <span class="hljs-number">1</span>;<br>k = <span class="hljs-number">243</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--k);<br>&#125; <span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>&#125;    <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>open_led_0();<br>delay1000ms();<br>close_led();<br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
      <category>C51</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理第三章</title>
    <link href="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章、存储系统"><a href="#第三章、存储系统" class="headerlink" title="第三章、存储系统"></a>第三章、存储系统</h1><h2 id="3-1-存储系统基本概念"><a href="#3-1-存储系统基本概念" class="headerlink" title="3.1 存储系统基本概念"></a>3.1 存储系统基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171101543.png" alt="image-20230517110154486"></p><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20230517092019116.png" alt="image-20230517092019116"></h3><h4 id="主存及以上"><a href="#主存及以上" class="headerlink" title="主存及以上"></a>主存及以上</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305170921241.png" alt="image-20230517092153197"></p><ul><li><p>在辅存里的数据，只有调入到主存之后才可以被cpu访问</p></li><li><p>主存和cpu所连接的这两个箭头就是指cpu可以直接从主存读数据也可以直接向主存写数据</p></li><li><p>Cache（高速缓冲存储器），主存的数据会被放到Cache当中然后cpu可以直接往Cache写数据和读数据，另外Cache里被更改的数据也会被写回主存</p></li></ul><p><strong>增加这样的一层高速缓冲存储器有什么作用？</strong></p><p>主存的读写速度已经很快了<br>但是主存的读写速度<br>远远跟不上CPU的运算速度<br>为了缓解这种速度矛盾<br>通常计算机硬件会把当前有可能被频繁访问的代码数据从主存复制一份到Cache当中<br>然后CPU可以直接读取Cache当中的这个副本数据</p><ul><li><p>寄存器，寄存器的读写速度又要比Cache快得多，所以CPU在进行加减乘除之类的运算的时候，会把操作数先放到寄存器里面，CPU内部包含的寄存器数量是很有限的</p></li><li><p>总之越靠近上层存储器，速度越快，容量越小<br>造价也越高</p></li><li><p>主存和辅存之间的这些数据的交换是由硬件加上操作系统实现</p></li><li><p>操作系统需要负责实现页面置换算法<br>根据页面置换算法可以决定要把哪些数据从主存换出到外存</p></li><li><p>所以主存和辅存之间的数据交换<br>需要系统程序员关心</p></li><li><p>主存和Cache之间的数据交换<br>通常是由硬件自动完成的<br>所有的软件程序员都不需要关心<br>主存和Cache之间的数据交换如何实现<br>这部分是由硬件工程师来实现</p></li><li><p>主存——辅存：实现了虚拟存储系统，解决了主存容量不够的问题</p></li></ul><p><strong>应用程序员所看到的这个储存的容量可以比它实际的容量要大得多,这就是虚拟的意思</strong></p><ul><li>Cache——主存：解决了主存与CPU速度不匹配的问题</li></ul><h4 id="辅存、外存"><a href="#辅存、外存" class="headerlink" title="辅存、外存"></a>辅存、外存</h4><p>电脑里的机械硬盘也就是磁盘<br>它就是属于辅存</p><p>磁带、光盘、u盘<br>这些又属于外存<br>那有的教材当中会把安装在电脑内部的磁盘或者固态硬盘称为辅存<br>然后把u盘光盘这些称为外存</p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><blockquote><p>按照层次结构来分类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171013880.png" alt="image-20230517101345827"></p><blockquote><p>可以按照存储介质来分类</p></blockquote><ul><li><p>第一类存储器就是半导体存储器（主存、Cache）</p><ul><li>这一类的存储器读写速度通常要快一些</li></ul></li><li><p>磁性材料存储信息的存储器（软盘、磁盘、磁带）</p></li><li><p>光存储器，以光介质来存储信息（光盘、DVD、VCD)</p></li></ul><blockquote><p>按照存取方式分类</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171034434.png" alt="image-20230517103403334"></p><ul><li><p>随机存取存储器(Random Access Memory,RAM)：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关</p><ul><li>内存条</li></ul></li><li><p>顺序存取存储器（Sequential Access Memory，SAM）：读写一个存储单元所需时间取决于存储单元所在的物理位置</p><ul><li>比如复读机用的磁带</li><li>复读机或者录音机会有一个磁头来读写磁带里边存放的数据，比如说磁头在中间这个位置，那么这个磁带中间的轴转动的时候，这个词条会划过读写磁头，可以读出里面存储的数据，如果现在这个读写磁头，要读取的是这个磁带后半部分的一段数据的话，需要让这个磁带一直转转转转，让这一段划过读写磁头才可以进行读写</li><li>读取存储单元里面所存储的数据的和存储单元的物理位置是有关</li></ul></li><li><p>直接存取存储器（Direction Access Memory, DAM)：既有随机存取特性，也有顺序存取特性，先直接选取信息所在区域，然后按顺序方式存取</p><ul><li>磁盘</li><li>它的读写速度要比顺序存取的这种存储器要更快，但是要比随机存取存储器要更慢</li></ul></li><li><p>顺序存取存储器和直接存取存储器可以被归为<strong>串行访问存储器</strong>：读写某个存储单元所需时间与存储单元的物理位置有关</p></li><li><p>这三种类型的存储器，都是我们要指明一个读写的地址。然后进行读取</p></li><li><p>还有一种存储器的存储方式不太一样，叫做相联存储器，也可以称为按内容访问的存储器，英文缩写叫CAM</p><ul><li>快表就是一种相联存储器</li></ul></li><li><p>下面三种是按照地址来访问<br>上面这种是按照内容来访问</p></li></ul><blockquote><p>按照信息的可更改性分类</p></blockquote><ul><li><p>读写存储器——可读、可写（磁盘、内存、Cache）</p></li><li><p>只读存储器（ROM）——只能读、不能写（实体音乐专辑CD-ROM，实体电影采用蓝光光碟，BIOS写在ROM中）</p></li></ul><blockquote><p>按照信息的可保存器进行分类</p></blockquote><ul><li><p>断电后，存储信息消失的存储器——易失存储器（主存、Cache）</p></li><li><p>断电后，存储信息依然保持的存储器——非易失性存储器（磁盘、光盘）</p></li><li><p>信息读出后，原存储信息被破坏——破坏性读出（DRAM芯片，读出数据后要进行重写）</p></li><li><p>信息读出后，原存储信息不会被破坏——非破坏性读出（SRAM芯片、磁盘、光盘）</p></li></ul><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><ul><li>存储容量：存储字数*存储字长</li><li>单位成本：每一个比特位价格&#x3D;总成本&#x2F;总容量</li><li>存储速度：数据传输率&#x3D;数据的宽度&#x2F;存储周期</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305171058581.png" alt="image-20230517105820508"></p><ul><li><p>存取时间：从启动一次存储器操作到完成该操作所经历的世界，分为读出时间和写入时间</p></li><li><p>存取周期：存取周期又称为读写周期或访问周期，它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作之间所需的最小时间间隔</p></li><li><p>主存带宽（Bm）:又称数据传输率，表示每秒从主存进出信息的最大数量</p></li></ul><h2 id="3-2-1-主存储器的基本组成"><a href="#3-2-1-主存储器的基本组成" class="headerlink" title="3.2.1 主存储器的基本组成"></a>3.2.1 主存储器的基本组成</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261734853.png" alt="image-20230626173429798"></p><h3 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h3><h4 id="存储元"><a href="#存储元" class="headerlink" title="存储元"></a>存储元</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306151404182.png" alt="image-20230615140442146"></p><p><strong>读出二进制原理</strong>：</p><ul><li>MOS管可以理解为一种电控开关，输入电压达到某个阈值时，MOS管就可以接通，否则绝缘</li><li>给电容上面的金属板加一个高电压，那么由于这两块金属板产生了电压差, 电容里面的电荷就会开始移动, 也就是所谓给电容充电的过程, 这个电容里边就可以保存一定的电荷, 而如果我们在上边输入的是一个低电平信号, 比如说0伏或者1伏, 那么上面这块金属板, 和下面这块金属板的电压差非常小, 所以这种情况下电容不会充点，也就不保存电荷</li><li>两种状态的信息对应二进制的0和1</li><li>假设现在这个电容上是保存了一些电荷的, 我们规定当它保存了一些电荷的时候, 它表示的是二进制的1</li><li>如何读取这个二进制的比特位呢, 很简单, 只需要给mos管的这一端, 加一个高电平信号，也可以理解为是输入一个二进制的1, mos管就接通, 相当于这个开关可以开始导电, 此时电容里面保存的这些电荷, 就可以顺着这个导线往外流, 当我们在另一端, 检测到有一个输出电流的时候, 就意味着它输出了一个二进制的1</li><li>如果本来这个电容它里边没有保存电荷, 也就是说这种状态表示二进制的0, 那么当mos管接通的时候, 我们在这一端并不能检测到有电荷的流出在这种情况下, 我们就可以判断, 这个电容里边保存的是二进制的0</li></ul><p><strong>写入二进制原理</strong>：</p><ul><li>假设现在我们想要让这个电容保存一个二进制的1</li><li>那么我们可以在导线的这一端, 加一个5伏的高电平, 同时给这个mos管也加一个5伏的高电平, 这样的话mos管可以接通, 接通之后意味着电容上边这一块金属板, 它的电压应该是5伏, 而下边这个金属板由于是接了地, 所以它是0伏, 那只要电容的两块金属板之间有这种电压差, 就会导致这个电容里面的电荷开始移动, 于是这个电容就会存储一些电荷, 也就是存储了二进制的1</li><li>接下来再让这个mos管断开, 这样的话电容里的电荷就跑不出去了</li></ul><h4 id="多个存储元构成存储单元"><a href="#多个存储元构成存储单元" class="headerlink" title="多个存储元构成存储单元"></a>多个存储元构成存储单元</h4><p><strong>如果我们把多个存储元进行科学合理的连接</strong>, <strong>那么我们就可以一次性读出或者写入多个二进制数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306151417318.png" alt="image-20230615141755272"></p><ul><li><p>图里有一条红色的线, 这条线连接了每一个存储源的mos管, 如果给这条红色的线加一个5伏的高电平, 就意味着所有这些存储源的mos管都可以被导通, 当mos管导通之后, 电容里存储的电荷就可以顺着这条线, 往绿色这条线往外导出</p></li><li><p>也就是说, 只需要监测每一条绿色的线, 有没有产生电流, 就可以判断每一条线所对应的是二进制的零还是一, 如果有电流, 那么意味着产生的是一个二进制的1, 如果没有电流, 那么就意味着产生的是一个二进制的0</p></li><li><p>用这样的方式, 就可以读出这一整行的存储元所存储的这些二进制比特的信息, 这样的一整行, 就是我们之前提到过的存储单元, 也就是一个存储字</p></li></ul><h4 id="多个存储单元也就构成了一个存储体"><a href="#多个存储单元也就构成了一个存储体" class="headerlink" title="多个存储单元也就构成了一个存储体"></a>多个存储单元也就构成了一个存储体</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261645004.png" alt="image-20230626164501934"></p><h3 id="存储芯片的基本原理"><a href="#存储芯片的基本原理" class="headerlink" title="存储芯片的基本原理"></a>存储芯片的基本原理</h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261649688.png" alt="image-20230626164910624"></p><ul><li>给出了n位二进制地址之后, n 位2 进制地址应该会对应$2^n$个存储单元, 译码器会根据这个地址, 寄存器MAR里边给出的这几位地址, 把它转变成某一条选通线的高电平信号</li><li>比如此时cpu给这个MAR送过来的地址是三个零, 三个零翻译成十进制, 就应该是对应十进制的零</li><li>所以译码器会把第0根字选择线, 给它一个高电平的输出, 这样的话, 第一个存储字所对应的这些存储元件, 都会被选通, 就可以读出每一位二进制数据</li><li>总之，每一个地址会对应译码器的一条输出线, 0号1号2号, 以此类推, 总共有二的三次方个地址, 也就是八个地址, 因此译码器的输出端总共会有八条线好, 所以经过译码器的处理, 一个地址信号会被转换成译码器的某一条输出线的高电平信号</li><li>当这一条红色的自选择线被接通之后, 就可以通过这个数据线, 也就是这绿色的这条线, 把每一位的二进制信息传送到MDR当中, 然后接下来cpu会通过数据总线, 从MDR当中取走这一整个字的数据</li><li>那这数据总线的宽度, 应该是和存储字长是相同的，这就是给出地址之后, 通过译码器的处理, 选中其中的某一个字的原理</li></ul><p><strong>总容量&#x3D;存储单元个数 * 存储字长</strong></p><h4 id="控制电路"><a href="#控制电路" class="headerlink" title="控制电路"></a>控制电路</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261704708.png" alt="image-20230626170417627"></p><ul><li>控制电路, 用于控制译码器mar和mdr, 比如cpu通过地址总线把地址送到mar当中, 但是由于我们使用的是电信号, 来传送这些二进制数据, 而电信号难免会有不稳定的情况, 当mar里面的这个电信号稳定之前, 这个地址信息是不能送到译码器当中的</li><li>所以这就是控制电路的一个作用, 只有mar稳定之后, 它才会打开这个译码器的开关, 让译码器来翻译这个地址, 然后给出相应的输出信号, 那那同样的当数据输出的时候, 只有这个输出的电信号稳定之后, 控制电路才会认为此时的输出是正确无误的, 所以他也需要控制mdr, 在什么时候给数据总线送出数据</li></ul><h4 id="片选线"><a href="#片选线" class="headerlink" title="片选线"></a>片选线</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261707634.png" alt="image-20230626170750593"></p><ul><li>通常我们会用CS上面加一个杠, 或者CE上面加一个杠来表示片选线的电信号, 像这种头上画了一横的意思, 就是当电信号是低电平时有效, CS和CE是因为缩写, C表示芯片的英文Chip, 然后CS表示的是芯片选择, chip select芯片选择信号, 如果我们给出的芯片选择信号, 是一个低电平的时候, 就说明这个芯片的总开关是被我们接通的</li><li>有的地方也会把片选线的信号, 把它命名为CE，CE是chip enable, 也就是芯片使能的一个信号, 和芯片选择信号的含义一样, 也就是说, 当我们给这个片选线加一个低电平的时候, 就意味着这块芯片是可以工作的</li></ul><h4 id="读写控制线"><a href="#读写控制线" class="headerlink" title="读写控制线"></a>读写控制线</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261715079.png" alt="image-20230626171539034"></p><ul><li>可以读写控制线分开，各一根</li><li>也可以不分开，一根线判断读还是写</li></ul><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261718029.png" alt="image-20230626171818962"></p><ul><li><p>存储矩阵也就是一个个存储元</p></li><li><p>驱动是指一般在译码器旁再接一个驱动器，使得输出的信号稳定有效</p></li><li><p>片选线究竟有什么用？</p><ul><li>一个内存条可能包含多块存储芯片</li><li>要查找的数据在内存条的某一块存储芯片当中</li><li>用片选线，即可选中那块存储芯片</li></ul></li><li><p>上图的每根线都至少会对应一个金属引脚</p><ul><li>”至少“只针对读写控制线</li><li>另外还有供电引脚和接地引脚</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261730914.png" alt="image-20230626173003848"></p><h3 id="如何实现不同的寻址方式"><a href="#如何实现不同的寻址方式" class="headerlink" title="如何实现不同的寻址方式"></a>如何实现不同的寻址方式</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261732535.png" alt="image-20230626173235470"></p><h2 id="3-2-2-SRAM和DRAM"><a href="#3-2-2-SRAM和DRAM" class="headerlink" title="3.2.2 SRAM和DRAM"></a>3.2.2 SRAM和DRAM</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306261923316.png" alt="image-20230626192345230"></p><ul><li><p>Dynamic Random Access Memory ，即动态RAM</p></li><li><p>Static Random Access Memory， 静态RAM</p></li><li><p>DRAM用于主存，SRAM用于Cache</p></li><li><p>DRAM芯片：使用栅极电容存储信息</p></li><li><p>SRAM芯片：使用双稳态触发器存储信息</p></li></ul><blockquote><p>栅极电容 VS 双稳态触发器</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306270822703.png" alt="image-20230627082221627"></p><p>栅极电容：</p><ul><li>读出1：MOS管接通，<strong>电容放电</strong>，数据线上产生电流</li><li>读出0：MOS管接头后，数据线上无电流<ul><li><strong>电容放电时</strong>信息被破坏，是<strong>破坏性读出</strong>。读出后应有<strong>重写</strong>操作，也称为再生</li></ul></li><li>每个存储元制造成本更低，集成度高，功耗低</li><li>电容内的电荷只能维持2ms，即便不断电，2ms后信息也会消失<ul><li>这也是DRAM需要刷新的原因（刷新也就是给电容充电）</li></ul></li></ul><p>双稳态：</p><ul><li>A高B低为1</li><li>A低B高为0</li><li>读出0时，BL为低电平<ul><li>读出数据，触发器状态保持稳定，是<strong>非破坏性读出</strong>，<strong>无需重写</strong></li></ul></li><li>读出1时，BLX为低电平</li><li>每个存储元制造成本更高，集成度低，功耗大</li><li>只要不断电，触发器的状态就不会改变</li></ul><blockquote><p>DRAM VS SRAM</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306270941116.png" alt="image-20230627094126990"></p><p><strong>现在来看，DRAM已经过时了，目前主存通常采用SDRAM芯片</strong></p><blockquote><p>DRAM的刷新</p></blockquote><ul><li><p>多久需要刷新？——刷新周期：一般为2ms</p></li><li><p>每次刷新多少存储单元？——以行为单位，每次刷新一行</p></li><li><p>为什么要用行列地址——减少选通线的数量</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306270959857.png" alt="image-20230627095933757"></p><p>用二维的矩阵，采用行列地址，大大减少每个译码器选通线的数量</p><ul><li>如何刷新？——有硬件支持，读出一行的信息后重新写入，占用一个读&#x2F;写周期</li><li>在什么时刻刷新？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271016613.png" alt="image-20230627101623506"></p><p><strong>异步刷新最科学，每15.6微妙内有0.5微妙的死时间用来刷新，可以利用CPU不访问存储器的时间来刷新，比如可在译码阶段刷新</strong></p><blockquote><p>DRAM的地址线复用技术</p></blockquote><p><strong>行、列地址分两次送，可使地址线更少，芯片引脚更少</strong></p><h2 id="3-2-3-只读存储器ROM"><a href="#3-2-3-只读存储器ROM" class="headerlink" title="3.2.3 只读存储器ROM"></a>3.2.3 只读存储器ROM</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271601027.png" alt="image-20230627160155919"></p><h3 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h3><ul><li><p>RAM芯片——易失性，断电后数据消失</p></li><li><p>ROM芯片——非易失性，断电后数据不会丢失</p></li><li><p>ROM可分为MROM、PROM、EPROM、闪存、SSD</p></li></ul><h3 id="了解各种ROM"><a href="#了解各种ROM" class="headerlink" title="了解各种ROM"></a>了解各种ROM</h3><p>MROM（Mask Read-Only Memory）——掩模式只读存储器</p><p>厂家按照客户需求，在芯片生产过程中直接写入信息，之后<strong>任何人不可重写</strong>（只能读出）</p><p>可靠性高、灵活性差、生产周期长、只适合批量定制</p><p>PROM（Programmable Read-Only Memory）——可编程只读存储器</p><p>用户可用专门的PROM写入器写入信息，<strong>写一次之后就不可更改</strong></p><p>EPROM（Erasable Programmable Read-Only Memory）——可擦除可编程只读存储器</p><p>允许用户写入信息，之后用某种方法擦除数据  <strong>可进行多次重写</strong></p><p>UVEPROM（ultraviolet rays）——用紫外线照射8~20分钟，<strong>擦除所有信息</strong></p><p>EEPROM（也常记为$E^2PROM$，第一个E是Electrically）——可用“电擦除”的方式，<strong>擦除特定的字</strong></p><p>FLASH MEMORY——闪速存储器（注：U盘、SD卡就是闪存）</p><p>在EEPROM基础发展而来，<strong>断电后也能保存信息</strong>，且可以进行<strong>多次快速擦除重写</strong></p><p>注意：由于闪存需要先擦除再写入，因此闪存的<strong>写速度要比读速度更慢</strong></p><p> 闪存的每个存储元只需要单个MOS管，位密度比RAM高，也就是说相同体积下，闪存的存储元数量比RAM上存储元数量多，因此可以存储的位数更多</p><p>SSD（Solid State  Drives）——固态硬盘</p><p>由控制单元+存储单元（Flash芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，可进行<strong>多次快速擦除重写</strong>。SSD速度快、功耗低、价格高。目前个人电脑上常用SSD取代传统的机械硬盘</p><p>拓展：手机辅存也使用Flash芯片，但相比SSD使用的芯片集成度高、功耗低、价格贵</p><h3 id="计算机内的重要ROM"><a href="#计算机内的重要ROM" class="headerlink" title="计算机内的重要ROM"></a>计算机内的重要ROM</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271554077.png" alt="image-20230627155430909"></p><p>主存是RAM，由于断电后，RAM内数据全部丢失，当开机时，CPU从主存中读取不到任何指令，那么这个时候该怎么办呢？找主板上的BIOS芯片，主板上的BIOS芯片（ROM），存储了“自举装入程序”，负责引导装入操作系统（开机）</p><p><strong>注意：逻辑上，主存由RAM+ROM组成，且二者常统一编址。我们常说的内存条就是主存，但事实上，主板上的ROM芯片也是主存的一部分</strong></p><p>统一编址：假如存储容量为1K，那么0~1023号地址分配给ROM，RAM的地址从1024开始</p><h2 id="3-3-1-主存储器与CPU的连接"><a href="#3-3-1-主存储器与CPU的连接" class="headerlink" title="3.3.1 主存储器与CPU的连接"></a>3.3.1 主存储器与CPU的连接</h2><h3 id="知识总览-1"><a href="#知识总览-1" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271605229.png" alt="image-20230627160527156"></p><h3 id="单块存储芯片与CPU的连接"><a href="#单块存储芯片与CPU的连接" class="headerlink" title="单块存储芯片与CPU的连接"></a>单块存储芯片与CPU的连接</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271615686.png" alt="image-20230627161520563"></p><p>注：现在的计算机MAR、MDR通常集成在CPU内部。存储芯片内只需要一个普通的寄存器（暂存输入、输出数据）</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271645365.png" alt="image-20230627164536321"></p><h3 id="增加主存的存储字长-位扩展"><a href="#增加主存的存储字长-位扩展" class="headerlink" title="增加主存的存储字长-位扩展"></a>增加主存的存储字长-位扩展</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271656860.png" alt="image-20230627165651782"></p><p>这样就通过2个8K * 1位存储器，将主存的存储容量扩展为8K  * 2 位</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271658613.png" alt="image-20230627165846547"></p><p>将8片8K * 1位的存储芯片转化成一个8K * 8位的存储器，容量8KB</p><h3 id="增加主存的存储字数-字扩展"><a href="#增加主存的存储字数-字扩展" class="headerlink" title="增加主存的存储字数-字扩展"></a>增加主存的存储字数-字扩展</h3><blockquote><p>  <strong>线选法</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271709047.png" alt="image-20230627170937949"></p><blockquote><p> <strong>译码片选法</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271737030.png" alt="image-20230627173730928"></p><p>考试有可能会这样出题</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271828445.png" alt="image-20230627182802345"></p><p>译码器不接A14接A15，这就导致A14的信号对每个存储芯片不起作用，从而导致每个8K * 8位的存储芯片拥有16K个地址，这显然是不对的</p><table><thead><tr><th align="center">线选法</th><th align="center">译码片选法</th></tr></thead><tbody><tr><td align="center">n条线-&gt;n个选片信号</td><td align="center">n条线-&gt;$2^n$个选片信号</td></tr><tr><td align="center">电路简单</td><td align="center">电路复杂</td></tr><tr><td align="center">地址空间不连接</td><td align="center">地址空间可连续</td></tr></tbody></table><p><strong>总结：</strong></p><ul><li>位扩展可以使存储器的字长变得更长，从而更好发挥数据总线的数据传输能力，而字扩展可以增加存储器的存储字数，可以更好地利用cpu的寻址能力</li></ul><h3 id="主存容量扩展-字位同时扩展"><a href="#主存容量扩展-字位同时扩展" class="headerlink" title="主存容量扩展-字位同时扩展"></a>主存容量扩展-字位同时扩展</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271841760.png" alt="image-20230627184111701"></p><h3 id="本节回顾"><a href="#本节回顾" class="headerlink" title="本节回顾"></a>本节回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271841462.png" alt="image-20230627184152416"></p><h3 id="补充：译码器"><a href="#补充：译码器" class="headerlink" title="补充：译码器"></a>补充：译码器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271844468.png" alt="image-20230627184406395"></p><p>现实中的译码器往往有使能端，甚至有多个使能端</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271844179.png" alt="image-20230627184454134"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271845060.png" alt="image-20230627184514007"></p><p>图中多个使能的译码器便是74l138译码器</p><p>注：CPU可使用译码器的使能端控制片选信号的生效时间 </p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202306271851297.png" alt="image-20230627185151235"></p><h2 id="3-3-2-双端口RAM和多模块存储器"><a href="#3-3-2-双端口RAM和多模块存储器" class="headerlink" title="3.3.2 双端口RAM和多模块存储器"></a>3.3.2 双端口RAM和多模块存储器</h2><p>回顾存取周期的概念</p><p>存取周期：可以连续读&#x2F;写的最短时间间隔</p><p>注：DRAM芯片的恢复时间比较长，有可能是存取时间的几倍（SRAM的恢复时间较短）</p><p>如：存取时间为r，存取周期为T，T&#x3D;4r。</p><h3 id="知识总览-2"><a href="#知识总览-2" class="headerlink" title="知识总览"></a>知识总览</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307121656503.png" alt="image-20230712165227823"></p><p>我想进行树莓派和STM32的UART通信，我在树莓派上执行这一脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment">#coding=UTF-8</span><br><span class="hljs-keyword">import</span> serial<br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 配置串口</span><br>ser = serial.Serial(<span class="hljs-string">&#x27;/dev/ttyAMA0&#x27;</span>, <span class="hljs-number">9600</span>,timeout=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 根据实际情况修改串口名称和波特率</span><br><span class="hljs-built_in">print</span>(ser.name)<br><span class="hljs-built_in">print</span>(ser.port)<br><span class="hljs-built_in">print</span>(ser.baudrate)<br><span class="hljs-built_in">print</span>(ser.bytesize)<br><span class="hljs-built_in">print</span>(ser.parity)<span class="hljs-comment">#校验位N－无校验，E－偶校验，O－奇校验</span><br><span class="hljs-built_in">print</span>(ser.stopbits)<span class="hljs-comment">#停止位</span><br><span class="hljs-built_in">print</span>(ser.timeout)<span class="hljs-comment">#读超时设置</span><br><span class="hljs-built_in">print</span>(ser.writeTimeout)<span class="hljs-comment">#写超时</span><br><span class="hljs-built_in">print</span>(ser.xonxoff)<span class="hljs-comment">#软件流控</span><br><span class="hljs-built_in">print</span>(ser.rtscts)<span class="hljs-comment">#硬件流控</span><br><span class="hljs-built_in">print</span>(ser.dsrdtr)<span class="hljs-comment">#硬件流控</span><br><span class="hljs-built_in">print</span>(ser.interCharTimeout)<span class="hljs-comment">#字符间隔超时</span><br>data_to_send = <span class="hljs-string">&quot;#u*&quot;</span><br><br><span class="hljs-comment"># 发送数据</span><br>ser.write(data_to_send.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>time.sleep(<span class="hljs-number">0.5</span>)<br><span class="hljs-comment"># 接收并打印数据</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">if</span> ser.in_waiting &gt; <span class="hljs-number">0</span>:<br>        received_data = ser.read_all().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).rstrip(<span class="hljs-string">&quot;\r\n&quot;</span>)  <span class="hljs-comment"># 解码并移除换行符</span><br>        <span class="hljs-built_in">print</span>(received_data)<br>        <span class="hljs-keyword">break</span><br>ser.flushInput()<br><span class="hljs-comment"># 关闭串口连接</span><br>ser.close()<br><br><br></code></pre></td></tr></table></figure><p>给stm32烧录包含下面的中断服务程序函数的工程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">USART2_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  u8 dat;<br>  <span class="hljs-type">static</span> u8 rx_index = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">static</span> u8 is_receiving = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)<br>  &#123;<br>    dat = USART_ReceiveData(USART2);<br><br>    <span class="hljs-keyword">if</span> (dat == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-comment">// 接收到 &#x27;#&#x27;，开始接收数据</span><br>    &#123;<br>      rx_index = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置接收数据的索引</span><br>      is_receiving = <span class="hljs-number">1</span>; <span class="hljs-comment">// 设置接收状态为正在接收</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (is_receiving) <span class="hljs-comment">// 如果处于接收状态</span><br>    &#123;<br>      uart_data[rx_index++] = dat; <span class="hljs-comment">// 存储接收到的数据</span><br><br>      <span class="hljs-keyword">if</span> (dat == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-comment">// 接收到 &#x27;*&#x27;，表示数据接收完成</span><br>      &#123;<br>        uart_flag = <span class="hljs-number">1</span>; <span class="hljs-comment">// 设置uart_flag为1，表示数据接收完成</span><br>        is_receiving = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设置接收状态为不在接收</span><br>        uart_data[rx_index] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 在数据末尾添加字符串结束符</span><br>USART_Send_string(USART2,uart_data); <br>USART_Send_string(USART2,uart_test_data);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请问在树莓派上执行脚本的结果是什么</p><h2 id="3-4-1-磁盘存储器"><a href="#3-4-1-磁盘存储器" class="headerlink" title="3.4.1 磁盘存储器"></a>3.4.1 磁盘存储器</h2><h2 id="3-4-2固态硬盘SSD"><a href="#3-4-2固态硬盘SSD" class="headerlink" title="3.4.2固态硬盘SSD"></a>3.4.2固态硬盘SSD</h2><h2 id="3-5-1-Cache的基本概念和原理"><a href="#3-5-1-Cache的基本概念和原理" class="headerlink" title="3.5.1 Cache的基本概念和原理"></a>3.5.1 Cache的基本概念和原理</h2><h2 id="3-5-2-Cache和主存的映射方式"><a href="#3-5-2-Cache和主存的映射方式" class="headerlink" title="3.5.2 Cache和主存的映射方式"></a>3.5.2 Cache和主存的映射方式</h2><h2 id="3-5-3-Cache替换算法"><a href="#3-5-3-Cache替换算法" class="headerlink" title="3.5.3 Cache替换算法"></a>3.5.3 Cache替换算法</h2><h2 id="3-5-4-Cache写策略"><a href="#3-5-4-Cache写策略" class="headerlink" title="3.5.4 Cache写策略"></a>3.5.4 Cache写策略</h2><h2 id="3-6-1-页式存储器"><a href="#3-6-1-页式存储器" class="headerlink" title="3.6.1 页式存储器"></a>3.6.1 页式存储器</h2><h2 id="3-6-2-虚拟存储器"><a href="#3-6-2-虚拟存储器" class="headerlink" title="3.6.2 虚拟存储器"></a>3.6.2 虚拟存储器</h2>]]></content>
    
    
    <categories>
      
      <category>王道计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王道计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理第二章</title>
    <link href="/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2023/05/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章、数据的表示和运算"><a href="#第二章、数据的表示和运算" class="headerlink" title="第二章、数据的表示和运算"></a>第二章、数据的表示和运算</h1><h2 id="电路的基本原理、加法器设计"><a href="#电路的基本原理、加法器设计" class="headerlink" title="电路的基本原理、加法器设计"></a>电路的基本原理、加法器设计</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232026210.png" alt="image-20230523202651151"></p><h3 id="基本运算部件（ALU）"><a href="#基本运算部件（ALU）" class="headerlink" title="基本运算部件（ALU）"></a>基本运算部件（ALU）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305162110570.png" alt="image-20230516210920389"></p><blockquote><p>抽象ALU结构图（左下）</p></blockquote><ul><li><p>左边A右边B这两个指的是输入信号, 就比如说想实现两个八比特二进制数的加法, 其中一个数是从a端输入,另一个数是从b端输入, 输入的本质是一些电信号, 也就是高低电平, 这是两个需要进行运算的数</p></li><li><p>F指的是输出信号, 也就是运算结果是从这一端输出的, 两个八比特的数相加, 得到一个新的八比特的数, 从这一端输出</p></li><li><p>K端是控制信号, 控制信号是由控制单元CU发出的</p></li></ul><blockquote><p>具象ALU例子</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305162121576.png" alt="image-20230516212140542"></p><ul><li><p>74181是这块芯片的一个型号, 这块芯片就是一个很经典的四位的ALU</p></li><li><p>右边S1到S3 , 还有M是来自cu控制单元的控制信号, 控制单元会负责解析指令的含义,CU解析完指令之后, 会根据这个指令的含义发出一些控制信号, 就是一些0101的电信号, 那如果和这块芯片配合工作, CU需要发出这样的五个信号, 每个信号就是一个高低电平</p></li><li><p>这里的电信号M是用来指明, 当前ALU要执行的是一个逻辑运算, 还是一个算术运算, M&#x3D;1的时候表示这是一个逻辑运算, M&#x3D;0的时候表示这是一个算术运算</p></li><li><p>另外S0 到S3 , 这几个信号可以用来指明, 此次要进行的是哪一种算术运算, 哪一种逻辑运算，由于总共有四个比特的信息, 也就是可以对应16种状态, 因此这块芯片它可以支持16种算术运算, 和16种逻辑运算</p></li><li><p>A B F这几个部分, 和刚才的抽象图示能够对应上, 那A和B就是两个四比特的数据, 输入两个四比特的数据, 然后ALU经过加减乘除之类的运算之后, 会有一个四比特的输出F</p></li><li><p>机器字长的真面目, 就是ALU里边, 它可以支持同时输入多少个比特的信息, 这就是机器字长的本质</p></li><li><p>一般来说ALU可以处理多少比特的数据, 就会把这些寄存器的位数和ALU保持一致, 目的是让寄存器和ALU能够完美的适配</p></li></ul><h3 id="最基本的逻辑运算"><a href="#最基本的逻辑运算" class="headerlink" title="最基本的逻辑运算"></a>最基本的逻辑运算</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305231953257.png" alt="image-20230523195321134"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305231955961.png" alt="image-20230523195522910"></p><h3 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232005115.png" alt="image-20230523200522069"></p><h3 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h3><p> <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232014618.png" alt="image-20230523201433573"></p><p>串行加法器：只有一个全加器，数据逐位送入加法器中进行运算，进位触发器用来寄存进位信号，以便参与下一次运算</p><p>如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器</p><h3 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232019109.png" alt="image-20230523201921063"></p><p>串行进位的并行加法器：把n个全加器串接起来，就可以进行两个n位数的相加。串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的</p><p>多个全加器简单串联，可多位同时加</p><p>计算速度取决于进位产生和传递的速度</p><p><strong>如何更快的产生进位？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232045043.png" alt="image-20230523204516986"></p><h3 id="并行进位的并行加法器"><a href="#并行进位的并行加法器" class="headerlink" title="并行进位的并行加法器"></a>并行进位的并行加法器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232051132.png" alt="image-20230523205142077"></p><p>但是逻辑表达式C5,C6…随着套娃会导致电路越来越复杂，一般到四位并行进位就为止了</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305232052590.png" alt="image-20230523205254546"></p>]]></content>
    
    
    <categories>
      
      <category>王道计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王道计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成原理第一章</title>
    <link href="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章、计算机系统概述"><a href="#第一章、计算机系统概述" class="headerlink" title="第一章、计算机系统概述"></a>第一章、计算机系统概述</h1><h2 id="1-1计算机发展"><a href="#1-1计算机发展" class="headerlink" title="1.1计算机发展"></a>1.1计算机发展</h2><h3 id="每一代的计算机的逻辑元件更替"><a href="#每一代的计算机的逻辑元件更替" class="headerlink" title="每一代的计算机的逻辑元件更替"></a>每一代的计算机的逻辑元件更替</h3><ul><li>第一代是采用电子管作为逻辑元件, 耗电量高, 体积大</li><li>第二代采用晶体管作为逻辑元件, 体积比电子管更小, 同时也更省电</li><li>而第三代的计算机是采用了中小规模集成电路, 其实就是把晶体管啊, 电容啊之类的这些元器件, 把这些电子元器件, 高密度的集成在了一个电路板上,</li><li>那随着集成电路制造工艺的一个提升, 就出现了第四代的计算机, 也就是采用大规模超大规模集成电路,</li></ul><h3 id="计算机硬件的基本组成"><a href="#计算机硬件的基本组成" class="headerlink" title="计算机硬件的基本组成"></a>计算机硬件的基本组成</h3><h4 id="两种结构"><a href="#两种结构" class="headerlink" title="两种结构"></a>两种结构</h4><ul><li>第一种是早期的冯诺依曼结构,</li><li>另一种是现代计算机所普遍采用的结构, 其实也是冯诺依曼结构的一个优化</li></ul><h5 id="冯诺依曼结构计算机"><a href="#冯诺依曼结构计算机" class="headerlink" title="冯诺依曼结构计算机"></a>冯诺依曼结构计算机</h5><blockquote><p>背景</p></blockquote><p>世界上第一台计算机是ENIAC埃尼亚克, 当时冯诺依曼就是这台计算机设计的一个顾问, 这台计算机一个很大的缺点, 就是每一步的计算需要执行什么指令, 都需要程序员、操作员们通过手动连接这些线缆来告诉计算机，因此安尼亚克的计算速度就被手工操作的,所需要的耗时给抵消了, 为了解决这个问题, 冯诺依曼第一次提出了<strong>存储程序</strong>的概念</p><p>对于安尼亚克这台计算机, 是程序员们告诉他一条指令, 他就往下执行一条指令, 说一句做一句</p><p>而冯诺依曼提出的存储程序的这种实现方式意味着可以把我们想要让计算机执行的一系列指令一口气告诉他, 全部先放到储存里, 然后接下来会由计算机一条一条的来执行这些指令, 程序员们就不需要,每一步都进行手工连接的操作, 这就可以大幅提升计算机的一个计算速度</p><p>基于他提出的这个设计方案, 世界上第一台具有冯诺依曼结构的计算机, 就诞生了, 这台计算机的英文缩写叫EDVAC</p><blockquote><p>存储程序</p></blockquote><p>所谓存储程序就是指, 可以把我们需要执行的一系列指令, 以二进制代码的方式, 提前把它输入到计算机的主存储器当中, 也就是我们熟悉的内存里边, 然后计算机会根据存储器里边存储的, 这一系列的指令来一条一条的执行, 直到程序执行结束</p><blockquote><p>冯诺依曼结构图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305042327388.png" alt="image-20230504232729308"></p><ul><li>在这个图中, 实线箭头来表示数据线, 也就是说数据实线箭头的流动方向, 来传输, 双箭头意味着两个部件之间有你来我往的数据传输</li><li>虚线表示控制线和反馈线,</li><li>输入设备, 把数据输入到计算机当中,数据包含要进行数学运算的数据, 也包含了程序, 也就是指令集合, 所以输入设备的一个作用, 就是把计算机要处理的信息, 转换成机器能够识别的形式, 也就是0101这样的二进制数, </li><li>输入的数据、程序通过输入设备处理, 先流向运算器, 然后通过运算器的中转, 才会把这些程序数据放到内存, 也就存储器当中</li><li>存储器就是用来存放要处理的数据, 还有程序指令 </li><li>中间的这个运算器, 最主要的一个功能是实现算数运算和逻辑运算</li><li>经过运算器的处理, 数据的运算结果会通过输出设备转换成人类比较熟悉的形式</li><li>控制器会用一些电信号来协调其他部件相互配合的工作, 另外控制器也会负责来解析存储器里存储的那些程序指令, 所以我们会看到有一条存储器到控制器的数据线, 这条数据线其实就是控制器从存储器当中读取出一条指令的一个数据流, 所以程序指令的解析是由控制器来完成的</li><li>我们输入计算机的数据和程序, 其实就是所谓的软件的模块, 框里边的部分, 其实就是计算机的硬件部件, 在计算机系统中, 其实软件和硬件在逻辑上是等效的,也就是说对于同一个功能, 我们既可以用软件来实现, 也可以用硬件来实现, 不过通常来说用软件实现的成本更低, 但是效率也会更低, 而用硬件来实现成本会更高, 当然效率也会更高, </li><li>比如，如果我们要实现乘法运算, 那么我们完全可以在运算器里边, 设计一个专门的硬件电路来实现这种乘法运算, 我们只需要给出一条乘法指令, 运算器就可以得到最终的结果, 但是如果我们没有这个硬件部件, 其实也可以实现乘法, 乘法可以用多次的加法运算来模拟, 所以才说, 软件和硬件在逻辑上其实是等效的, 显然用硬件的方式乘法电路, 直接计算更快一些, 用软件的方式进行多次加法, 0需要消耗更长的时间</li></ul><blockquote><p>冯诺依曼计算机的特点</p></blockquote><ul><li>第一个特点计算机有五大部件组成, 也就是输入、输出、运算器、存储器、控制器</li><li>第二个特点, 指令和数据同样都是以同等的地位存放在存储器当中, 我们可以根据存储单元的地址, 来进行缓存的操作</li><li>第三个特点，指令和数据都用二进制表示</li><li>第四个特点, 指令由操作码和地址码组成</li><li>第五个特征就是存储程序</li><li>第六个特征就是冯诺依曼计算机是<strong>以运算器为中心</strong></li></ul><p><strong>什么叫以运算器为中心？</strong></p><p>运算器, 它处在整个结构的中间位置, 无论是输入设备, 输入数据还是输出设备输出数据, 都肯定需要经过运算器的一个中转, 虽然说刚开始输入的这些数据和程序, 本来就是想要放到这个存储器里的, 但是冯诺依曼这种结构的计算机, 都会通过运算器作为中转站, 把它转存到这个存储器里边的, 所以由于数据的传送必须经过运算器来完成, 因此我们说这种结构是以运算器为中心, 那这就产生了一个问题, 运算器本来是用来处理这些数据的核心部件, 但是现在所有的数据中转还需要它来帮忙完成, 导致数据计算的效率降低, </p><p>效率降低的解决方案很简单，其实就是现代计算机的一个结构, 以存储器为中心, 也就是说输入设备, 它的数据是直接放到存储器里边的, 当运算器处理完这些数据之后, 输出设备也会直接从存储器当中取走最终的数据, 进行计算结果的输出, 这样就可以解放运算器的时间, 让运算器进行更多的运算</p><h5 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305042343438.png" alt="image-20230504234331385"></p><ul><li>cpu里边包含了运算器和控制器, 控制器通过控制线来告诉运算器, 接下来应该执行的是什么样的运算, 另外控制器也会控制主存储器的读写, 以及输入输出设备的启动停止</li><li>主存储器和cpu之间会进行数据的交换, 第一种就是需要参与运算的数据, 比如xy之类的一些变量, 另外一种数据就是指令, 指令会放到控制器当中, 由控制器来解析指令的含义, 并且发出相应的控制信号</li><li>最右边的双向箭头是io设备, 也就是输入输出设备, 会直接的和主存储器进行数据的交换, 主存储器和cpu统称为主机</li><li>主存和辅存这两个东西, 那这两个东西都统称为存储器, 主存就是主存储器, 也就是我们熟知的内存, 而辅助存就是辅助存储器, 在电脑里边就是我们的机械硬盘, 固态硬盘, 需要注意的是, 虽然它们都是存储器, 但是主机是只包含了主存, 辅存我们应该把它归为io设备, 像我们平时手机里安装的app, 其实它就是存放在辅存里面的, 只有这个app需要启动运行的时候, 才会把辅存里边的app相关的程序, 数据代码的数据把它读到主存里边, 所以辅存应该把它看作是一种io设备, 像之前我们给的这个图, 华为这个手机, 他这所谓的运行内存八GB, 指的就是主存储器的大小容量是八GB, 然后机身存储是128GB, 这个指的就是辅存</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305161831724.png" alt="image-20230516183100607"></p><h2 id="各个硬件的工作原理"><a href="#各个硬件的工作原理" class="headerlink" title="各个硬件的工作原理"></a>各个硬件的工作原理</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061042365.png" alt="image-20230506104238310"></p><ul><li><p>主存储器里边用于存放数据的东西叫做存储体,</p></li><li><p>存储体就是由一系列的存储元件来构成的, 可以存放二进制0或1</p></li><li><p>两个重要的寄存器, 一个叫MAR, 一个叫MDR, 它们分别是存储地址寄存器和存储数据寄存器</p></li><li><p>一整个存储体会被分成一个一个的存储单元, 每一个存储单元会存放一串二进制代码</p></li><li><p>那每一个单元里边存储的这一串二进制代码, 我们就把它称为一个存储字</p></li><li><p>而每一个存储字包含多少个二进制位, 这个信息我们把它称为存储字长</p></li><li><p>存储元， 用于存储二进制数据的电子元件，每个存储元可存一个二进制的比特位(1bit),</p></li><li><p>MAR是指明了存储单元的地址, 所以MAR寄存器的位数反映了存储体里边到底有多少个存储单元</p></li><li><p>另一方面, 从存储单元里边取出来的数据, 是要放到MDR当中的, 所以MDR的二进制位数, 应该和存储单元是保持一致的, 也就是要等于存储字长</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061059967.png" alt="image-20230506105948920"></p><ul><li>比如这个主存储器, 它的MDR地址寄存器只有四个比特位, 那么也就意味着它的存储体里边, 总共只有二的四次方个存储单元， </li><li>如果MDR, 总共有16位,一个字的大小就是16个比特</li><li>注意区分字和字节的概念</li><li>需要强调的点, 在描述一个字节的时候, 经常会用B表示， 但是在描述一个比特, 一个二进制位的时候, 一般是用b</li></ul><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061107190.png" alt="image-20230506110739134"></p><ul><li>ACC它其实是一个寄存器,  一般叫做累加器, 累加器可以用来存放, 进行加减乘除或者逻辑运算的那些操作数, 同时也会用于存放运算的结果,</li><li>第二个寄存器叫MQ, 就是乘商寄存器,这个寄存器只会在乘法除法才会用得到, 同样的会用来存放乘法, 除法的操作数或者运算的一个结果</li><li>第三个寄存器x它叫通用的操作数寄存器,简称为通用寄存器, 用于存放操作数，其实这种通用寄存器一般在运算器里边是可能会有多个, 但理论上我们只需要有一个通用寄存器, 就可以实现我们想要的那些算术运算, </li><li>ALU叫算术逻辑单元，是运算器的核心部件, 它里边集成了一些复杂的电路, 用这些复杂的电路可以实现算术运算, 或者逻辑运算</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061115974.png" alt="image-20230506111532922"></p><ul><li>CU，控制单元，是控制器里面最核心的一个部件,, 可以分析指令, 并且可以给其他的部件发出一些控制信号</li><li>IR是指令寄存器, 就是用来存放当前执行的指令</li><li>PC是程序计数器, 用来存放下一条指令的地址, 并且有自动加一的功能</li><li>完成一条指令需要分为这样的三个阶段：<ul><li>第一个阶段是取指令, 会根据PC里边所记录的指令地址，从内存里边取出那一条指令, 取出的指令会被放在IR</li><li>然后CU分析, 这条指令到底是要干什么的</li><li>分析完了之后, CU就会控制着其他部件, 来配合着完成指令的具体执行</li></ul></li></ul><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061125839.png" alt="image-20230506112526764"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061131119.png" alt="image-20230506113133054"></p><ul><li>初：这个程序要执行的第一个指令, 应该是存放在0号位置的这条指令, 所以在程序运行之后, PC会指向零这个位置, </li><li>接下来我们应该把这个位置存放的这条指令, 取出来执行, </li><li>#1：PC存放的内容, 需要通过地址总线, 把它传送到MAR中,  此时PC是零, 那这个操作就会导致MAR这个寄存器的值变为了零, 也就是说控制器向主存指明了接下来要访问的是0号地址所对应的一串数据</li><li>同时控制器会通过控制总线告诉主存储器, 这次要进行的是读操作</li><li>#3：接下来主存储器会根据MAR记录的这个地址信息去存储体里边, 找出0号地址所对应的这些二进制数据, 并且把这些二进制数据放到MDR中, 那么这就导致了MDR这个寄存器当中里边存放的就是我们想要读取的第一条指令,</li><li>我们把一个寄存器的名字外面打一个括号, 指的是这个寄存器里边的内容</li><li>然后这一个M表示的是memory, 也就是主存储器, 主存储器里边, MAR这个地址所指明的存储单元里边的数据, 放到MDR这个寄存器当中, 是这样的一个意思</li><li>#4：指令会通过数据总线把它放到IR中,  这就导致控制器的IR里边存放了此次要执行的指令, </li><li>#5：接下来这条指令的前边六个比特, 也就是操作码, 会被送到CU控制单元里边, 然后CU会分析这个操作吗, 它就可以知道00001, 它对应的是一条取数的指令, </li><li>#6：接下来要把这个地址码所指明的内存单元里的数据取出来, 并且放到ACC这个寄存器当中, 这是取数指令要做的事情, 那既然要读取储存的这个地址的信息, 于是就需要把这个地址码, 放到主存的MAR当中, 这就导致此时MAR是等于五, 因为这个二进制数转换成十进制, 就是五, 那5号存储单元所指向的刚好就是a这个变量</li><li>#8：接下来主存储器根据MAR指明的这些地址, 去存储体当中, 找出5号单元的这些数据, 并且把这些数据放到MDR当中, 也就把a这个变量的值现在放到了MDR里, 那a的值是2</li><li>#9：最后在控制单元的指挥下, MDR里的数据会被传送到ACC, 也就累加寄存器当中, 到此为止我们就完成了一个取数的指令, 最终导致a这个变量的值已经被我们放到ACC当中了,</li><li>1234这几步, 其实就是对应取指令的一个过程, 然后第五步是对应了分析指令的过程, 后边的6~9步才是实际执行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061150132.png" alt="image-20230506115043064"></p><ul><li>那之前我们说过程序计数器, pc它有自动加1的功能, 其实在取指令这个动作完成之后, pc的值就会自动的加1了, 他以前是零, 那自动加1它就会指向1, 也就是指明了下一条我们要执行的指令</li><li>接下来根据程序计数器pc所指向的位置, 取得第二条指令, 那么取指令的过程和之前是类似的, 通过这样的四个步骤, 把第二条指令放到IR寄存器当中</li><li>取完指令之后就需要分析指令, 那和之前一样, 会把操作码这个部分送到cu控制单元, 然后经过CU分析之后, 可以知道, 000100, 这个操作码对应的是一个乘法操作, 所以这是一条乘法指令, 因此接下来CU会指挥其他部件来协调地完成,</li><li>现在这一步我们要完成的是a乘以b的操作, 而a这个变量之前已经被送到ACC, 里边了, 所以现在这一条乘法指令, 它的地址码指明的是另一个乘数b的存放位置, 那b存放在6这个位置, 刚好这个地址码把它翻译成十进制数也是等于六, 所以这条指令的地址码会被送到MAR当中, 指明我要取出的是6号存储单元里边的数据</li><li>所以接下来储存会根据MAR所指明的这些地址, 取出相应的这个数据, 也就是把b这个变量的值放到了MDR当中, 接下来b的值会从mdr, 再通过数据总线送到MQ, 也就是乘商寄存器当中, 所以现在b的值已经放到MQ里面了</li><li>接下来还需要把a的值先放到通用寄存器x当中, 也就是说当这个cpu执行乘法操作的时候, 他会把被乘数放到x这个通用寄存器里边, 然后把乘数放到mq这个乘商寄存器里边, </li><li>接下来CU会通过控制线告诉ALU让它进行乘法运算, ALU会把x和mq里边存储的这两个数, 把它们进行一个相乘的操作, 然后把最终乘得的结果放到ACC里边, 那这个操作导致acc里面得到了a乘以b的值, 2*3&#x3D;6</li><li>在我们这个例子当中进行相乘的这两个数很小, 但是如果说这两个数很大的话, 那么有可能ACC这个寄存器里边是存不下的, 这种情况下, 就需要mq乘商寄存器的一个辅助存储, mq里边会用来存放乘法运算结果的低位</li><li>那这样我们就完成了第二条指令, 也就是乘法指令, 那大家会发现和前边那条指令相比, 其实第一步到第五步, 这几个步骤, 每一步要做的事情都是一模一样的, 只有当CU控制单元, 分析出这条指令是乘法指令的时候, 接下来的操作就会产生一些区别</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061204145.png" alt="image-20230506120431084"></p><ul><li>当取指令结束之后, pc的值也会自动加一, 所以这条指令执行结束之后, 得到的效果就是pc指向了2, 也就指向了下一条要执行的指令, ACC里边此时存放我们上一个运算的结果, 也就是a乘以b的值, a乘以b等于六</li><li>接下来执行二这个地址存放的这条指令, 那前边的几个步骤都是一样的, 通过五个步骤, 可以完成取指令和分析指令的操作, </li><li>CU发现这次要执行的操作码, 应该是000011, 这个操作码对应的是一个加法操作</li><li>接下来CU会根据加法指令的这个执行步骤, 来指挥这其他部件协调工作, 这次要计算的是a乘以b加c, 而a乘以b的结果我们是已经存放在acc当中, 所以这个加法指令的地址码, 指明的是c这个变量它的存放地址, 那c是存放在7这个位置的, 刚好把这个二进制数转换成十进制, 就是7</li><li>因此接下来要取出7这个地址所存放的数据, 那么就需要把这个地址码, 把它放到mar地址寄存器当中, 接下来主存根据mar指明的地址, 取出相应的这个数据, 也就把c的值放到了mdr当中</li><li>接下来这一步会把mdr的值, 再传送到通用寄存器x当中, 也就是说当我们进行加法运算的时候, ACC里边会先存入被加数, 然后通用寄存器x当中会存放加数, 也就是c的值</li><li>接下来控制单元会向ALU发送一个信号, 告诉他你此次要执行的是加法操作, 那么ALU算术逻辑单元, 就会把acc和x里面存放的值进行一个相加, 并且把加的结果再次存回acc当中, 因此这就导致了acc等于七, 也就是把a乘以b加c的值存放到了acc里边, 好那到此为止, 我们完成了第三条指令, 也就是这个加法指令</li><li>另外在取完指令之后, 同样的也会自动的进行pc加一的操作, 也就是pc会指向下一条我们应该执行的指令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061213523.png" alt="image-20230506121302448"></p><ul><li>接下来这条指令的执行, 前边的这些步骤都是一样的, 根据pc记录的这个地址, 取出这条指令, 并且放到r指令寄存器当中, 然后第五个步骤会把这个指令的操作码, 把它送到CU当中进行分析, 然后CU分析之后发现000010, 这是一条纯数的指令, 也就是要把acc里边的数据, 把它存到地址码所指明的存储单元当中, 那这个地址码转换成十进制, 应该是8, 而8这个存储单元, 刚好对应的是y这个变量的存储位置, </li><li>那现在acc里面存的是七, 也就是a乘以b加c的值好, 接下来执行这个存储指令, 首先会把这个指令的地址码部分, 把它送到mar里边, 用来指明此次我要存入的是哪一个存储单元</li><li>另外还需要把acc里边的运算结果, 通过数据总线把它送到mdr当中, 也就是说, 此时mdr里边保存了a乘以b加c的值, 并且此时mar里边指明了这个值是要存到内存地址为八的这个地方</li><li>接下来, cu控制单元会通过控制总线告诉主存储器说, 我此次要进行的是一个存一个写的操作, 于是主存储器会根据mar所指明的地址, 把mdr当中的这个数据放到相应的位置当中, 这就导致了8号存储单元, 它的值变为了7, 也就是我们最终想要得到的这个结果, y等于a乘以b加c</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061215060.png" alt="image-20230506121532003"></p><ul><li>pc再加一指向下一条应该执行的指令,  首先需要取出指令, 把这个指令把它取到ir指令寄存器当中, 然后接下来要把操作码部分送到cu里边, 然后cu一分析发现000110 , 这个操作码对应的是停机指令, 所以执行到这一步, 就知道我们的这段程序运行结束了,</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305061217589.png" alt="image-20230506121701532"></p><ul><li>取数指令的执行过程分为取指令, 分析指令和执行指令这样的三个阶段, 任何一条指令的执行一定都是这样的三个阶段, 那无论我们执行的是什么指令, 前边取指令和分析指令的这些步骤, 其实都是一模一样的</li><li>只有分析完指令之后, cu才可以知道这条指令到底是要做什么, 于是接下来的这些步骤啊, 对于不同的指令来说就有可能不一样, </li><li>在取指令的阶段, mdr里的数据肯定是要传送到ir指令寄存器当中, 而在执行指令的阶段, cu会根据具体的这条指令来决定mdr里的数据应该是放到acc还是放到mq, 还是放到其他的通用寄存器里边</li><li>所以根据指令执行周期的不同, 它处于不同的阶段, cpu就可以区分出这次从内存里取出的,到底是指令还是数据了</li></ul><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305111443076.png" alt="image-20230511144327858"></p><h3 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305111444479.png" alt="image-20230511144455380"></p><p><strong>编译程序和解释程序的区别</strong></p><ul><li>编译程序是直接把高级语言编写的语言程序, 全部一次性翻译成机器语言程序, 然后再来执行这个机器语言程序, 我们只需要进行一次编译，之后就不需要再编译了，比如我们用c语言写的程序, 把它经过编译, 还有汇编这些步骤之后, 最终会形成一个大家都很熟悉的文件, 叫做.exe文件, 那这个.exe文件, 就是用机器语言描述的程序</li><li>而解释程序是这样的一个原理, 比如我们用javascript这种脚本语言写了几句代码, 用高级语言写的代码, 这几句代码在执行的时候, 每执行一句都会丢给解释程序, 来帮我们把这个代码翻译成与之对等的机器语言, 翻译一句就立即执行, 紧接着再翻译下一句, 所以每一次我们要执行这段代码的时候, 解释程序都需要翻译一遍</li><li>显然编译型的语言, 执行效率更高，解释型的语言执行效率会更低</li></ul><h3 id="计算机体系结构VS计算机组成原理"><a href="#计算机体系结构VS计算机组成原理" class="headerlink" title="计算机体系结构VS计算机组成原理"></a>计算机体系结构VS计算机组成原理</h3><ul><li><p>计算机体系结构——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I&#x2F;O机理）</p><ul><li>计算机体系结构这门课必须要探讨的是, 指令系统应该怎么设计, 也就是说我设计的这台计算机, 要对上层的机器语言程序员提供哪一些指令</li><li>也就是：如何设计硬件和软件之间的接口</li></ul></li><li><p>计算机组成原理——实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p><ul><li>怎么用硬件来实现我们定义的这些接口</li></ul></li></ul><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202305111459898.png" alt="image-20230511145956781"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><strong>总容量&#x3D;存储单元个数*存储字长 bit</strong></p><p>​            <strong>&#x3D;存储单元个数*存储字长&#x2F;8 Byte</strong></p><ul><li>MAR（存储地址寄存器）位数反映存储单元的个数</li><li>MDR（存储数据寄存器）位数反映存储字长，也就是每个存储单元的大小</li></ul><blockquote><p>Eg: MAR为32位 MDR为8位</p></blockquote><p>总容量 &#x3D; 2^32*8 bit &#x3D; 2^32 Byte&#x3D; 4 GB</p><h3 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h3><ul><li><p>CPU主频：CPU内数字脉冲信号振荡的频率，也就是每秒钟有多少个脉冲信号振荡，为计算简便，可以看成每秒钟有多少个时钟周期.</p></li><li><p>CPU时钟周期：每个脉冲信号的时间  </p></li><li><p>CPU主频（时钟频率）&#x3D;1&#x2F;CPU时钟周期</p></li><li><p>CPI：执行一条指令所需的时钟周期</p><ul><li>不同的指令，CPI不同，甚至相同的指令，CPI也可能变化</li><li>一般考虑CPI，是平均的情况</li></ul></li><li><p>执行一条指令的耗时 &#x3D; CPI*CPU时钟周期</p></li><li><p>CPU执行时间（整个程序的耗时）&#x3D;CPU时间周期数&#x2F;主频&#x3D;（指令条数*CPI）&#x2F;主频</p></li><li><p>IPS：每秒执行多少条指令</p></li><li><p>IPS &#x3D; 主频&#x2F;平均CPI</p></li><li><p>FLOPS：每秒执行多少次浮点运算</p></li></ul><blockquote><p>Eg：某CPU主频为1000HZ，某程序包含100条指令，平均来看指令的CPI&#x3D;3，该程序在CPU上执行需要多久</p></blockquote><p>100 * 3 * 1&#x2F;1000 &#x3D;0.3 s</p><h3 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h3><ul><li><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p></li><li><p>吞吐量：指系统在单位时间内处理请求的数量</p><ul><li>取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，<strong>系统吞吐量主要取决于主存的存取周期</strong></li></ul></li><li><p>响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间</p></li><li><p>基准程序（跑分软件）：用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较</p></li></ul><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><blockquote><p>主频高的CPU一定比主频低的CPU快吗？</p></blockquote><ul><li>不一定，如两个CPU，A的主频为2GHz，平均CPI&#x3D;10；B的主频1GHz，平均CPI&#x3D;1，那么A一秒钟可以执行0.2G条指令，而B一秒钟可以执行1G条指令</li></ul><blockquote><p>若A、B两个CPU的平均CPI相同，那么A一定更快吗？</p></blockquote><p>不一定，还要看指令系统，如果A不支持乘法指令，只能用多次加法实现乘法，而B支持乘法指令 </p><blockquote><p>基准程序执行得越快，说明机器性能越好吗</p></blockquote><p>基准程序的语句存在频度差异，运行结果也不能完全说明问题</p>]]></content>
    
    
    <categories>
      
      <category>王道计组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王道计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令大全</title>
    <link href="/2023/03/14/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <url>/2023/03/14/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>arch</td><td>显示机器的处理器架构(1)</td></tr><tr><td>uname -m</td><td>显示机器的处理器架构(2)</td></tr><tr><td>uname -r</td><td>显示正在使用的内核版本</td></tr><tr><td>dmidecode -q</td><td>显示硬件系统部件 - (SMBIOS &#x2F; DMI)</td></tr><tr><td>hdparm -i &#x2F;dev&#x2F;hda</td><td>罗列一个磁盘的架构特性</td></tr><tr><td>hdparm -tT &#x2F;dev&#x2F;sda</td><td>在磁盘上执行测试性读取操作</td></tr><tr><td>cat &#x2F;proc&#x2F;cpuinfo</td><td>显示CPU info的信息</td></tr><tr><td>cat &#x2F;proc&#x2F;interrupts</td><td>显示中断</td></tr><tr><td>cat &#x2F;proc&#x2F;meminfo</td><td>校验内存使用</td></tr><tr><td>cat &#x2F;proc&#x2F;swaps</td><td>显示哪些swap被使用</td></tr><tr><td>cat &#x2F;proc&#x2F;version</td><td>显示内核的版本</td></tr><tr><td>cat &#x2F;proc&#x2F;net&#x2F;dev</td><td>显示网络适配器及统计</td></tr><tr><td>cat &#x2F;proc&#x2F;mounts</td><td>显示已加载的文件系统</td></tr><tr><td>lspci -tv</td><td>罗列 PCI 设备</td></tr><tr><td>lsusb -tv</td><td>显示 USB 设备</td></tr><tr><td>date</td><td>显示系统日期</td></tr><tr><td>cal 2007</td><td>显示2007年的日历表</td></tr><tr><td>date 041217002007.00</td><td>设置日期和时间 - 月日时分年.秒</td></tr><tr><td>clock -w</td><td>将时间修改保存到 BIOS</td></tr></tbody></table><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>关闭系统(1)</td></tr><tr><td>init 0</td><td>关闭系统(2)</td></tr><tr><td>telinit 0</td><td>关闭系统(3)</td></tr><tr><td>shutdown -h hours:minutes</td><td>按预定时间关闭系统</td></tr><tr><td>shutdown -c</td><td>取消按预定时间关闭系统</td></tr><tr><td>shutdown -r now</td><td>重启(1)</td></tr><tr><td>reboot</td><td>重启(2)</td></tr><tr><td>logout</td><td>注销</td></tr></tbody></table><h3 id="文件和目录查看"><a href="#文件和目录查看" class="headerlink" title="文件和目录查看"></a>文件和目录查看</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>cd &#x2F;home</td><td>进入 ‘&#x2F; home’ 目录’</td></tr><tr><td>cd ..</td><td>返回上一级目录</td></tr><tr><td>cd ..&#x2F;..</td><td>返回上两级目录</td></tr><tr><td>cd</td><td>进入个人的主目录</td></tr><tr><td>cd ~user1</td><td>进入个人的主目录</td></tr><tr><td>cd -</td><td>返回上次所在的目录</td></tr><tr><td>pwd</td><td>显示工作路径</td></tr><tr><td>ls</td><td>查看目录中的文件</td></tr><tr><td>ls -F</td><td>查看目录中的文件</td></tr><tr><td>ls -l</td><td>显示文件和目录的详细资料</td></tr><tr><td>ls -a</td><td>显示隐藏文件</td></tr><tr><td>ls <em>[0-9]</em></td><td>显示包含数字的文件名和目录名</td></tr><tr><td>tree</td><td>显示文件和目录由根目录开始的树形结构(1)</td></tr><tr><td>lstree</td><td>显示文件和目录由根目录开始的树形结构(2)</td></tr><tr><td>mkdir dir1</td><td>创建一个叫做 ‘dir1’ 的目录’</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个目录</td></tr><tr><td>mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2</td><td>创建一个目录树</td></tr><tr><td>rm -f file1</td><td>删除一个叫做 ‘file1’ 的文件’</td></tr><tr><td>rmdir dir1</td><td>删除一个叫做 ‘dir1’ 的目录’</td></tr><tr><td>rm -rf dir1</td><td>删除一个叫做 ‘dir1’ 的目录并同时删除其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个目录及它们的内容</td></tr><tr><td>mv dir1 new_dir</td><td>重命名&#x2F;移动 一个目录</td></tr><tr><td>cp file1 file2</td><td>复制一个文件</td></tr><tr><td>cp dir&#x2F;* .</td><td>复制一个目录下的所有文件到当前工作目录</td></tr><tr><td>cp -a &#x2F;tmp&#x2F;dir1 .</td><td>复制一个目录到当前工作目录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制一个目录</td></tr><tr><td>ln -s file1 lnk1</td><td>创建一个指向文件或目录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建一个指向文件或目录的物理链接</td></tr><tr><td>touch -t 0712250000 file1</td><td>修改一个文件或目录的时间戳 - (YYMMDDhhmm)</td></tr><tr><td>iconv -l</td><td>列出已知的编码</td></tr></tbody></table><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>find &#x2F; -name file1</td><td>从 ‘&#x2F;‘ 开始进入根文件系统搜索文件和目录</td></tr><tr><td>find &#x2F; -user user1</td><td>搜索属于用户 ‘user1’ 的文件和目录</td></tr><tr><td>find &#x2F;home&#x2F;user1 -name *.bin</td><td>在目录 ‘&#x2F; home&#x2F;user1’ 中搜索带有’.bin’ 结尾的文件</td></tr><tr><td>find &#x2F;usr&#x2F;bin -type f -atime +100</td><td>搜索在过去100天内未被使用过的执行文件</td></tr><tr><td>find &#x2F;usr&#x2F;bin -type f -mtime -10</td><td>搜索在10天内被创建或者修改过的文件</td></tr><tr><td>find &#x2F; -name *.rpm -exec chmod 755 ‘{}’ ;</td><td>搜索以 ‘.rpm’ 结尾的文件并定义其权限</td></tr><tr><td>find &#x2F; -xdev -name *.rpm</td><td>搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备</td></tr><tr><td>locate *.ps 寻找以 ‘.ps’</td><td>结尾的文件 - 先运行 ‘updatedb’ 命令</td></tr><tr><td>whereis halt</td><td>显示一个二进制文件、源码或man的位置</td></tr><tr><td>which halt</td><td>显示一个二进制文件或可执行文件的完整路径</td></tr></tbody></table><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2</td><td>挂载一个叫做hda2的盘 - 确定目录 ‘&#x2F; mnt&#x2F;hda2’ 已经存在</td></tr><tr><td>umount &#x2F;dev&#x2F;hda2</td><td>卸载一个叫做hda2的盘 - 先从挂载点 ‘&#x2F; mnt&#x2F;hda2’ 退出</td></tr><tr><td>fuser -km &#x2F;mnt&#x2F;hda2</td><td>当设备繁忙时强制卸载</td></tr><tr><td>umount -n &#x2F;mnt&#x2F;hda2</td><td>运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用</td></tr><tr><td>mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy</td><td>挂载一个软盘</td></tr><tr><td>mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom</td><td>挂载一个cdrom或dvdrom</td></tr><tr><td>mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder</td><td>挂载一个cdrw或dvdrom</td></tr><tr><td>mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder</td><td>挂载一个cdrw或dvdrom</td></tr><tr><td>mount -o loop file.iso &#x2F;mnt&#x2F;cdrom</td><td>挂载一个文件或ISO镜像文件</td></tr><tr><td>mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5</td><td>挂载一个Windows FAT32文件系统</td></tr><tr><td>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk</td><td>挂载一个usb 捷盘或闪存设备</td></tr><tr><td>mount -t smbfs -o username&#x3D;user,password&#x3D;pass &#x2F;&#x2F;WinClient&#x2F;share &#x2F;mnt&#x2F;share</td><td>挂载一个windows网络共享</td></tr></tbody></table><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>df -h</td><td>显示已经挂载的分区列表</td></tr><tr><td>ls -lSr | more</td><td>以尺寸大小排列文件和目录</td></tr><tr><td>du -sh dir1</td><td>估算目录 ‘dir1’ 已经使用的磁盘空间’</td></tr><tr><td>du -sk * | sort -rn</td><td>以容量大小为依据依次显示文件和目录的大小</td></tr><tr><td>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n</td><td>以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</td></tr><tr><td>dpkg-query -W -f&#x3D;’<img src="https://math.jianshu.com/math?formula=%7BInstalled-Size;10%7Dt" alt="{Installed-Size;10}t">{Package}n’ | sort -k1,1n</td><td>以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</td></tr></tbody></table><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>groupadd group_name</td><td>创建一个新用户组</td></tr><tr><td>groupdel group_name</td><td>删除一个用户组</td></tr><tr><td>groupmod -n new_group_name old_group_name</td><td>重命名一个用户组</td></tr><tr><td>useradd -c “Name Surname “ -g admin -d &#x2F;home&#x2F;user1 -s &#x2F;bin&#x2F;bash user1</td><td>创建一个属于 “admin” 用户组的用户</td></tr><tr><td>useradd user1</td><td>创建一个新用户</td></tr><tr><td>userdel -r user1</td><td>删除一个用户 ( ‘-r’ 排除主目录)</td></tr><tr><td>usermod -c “User FTP” -g system -d &#x2F;ftp&#x2F;user1 -s &#x2F;bin&#x2F;nologin user1</td><td>修改用户属性</td></tr><tr><td>passwd</td><td>修改口令</td></tr><tr><td>passwd user1</td><td>修改一个用户的口令 (只允许root执行)</td></tr><tr><td>chage -E 2005-12-31 user1</td><td>设置用户口令的失效期限</td></tr><tr><td>pwck</td><td>检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的用户</td></tr><tr><td>grpck</td><td>检查 ‘&#x2F;etc&#x2F;passwd’ 的文件格式和语法修正以及存在的群组</td></tr><tr><td>newgrp group_name</td><td>登陆进一个新的群组以改变新创建文件的预设群组</td></tr></tbody></table><h3 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ls -lh</td><td>显示权限</td></tr><tr><td>ls &#x2F;tmp | pr -T5 -W$COLUMNS</td><td>将终端划分成5栏显示</td></tr><tr><td>chmod ugo+rwx directory1</td><td>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</td></tr><tr><td>chmod go-rwx directory1</td><td>删除群组(g)与其他人(o)对目录的读写执行权限</td></tr><tr><td>chown user1 file1</td><td>改变一个文件的所有人属性</td></tr><tr><td>chown -R user1 directory1</td><td>改变一个目录的所有人属性并同时改变改目录下所有文件的属性</td></tr><tr><td>chgrp group1 file1</td><td>改变文件的群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变一个文件的所有人和群组属性</td></tr><tr><td>find &#x2F; -perm -u+s</td><td>罗列一个系统中所有使用了SUID控制的文件</td></tr><tr><td>chmod u+s &#x2F;bin&#x2F;file1</td><td>设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</td></tr><tr><td>chmod u-s &#x2F;bin&#x2F;file1</td><td>禁用一个二进制文件的 SUID位</td></tr><tr><td>chmod g+s &#x2F;home&#x2F;public</td><td>设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</td></tr><tr><td>chmod g-s &#x2F;home&#x2F;public</td><td>禁用一个目录的 SGID 位</td></tr><tr><td>chmod o+t &#x2F;home&#x2F;public</td><td>设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</td></tr><tr><td>chmod o-t &#x2F;home&#x2F;public</td><td>禁用一个目录的 STIKY 位</td></tr></tbody></table><h3 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>chattr +a file1</td><td>只允许以追加方式读写文件</td></tr><tr><td>chattr +c file1</td><td>允许这个文件能被内核自动压缩&#x2F;解压</td></tr><tr><td>chattr +d file1</td><td>在进行文件系统备份时，dump程序将忽略这个文件</td></tr><tr><td>chattr +i file1</td><td>设置成不可变的文件，不能被删除、修改、重命名或者链接</td></tr><tr><td>chattr +s file1</td><td>允许一个文件被安全地删除</td></tr><tr><td>chattr +S file1</td><td>一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</td></tr><tr><td>chattr +u file1</td><td>若文件被删除，系统会允许你在以后恢复这个被删除的文件</td></tr></tbody></table><p>lsattr 显示特殊的属性</p><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>bunzip2 file1.bz2</td><td>解压一个叫做 ‘file1.bz2’的文件</td></tr><tr><td>bzip2 file1</td><td>压缩一个叫做 ‘file1’ 的文件</td></tr><tr><td>gunzip file1.gz</td><td>解压一个叫做 ‘file1.gz’的文件</td></tr><tr><td>gzip file1</td><td>压缩一个叫做 ‘file1’的文件</td></tr><tr><td>gzip -9 file1</td><td>最大程度压缩</td></tr><tr><td>rar a file1.rar test_file</td><td>创建一个叫做 ‘file1.rar’ 的包</td></tr><tr><td>rar a file1.rar file1 file2 dir1</td><td>同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’</td></tr><tr><td>rar x file1.rar</td><td>解压rar包</td></tr><tr><td>unrar x file1.rar</td><td>解压rar包</td></tr><tr><td>tar -cvf archive.tar file1</td><td>创建一个非压缩的 tarball</td></tr><tr><td>tar -cvf archive.tar file1 file2 dir1</td><td>创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件</td></tr><tr><td>tar -tf archive.tar</td><td>显示一个包中的内容</td></tr><tr><td>tar -xvf archive.tar</td><td>释放一个包</td></tr><tr><td>tar -xvf archive.tar -C &#x2F;tmp</td><td>将压缩包释放到 &#x2F;tmp目录下</td></tr><tr><td>tar -cvfj archive.tar.bz2 dir1</td><td>创建一个bzip2格式的压缩包</td></tr><tr><td>tar -jxvf archive.tar.bz2</td><td>解压一个bzip2格式的压缩包</td></tr><tr><td>tar -cvfz archive.tar.gz dir1</td><td>创建一个gzip格式的压缩包</td></tr><tr><td>tar -zxvf archive.tar.gz</td><td>解压一个gzip格式的压缩包</td></tr><tr><td>zip file1.zip file1</td><td>创建一个zip格式的压缩包</td></tr><tr><td>zip -r file1.zip file1 file2 dir1</td><td>将几个文件和目录同时压缩成一个zip格式的压缩包</td></tr><tr><td>unzip file1.zip</td><td>解压一个zip格式压缩包</td></tr></tbody></table><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>rpm -ivh package.rpm</td><td>安装一个rpm包</td></tr><tr><td>rpm -ivh –nodeeps package.rpm</td><td>安装一个rpm包而忽略依赖关系警告</td></tr><tr><td>rpm -U package.rpm</td><td>更新一个rpm包但不改变其配置文件</td></tr><tr><td>rpm -F package.rpm</td><td>更新一个确定已经安装的rpm包</td></tr><tr><td>rpm -e package_name.rpm</td><td>删除一个rpm包</td></tr><tr><td>rpm -qa</td><td>显示系统中所有已经安装的rpm包</td></tr><tr><td>rpm -qa | grep httpd</td><td>显示所有名称中包含 “httpd” 字样的rpm包</td></tr><tr><td>rpm -qi package_name</td><td>获取一个已安装包的特殊信息</td></tr><tr><td>rpm -qg “System Environment&#x2F;Daemons”</td><td>显示一个组件的rpm包</td></tr><tr><td>rpm -ql package_name</td><td>显示一个已经安装的rpm包提供的文件列表</td></tr><tr><td>rpm -qc package_name</td><td>显示一个已经安装的rpm包提供的配置文件列表</td></tr><tr><td>rpm -q package_name –whatrequires</td><td>显示与一个rpm包存在依赖关系的列表</td></tr><tr><td>rpm -q package_name –whatprovides</td><td>显示一个rpm包所占的体积</td></tr><tr><td>rpm -q package_name –scripts</td><td>显示在安装&#x2F;删除期间所执行的脚本l</td></tr><tr><td>rpm -q package_name –changelog</td><td>显示一个rpm包的修改历史</td></tr><tr><td>rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</td><td>确认所给的文件由哪个rpm包所提供</td></tr><tr><td>rpm -qp package.rpm -l</td><td>显示由一个尚未安装的rpm包提供的文件列表</td></tr><tr><td>rpm –import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY</td><td>导入公钥数字证书</td></tr><tr><td>rpm –checksig package.rpm</td><td>确认一个rpm包的完整性</td></tr><tr><td>rpm -qa gpg-pubkey</td><td>确认已安装的所有rpm包的完整性</td></tr><tr><td>rpm -V package_name</td><td>检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</td></tr><tr><td>rpm -Va</td><td>检查系统中所有已安装的rpm包- 小心使用</td></tr><tr><td>rpm -Vp package.rpm</td><td>确认一个rpm包还未安装</td></tr><tr><td>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em></td><td>从一个rpm包运行可执行文件</td></tr><tr><td>rpm -ivh  &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;arch&#x2F;package.rpm</td><td>从一个rpm源码安装一个构建好的包</td></tr><tr><td>rpmbuild –rebuild package_name.src.rpm</td><td>从一个rpm源码构建一个 rpm 包</td></tr></tbody></table><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>yum install package_name</td><td>下载并安装一个rpm包</td></tr><tr><td>yum localinstall package_name.rpm</td><td>将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</td></tr><tr><td>yum update package_name.rpm</td><td>更新当前系统中所有安装的rpm包</td></tr><tr><td>yum update package_name</td><td>更新一个rpm包</td></tr><tr><td>yum remove package_name</td><td>删除一个rpm包</td></tr><tr><td>yum list</td><td>列出当前系统中安装的所有包</td></tr><tr><td>yum search package_name</td><td>在rpm仓库中搜寻软件包</td></tr><tr><td>yum clean packages</td><td>清理rpm缓存删除下载的包</td></tr><tr><td>yum clean headers</td><td>删除所有头文件</td></tr><tr><td>yum clean all</td><td>删除所有缓存的包和头文件</td></tr></tbody></table><h2 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>dpkg -i package.deb</td><td>安装&#x2F;更新一个 deb 包</td></tr><tr><td>dpkg -r package_name</td><td>从系统删除一个 deb 包</td></tr><tr><td>dpkg -l</td><td>显示系统中所有已经安装的 deb 包</td></tr><tr><td>dpkg -l | grep httpd</td><td>显示所有名称中包含 “httpd” 字样的deb包</td></tr><tr><td>dpkg -s package_name</td><td>获得已经安装在系统中一个特殊包的信息</td></tr><tr><td>dpkg -L package_name</td><td>显示系统中已经安装的一个deb包所提供的文件列表</td></tr><tr><td>dpkg –contents package.deb</td><td>显示尚未安装的一个包所提供的文件列表</td></tr><tr><td>dpkg -S &#x2F;bin&#x2F;ping</td><td>确认所给的文件由哪个deb包提供</td></tr></tbody></table><h2 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>apt-get install package_name</td><td>安装&#x2F;更新一个 deb 包</td></tr><tr><td>apt-cdrom install package_name</td><td>从光盘安装&#x2F;更新一个 deb 包</td></tr><tr><td>apt-get update</td><td>升级列表中的软件包</td></tr><tr><td>apt-get upgrade</td><td>升级所有已安装的软件</td></tr><tr><td>apt-get remove package_name</td><td>从系统删除一个deb包</td></tr><tr><td>apt-get check</td><td>确认依赖的软件仓库正确</td></tr><tr><td>apt-get clean</td><td>从下载的软件包中清理缓存</td></tr><tr><td>apt-cache search searched-package</td><td>返回包含所要搜索字符串的软件包名称</td></tr></tbody></table><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容*"></a>查看文件内容*</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>cat file1</td><td>从第一个字节开始正向查看文件的内容</td></tr><tr><td>tac file1</td><td>从最后一行开始反向查看一个文件的内容</td></tr><tr><td>more file1</td><td>查看一个长文件的内容</td></tr><tr><td>less file1</td><td>类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</td></tr><tr><td>head -2 file1</td><td>查看一个文件的前两行</td></tr><tr><td>tail -2 file1</td><td>查看一个文件的最后两行</td></tr><tr><td>tail -f &#x2F;var&#x2F;log&#x2F;messages</td><td>实时查看被添加到一个文件中的内容</td></tr></tbody></table><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt</td><td>合并一个文件的详细说明文本，并将简介写入一个新文件中</td></tr><tr><td>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt</td><td>合并一个文件的详细说明文本，并将简介写入一个已有的文件中</td></tr><tr><td>grep Aug &#x2F;var&#x2F;log&#x2F;messages</td><td>在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找关键词”Aug”</td></tr><tr><td>grep ^Aug &#x2F;var&#x2F;log&#x2F;messages</td><td>在文件 ‘&#x2F;var&#x2F;log&#x2F;messages’中查找以”Aug”开始的词汇</td></tr><tr><td>grep [0-9] &#x2F;var&#x2F;log&#x2F;messages</td><td>选择 ‘&#x2F;var&#x2F;log&#x2F;messages’ 文件中所有包含数字的行</td></tr><tr><td>grep Aug -R &#x2F;var&#x2F;log&#x2F;*</td><td>在目录 ‘&#x2F;var&#x2F;log’ 及随后的目录中搜索字符串”Aug”</td></tr><tr><td>sed ‘s&#x2F;stringa1&#x2F;stringa2&#x2F;g’ example.txt</td><td>将example.txt文件中的 “string1” 替换成 “string2”</td></tr><tr><td>sed ‘&#x2F;^$&#x2F;d’ example.txt</td><td>从example.txt文件中删除所有空白行</td></tr><tr><td>sed ‘&#x2F; *#&#x2F;d; &#x2F;^$&#x2F;d’ example.txt</td><td>从example.txt文件中删除所有注释和空白行</td></tr><tr><td>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’</td><td>合并上下单元格内容</td></tr><tr><td>sed -e ‘1d’ result.txt 从文件example.txt</td><td>中排除第一行</td></tr><tr><td>sed -n ‘&#x2F;stringa1&#x2F;p’</td><td>查看只包含词汇 “string1”的行</td></tr><tr><td>sed -e ‘s&#x2F; *$&#x2F;&#x2F;‘ example.txt</td><td>删除每一行最后的空白字符</td></tr><tr><td>sed -e ‘s&#x2F;stringa1&#x2F;&#x2F;g’ example.txt</td><td>从文档中只删除词汇 “string1” 并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ example.txt</td><td>查看从第一行到第5行内容</td></tr><tr><td>sed -n ‘5p;5q’ example.txt</td><td>查看第5行</td></tr><tr><td>sed -e ‘s&#x2F;00*&#x2F;0&#x2F;g’ example.txt</td><td>用单个零替换多个零</td></tr><tr><td>cat -n file1</td><td>标示文件的行数</td></tr><tr><td>cat example.txt | awk ‘NR%2&#x3D;&#x3D;1’</td><td>删除example.txt文件中的所有偶数行</td></tr><tr><td>echo a b c | awk ‘{print $1}’</td><td>查看一行第一栏</td></tr><tr><td>echo a b c | awk ‘{print <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141134478.svg+xml;%20charset=utf-8" alt="1,">3}’</td><td>查看一行的第一和第三栏</td></tr><tr><td>paste file1 file2</td><td>合并两个文件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个文件或两栏的内容，中间用”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个文件的内容</td></tr><tr><td>sort file1 file2 | uniq</td><td>取出两个文件的并集(重复的行只保留一份)</td></tr><tr><td>sort file1 file2 | uniq -u</td><td>删除交集，留下其他的行</td></tr><tr><td>sort file1 file2 | uniq -d</td><td>取出两个文件的交集(只留下同时存在于两个文件中的文件)</td></tr><tr><td>comm -1 file1 file2</td><td>比较两个文件的内容只删除 ‘file1’ 所包含的内容</td></tr><tr><td>comm -2 file1 file2</td><td>比较两个文件的内容只删除 ‘file2’ 所包含的内容</td></tr><tr><td>comm -3 file1 file2</td><td>比较两个文件的内容只删除两个文件共有的部分</td></tr></tbody></table><h2 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>dos2unix filedos.txt fileunix.txt</td><td>将一个文本文件的格式从MSDOS转换成UNIX</td></tr><tr><td>unix2dos fileunix.txt filedos.txt</td><td>将一个文本文件的格式从UNIX转换成MSDOS</td></tr><tr><td>recode ..HTML &lt; page.txt &gt; page.html</td><td>将一个文本文件转换成html</td></tr><tr><td>recode -l | more</td><td>显示所有允许的转换格式</td></tr></tbody></table><h2 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>badblocks -v &#x2F;dev&#x2F;hda1</td><td>检查磁盘hda1上的坏磁块</td></tr><tr><td>fsck &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上linux文件系统的完整性</td></tr><tr><td>fsck.ext2 &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上ext2文件系统的完整性</td></tr><tr><td>e2fsck &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上ext2文件系统的完整性</td></tr><tr><td>e2fsck -j &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上ext3文件系统的完整性</td></tr><tr><td>fsck.ext3 &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上ext3文件系统的完整性</td></tr><tr><td>fsck.vfat &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上fat文件系统的完整性</td></tr><tr><td>fsck.msdos &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上dos文件系统的完整性</td></tr><tr><td>dosfsck &#x2F;dev&#x2F;hda1</td><td>修复&#x2F;检查hda1磁盘上dos文件系统的完整性</td></tr></tbody></table><h2 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>mkfs &#x2F;dev&#x2F;hda1</td><td>在hda1分区创建一个文件系统</td></tr><tr><td>mke2fs &#x2F;dev&#x2F;hda1</td><td>在hda1分区创建一个linux ext2的文件系统</td></tr><tr><td>mke2fs -j &#x2F;dev&#x2F;hda1</td><td>在hda1分区创建一个linux ext3(日志型)的文件系统</td></tr><tr><td>mkfs -t vfat 32 -F &#x2F;dev&#x2F;hda1</td><td>创建一个 FAT32 文件系统</td></tr><tr><td>fdformat -n &#x2F;dev&#x2F;fd0</td><td>格式化一个软盘</td></tr><tr><td>mkswap &#x2F;dev&#x2F;hda3</td><td>创建一个swap文件系统</td></tr></tbody></table><h2 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>mkswap &#x2F;dev&#x2F;hda3</td><td>创建一个swap文件系统</td></tr><tr><td>swapon &#x2F;dev&#x2F;hda3</td><td>启用一个新的swap文件系统</td></tr><tr><td>swapon &#x2F;dev&#x2F;hda2 &#x2F;dev&#x2F;hdb3</td><td>启用两个swap分区</td></tr></tbody></table><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home</td><td>制作一个 ‘&#x2F;home’ 目录的完整备份</td></tr><tr><td>dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home</td><td>制作一个 ‘&#x2F;home’ 目录的交互式备份</td></tr><tr><td>restore -if &#x2F;tmp&#x2F;home0.bak</td><td>还原一个交互式备份</td></tr><tr><td>rsync -rogpav –delete &#x2F;home &#x2F;tmp</td><td>同步两边的目录</td></tr><tr><td>rsync -rogpav -e ssh –delete &#x2F;home ip_address:&#x2F;tmp</td><td>通过SSH通道rsync</td></tr><tr><td>rsync -az -e ssh –delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local</td><td>通过ssh和压缩将一个远程目录同步到本地目录</td></tr><tr><td>rsync -az -e ssh –delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public</td><td>通过ssh和压缩将本地目录同步到远程目录</td></tr><tr><td>dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr ‘dd of&#x3D;hda.gz’</td><td>通过ssh在远程主机上执行一次备份本地磁盘的操作</td></tr><tr><td>dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1</td><td>备份磁盘内容到一个文件</td></tr><tr><td>tar -Puf backup.tar &#x2F;home&#x2F;user</td><td>执行一次对 ‘&#x2F;home&#x2F;user’ 目录的交互式备份操作</td></tr><tr><td>( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p’</td><td>通过ssh在远程目录中复制一个目录内容</td></tr><tr><td>( tar c &#x2F;home )</td><td>ssh -C user@ip_addr ‘cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录</td></tr><tr><td>tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - )</td><td>本地将一个目录复制到另一个地方，保留原有权限及链接</td></tr><tr><td>find &#x2F;home&#x2F;user1 -name ‘*.txt’ | xargs cp -av –target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; –parents</td><td>从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录</td></tr><tr><td>find &#x2F;var&#x2F;log -name ‘*.log’ | tar cv –files-from&#x3D;- | bzip2 &gt; log.tar.bz2</td><td>查找所有以 ‘.log’ 结尾的文件并做成一个bzip包</td></tr><tr><td>dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1</td><td>做一个将 MBR (Master Boot Record)内容复制到软盘的动作</td></tr><tr><td>dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1</td><td>从已经保存到软盘的备份中恢复MBR内容</td></tr></tbody></table><h2 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>cdrecord -v gracetime&#x3D;2 dev&#x3D;&#x2F;dev&#x2F;cdrom -eject blank&#x3D;fast -force</td><td>清空一个可复写的光盘内容</td></tr><tr><td>mkisofs &#x2F;dev&#x2F;cdrom &gt; cd.iso</td><td>在磁盘上创建一个光盘的iso镜像文件</td></tr><tr><td>mkisofs &#x2F;dev&#x2F;cdrom | gzip &gt; cd_iso.gz</td><td>在磁盘上创建一个压缩了的光盘iso镜像文件</td></tr><tr><td>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o .&#x2F;cd.iso data_cd</td><td>创建一个目录的iso镜像文件</td></tr><tr><td>cdrecord -v dev&#x3D;&#x2F;dev&#x2F;cdrom cd.iso</td><td>刻录一个ISO镜像文件</td></tr><tr><td>gzip -dc cd_iso.gz | cdrecord dev&#x3D;&#x2F;dev&#x2F;cdrom -</td><td>刻录一个压缩了的ISO镜像文件</td></tr><tr><td>mount -o loop cd.iso &#x2F;mnt&#x2F;iso</td><td>挂载一个ISO镜像文件</td></tr><tr><td>cd-paranoia -B</td><td>从一个CD光盘转录音轨到 wav 文件中</td></tr><tr><td>cd-paranoia – “-3”</td><td>从一个CD光盘转录音轨到 wav 文件中（参数-3）</td></tr><tr><td>cdrecord –scanbus</td><td>扫描总线以识别scsi通道</td></tr><tr><td>dd if&#x3D;&#x2F;dev&#x2F;hdc | md5sum</td><td>校验一个设备的md5sum编码，例如一张 CD</td></tr></tbody></table><h2 id="网络-（以太网和WIFI无线-）"><a href="#网络-（以太网和WIFI无线-）" class="headerlink" title="网络 - （以太网和WIFI无线**）"></a>网络 - （以太网和WIFI无线**）</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ifconfig eth0</td><td>显示一个以太网卡的配置</td></tr><tr><td>ifup eth0</td><td>启用一个 ‘eth0’ 网络设备</td></tr><tr><td>ifdown eth0</td><td>禁用一个 ‘eth0’ 网络设备</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>控制IP地址</td></tr><tr><td>ifconfig eth0 promisc 设置 ‘eth0’</td><td>成混杂模式以嗅探数据包 (sniffing)</td></tr><tr><td>dhclient eth0 以dhcp</td><td>模式启用 ‘eth0’</td></tr></tbody></table><p>作者：yichen_china<br>链接：<a href="https://www.jianshu.com/p/ca2d79cc344f">https://www.jianshu.com/p/ca2d79cc344f</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习</title>
    <link href="/2023/03/14/Linux%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/14/Linux%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux文件基本属性"><a href="#Linux文件基本属性" class="headerlink" title="Linux文件基本属性"></a>Linux文件基本属性</h1><p>在Linux中我们常用一下两个命令来修改文件或目录的所属用户与权限：</p><ul><li>chown（change owner）：修改所属用户与组</li><li>chmod（change mode）：修改用户的权限</li></ul><p>在Linux中我们可使用<code>ls -l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www /]<span class="hljs-comment"># ls -l</span><br>total 64<br>dr-xr-xr-x  <span class="hljs-number"> 2 </span>root root<span class="hljs-number"> 4096 </span>Dec<span class="hljs-number"> 14 </span><span class="hljs-number"> 2012 </span>bin<br>dr-xr-xr-x  <span class="hljs-number"> 4 </span>root root<span class="hljs-number"> 4096 </span>Apr<span class="hljs-number"> 19 </span><span class="hljs-number"> 2012 </span>boot<br>……<br></code></pre></td></tr></table></figure><p>实例中，<strong>bin</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p><p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为 <strong>d</strong> 则是目录</li><li>当为 <strong>-</strong> 则是文件；</li><li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li><li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141141687.png" alt="image-20230314114115614"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141156823.png" alt="image-20230314115600767"></p><h2 id="Linux文件属主和属组"><a href="#Linux文件属主和属组" class="headerlink" title="Linux文件属主和属组"></a>Linux文件属主和属组</h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www /]<span class="hljs-comment"># ls -l</span><br>total 64<br>drwxr-xr-x<span class="hljs-number"> 2 </span>root  root <span class="hljs-number"> 4096 </span>Feb<span class="hljs-number"> 15 </span>14:46 cron<br>drwxr-xr-x<span class="hljs-number"> 3 </span>mysql mysql<span class="hljs-number"> 4096 </span>Apr<span class="hljs-number"> 21 </span><span class="hljs-number"> 2014 </span>mysql<br>……<br></code></pre></td></tr></table></figure><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p><p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p><h2 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h2><h3 id="1、chgrp：更改文件属组"><a href="#1、chgrp：更改文件属组" class="headerlink" title="1、chgrp：更改文件属组"></a>1、chgrp：更改文件属组</h3><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chgrp</span> [-R] 属组名 文件名<br></code></pre></td></tr></table></figure><p>参数选项</p><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><h3 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h3><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [–R] 属主名 文件名<br><span class="hljs-built_in">chown</span> [-R] 属主名：属组名 文件名<br></code></pre></td></tr></table></figure><p>进入 &#x2F;root 目录（~）将install.log的拥有者改为bin这个账号：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~] cd ~<br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># chown bin install.log</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls -l</span><br>-rw-r--r--  <span class="hljs-number">1</span> bin  users <span class="hljs-number">68495</span> Jun <span class="hljs-number">25</span> <span class="hljs-number">08</span>:<span class="hljs-number">53</span> install.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>将install.log的拥有者与群组改回为root：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># chown root:root install.log</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls -l</span><br>-rw-r--r--  <span class="hljs-number">1</span> root root <span class="hljs-number">68495</span> Jun <span class="hljs-number">25</span> <span class="hljs-number">08</span>:<span class="hljs-number">53</span> install.<span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h3 id="chmod：更改文件九个属性"><a href="#chmod：更改文件九个属性" class="headerlink" title="chmod：更改文件九个属性"></a>chmod：更改文件九个属性</h3><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux 文件的基本权限就有九个，分别是 <strong>owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他)</strong> 三种身份各有自己的 <strong>read&#x2F;write&#x2F;execute</strong> 权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为： <strong>-rwxrwxrwx</strong> ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为： <strong>-rwxrwx—</strong> 分数则是：</p><ul><li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li><li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li><li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是 <strong>770</strong>。变更权限的指令 chmod 的语法是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>xyz</strong> : 就是刚刚提到的数字类型的权限属性，为 <strong>rwx</strong> 属性数值的相加。</li><li><strong>-R</strong> : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更</li></ul><p>举例来说，如果要将 <strong>.bashrc</strong> 这个文件所有的权限都设定启用，那么命令如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www ~]<span class="hljs-comment"># ls -al .bashrc</span><br>-rw-r--r-- <span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 395 </span>Jul <span class="hljs-number"> 4 </span>11:45 .bashrc<br>[root@www ~]<span class="hljs-comment"># chmod 777 .bashrc</span><br>[root@www ~]<span class="hljs-comment"># ls -al .bashrc</span><br>-rwxrwxrwx <span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 395 </span>Jul <span class="hljs-number"> 4 </span>11:45 .bashrc<br></code></pre></td></tr></table></figure><p>那如果要将权限变成 <em>-rwxr-xr–</em> 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]&#x3D;754。</p><h3 id="符号类型改变文件权限"><a href="#符号类型改变文件权限" class="headerlink" title="符号类型改变文件权限"></a>符号类型改变文件权限</h3><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p><ul><li>user：用户</li><li>group：组</li><li>others：其他</li></ul><p>那么我们就可以使用 <strong>u, g, o</strong> 来代表三种身份的权限。</p><p>此外， <strong>a</strong> 则代表 <strong>all</strong>，即全部的身份。读写的权限可以写成 <strong>r, w, x</strong>，也就是可以使用下表的方式来看：</p><table><thead><tr><th>chmod</th><th>u g o a</th><th>+(加入) -(除去) &#x3D;(设定)</th><th>r w x</th><th>文件或目录</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>如果我们需要将文件权限设置为 <strong>-rwxr-xr–</strong> ，可以使用 <strong>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r 文件名</strong> 来设定:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment">#  touch test1    // 创建 test1 文件</span><br><span class="hljs-comment"># ls -al test1    // 查看 test1 默认权限</span><br>-rw-r--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>Nov<span class="hljs-number"> 15 </span>10:32 test1<br><span class="hljs-comment"># chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限</span><br><span class="hljs-comment"># ls -al test1</span><br>-rwxr-xr--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>Nov<span class="hljs-number"> 15 </span>10:32 test1<br></code></pre></td></tr></table></figure><p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment">#  chmod  a-x test1</span><br><span class="hljs-comment"># ls -al test1</span><br>-rw-r--r--<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>Nov<span class="hljs-number"> 15 </span>10:32 test1<br></code></pre></td></tr></table></figure><h1 id="Linux文件与目录管理"><a href="#Linux文件与目录管理" class="headerlink" title="Linux文件与目录管理"></a>Linux文件与目录管理</h1><p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 **&#x2F;**。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><ul><li><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>&#x2F;</strong> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。</li><li><strong>相对路径：</strong><br>路径的写法，不是由 <strong>&#x2F;</strong> 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： <strong>cd ..&#x2F;man</strong> 这就是相对路径的写法。</li></ul><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><ul><li>ls（英文全拼：list files）: 列出目录及文件名</li><li>cd（英文全拼：change directory）：切换目录</li><li>pwd（英文全拼：print work directory）：显示目前的目录</li><li>mkdir（英文全拼：make directory）：创建一个新的目录</li><li>rmdir（英文全拼：remove directory）：删除一个空的目录</li><li>cp（英文全拼：copy file）: 复制文件或目录</li><li>rm（英文全拼：remove）: 删除文件或目录</li><li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">[root@www ~]# <span class="hljs-keyword">ls</span> [-aAdfFhilnrRSt] 目录名称<br>[root@www ~]# <span class="hljs-keyword">ls</span> [--<span class="hljs-keyword">color</span>=&#123;never,auto,always&#125;] 目录名称<br>[root@www ~]# <span class="hljs-keyword">ls</span> [--full-time] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># ls -al ~</span><br></code></pre></td></tr></table></figure><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx"> <span class="hljs-attribute">cd</span> [相对路径或绝对路径]<br><span class="hljs-comment">#使用 mkdir 命令创建 runoob 目录</span><br>[root<span class="hljs-variable">@www</span> ~]<span class="hljs-comment"># mkdir runoob</span><br><br><span class="hljs-comment">#使用绝对路径切换到 runoob 目录</span><br>[root<span class="hljs-variable">@www</span> ~]<span class="hljs-comment"># cd /root/runoob/</span><br><br><span class="hljs-comment">#使用相对路径切换到 runoob 目录</span><br>[root<span class="hljs-variable">@www</span> ~]<span class="hljs-comment"># cd ./runoob/</span><br><br><span class="hljs-comment"># 表示回到自己的家目录，亦即是 /root 这个目录</span><br>[root<span class="hljs-variable">@www</span> runoob]<span class="hljs-comment"># cd ~</span><br><br><span class="hljs-comment"># 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span><br>[root<span class="hljs-variable">@www</span> ~]<span class="hljs-comment"># cd ..</span><br></code></pre></td></tr></table></figure><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># pwd [-P]</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li></ul><p>实例：单纯显示出目前的工作目录：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># pwd</span><br>/root   &lt;== 显示出目录啦～<br></code></pre></td></tr></table></figure><p>实例显示出实际的工作目录，而非链接档本身的目录名而已。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@www ~]# cd <span class="hljs-regexp">/var/m</span>ail   &lt;==注意，<span class="hljs-regexp">/var/m</span>ail是一个链接档<br>[root@www mail]# pwd<br><span class="hljs-regexp">/var/m</span>ail         &lt;==列出目前的工作目录<br>[root@www mail]# pwd -P<br><span class="hljs-regexp">/var/</span>spool/mail   &lt;==怎么回事？有没有加 -P 差很多～<br>[root@www mail]# ls -ld <span class="hljs-regexp">/var/m</span>ail<br>lrwxrwxrwx <span class="hljs-number">1</span> root root <span class="hljs-number">10</span> Sep  <span class="hljs-number">4</span> <span class="hljs-number">17</span>:<span class="hljs-number">54</span> <span class="hljs-regexp">/var/m</span>ail -&gt; spool/mail<br># 看到这里应该知道为啥了吧？因为 <span class="hljs-regexp">/var/m</span>ail 是链接档，链接到 <span class="hljs-regexp">/var/</span>spool/mail <br># 所以，加上 pwd -P 的选项后，会不以链接档的数据显示，而是显示正确的完整路径啊！<br></code></pre></td></tr></table></figure><h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir [-mp] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：请到&#x2F;tmp底下尝试创建数个新目录看看：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">[root@www ~]# <span class="hljs-keyword">cd</span> /tmp<br>[root@www tmp]# <span class="hljs-keyword">mkdir</span> <span class="hljs-keyword">test</span>    &lt;==创建一名为 <span class="hljs-keyword">test</span> 的新目录<br>[root@www tmp]# <span class="hljs-keyword">mkdir</span> test1/test2/test3/test4<br><span class="hljs-keyword">mkdir</span>: cannot create directory `test1/test2/test3/test4&#x27;: <br><span class="hljs-keyword">No</span> such <span class="hljs-keyword">file</span> or directory       &lt;== 没办法直接创建此目录啊！<br>[root@www tmp]# <span class="hljs-keyword">mkdir</span> -p test1/test2/test3/test4<br></code></pre></td></tr></table></figure><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p><p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www tmp]<span class="hljs-comment"># mkdir -m 711 test2</span><br>[root@www tmp]<span class="hljs-comment"># ls -l</span><br>drwxr-xr-x <span class="hljs-number"> 3 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:50 test<br>drwxr-xr-x <span class="hljs-number"> 3 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:53 test1<br>drwx--x--x <span class="hljs-number"> 2 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:54 test2<br></code></pre></td></tr></table></figure><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p><p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmdir [-p] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-p ：</strong>从该目录起，一次删除多级空目录</li></ul><p>删除 runoob 目录</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># rmdir runoob/</span><br></code></pre></td></tr></table></figure><p>将 mkdir 实例中创建的目录(&#x2F;tmp 底下)删除掉！</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@www tmp]<span class="hljs-comment"># ls -l   &lt;==看看有多少目录存在？</span><br>drwxr-xr-x <span class="hljs-number"> 3 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:50 test<br>drwxr-xr-x <span class="hljs-number"> 3 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:53 test1<br>drwx--x--x <span class="hljs-number"> 2 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:54 test2<br>[root@www tmp]<span class="hljs-comment"># rmdir test   &lt;==可直接删除掉，没问题</span><br>[root@www tmp]<span class="hljs-comment"># rmdir test1  &lt;==因为尚有内容，所以无法删除！</span><br>rmdir: `test1&#x27;: Directory not empty<br>[root@www tmp]<span class="hljs-comment"># rmdir -p test1/test2/test3/test4</span><br>[root@www tmp]<span class="hljs-comment"># ls -l        &lt;==您看看，底下的输出中test与test1不见了！</span><br>drwx--x--x <span class="hljs-number"> 2 </span>root  root<span class="hljs-number"> 4096 </span>Jul<span class="hljs-number"> 18 </span>12:54 test2<br></code></pre></td></tr></table></figure><p>利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除。</p><p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p><p>语法:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-attr">[root@www ~]</span># cp <span class="hljs-selector-attr">[-adfilprsu]</span> 来源档(source) 目标档(destination)<br><span class="hljs-selector-attr">[root@www ~]</span># cp <span class="hljs-selector-attr">[options]</span> source1 source2 source3 .... directory<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-d：</strong>若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式链接(hard link)的链接档创建，而非复制文件本身；</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-s：</strong>复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@www ~]# cp ~<span class="hljs-regexp">/.bashrc /</span>tmp/bashrc<br>[root@www ~]# cp -i ~<span class="hljs-regexp">/.bashrc /</span>tmp/bashrc<br>cp: overwrite `<span class="hljs-regexp">/tmp/</span>bashrc<span class="hljs-string">&#x27;? n  &lt;==n不覆盖，y为覆盖</span><br></code></pre></td></tr></table></figure><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> [-fir] 文件或目录<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li><li></li></ul><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">[root@www tmp]# <span class="hljs-keyword">rm</span> -i bashrc<br><span class="hljs-keyword">rm</span>: remove regular <span class="hljs-keyword">file</span> <span class="hljs-symbol">`bashrc&#x27;</span>? y<br></code></pre></td></tr></table></figure><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># mv [-fiu] source destination</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># mv [options] source1 source2 source3 .... directory</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>复制一文件，创建一目录，将文件移动到目录中</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># cd /tmp</span><br>[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># cp ~/.bashrc bashrc</span><br>[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># mkdir mvtest</span><br>[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># mv bashrc mvtest</span><br></code></pre></td></tr></table></figure><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> tmp]<span class="hljs-meta"># mv mvtest mvtest2</span><br></code></pre></td></tr></table></figure><h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p><p>语法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span><span class="hljs-meta"> [-AbEnTv]</span><br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>检看 &#x2F;etc&#x2F;issue 这个文件的内容：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@www ~]<span class="hljs-comment"># cat /etc/issue</span><br>CentOS release <span class="hljs-number">6.4</span> (Final)<br>Kernel <span class="hljs-string">\r</span> <span class="hljs-literal">on</span> an <span class="hljs-string">\m</span><br></code></pre></td></tr></table></figure><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@www ~]<span class="hljs-comment"># tac /etc/issue</span><br><br>Kernel <span class="hljs-string">\r</span> <span class="hljs-literal">on</span> an <span class="hljs-string">\m</span><br>CentOS release <span class="hljs-number">6.4</span> (Final)<br></code></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nl</span> [-bnw] 文件<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>实例一：用 nl 列出 &#x2F;etc&#x2F;issue 的内容</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">[root@www ~]<span class="hljs-comment"># nl /etc/issue</span><br>     <span class="hljs-number">1</span>  CentOS release <span class="hljs-number">6.4</span> (Final)<br>     <span class="hljs-number">2</span>  Kernel <span class="hljs-string">\r</span> <span class="hljs-literal">on</span> an <span class="hljs-string">\m</span><br></code></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@www ~]<span class="hljs-comment"># more /etc/man_db.config </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Generated automatically from man.conf.in by the</span><br><span class="hljs-comment"># configure script.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># man.conf from man-1.6d</span><br><span class="hljs-string">....</span><span class="hljs-params">(中间省略)</span><span class="hljs-string">....</span><br><span class="hljs-params">--More--</span><span class="hljs-params">(28%)</span>  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令<br></code></pre></td></tr></table></figure><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter     ：代表向下翻『一行』；</li><li>&#x2F;字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f      ：立刻显示出档名以及目前显示的行数；</li><li>q       ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">[root@www ~]<span class="hljs-comment"># less /etc/man.config</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Generated automatically from man.conf.in by the</span><br><span class="hljs-comment"># configure script.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># man.conf from man-1.6d</span><br><span class="hljs-string">....</span><span class="hljs-params">(中间省略)</span><span class="hljs-string">....</span><br>:   &lt;== 这里可以等待你输入命令！<br></code></pre></td></tr></table></figure><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>&#x2F;字串   ：向下搜寻『字串』的功能；</li><li>?字串   ：向上搜寻『字串』的功能；</li><li>n     ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li><li>N     ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li><li>q     ：离开 less 这个程序；</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p><p>语法：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">head [-n <span class="hljs-built_in">number</span>] 文件 <br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># head /etc/man.config</span><br></code></pre></td></tr></table></figure><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># head -n 20 /etc/man.config</span><br></code></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p><p>语法：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">tail [-n <span class="hljs-built_in">number</span>] 文件 <br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># tail /etc/man.config</span><br><span class="hljs-meta"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span><br>[root<span class="hljs-symbol">@www</span> ~]<span class="hljs-meta"># tail -n 20 /etc/man.config</span><br></code></pre></td></tr></table></figure><h1 id="Linux-vim"><a href="#Linux-vim" class="headerlink" title="Linux vim"></a>Linux vim</h1><p>vim 键盘图：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141208876.png" alt="image-20230314120835808"> </p><h2 id="vi-x2F-vim-的使用"><a href="#vi-x2F-vim-的使用" class="headerlink" title="vi&#x2F;vim 的使用"></a>vi&#x2F;vim 的使用</h2><p>基本上 vi&#x2F;vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p><h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>&#x2F;<strong>END</strong>，移动光标到行首&#x2F;行尾</li><li><strong>Page Up</strong>&#x2F;<strong>Page Down</strong>，上&#x2F;下翻页</li><li><strong>Insert</strong>，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><h2 id="vi-x2F-vim-使用实例"><a href="#vi-x2F-vim-使用实例" class="headerlink" title="vi&#x2F;vim 使用实例"></a>vi&#x2F;vim 使用实例</h2><h3 id="使用-vi-x2F-vim-进入一般模式"><a href="#使用-vi-x2F-vim-进入一般模式" class="headerlink" title="使用 vi&#x2F;vim 进入一般模式"></a>使用 vi&#x2F;vim 进入一般模式</h3><p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>vim runoob.txt<br></code></pre></td></tr></table></figure><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141210433.png" alt="image-20230314121017372"></p><h3 id="按下-i-进入输入模式-也称为编辑模式-，开始编辑文字"><a href="#按下-i-进入输入模式-也称为编辑模式-，开始编辑文字" class="headerlink" title="按下 i 进入输入模式(也称为编辑模式)，开始编辑文字"></a>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</h3><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141210770.png" alt="image-20230314121036712"></p><h3 id="按下-ESC-按钮回到一般模式"><a href="#按下-ESC-按钮回到一般模式" class="headerlink" title="按下 ESC 按钮回到一般模式"></a>按下 ESC 按钮回到一般模式</h3><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p><h3 id="在一般模式中按下-wq-储存后离开-vi"><a href="#在一般模式中按下-wq-储存后离开-vi" class="headerlink" title="在一般模式中按下 :wq 储存后离开 vi"></a>在一般模式中按下 <strong>:wq</strong> 储存后离开 vi</h3><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202303141210979.png" alt="image-20230314121057916"></p><h2 id="vi-x2F-vim-按键说明"><a href="#vi-x2F-vim-按键说明" class="headerlink" title="vi&#x2F;vim 按键说明"></a>vi&#x2F;vim 按键说明</h2><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><h3 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h3><table><thead><tr><th align="left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">n<space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="left">n<Enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr><tr><td align="left">搜索替换</td><td></td></tr><tr><td align="left">&#x2F;word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="left">使用 &#x2F;word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td align="left">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</td></tr><tr><td align="left"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;g</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="left"><strong>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc</strong> 或 <strong>:%s&#x2F;word1&#x2F;word2&#x2F;gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td align="left">删除、复制与贴上</td><td></td></tr><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>剪切游标所在的那一整行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="left">ndd</td><td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p&#x2F;P 可以粘贴。</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td align="left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><h3 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h3><table><thead><tr><th align="left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td align="left">a, A</td><td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="left">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr><td align="left">r, R</td><td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="left">上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><h3 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h3><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr><td align="left">ZQ</td><td>不保存，强制退出。效果等同于 **:q!**。</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！</td></tr><tr><td align="left">vim 环境的变更</td><td></td></tr><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p>特别注意，在 vi&#x2F;vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p><p>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p><p><strong>vim 中批量添加注释</strong></p><p>方法一 ：块选择模式</p><p>批量注释：</p><p><strong>Ctrl + v</strong> 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 <strong>I</strong> 进入行首插入模式输入注释符号如 <strong>&#x2F;&#x2F;</strong> 或 <strong>#<strong>，输入完毕之后，按两下 <strong>ESC</strong>，</strong>Vim</strong> 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p><p>取消注释：</p><p><strong>Ctrl + v</strong> 进入块选择模式，选中你要删除的行首的注释符号，注意 <strong>&#x2F;&#x2F;</strong> 要选中两个，选好之后按 <strong>d</strong> 即可删除注释，<strong>ESC</strong> 保存退出。</p><p>方法二: 替换命令</p><p>批量注释。</p><p>使用下面命令在指定的行首添加注释。</p><p>使用名命令格式： <strong>:起始行号,结束行号s&#x2F;^&#x2F;注释符&#x2F;g</strong>（注意冒号）。</p><p>取消注释：</p><p>使用名命令格式： <strong>:起始行号,结束行号s&#x2F;^注释符&#x2F;&#x2F;g</strong>（注意冒号）。</p><p>例子：</p><p>1、在 10 - 20 行添加 <strong>&#x2F;&#x2F;</strong> 注释</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s#^#<span class="hljs-comment">//#g</span><br></code></pre></td></tr></table></figure><p>2、在 10 - 20 行删除 <strong>&#x2F;&#x2F;</strong> 注释</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s<span class="hljs-meta">#^<span class="hljs-comment">//##g</span></span><br></code></pre></td></tr></table></figure><p>3、在 10 - 20 行添加 <strong>#</strong> 注释</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s<span class="hljs-regexp">/^/</span><span class="hljs-comment">#/g</span><br></code></pre></td></tr></table></figure><p>4、在 <strong>10 - 20</strong> 行删除 # 注释</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s/<span class="hljs-meta">#<span class="hljs-comment">//g</span></span><br></code></pre></td></tr></table></figure><p><strong>vim快捷键补充（插入模式）</strong></p><ol><li>自动补全：<strong>ctrl</strong> + <strong>n</strong></li><li>**\p&lt;** 插入一个include，并把光标置于&lt;&gt;中间</li><li><strong>\im</strong> 插入主函数</li><li><strong>\ip</strong> 插入printf，并自动添加<strong>\n</strong>，且把光标置于双引号中间</li></ol><p>vim快捷键补充（编辑模式）</p><ol><li>dw 删除一个单词（配合b：将光标置于所在单词的首部）</li><li>yw 复制一个单词（配合p：粘贴）</li></ol><p>vim快捷键补充（插入与编辑模式通用）</p><ol><li>\rr 运行程序</li><li>\rc 保存并编译程序（会生成二进制文件）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统概述复习</title>
    <link href="/2023/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/02/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="#%E7%AC%AC1%E7%AB%A0%20%E6%A6%82%E8%BF%B0">第1章 概述</a></p><p><a href="#1.1%20DBS%E6%A6%82%E8%BF%B0">1.1 DBS概述</a></p><p><a href="#1.1.1%20%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">1.1.1 四个基本概念</a></p><p><a href="#1.1.2%20%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5">1.1.1 1.1.2 数据管理的三个阶段</a></p><p><a href="#1.1.3%20DBS%E7%9A%84%E7%89%B9%E7%82%B9">1.1.3 DBS的特点</a></p><p><a href="#1.2%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2 数据模型</a></p><p><a href="#1.2.1%20%E4%B8%A4%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2.1 两类数据模型</a></p><p><a href="#1.2.2%20%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B">1.2.2 概念模型</a></p><p><a href="#1.2.3%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0">1.2.3 数据模型的组成要素</a></p><p><a href="#1.2.4%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">1.2.4 常用的数据模型</a></p><p><a href="#1.2.7%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B">1.2.7 关系模型</a></p><p><a href="#1.3%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84">1.3 数据库系统的结构</a></p><p><a href="#1.3.1%20DBS%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5">1.3.1 DBS模式的概念</a></p><p><a href="#1.3.2%20DBS%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84">1.3.2 DBS的三级模式结构</a></p><p><a href="#1.3.3%20DB%E7%9A%84%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%83%8F%E5%8A%9F%E8%83%BD%E5%92%8C%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7">1.3.3 DB的二级映像功能和数据独立性</a></p><p><a href="#%E7%AC%AC2%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">第2章 关系数据库</a></p><p><a href="#2.1%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BD%A2%E5%BC%8F%E5%8C%96%E5%AE%9A%E4%B9%89">2.1 关系数据结构及形式化定义</a></p><p><a href="#2.1.1%20%E5%85%B3%E7%B3%BB">2.1.1 关系</a></p><p><a href="#2.1.2%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F">2.1.2 关系模式</a></p><p><a href="#2.2%20%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C">2.2 关系操作</a></p><p><a href="#2.3%20%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">2.3 关系的完整性</a></p><p><a href="#2.3.1%20%E5%AE%9E%E4%BD%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.1 实体的完整性</a></p><p><a href="#2.3.2%20%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.2 参照完整性</a></p><p><a href="#2.3.3%20%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7">2.3.3 用户定义完整性</a></p><p><a href="#2.4%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0">2.4 关系代数</a></p><p><a href="#2.4.1%20%E4%BC%A0%E7%BB%9F%E7%9A%84%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97">2.4.1 传统的集合运算</a></p><p><a href="#2.4.2%20%E4%B8%93%E9%97%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97">2.4.2 专门的关系运算</a></p><p><a href="#%E7%AC%AC3%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL">第3章 关系型数据库标准语言SQL</a></p><p><a href="#3.1%20SQL%E6%A6%82%E8%BF%B0">3.1 SQL概述</a></p><p><a href="#3.1.3%20SQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5P78">3.1.3 SQL的基本概念P78</a></p><p><a href="#3.3%20%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89">3.3 数据定义</a></p><p><a href="#3.3.1%20%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%A0%E9%99%A4">3.3.1 模式的定义和删除</a></p><p><a href="#3.3.2%20%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%88%A0%E9%99%A4%E4%B8%8E%E4%BF%AE%E6%94%B9">3.3.2 基本表的定义、删除与修改</a></p><p><a href="#3.3.3%20%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E5%88%A0%E9%99%A4">3.3.3 索引的建立与删除</a></p><p><a href="#3.4%20%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2">3.4 数据查询</a></p><p><a href="#3.4.1%20%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2">3.4.1 单表查询</a></p><p><a href="#3.4.2%20%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2">3.4.2 连接查询</a></p><p><a href="#3.4.3%20%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2">3.4.3 嵌套查询（nested query）凸显结构化</a></p><p><a href="#3.4.4%20%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2">3.4.4 集合查询</a></p><p><a href="#3.4.5%20%E5%9F%BA%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2">3.4.5 基于派生表的查询</a></p><p><a href="#3.4.6%20select%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F">3.4.6 select语句的一般格式</a></p><p><a href="#3.5%20%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0">3.5 数据更新</a></p><p><a href="#3.5.1%20%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">3.5.1 插入数据</a></p><p><a href="#3.5.2%20%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE">3.5.2 修改数据</a></p><p><a href="#3.5.3%20%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">3.5.3 删除数据</a></p><p><a href="#3.6%20%E7%A9%BA%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86">3.6 空值的处理</a></p><p><a href="#3.7%20%E8%A7%86%E5%9B%BE">3.7 视图</a></p><p><a href="#3.7.1%20%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE">3.7.1 定义视图</a></p><p><a href="#3.7.2%20%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE">3.7.2 查询视图</a></p><p><a href="#3.7.3%20%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE">3.7.3 更新视图</a></p><p><a href="#3.7.4%20%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8">3.7.4 视图的作用</a></p><p><a href="#%E7%AC%AC4%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7">第4章 数据库安全性</a></p><p><a href="#4.2%20DB%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6">4.2 DB安全性控制</a></p><p><a href="#4.2.1%20%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E9%89%B4%E5%88%AB">4.2.1 用户身份鉴别</a></p><p><a href="#4.2.2%20%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6">4.2.2 存取控制</a></p><p><a href="#4.2.3%20%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95">4.2.3 自主存取控制方法</a></p><p><a href="#4.2.4%20%E6%8E%88%E6%9D%83%EF%BC%9A%E6%8E%88%E4%BA%88%E4%B8%8E%E6%94%B6%E5%9B%9E">4.2.4 授权：授予与收回</a></p><p><a href="#%E7%AC%AC5%E7%AB%A0">第5章</a></p><p><a href="#5.3%20%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7">5.3 用户定义的完整性</a></p><p><a href="#5.3.1%20%E5%B1%9E%E6%80%A7%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6(P163)">5.3.1 属性上的约束条件(P163)</a></p><p><a href="#5.3.2%20%E5%85%83%E7%BB%84%E4%B8%8A%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89">5.3.2 元组上的约束条件的定义</a></p><p><a href="#%E7%AC%AC7%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1">第7章 数据库设计</a></p><p><a href="#7.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0">7.1 数据库设计概述</a></p><p><a href="#7.1.3%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">7.1.3 数据库设计基本步骤</a></p><p><a href="#7.3%20%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">7.3 概念结构设计</a></p><p><a href="#7.4%20%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">7.4 逻辑结构设计</a></p><p><a href="#7.4.1%20ER%E5%9B%BE%E5%90%91%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2">7.4.1 ER图向关系模型的转换</a></p><p><a href="#7.6%20DB%E7%9A%84%E5%AE%9E%E6%96%BD%E5%92%8C%E7%BB%B4%E6%8A%A4">7.6 DB的实施和维护</a></p><p><a href="#7.6.1%20%E6%95%B0%E6%8D%AE%E8%BD%BD%E5%85%A5%E5%92%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%B0%83%E8%AF%95">7.6.1 数据载入和应用程序的调试</a></p><p><a href="#%E7%AC%AC9%E7%AB%A0%20%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">第9章 关系查询处理和查询优化</a></p><p><a href="#9.1%20%E5%85%B3%E7%B3%BBDBS%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86">9.1 关系DBS的查询处理</a></p><p><a href="#1.%20%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90">1. 查询分析</a></p><p><a href="#2.%20%E6%9F%A5%E8%AF%A2%E6%A3%80%E6%9F%A5">2. 查询检查</a></p><p><a href="#3.%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">3. 查询优化</a></p><p><a href="#4.%20%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C">4. 查询执行</a></p><p><a href="#9.2%20%E5%85%B3%E7%B3%BBDBS%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">9.2 关系DBS的查询优化</a></p><p><a href="#9.2.1%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%A6%82%E8%BF%B0">9.2.1 查询优化概述</a></p><p><a href="#9.3%20%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96">9.3 代数优化</a></p><p><a href="#9.3.2%20%E6%9F%A5%E8%AF%A2%E6%A0%91%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E4%BC%98%E5%8C%96">9.3.2 查询树的启发式优化</a></p><p><a href="#%E7%AC%AC10%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF">第10章 数据库恢复技术</a></p><p><a href="#10.1%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">10.1 事务的基本概念</a></p><p><a href="#1.%E4%BA%8B%E5%8A%A1">1.事务</a></p><p><a href="#2.%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7">2.事务的ACID特性</a></p><p><a href="#10.3%20%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB">10.3 故障的种类</a></p><p><a href="#1.%20%E4%BA%8B%E5%8A%A1%E5%86%85%E9%83%A8%E7%9A%84%E6%95%85%E9%9A%9C">1. 事务内部的故障</a></p><p><a href="#2.%20%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C">2. 系统故障</a></p><p><a href="#3.%20%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C">3. 介质故障</a></p><p><a href="#4.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">4. 计算机病毒</a></p><p><a href="#10.4%20%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF">10.4 恢复的实现技术</a></p><p><a href="#10.4.2%20%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">10.4.2 日志文件</a></p><p><a href="#%E8%AF%95%E9%A2%98:">试题:</a></p><hr><h1 id="第1章 概述">第1章 概述</h1><h2 id="1.1 DBS概述">1.1 DBS概述</h2><h3 id="1.1.1 四个基本概念">1.1.1 四个基本概念</h3><p>数据data：描述事物的<strong>符号记录</strong>。<br>数据库DB：长期存储在计算机内的、有组织的、可共享的大量数据集合。<br>数据库管理系统DBMS：是位于用户与操作系统之间的具有数据定义、数据操纵、数据库的运行管理、数据库的建立和维护功能的一层数据管理软件。<br>数据库系统DBS：在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员<strong>DBA</strong>和用户构成。<br>DDL：数据定义语言(Data Definition Launguage)。<br>DML：数据操纵语言(Data Manipulation Launguage)。  </p><h3 id="1.1.2 数据管理的三个阶段">1.1.2 数据管理的三个阶段</h3><table><thead><tr><th></th><th>人工管理阶段</th><th>文件系统阶段</th><th>数据库系统阶段</th></tr></thead><tbody><tr><td>处理方式</td><td>批处理</td><td>联机实时处理，批处理</td><td>有数据库管理系统</td></tr><tr><td>面向对象</td><td>某一个应用程序</td><td>某一个应用</td><td>现实世界</td></tr><tr><td>数据共享程度</td><td>无共享，冗余度极大</td><td>共享性差，冗余度大</td><td>共享性高，冗余度小</td></tr><tr><td>独立性</td><td>不独立，完全依赖程序</td><td>独立性差</td><td>具有高度的物理独立性和一定的逻辑独立性</td></tr></tbody></table><h3 id="1.1.3 DBS的特点">1.1.3 DBS的特点</h3><p>1. <strong>数据结构化</strong></p><p>2. 数据<strong>共享性高</strong>、冗余度低<strong>且易扩充</strong></p><p>3. 数据独立性高</p><blockquote><p>物理独立性：应用程序与数据库中<strong>数据的物理存储</strong>是相互独立的</p><p>逻辑独立性：应用程序与<strong>数据库的逻辑结构</strong>是相互独立的，数据的逻辑结构改变时用户程序可以不变  </p><p>数据的独立性是由<strong>二级映像决定的</strong></p></blockquote><p>4. 数据由DBMS统一管理和控制</p><h2 id="1.2 数据模型">1.2 数据模型</h2><h3 id="1.2.1 两类数据模型">1.2.1 两类数据模型</h3><blockquote><p>1. 概念模型（信息模型） 按用户的观点对数据和信息建模，用于DB设计</p><p>2. 逻辑和物理模型  逻辑模型用于DBMS的实现 物理模型是对底层的抽象</p></blockquote><h3 id="1.2.2 概念模型">1.2.2 概念模型</h3><p>1. 实体：客观存在并可相互区别的事物</p><p>2. 属性：实体所具有的某一特性称为属性</p><p>3. 码：唯一标识实体的属性集</p><p>4. 实体型：同类实体，比如学生</p><p>5. 实体集：同一类型的集合，比如全体学生</p><p>6. 联系：实体内部联系，或者实体之间的联系，如一对一，一对多和多对多</p><p>ER图：概念模型的表示方法</p><h3 id="1.2.3 数据模型的组成要素">1.2.3 数据模型的组成要素</h3><p>1. 数据结构（静态特性）</p><p>2. 数据操作（动态特性）</p><p>3. 数据的完整性约束条件</p><h3 id="1.2.4 常用的数据模型">1.2.4 常用的数据模型</h3><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li><li>面向对象数据模型</li><li>对象关系数据模型</li><li>半结构化数据模型</li></ul><h3 id="1.2.7 关系模型">1.2.7 关系模型</h3><p>1. 关系模型的数据结构</p><blockquote><ol><li>关系：二维表</li><li>元组：行</li><li>属性：列</li><li>码：表里的某个属性组，它可以唯一确定一个元组</li><li>域：一组具有相同数据类型的集合</li><li>分量：行中的某个值</li><li>关系模式：对关系的描述</li></ol></blockquote><p><strong>关系的每一个分量必须是一个不可分的数据项，即不允许表里有表</strong></p><p>2. 数据操纵和完整性约束</p><p>3. 优缺点</p><blockquote><ol><li>具有严谨的数学基础</li><li>概念单一，数据结构简单、清晰，用户易懂</li><li>数据独立性、安全保密性、简化开发工作</li><li>缺点：查询效率不如格式化数据模型，需要查询优化</li></ol></blockquote><h2 id="1.3 数据库系统的结构">1.3 数据库系统的结构</h2><h3 id="1.3.1 DBS模式的概念">1.3.1 DBS模式的概念</h3><blockquote><p>模式是DB中<strong>全体数据</strong>的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值（实例），模式是相对稳定的，而实例是相对变动的，模式反映的是数据的结构和联系，实例反映的是DB某一时刻的状态</p></blockquote><h3 id="1.3.2 DBS的三级模式结构">1.3.2 DBS的三级模式结构</h3><p>1. 外模式（external schema，用户模式）：用户能看到、使用的<strong>局部</strong>数据的<strong>逻辑结构和特征的描述</strong>，是DB用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式是模式的子集，<strong>根据用户的不同而不同</strong>，一个DB可以有多个外模式。外模式是保障DB安全的有利措施，每个用户只能访问对应外模式中的数据，其余不可见。</p><p>2. 模式（逻辑模式）：DB中<strong>全体数据</strong>的<strong>逻辑结构和特征的描述</strong>，是所有用户的<strong>公共数据视图</strong>；是DB模式结构的<strong>中间层</strong>，不涉及物理存储，与应用程序也无关。<strong>一个DB只有一个模式</strong>。</p><p>3. 内模式（internal schema，存储模式）：一个DB只有一个内模式，是物理结构</p><p><strong>注：</strong></p><blockquote><p>一个关系型DBMS的实例（instance）中可建立多个数据库，<strong>一个DB中可建立多个模式（包括不同级的模式）</strong>，一个模式下通常包括多个table、视图、索引等数据库对象。</p><p>DBMS提供<strong>模式DDL</strong>来定义模式，<strong>外模式DDL</strong>来定义外模式</p></blockquote><h3 id="1.3.3 DB的二级映像功能和数据独立性">1.3.3 DB的二级映像功能和数据独立性</h3><p>为了实现三种模式的联系和转换，DBMS提供了两层映像，正因如此，保证了DBS中的数据有较高的独立性</p><p>1. 外模式&#x2F;模式映像</p><p>对于每一个外模式，DBS都有一个外模式&#x2F;模式映像，它定义了该外模式和模式之间的对应关系，这些映像通常包含在各自外模式的描述中。<strong>当模式改变时</strong>，由数据库管理员对映像做相应改变，可使外模式保持不变，而应用程序是根据外模式编写的，所以也不用改，从而保证了数据和程序的逻辑独立性。</p><p>2. 模式&#x2F;内模式映像</p><p>DB中只有一个模式和一个内模式，所以模式&#x2F;内模式映像是<strong>唯一的。定义了数据全局逻辑结构二号存储结构之间的对应关系。当存储结构改变时</strong>，由数据库管理员对映像做相应改变，可使模式保持不变，从而应用程序不用改，从而保证了数据和程序的物理独立性。</p><p>注：</p><blockquote><p>设计DB模式结构时应首先确定数据库的全局逻辑结构，即模式（P30）</p><p>设计外模式时应充分考虑应用的扩充性（P30）</p></blockquote><h1 id="第2章 关系数据库">第2章 关系数据库</h1><h2 id="2.1 关系数据结构及形式化定义"> 2.1 关系数据结构及形式化定义</h2><h3 id="2.1.1 关系">2.1.1 关系</h3><p>1. 域：一组具有相同数据类型的值的集合； 一个域允许的不同取值的个数成为基数</p><p>2. 笛卡儿积：每个域的基数相乘&#x3D;行数,一行&#x3D;元组，元组每一个值叫分量</p><p>3. 关系：笛卡儿积的<strong>有限集合</strong>，就是一张二维表，<strong>关系&#x3D;表</strong></p><blockquote><ol><li>候选码：每一个属性组的值能够唯一标识一个元组，而子集不行。候选码的诸属性为主属性。若有多个候选码，选其中一个作为主码</li><li>全码，所有属性全是该关系模式的候选码</li><li>关系有三种类型：基本关系（实际存在，实际数据的逻辑表示）、视图表（虚表）、查询表</li></ol></blockquote><p>基本关系具有6条性质：</p><blockquote><p>1. 列是同质的，每个元组的某个分量属于同一个域</p></blockquote><blockquote><p>2. 不同的列可能出自同一域，每一列称为属性，属性必须是不同的属性名</p></blockquote><blockquote><p>3. 列顺序无所谓</p></blockquote><blockquote><p>4. 任意元组候选码不能取相同值</p></blockquote><blockquote><p>5. 行顺序无所谓</p></blockquote><blockquote><p>6. 分量原子值，即不能表中有表</p></blockquote><h3 id="2.1.2 关系模式">2.1.2 关系模式</h3><p>关系模式：关系的描述，应当要刻划出完整性的约束条件</p><p>形式化表示：</p><blockquote><p>R(U,D,DOM,F)</p></blockquote><p><strong>关系实际上就是关系模式在某一时刻的状态或内容。也就是说，关系模式是型，关系是它的值。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。</strong></p><h2 id="2.2 关系操作">2.2 关系操作</h2><p>增删改查</p><p>查又分为：</p><p>基本操作是：选择、投影、并、差、笛卡儿积</p><h2 id="2.3 关系的完整性">2.3 关系的完整性</h2><h3 id="2.3.1 实体的完整性">2.3.1 实体的完整性</h3><p>主码不能为空，若主码有多个，则都不能空</p><h3 id="2.3.2 参照完整性">2.3.2 参照完整性</h3><p>外码</p><p>参照关系(有外码)</p><p>被参照关系（被引用的主码）</p><p>参照和被参照关系可以是同一个</p><p>外码不一定要与相应的主码同名</p><p>对于有F(外码)的R的元组，要么取空（不存在），要么取S（被参照关系）的主码</p><h3 id="2.3.3 用户定义完整性">2.3.3 用户定义完整性</h3><h2 id="2.4 关系代数">2.4 关系代数</h2><table><thead><tr><th></th><th>并</th><th>差</th><th>交</th><th>笛卡儿积</th><th>选择</th><th>投影</th><th>连接</th><th>除</th></tr></thead><tbody><tr><td>符号</td><td>∪</td><td>-</td><td>∩</td><td>x</td><td>σ</td><td>Π</td><td>⋈</td><td>÷</td></tr></tbody></table><h3 id="2.4.1 传统的集合运算">2.4.1 传统的集合运算</h3><blockquote><p>基于行的，和集合运算无区别</p></blockquote><p>1. 并</p><p>2. 差</p><p>3. 交</p><p>4. 笛卡儿积（用R X S表示）</p><h3 id="2.4.2 专门的关系运算">2.4.2 专门的关系运算</h3><p>1. 选择  针对行</p><p>2. 投影  针对列，也可能取消某些行，避免重复</p><p>3. 连接</p><blockquote><p>等值连接：从广义笛卡儿积中选取A、B<strong>属性值</strong>相等的元组（注意相等的不能合并）</p><p>自然连接：特殊的等值连接，将相等的合并了（它要求两个关系中进行比较的<strong>分量</strong>必须是相同的属性组，并且要在结果中把重复的属性去掉）</p><p>非等值连接：从广义笛卡儿积中选择符合条件的</p><p>在连接中被舍弃的元组为悬浮元组</p><p>若不舍弃，则为外连接</p><p>不舍弃左边关系中的，就叫左外连接</p></blockquote><p>4. 除</p><blockquote><p>象集：R中属性组X上的x值的诸元组在Z上分量的集合</p><p>R(X,Y),S(Y,Z),Y属于同一域<br>除的定义：元组在<strong>X</strong>上 分量值 <strong>x</strong> 的象集 <strong>Yx</strong> 包含 <strong>S</strong> 在 <strong>Y</strong> 上投影 的集合</p></blockquote><h1 id="第3章-关系型数据库标准语言SQL"><a href="#第3章-关系型数据库标准语言SQL" class="headerlink" title="第3章 关系型数据库标准语言SQL"></a>第3章 关系型数据库标准语言SQL</h1><h2 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h2><h3 id="3-1-3-SQL的基本概念P78"><a href="#3-1-3-SQL的基本概念P78" class="headerlink" title="3.1.3 SQL的基本概念P78"></a>3.1.3 SQL的基本概念P78</h3><blockquote><p>外模式：包括若干视图和部分基本表，基本表是本身独立存在的表，一个关系就对应一个基本表，一个或多个基本表对应一个存储文件；视图是从一个或多个基本表导出的表，本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放其数据，数据仍存在基本表中，因此视图是虚表，视图上可以再定义视图。</p><p>模式：包括若干基本表</p><p>内模式：包含若干存储文件，<strong>存储文件的逻辑结构组成了关系数据库的内模式</strong>，存储文件的物理结构对用户是隐蔽的</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">首先进入mysql文件夹下的bin目录，然后输入MySQL -u+用户名 -p然后输入密码，AC  musk  spacexjack  密码忘了Yang  。。。 <span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> 用户名 identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;密码&#x27;</span>; 授予权限： <span class="hljs-keyword">grant</span> <span class="hljs-keyword">insert</span>,<span class="hljs-keyword">update</span>,<span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> student_course <span class="hljs-keyword">to</span> musk; 撤回权限： <span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> student <span class="hljs-keyword">from</span> musk;//mysql只能一次撤一个对象<br></code></pre></td></tr></table></figure><h2 id="3-3-数据定义"><a href="#3-3-数据定义" class="headerlink" title="3.3 数据定义"></a>3.3 数据定义</h2><h3 id="3-3-1-模式的定义和删除"><a href="#3-3-1-模式的定义和删除" class="headerlink" title="3.3.1 模式的定义和删除"></a>3.3.1 模式的定义和删除</h3><h3 id="3-3-2-基本表的定义、删除与修改"><a href="#3-3-2-基本表的定义、删除与修改" class="headerlink" title="3.3.2 基本表的定义、删除与修改"></a>3.3.2 基本表的定义、删除与修改</h3><p>1. 定义基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(sno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">primary</span>, sname <span class="hljs-type">char</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">unique</span>, <span class="hljs-keyword">foreign</span> key(Cno) <span class="hljs-keyword">references</span> Course(Cno)); 跟在列名后面的是列级完整性约束 单独定义的是表级   <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> SC(<span class="hljs-keyword">primary</span> key(Sno, Cno), Cno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>), Sno <span class="hljs-type">char</span>(<span class="hljs-number">3</span>), grade <span class="hljs-type">smallint</span>); 如果完整性约束条件涉及多个属性列，则必须定义在表级，如上所示<br></code></pre></td></tr></table></figure><p>2. 数据类型</p><p>3. 模式与表</p><p><strong>4. 修改基本表*************************************</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 删除列alter table 表名 drop column 属性名 cascade/restrict    <span class="hljs-comment">//column是列的意思注：后面的条件可不写，默认restrict；restrict是指删除是有条件的，所删除的属性不能被其他表的约束所引用，不能有视图、触发器、存储过程或函数； cascade是指删除没有条件，删除的同时，所有相关的对象都将删除 2. 增加列alter table 表名 add column 属性名 数据类型;如：alter table student add column Sname char(6);//mqsql里column可不写 修改列的数据类型//主码好像改不了,外码似乎也是alter table 表名 change 原列名 现列名 数据类型; 3. 删除主键约束alter table student drop primary key;4. 增加主键约束alter table student add primary key(sno);//注意：mysql一张表里只能有一个主键 5. 设置唯一性约束alter table student add unique（sname）;//注意：主键本身就是唯一的 6.设置外键约束（注意外键一定要是所参考的表（student）的主键，不然报错）alter table student_course add foreign key(sno) references student(sno);  7. 元组上的约束条件 P164    a. 检查约束check //mysql不支持检查约束，但写上不会报错    alter table student_course add constraint check(score &gt;= 0 and score &lt;= 100); 8. 设置默认约束alter table 表名 change 原列名 现列名 数据类型 default 默认值;如：alter table student change entime entime date default &#x27;2002-09-01&#x27;;  9. 删除表drop table stu cascade/restrict;  </span><br></code></pre></td></tr></table></figure><h3 id="3-3-3-索引的建立与删除"><a href="#3-3-3-索引的建立与删除" class="headerlink" title="3.3.3 索引的建立与删除"></a>3.3.3 索引的建立与删除</h3><h2 id="3-4-数据查询"><a href="#3-4-数据查询" class="headerlink" title="3.4 数据查询"></a>3.4 数据查询</h2><p>数据查询是数据库的核心操作</p><h3 id="3-4-1-单表查询"><a href="#3-4-1-单表查询" class="headerlink" title="3.4.1 单表查询"></a>3.4.1 单表查询</h3><p>1. 选择表中的若干列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 查询指定列select 属性列,属性列,··· from 表名;<span class="hljs-comment">//各列的顺序可以和原表不一样2. 查询所有列select * from 表名;3. 查询经过计算的值select Sname,2014-Sage from 表名; 属性列还可以是算术表达式、字符串常量、函数等。如：select sname,&#x27;year of birth&#x27;,2014-sage,LOWER(sdept) from student;//小写字母表示系名 还可以通过指定别名来改变查询结果的列标题，例如有些含有算术表达式、函数、常量的列名就可指定别名如：select sname NAME,&#x27;yaer of birth&#x27; BIRTH,2014-sage BIRTHDAY from student;</span><br></code></pre></td></tr></table></figure><p>2. 选择表中的若干元组（行）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 消除取值重复的行（两个不相同的元组投影到指定列后，可能会变成相同的行）使用distinct消除:select distinct sno from sc; <span class="hljs-number">2.</span> 查询满足条件的元组     a. 比较大小    b. 确定范围    c. 确定集合    d. 字符匹配        select * from student where Sno like <span class="hljs-string">&#x27;12313&#x27;</span>;<span class="hljs-comment">//like等价于=        //如果like后面的匹配串中不含通配符(%和_)，则可用=取代like，用!=或&lt;&gt;取代not like        select * from student where Sname like &#x27;刘%&#x27;;//有通配符必须用like        //通配符%代表任意长度（包括0）的字符串，_表示任意单个字符        select * from student where Sname like &#x27;欧阳_&#x27;;        select * from student where Sname like &#x27;_阳%&#x27;;//第二个字为阳的        select * from student where Sname not like &#x27;杨%&#x27;;                //如果要查询的字符串本身有通配符，要用escape转义符        select Cno,Credit from Course where Cname like &#x27;DB\_Design&#x27; escape&#x27;\&#x27;;        //escape\表示\为换码字符，这样跟在\后面的字符不再具有通配符的含义    e. 涉及空值的查询    f. 多重条件查询</span><br></code></pre></td></tr></table></figure><p>3. order by 子句（排序用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">select Sno,Grade from SC where Cno = <span class="hljs-string">&#x27;3&#x27;</span> order by Grade desc;desc: 降序asc: 升序<br></code></pre></td></tr></table></figure><p>4. 聚集函数</p><blockquote><ol><li>count(*)&#x2F;&#x2F;统计元组个数</li><li>count(distinct 列名)&#x2F;&#x2F;统计一列中值的个数，取消重复值</li><li>sum(distinct 列名)&#x2F;&#x2F;计算一列值的总和</li><li>max(distinct 列名)&#x2F;&#x2F;计算一列中的最大值</li><li>avg(列名)&#x2F;&#x2F;平均值</li></ol><p>当聚集函数遇到空值时，除count(*)，都跳过空值</p><p>where 子句中不能用聚集函数</p></blockquote><p>5. group by子句（分组用）</p><blockquote><p>将查询结果按某一列或多列的值分组，值相等的一组</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-number">1.</span>求各个课程号及相应的选课人数select Cno,count(Sno) from sc group by Cno;  如果分组后还要筛选，用having语句select Cno,count(Sno) from sc group by Cnohaving count(*) &gt; <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><blockquote><p>where语句和having语句的区别：</p><p>where语句不能用聚集函数，作用于基本表或视图；having短语作用于组，也就是group</p></blockquote><h3 id="3-4-2-连接查询"><a href="#3-4-2-连接查询" class="headerlink" title="3.4.2 连接查询"></a>3.4.2 连接查询</h3><p>1. 等值与非等值连接查询</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">select stu.sno, snamefrom stu,scwhere stu.sno = sc.sno and sc.cno<span class="hljs-string">&#x27;2&#x27;</span>; <span class="hljs-regexp">//</span>sno在两个表都有，所以要加前缀<br></code></pre></td></tr></table></figure><p>2. 自身连接</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">查询每一门课的间接先修课（先修课的先修课）<br></code></pre></td></tr></table></figure><p>3. 外连接</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">左外连接<span class="hljs-keyword">select</span> student.sno, sname, ssex, sage, sdept, cno, gradefrom student <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> (student.sno = sc.sno);<br></code></pre></td></tr></table></figure><p>4**. 多表连接**</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">查询每个学生的学号、姓名、选修的课程名、成绩select student.sno, Sname, Cname, Gradefrom student, <span class="hljs-keyword">sc, </span>coursewhere student.sno = <span class="hljs-keyword">sc.sno </span><span class="hljs-keyword">AND </span><span class="hljs-keyword">sc.cno </span>= course.cno;<br></code></pre></td></tr></table></figure><h3 id="3-4-3-嵌套查询（nested-query）凸显结构化"><a href="#3-4-3-嵌套查询（nested-query）凸显结构化" class="headerlink" title="3.4.3 嵌套查询（nested query）凸显结构化"></a>3.4.3 嵌套查询（nested query）凸显结构化</h3><blockquote><p>子查询的select语句不能用order by子句，order by只能对最终查询结果排序</p></blockquote><p>1. <strong>带有IN谓词的子查询</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">查询和刘成在同一个系学习的学生<span class="hljs-keyword">SELECT</span> sname,sno,sdept <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> sdept <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">select</span> sdept <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> sname = <span class="hljs-string">&#x27;刘成&#x27;</span>);  在此例中，IN可以用=替换<br></code></pre></td></tr></table></figure><p>子查询的条件不依赖与父查询，称不相关子查询(相关子查询（相关嵌套查询）反之)</p><p><strong>2. 带有比较运算符的子查询</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">找出每个学生超过他自己选秀课程平均成绩的课程号 <span class="hljs-keyword">SELECT</span> Sno,Cno <span class="hljs-keyword">FROM</span> SC xWHERE Grade &gt;= (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(Grade)                <span class="hljs-keyword">FROM</span>                <span class="hljs-keyword">WHERE</span> y.Sno = x.Sno);<br></code></pre></td></tr></table></figure><p><strong>3.带有any（some）或all谓词的子查询</strong></p><p><strong>4. 带有exists谓词的子查询</strong></p><h3 id="3-4-4-集合查询"><a href="#3-4-4-集合查询" class="headerlink" title="3.4.4 集合查询"></a>3.4.4 集合查询</h3><h3 id="3-4-5-基于派生表的查询"><a href="#3-4-5-基于派生表的查询" class="headerlink" title="3.4.5 基于派生表的查询"></a>3.4.5 基于派生表的查询</h3><h3 id="3-4-6-select语句的一般格式"><a href="#3-4-6-select语句的一般格式" class="headerlink" title="3.4.6 select语句的一般格式"></a>3.4.6 select语句的一般格式</h3><h2 id="3-5-数据更新"><a href="#3-5-数据更新" class="headerlink" title="3.5 数据更新"></a>3.5 数据更新</h2><h3 id="3-5-1-插入数据"><a href="#3-5-1-插入数据" class="headerlink" title="3.5.1 插入数据"></a>3.5.1 插入数据</h3><p><strong>1. 插入元组</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名（属性列，···，···） <span class="hljs-keyword">values</span>（对应的值，···，···）； 注意：<span class="hljs-number">1.</span> 没有出现的属性列，将自动取空值；但说明了<span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> 的属性列不能取空值，否则出错      <span class="hljs-number">2.</span> 如果没有指明任何属性列， 则新插入的必须在每个属性列上都有值（如果为<span class="hljs-literal">null</span>要显式给出），且顺序要和表的属性列顺序一样      <span class="hljs-number">3.</span>值如果为字符串常数，要用单引号括起来，数字不用      <span class="hljs-number">4.</span> 可以把属性列显式的置为<span class="hljs-literal">NULL</span> 例：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student（Sno，Sname，Ssex） <span class="hljs-keyword">values</span>（<span class="hljs-string">&#x27;29193&#x27;</span>,<span class="hljs-string">&#x27;李明&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>）;   一次同时插入多条数据：<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名（属性列，···，···） <span class="hljs-keyword">values</span>（对应的值，···，···），（对应的值<span class="hljs-number">2</span>，···，···），（对应的值<span class="hljs-number">3</span>，···，···），···；<br></code></pre></td></tr></table></figure><p><strong>2. <strong>插</strong>入子查询结果</strong></p><blockquote><p>子查询既可以嵌套在select语句中，也可以用在insert语句中用以生成要插入的数据</p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept_age(sdept, avg_age) <span class="hljs-keyword">select</span> sdept, <span class="hljs-built_in">avg</span>(sage) <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sdept;<br></code></pre></td></tr></table></figure><h3 id="3-5-2-修改数据"><a href="#3-5-2-修改数据" class="headerlink" title="3.5.2 修改数据"></a>3.5.2 修改数据</h3><p>1. 修改某一个元组的值</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">where</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span>；如：<span class="hljs-keyword">update</span> student <span class="hljs-keyword">set</span> Sage = <span class="hljs-number">16</span> <span class="hljs-keyword">where</span> Sno = <span class="hljs-string">&#x27;201215121&#x27;</span>；<br></code></pre></td></tr></table></figure><p>2. 修改多个元组的值</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">update 表名 <span class="hljs-keyword">set</span> Sage <span class="hljs-comment">= Sage + 1</span>；<br></code></pre></td></tr></table></figure><p>3. 带子查询的修改语句</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">update SC <span class="hljs-keyword">set</span> Grade = <span class="hljs-number">0</span> <span class="hljs-function"><span class="hljs-keyword">where</span> Sno <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> Sno <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">where</span> Sdept <span class="hljs-string">&#x27;CS&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-删除数据"><a href="#3-5-3-删除数据" class="headerlink" title="3.5.3 删除数据"></a>3.5.3 删除数据</h3><p>1. 删除一个元组</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 属性名 = <span class="hljs-string">&#x27;&#x27;</span>；<br></code></pre></td></tr></table></figure><p>2. 删除多个元组</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Delphi">delete from 表名；<span class="hljs-comment">//删除所有，该表成为空表</span><br></code></pre></td></tr></table></figure><p>3. 带子查询的删除语句</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">delete <span class="hljs-keyword">from</span> SC <span class="hljs-keyword">where</span> Sno <span class="hljs-title">in</span> (<span class="hljs-params"><span class="hljs-keyword">select</span> Sno <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">where</span> Sdept = <span class="hljs-string">&#x27;CS&#x27;</span></span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="3-6-空值的处理"><a href="#3-6-空值的处理" class="headerlink" title="3.6 空值的处理"></a>3.6 空值的处理</h2><h2 id="3-7-视图"><a href="#3-7-视图" class="headerlink" title="3.7 视图"></a>3.7 视图</h2><h3 id="3-7-1-定义视图"><a href="#3-7-1-定义视图" class="headerlink" title="3.7.1 定义视图"></a>3.7.1 定义视图</h3><p>1. 建立视图</p><blockquote><p>with check option 表示对视图操作时要满足视图定义中的条件(比如下例中的sdept&#x3D;’IS‘)</p><p>组成视图的列名要么全部省略，要么全部指定</p><p>以下三种情况必须全部指定：</p><ol><li>某个目标列是函数表达式</li><li>有同名列</li><li>需要更合适的名字</li></ol></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">create view <span class="hljs-constructor">IS_student(<span class="hljs-params">sno</span>,<span class="hljs-params">sname</span>,<span class="hljs-params">sage</span>)</span>asselect sno,sname,sagefrom studentwhere sdept = &#x27;IS&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>若一个视图是从单个基本表导出，且只去掉了某些行列，但保留了主码，称这类视图为行列子集视图</p><p>带虚拟列（派生属性，在基本表中不存在）的视图称为带表达式的视图</p><p>带有聚集函数和group by 子句的查询来定义的视图称为分组视图</p></blockquote><p>2. 删除视图</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">view</span> IS_stu <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></table></figure><blockquote><p>cascade表示把由该视图导出的所有视图都删除</p><p>当基本表删除后，视图的定义还在，必须用删除视图语句显式删除</p></blockquote><h3 id="3-7-2-查询视图"><a href="#3-7-2-查询视图" class="headerlink" title="3.7.2 查询视图"></a>3.7.2 查询视图</h3><blockquote><p>视图消解：把视图的查询转换为对基本表的查询</p></blockquote><h3 id="3-7-3-更新视图"><a href="#3-7-3-更新视图" class="headerlink" title="3.7.3 更新视图"></a>3.7.3 更新视图</h3><h3 id="3-7-4-视图的作用"><a href="#3-7-4-视图的作用" class="headerlink" title="3.7.4 视图的作用"></a>3.7.4 视图的作用</h3><h1 id="第4章-数据库安全性"><a href="#第4章-数据库安全性" class="headerlink" title="第4章 数据库安全性"></a>第4章 数据库安全性</h1><h2 id="4-2-DB安全性控制"><a href="#4-2-DB安全性控制" class="headerlink" title="4.2 DB安全性控制"></a>4.2 DB安全性控制</h2><h3 id="4-2-1-用户身份鉴别"><a href="#4-2-1-用户身份鉴别" class="headerlink" title="4.2.1 用户身份鉴别"></a>4.2.1 用户身份鉴别</h3><ol><li>静态口令鉴别   密码</li><li>动态口令鉴别   每次鉴别时都需使用动态产生的新口令登陆</li><li>生物特征鉴别</li><li>智能卡鉴别</li></ol><h3 id="4-2-2-存取控制"><a href="#4-2-2-存取控制" class="headerlink" title="4.2.2 存取控制"></a>4.2.2 存取控制</h3><ol><li>自主存取控制</li><li>强制存取控制  每个数据库对象被标以一定的密级</li></ol><h3 id="4-2-3-自主存取控制方法"><a href="#4-2-3-自主存取控制方法" class="headerlink" title="4.2.3 自主存取控制方法"></a>4.2.3 自主存取控制方法</h3><blockquote><p>用户权限由 数据库对象和操作类型 组成</p></blockquote><h3 id="4-2-4-授权：授予与收回"><a href="#4-2-4-授权：授予与收回" class="headerlink" title="4.2.4 授权：授予与收回"></a>4.2.4 授权：授予与收回</h3><p><strong>1. grant</strong></p><blockquote><p>一些权限：</p><p>基本表和视图：select, insert, update, delete references, all privileges</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">to</span> u1 <span class="hljs-keyword">with</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">option</span>;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> student,course <span class="hljs-keyword">to</span> u2,u3;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">to</span> <span class="hljs-built_in">public</span>;<span class="hljs-keyword">grant</span> <span class="hljs-keyword">update</span>(Sno),<span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">to</span> u4;<br></code></pre></td></tr></table></figure><p><strong>2. revoke</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">update</span>(Sno) <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> stu <span class="hljs-keyword">from</span> u4;<span class="hljs-keyword">revoke</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc <span class="hljs-keyword">from</span> <span class="hljs-built_in">public</span>;<span class="hljs-keyword">revoke</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> sc <span class="hljs-keyword">from</span> u5 <span class="hljs-keyword">cascade</span>;<br></code></pre></td></tr></table></figure><h1 id="第5章"><a href="#第5章" class="headerlink" title="第5章"></a>第5章</h1><h2 id="5-3-用户定义的完整性"><a href="#5-3-用户定义的完整性" class="headerlink" title="5.3 用户定义的完整性"></a>5.3 用户定义的完整性</h2><h3 id="5-3-1-属性上的约束条件-P163"><a href="#5-3-1-属性上的约束条件-P163" class="headerlink" title="5.3.1 属性上的约束条件(P163)"></a>5.3.1 属性上的约束条件(P163)</h3><p>1. 属性上约束条件的定义</p><blockquote><p>包括：</p><p>1. not null</p><p>2. unique</p><p>3. check</p></blockquote><h3 id="5-3-2-元组上的约束条件的定义"><a href="#5-3-2-元组上的约束条件的定义" class="headerlink" title="5.3.2 元组上的约束条件的定义"></a>5.3.2 元组上的约束条件的定义</h3><p>在创建表时可用check短语定义</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(sno <span class="hljs-type">char</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">primary</span>, sname <span class="hljs-type">char</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">unique</span>, sex <span class="hljs-type">char</span>(<span class="hljs-number">2</span>),<span class="hljs-keyword">foreign key</span>(Cno) <span class="hljs-keyword">references</span> Course(Cno),<span class="hljs-keyword">check</span>(sex = <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">OR</span> Sname <span class="hljs-keyword">not</span> lik<span class="hljs-string">e&#x27;Ms.%&#x27;</span>)); 男性名字不能以Ms.开头<br></code></pre></td></tr></table></figure><h1 id="第7章-数据库设计"><a href="#第7章-数据库设计" class="headerlink" title="第7章 数据库设计"></a>第7章 数据库设计</h1><h2 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h2><h3 id="7-1-3-数据库设计基本步骤"><a href="#7-1-3-数据库设计基本步骤" class="headerlink" title="7.1.3 数据库设计基本步骤"></a>7.1.3 数据库设计基本步骤</h3><p> 需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护</p><h2 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h2><h2 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h2><h3 id="7-4-1-ER图向关系模型的转换"><a href="#7-4-1-ER图向关系模型的转换" class="headerlink" title="7.4.1 ER图向关系模型的转换"></a>7.4.1 ER图向关系模型的转换</h3><h2 id="7-6-DB的实施和维护"><a href="#7-6-DB的实施和维护" class="headerlink" title="7.6 DB的实施和维护"></a>7.6 DB的实施和维护</h2><h3 id="7-6-1-数据载入和应用程序的调试"><a href="#7-6-1-数据载入和应用程序的调试" class="headerlink" title="7.6.1 数据载入和应用程序的调试"></a>7.6.1 数据载入和应用程序的调试</h3><h1 id="第9章-关系查询处理和查询优化"><a href="#第9章-关系查询处理和查询优化" class="headerlink" title="第9章 关系查询处理和查询优化"></a>第9章 关系查询处理和查询优化</h1><h2 id="9-1-关系DBS的查询处理"><a href="#9-1-关系DBS的查询处理" class="headerlink" title="9.1 关系DBS的查询处理"></a>9.1 关系DBS的查询处理</h2><h3 id="1-查询分析"><a href="#1-查询分析" class="headerlink" title="1. 查询分析"></a>1. 查询分析</h3><h3 id="2-查询检查"><a href="#2-查询检查" class="headerlink" title="2. 查询检查"></a>2. 查询检查</h3><h3 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3. 查询优化"></a>3. 查询优化</h3><h3 id="4-查询执行"><a href="#4-查询执行" class="headerlink" title="4. 查询执行"></a>4. 查询执行</h3><h2 id="9-2-关系DBS的查询优化"><a href="#9-2-关系DBS的查询优化" class="headerlink" title="9.2 关系DBS的查询优化"></a>9.2 关系DBS的查询优化</h2><h3 id="9-2-1-查询优化概述"><a href="#9-2-1-查询优化概述" class="headerlink" title="9.2.1 查询优化概述"></a>9.2.1 查询优化概述</h3><blockquote><p>查询优化的优点不仅在于用户不必考虑如何最好的表达查询以获得较高的效率，而且在于系统能比用户程序的“优化”做的更好，这是因为：</p><p>1. </p></blockquote><h2 id="9-3-代数优化"><a href="#9-3-代数优化" class="headerlink" title="9.3 代数优化"></a>9.3 代数优化</h2><h2 id="9-3-2-查询树的启发式优化"><a href="#9-3-2-查询树的启发式优化" class="headerlink" title="9.3.2 查询树的启发式优化"></a>9.3.2 查询树的启发式优化</h2><blockquote><p>风格恢复</p></blockquote><h1 id="第10章-数据库恢复技术"><a href="#第10章-数据库恢复技术" class="headerlink" title="第10章 数据库恢复技术"></a>第10章 数据库恢复技术</h1><h2 id="10-1-事务的基本概念"><a href="#10-1-事务的基本概念" class="headerlink" title="10.1 事务的基本概念"></a>10.1 事务的基本概念</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h3><blockquote><p>事务：是用户定义的数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</p></blockquote><p>在sql中，定义事务的语句有三条：</p><ol><li>begin transaction 表示开始</li><li>commit 提交</li><li>rollback 撤销</li></ol><h3 id="2-事务的ACID特性"><a href="#2-事务的ACID特性" class="headerlink" title="2.事务的ACID特性"></a>2.事务的ACID特性</h3><ol><li>原子性 atomicity</li><li>一致性 consistency 和原子性密切相关   一致性状态（正常）   中断（不一致） 所以要保证原子性</li><li>隔离性 isolation 并发执行的各个事务之间不能干扰</li><li>持续性 durability 永久性 事务一旦提交，改变就是永久性的，其他操作不能影响其结果</li></ol><blockquote><p>ACID特性可能遭到破坏的因素：</p><p>1. 多个事务并行运行，不同事务的操作交叉执行；</p><p>2. 事务在运行过程中被强行停止。</p></blockquote><h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a>10.3 故障的种类</h2><h3 id="1-事务内部的故障"><a href="#1-事务内部的故障" class="headerlink" title="1. 事务内部的故障"></a>1. 事务内部的故障</h3><p>非预期的，不能有由应用程序处理</p><p>发生后需要  事务撤销</p><h3 id="2-系统故障"><a href="#2-系统故障" class="headerlink" title="2. 系统故障"></a>2. 系统故障</h3><p>断电、死机</p><p>系统重启后，不仅要撤销所有未完成的事务，还要重做所有已提交的事务</p><h3 id="3-介质故障"><a href="#3-介质故障" class="headerlink" title="3. 介质故障"></a>3. 介质故障</h3><p>硬故障 磁盘损坏、磁头碰撞、瞬间强磁场干扰</p><h3 id="4-计算机病毒"><a href="#4-计算机病毒" class="headerlink" title="4. 计算机病毒"></a>4. 计算机病毒</h3><blockquote><p>总结，各类故障对DB的影响有两种：</p><p>1. 数据库本身被破坏</p><p>2. 没破坏，但数据不对了</p><p>恢复的原理：冗余</p></blockquote><h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a>10.4 恢复的实现技术</h2><h3 id="10-4-2-日志文件"><a href="#10-4-2-日志文件" class="headerlink" title="10.4.2 日志文件"></a>10.4.2 日志文件</h3><blockquote><p>用来记录事务对数据库的更新操作的文件</p><p>日志文件的作用：P299</p><p>1. </p></blockquote><p>两种：</p><p>1. 以记录为单位的</p><p>需要记录：</p><blockquote><p>1. 各个事务的开始</p><p>2. ················结束</p><p>3. ················所有更新操作</p><p>一个事务就是一个日志记录</p><p>每个日志记录包括：</p><ol><li></li></ol></blockquote><p>2. 以数据块为单位的</p><h1 id="试题"><a href="#试题" class="headerlink" title="试题:"></a>试题:</h1><p><strong>什么是数据库的再组织和重构造？为什么要进行数据库的再组织和重构造？</strong><br>[参考答案 ] 答：数据库的再组织是指：按原设计要求重新安排存储位置、回收垃圾、减少指针链等， 以提高系统性能。 数据库的重构造则是指部分修改数据库的模式和内模式， 即修改原设计的逻辑和物理结构。数据库的再组织是不修改数<br>据库的模式和内模式的。 进行数据库的再组织和重构造的原因： 数据库运行一段时间后，由于记录不断 增、删、改，会使数据库的物理存储情况变坏，降低了数 据 的 存 取 效 率 ，数 据库 性能 下 降 ， 这 时 DBA 就 要 对 数 据库 进行 重组织。 DBMS一般都提供用于数据重组织的实用程序。数据库应用环境常常发生变化，如增加新的应用或新的实体， 取消了某些应用， 有的实体与实体间的联系也发生了变化等， 使原有的数据库设计不能满足新的需求，需要调整数据库的模式和内模式。这就要进行数据库重构造</p><p><strong>什么是检查点记录？</strong><br>答：检查点记录是一类<strong>新的日志记录</strong>。它的内容包括：（1）<strong>建立检查点时刻</strong>所有正在执行的事务清单；（2）这些事务的<strong>最近</strong>一个<strong>日志</strong>记录的地址。</p><p><strong>关系系统中，当操作违反实体完整性、参照完整性和用户定义的完整性约束条件时，一般是如何分别进行处理的？</strong><br>答:<br>对于违反实体完整性和用户定义的完整性的操作一般都采用<strong>拒绝执行</strong>的方式进行处理。而对于违反参照完整性的操作，并不都是简单地拒绝执行，有时要根据应用语义执行<strong>一些附加的</strong>操作，以保证数据库的正确性。</p><p><strong>什么是数据库的审计功能，为什么要提供审计功能？</strong><br>答：审计功能是指 DBMS 的<strong>审计模块</strong>在用户对数据库执行操作的同时把所有操作自动记录到系统的审计日志中。因为任何系统的安全保护措施都不是完美无缺的，蓄意盗窃破坏数据的人总可能存在。利用数据库的审计功能， <strong>DBA</strong> 可以<strong>根据审计跟踪的信息</strong>，重现导致数据库现有状况的一系列事件，<strong>找出非法存取数据的</strong>人、时间和内容等。</p><p><strong>哪类视图是可以更新的？哪类视图是不可更新的？各举一例说明。</strong><br>答：基本表的<strong>行列子集视图</strong>一般是可更新的。若视图的属性来自集合函数、表达式，则该视图<strong>肯定是</strong>不可以更新的。</p><p><strong>什么是基本表？什么是视图？两者的区别和联系是什么？</strong><br>答：基本表是本身独立存在的表， 在 sQL 中一个关系就对应一个表。 视图是从一个或几个基本表导出的表。视图<strong>本身不独立存储在数据库中</strong>，是一个虚表。即数据库中只存放视图的定义而不存放视图对应的数据，<strong>这些数据</strong>仍存放在导出视图的基本表中。 视图在概念上与基本表等同， 用户可以如同基本表那样使用视图，可以在视图上再定义视图</p><p><strong>假设有下面两个关系模式：</strong></p><p>职工（职工号，姓名，年龄，职务，工资，部门号） ，其中职工号为主码；</p><p>部门（部门号，名称，经理名，电话） ，其中部门号为主码。</p><p>用 sQL 语言定义这两个关系模式，要求在模式中完成以下完整性约束条件的定义：</p><p>定义每个模式的<strong>主码</strong>；</p><p>定义<strong>参照完整性</strong>； 定义职工年龄不得超过 60岁。<br>答<br>CREATE TABLE DEPT<br>(Deptno NUMBER(2) <strong>PRIMARY KEY,</strong><br>Deptname VARCHAR(10),<br>Manager VARCHAR(10),<br>PhoneNumber Char(12)<br>);</p><p>CREATE TABLE EMP<br>(Empno NUMBER(4) <strong>PRIMARY KEY,</strong><br>Ename VARCHAR(10),<br>Age NUMBER(2),<br>CHECK ( Aage&lt;&#x3D;60),<br>Job VARCHAR(9),<br>Sal <strong>FLOAT</strong>(6),<br>Deptno NUMBER(2),<br><strong>FOREIGN KEY(Deptno)  REFERENCES DEPT(Deptno));</strong></p><p><strong>什么是数据库中的自主存取控制方法和强制存取控制方法？</strong><br>答：<br>自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。<br>强制存取控制方法：每一个数据对象被（强制地）标以一定的密级，每一个用户也被（强制地）授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。</p><p><strong>试述实现数据库安全性控制的常用方法和技术。</strong><br>答：实现数据库安全性控制的常用方法和技术有：<br>( l  ）<strong>用户标识和鉴别</strong>：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供系统的使用权。<br>( 2 ）<strong>存取控制</strong>：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未被授权的人员无法存取数据。例如 CZ 级中的自主存取控制 ( DAC ) , Bl  级中的强制存取控制（ MAC ）。<br>( 3 ）<strong>视图机制</strong>：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。<br>( 4 ）<strong>审计</strong>：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中， DBA 可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。<br>( 5 ）<strong>数据加密</strong>：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。</p><blockquote><ol><li>DB具有数据独立性的原因：三级模式结构</li><li>逻辑数据和物理数据的转换由DBMS负责</li><li>在嵌入式 SQL 中，当 SQL 语句中引用宿主语言的程序变量时，程序变量应加前缀：</li><li>在关系代数表达式的查询优化中，不正确的叙述是 尽可能早地执行连接</li><li>下列哪类不属于计算机系统的安全问题 政策安全类</li><li>数据库设计人员和用户之间沟通信息的桥梁是 实体联系图</li><li>并行数据库系统研究一直以三种并行计算结构为基础，分别是 <strong>共享内存结构、共享磁盘结构、无共享资源结构</strong></li><li>RDBMS查询处理可以分为四个阶段，包括 <strong>查询分析、检查、优化、执行</strong></li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构附录</title>
    <link href="/2023/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%99%84%E5%BD%95/"/>
    <url>/2023/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%99%84%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h2><blockquote><p>指针</p></blockquote><ul><li>定义指针时，* 号前面的数据类型，表示的是你所定义的指针要指向的数据类型</li></ul><blockquote><p>顺序表</p></blockquote><ul><li><p>逻辑结构与存储元素的物理结构一致</p></li><li><p>占用一片连续的存储空间，访问顺序表示，可快速算出任何一个元素的存储地址（即找到那个元素），可粗略认为访问每个元素所花费的时间相等（<strong>这种存取元素的方法称为随机存取法</strong>）</p></li><li><p>时间复杂度：查找、插入、删除算法的平均时间复杂度均为O(n)</p></li><li><p>存储密度大，等于1（存储密度&#x3D;结点本身所占存储量&#x2F;结点结构所占存储量）</p></li><li><p>可随机存取表中任一元素</p></li></ul><blockquote><p>链表</p></blockquote><ul><li><p>单链表由头指针唯一确定，因此单链表可用头指针的名字来命名</p></li><li><p>头指针：是指向链表中第一个结点的指针，即指向头结点</p></li><li><p>首元结点：是指链表中存储第一个数据元素的结点</p></li><li><p>头结点：附设在链表寿元结点之前的一个结点，是链表的第一个结点，头指针指向头结点</p></li><li><p>如何表示空表？</p><ul><li>无头结点时，头指针为空时表示空表</li><li>有头结点时，头结点的指针域为空时表示空表</li></ul></li><li><p>设置头结点有什么好处？</p><ul><li><p>便于首元结点的处理：首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无序进行特殊处理</p></li><li><p>便于空表和非空表的统一处理：在有头结点的情况下，无论链表是否为空，头指针都是指向头结点的非空指针，因此你空表和非空表的处理也就统一</p></li></ul></li><li><p>头结点的数据域放些什么？</p><ul><li>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但是此结点不能计入链表长度值，即计算表长时不能算头结点</li></ul></li><li><p>访问链表时，只能通过头指针进入链表，并且通过每个结点的指针域一次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不相同</p></li><li><p>链表时顺序存取的，顺序表是随机存取的</p></li><li><p>在看到如下代码时，怎么理解？(见注释)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">s-&gt;next = p-&gt;next;<span class="hljs-comment">//把p的指针域的指针（原本指向p后面一个结点的指针）赋值给s的指针域里的指针</span><br>p-&gt;next = s;<span class="hljs-comment">//把指向s结点的指针赋值给p的指针域里的指针</span><br></code></pre></td></tr></table></figure></li><li><p>单链表的查找、插入、删除算法时间效率分析</p><ul><li><p>因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为O(n)</p></li><li><p>插入和删除：因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为O(1)。但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)</p></li><li><p>头插法的时间复杂度是O(n)</p></li><li><p>尾插法的时间复杂度是O(n)</p></li></ul></li></ul><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ul><li><p>typedef</p><ul><li>是C语言关键字，是声明，用来给类型起别名</li><li>格式为：typedef   你要给起别名的数据类型    别名</li></ul></li><li><p>在头文件stdlib.h中</p><ul><li><p>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址</p></li><li><p>sizeof(x)运算，计算变量x的长度</p></li><li><p>free（p）函数，释放指针p所指变量的存储空间，即彻底删除一个变量</p></li></ul></li><li><p>new 类型名 T （初值列表） </p><ul><li>功能： 申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值 </li><li>结果值： <ul><li>成功：T类型的指针，指向新分配的内存 </li><li>失败：0（NULL)</li></ul></li><li>例如：int * p1 &#x3D; new int;或int * p1 &#x3D; new int(10); </li><li>注意：new出来的空间的返回值是一个地址所以只能赋值给指针</li></ul></li><li><p>delete 指针p </p><ul><li>功能： 释放指针p所指向的内存。p必须是new操作的返回值</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找——王卓</title>
    <link href="/2022/10/13/%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%9F%A5%E6%89%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第7章-查找"><a href="#第7章-查找" class="headerlink" title="第7章 查找"></a>第7章 查找</h1><h2 id="7-1-查找的基本概念"><a href="#7-1-查找的基本概念" class="headerlink" title="7.1 查找的基本概念"></a>7.1 查找的基本概念</h2><p><strong>查找表</strong>是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着<strong>松散的关系</strong>，因此查找表是一种应用灵便的结构。</p><p><strong>查找</strong>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）</p><ul><li><p><strong>关键字</strong>：用来标识一个数据元素（或记录）的某个数据项的值</p><ul><li><p><strong>主关键字</strong>：可唯一地标识一个记录的关键字是主关键字；</p></li><li><p><strong>次关键字</strong>：反之，用以识别若干记录的关键字是次关键字。</p></li></ul></li></ul><ol><li><p>查找的目的：</p><ul><li><p>查询某个“特定的”数据元素是否在查找表中；</p></li><li><p>检索某个“特定的“数据元素的各种属性；</p></li><li><p>在查找表中插入一个数据元素；</p></li><li><p>删除查找表中的某个数据元素。</p></li></ul></li><li><p>查找的分类</p><ul><li><p><strong>静态查找表</strong>：仅作“查询”（检索）操作的查找表</p></li><li><p><strong>动态查找表</strong>：作“插入”和“删除”操作的查找表</p></li></ul></li><li><p>如何评价查找算法</p><ul><li><p>查找算法的评价指标“：关键字的平均比较次数，也称为<strong>平均查找长度</strong>，（ASL, Average Search Length）。</p></li><li><p>平均查找长度定义</p></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131110029.png"></p><p>4.查找的过程中我们要研究什么？</p><p>查找的方法取决于查找表的结构，即表中数据元素是依何种关系组织在一起的。</p><p>由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时，若无规律可循，只能对集合中的元素一一加以辨认直至找到为止。而这样的“查询”或“检索”是任何计算机应用系统中使用频度都很高的操作，因此设法提高查找表的查找效率，是本章讨论问题的出发点。</p><p>为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的约束关系。</p><h2 id="7-2-线性表的查找"><a href="#7-2-线性表的查找" class="headerlink" title="7.2 线性表的查找"></a>7.2 线性表的查找</h2><h3 id="7-2-1-顺序查找（线性查找）"><a href="#7-2-1-顺序查找（线性查找）" class="headerlink" title="7.2.1 顺序查找（线性查找）"></a>7.2.1 顺序查找（线性查找）</h3><p>应用范围：顺序表或线性链表表示的<strong>静态查找表</strong>；表内元素之间无序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 若成功返回其位置信息，否则返回0</span><br>    <span class="hljs-keyword">for</span>(i = ST.length; i &gt;= <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(ST.R[i].key == key) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进：把待查关键字key存入表头（“哨兵”、”监视哨”），从后往前逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Seq</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    ST.R[<span class="hljs-number">0</span>].key = key;<br>    <span class="hljs-keyword">for</span>(i = ST.length; ST.R[i].key != key; i--);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>当ST.length较大时，此改进能使进行一次查找所需的平均时间几乎减少一半。</p><ul><li><p>时间复杂度：O(n)，查找成功时的平均查找长度为：<code>ASL(n) = (1+2+...+n)/n = (n+1)/2</code>。</p></li><li><p>空间复杂度：一个辅助空间，O(1)。</p></li></ul><p>讨论：</p><ol><li><p>记录的查找概率不相等时如何提高查找效率？</p><p> 查找表存储记录原则按查找概率高低存储：</p><ol><li><p>查找概率越高，比较次数越少；</p></li><li><p>查找概率越低，比较次数较多。</p></li></ol></li><li><p>记录的查找概率无法测定时如何提高查找效率？</p><p> 方法——按查找概率<strong>动态调整</strong>记录顺序：</p><ol><li><p>在每个记录中设一个访问频度域；</p></li><li><p>始终保持记录按非递增有序的次序排列；</p></li><li><p>每次查找后均将刚查到的记录直接移至表头。</p></li></ol></li></ol><p>优点：算法简单，逻辑次序无要求，且不同存储结构均适用。</p><p>缺点：ASL太长，时间效率太低</p><h3 id="7-2-2-折半查找（二分或对分查找）"><a href="#7-2-2-折半查找（二分或对分查找）" class="headerlink" title="7.2.2 折半查找（二分或对分查找）"></a>7.2.2 折半查找（二分或对分查找）</h3><p><strong>折半查找</strong>：每次将待查记录所在区间缩小一半。</p><ul><li><p>折半查找算法：（非递归算法）</p><ul><li><p>设表长为n，low、high和mid分别指向待查元素所在区间的上界、下界和中点，key为给定的要查找的值；</p></li><li><p>初始时，令low&#x3D;1，high&#x3D;n，mid&#x3D;floar((low+high)&#x2F;2)</p></li><li><p>让k与mid指向的记录比较</p><ul><li>若key&#x3D;&#x3D;R[mid].key，查找成功；</li><li>若key&lt;R[mid].key，high&#x3D;mid-1；</li><li>若key&gt;R[mid].key，low&#x3D;mid+1；</li></ul></li><li><p>重复上述操作，直至low&gt;high时，查找失败</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, KeyTable key)</span></span><br><span class="hljs-function"></span>&#123;<br>    low = <span class="hljs-number">1</span>; high = ST.length;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)<br>    &#123;<br>        mid = (low + high) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(ST.R[mid].key == key) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; ST.R[mid].key)<br>            high = mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>            low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Search_Bin</span><span class="hljs-params">(SSTable ST, KeyTable key, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    mid = (low + high) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(key == ST.elem[mid].key) <span class="hljs-keyword">return</span> mid;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; ST.elem[mid].key)<br>        <span class="hljs-built_in">Search_Bin</span>(ST,key, mid<span class="hljs-number">-1</span>, high);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">Search_Bin</span>(ST,key, low, mid+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>假定每个元素的查找概率相等，查找成功时的平均查找长度（ASL），设表长n&#x3D;2^h-1，则h&#x3D;log2(n+1)，查找概率相等为：1&#x2F;n，<code>ASL≈log2(n+1)-1    (n&gt;50)</code>。</p><p>优点：效率比顺序查找高</p><p>缺点：只适用于<strong>有序表</strong>，且限于<strong>顺序存储结构</strong>（对线性链表无效）。</p><h3 id="7-2-3-分块查找（索引顺序查找）"><a href="#7-2-3-分块查找（索引顺序查找）" class="headerlink" title="7.2.3 分块查找（索引顺序查找）"></a>7.2.3 分块查找（索引顺序查找）</h3><p>分块查找条件基础：</p><ol><li><p>将表分成几块，且表有序或者分块有序。若i &lt; j，则第j块中所有记录的关键字均大于第i块中的最大关键字。</p></li><li><p>建立”索引表“（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）。</p></li></ol><p>查找过程：先确定待查记录所在块（顺序或折半查找），再在块内查找（顺序查找）。</p><p>查找效率：ASL &#x3D; LB + LW；即对索引表查找的ASL加上对块内查找的ASL</p><ul><li>图2：分块查找效率<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131111682.png"></li></ul><p>优点：插入和删除较容易，无需进行大量移动</p><p>缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算</p><p>适用情况：如果线性表既要<strong>快速查找</strong>又经常<strong>动态变化</strong>，则可采用分块查找。</p><ul><li>图3：查找方法比较<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131111925.png"></li></ul><h2 id="7-3-树表的查找"><a href="#7-3-树表的查找" class="headerlink" title="7.3 树表的查找"></a>7.3 树表的查找</h2><h3 id="7-3-1-二叉排序树"><a href="#7-3-1-二叉排序树" class="headerlink" title="7.3.1 二叉排序树"></a>7.3.1 二叉排序树</h3><p><strong>二叉排序树</strong>（Binary Sort Tree）又称为二叉搜索树、二叉查找树。</p><ol><li><p>二叉排序树定义：</p><p> 二叉排序树或是空树，或是满足如下性质的二叉树：</p><ol><li><p>若其左子树非空，则左子树上所有结点的值均小于根结点的值；</p></li><li><p>若其右子树非空，则右子树上所有结点的值均大于等于根结点的值；</p></li><li><p>其左右子树本身又各是一棵二叉排序树</p></li></ol></li><li><p>二叉排序树的性质：</p><p> 中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的<strong>递增有序</strong>序列。</p></li><li><p>二叉排序树的操作——查找</p><ul><li><p>若查找的关键字等于根节点，成功。</p></li><li><p>否则：</p><ul><li><p>若小于根节点，查其左子树</p></li><li><p>若大于根节点，查找右子树</p></li></ul></li><li><p>在左右子树上的操作类似</p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-comment">// 二叉排序树的存储结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ElemType</span><br>&#123;<br>    KeyType key;    <span class="hljs-comment">// 关键字项</span><br>    InfoType otherInfo; <span class="hljs-comment">// 其他数据项</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span><br>&#123;<br>    ElemType data;      <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BSTNode</span> *lchild, *rchild;        <span class="hljs-comment">// 左右孩子指针</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> BSTNode* BSTree;<br><br><span class="hljs-comment">// 递归查找</span><br><span class="hljs-function">BSTree <span class="hljs-title">SearchBST</span><span class="hljs-params">(BSTree T, KeyType key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T || key == T-&gt;data.key) <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; T-&gt;data.key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">SearchBST</span>(T-&gt;rchild, key);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>二叉排序树的查找分析</p><p> 二叉排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径。</p><p> 比较的关键字次数 &#x3D; 此结点所在层次数；最多的比较次数 &#x3D; 树的深度</p><p> 对于含有n个结点的二叉排序树的平均查找长度和树的形状有关。</p><pre><code class="hljs"> - 最好情况：与折半查找中的判定树相同，O(log2n)； - 最坏情况：退化为单支树（类似于线性列表），树深度为n，ASL = (n+1)/2，O(n)；</code></pre><p> 为了提高形态不均衡的二叉排序树的查找效率，应当进行“平衡化”处理（即<strong>平衡二叉树</strong>），尽量使二叉树的形状均衡！</p></li><li><p>二叉排序树的操作——插入</p><ul><li><p>若二叉排序树为空，则插入结点作为根结点插入到空树中</p></li><li><p>否则，继续在其左、右子树上查找</p><ul><li><p>树中已有，不再插入</p></li><li><p>树中没有</p><ul><li>查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子</li></ul></li></ul></li></ul><p> <strong>插入的元素一定是叶子节点</strong>。</p></li><li><p>二叉排序树的操作——生成</p><p> 从空树出发，经过一系列的查找、插入操作之后，可生成一颗二叉排序树。</p><p> 一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。</p><p> 插入的结点均为叶子结点，故无需移动其他结点。相当于在有序序列上插入记录而无需移动其他记录。但是，<strong>关键字的输入顺序不同，建立的二叉排序树也不同</strong>。</p></li><li><p>二叉排序树的操作——删除</p><p> 从二叉排序树中删除一个结点，不能把以该结点为根的子树者都删除，只能删掉该结点，并且<strong>还应保证删除后所得的二叉树仍然满足二叉排序树的性质不变</strong>。</p><p> 由于中序遍历二叉排序树可以得到一个递增有序的序列。那么，在二叉排序树中删去一个结点相当于删去有序序列中的一个结点。</p><pre><code class="hljs"> - 将因删除结点而断开的二叉链表重新链接起来 - 防止重新链接后树的高度增加</code></pre><ol><li><p>如果删除的结点是叶子结点：直接删除该结点。</p></li><li><p>被删除的结点只有左子树或者只有右子树，用其左子树或者右子树替换它（结点替换）。</p></li><li><p>本删除的结点既有左子树，也有右子树：可以用其中序的前驱结点替换，然后删除该前驱结点（前驱结点是左子树中最大的结点）；也可以用中序的后继结点，然后删除该后继结点（后继是右子树中最小的结点）。</p></li></ol></li></ol><h3 id="7-3-2-平衡二叉树"><a href="#7-3-2-平衡二叉树" class="headerlink" title="7.3.2 平衡二叉树"></a>7.3.2 平衡二叉树</h3><ol><li><p>平衡二叉树的定义</p><p> <strong>平衡二叉树</strong>（balanced binary tree），又称为AVL树（Adelson-Velskii and Landis）。</p><p> 一棵平衡二叉树或者是空树，或者是具有以下性质的<strong>二叉排序树</strong>：</p><ul><li><p>左子树与右子树的高度之差的绝对值小于等于1；</p></li><li><p>左子树和右子树也是<strong>平衡二叉排序树</strong>。</p></li></ul><p> 左子树与右子树的高度差又称为结点的平衡因子（BF），<code>平衡因子=结点左子树的高度-结点右子树的高度</code>。根据平衡二叉树的定义，平衡二又树上所有结点的平衡因子只能是-1、0，或1。</p></li></ol><p>对于一棵有n个结点的AVL树，其高度保持在O(log2n)数量级，ASL也保持在O(log2n)量级。</p><ol start="2"><li><p>失衡二叉排序树的分析与调整</p><p>当我们在一个平衡二叉排序树上插入一个结点时，有可能导致<strong>失衡</strong>，即出现平衡因子绝对值大于1的结点。</p><p>如果在一个AVL树中插入一个新结点后造成失衡，则必须<strong>重新调整树的结构</strong>，使之回复平衡。</p></li></ol><p>平衡调整的四种类型：LL型、LR型、RL型和RR型</p><ul><li><p>图4：平衡调整的四种类型示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131112212.png"></p></li><li><p>图5：平衡调整的四种类型调整后示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131113075.png"></p></li></ul><p>平衡调整的原则：1）降低高度；2）保持二叉排序树性质</p><ol><li>LL型调整</li></ol><ul><li><p>图6：LL型调整前-后对比示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131113389.png"></p></li><li><p>B结点带左子树一起上升</p></li><li><p>A结点成为B的右孩子</p></li><li><p>原来B结点的右子树作为A的左子树</p></li><li><p>图7：LL型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131114924.png"></p></li></ul><ol start="2"><li>RR型调整</li></ol><ul><li><p>图8：RR型调整前-后对比示意图<br>  <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131115509.png"></p></li><li><p>B结点带右节点一起上升</p></li><li><p>A结点成为B结点的左孩子</p></li><li><p>原来B结点的左子树作为A的右子树</p></li><li><p>图9：RR型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131116899.png"></p></li></ul><ol start="3"><li>LR型调整</li></ol><ul><li><p>图10：LR型调整前-后对比示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131117344.png"></p></li><li><p>C结点穿过A、B结点上升</p></li><li><p>B结点成为C的左孩子，A结点成为C的右孩子</p></li><li><p>原来C结点的左子树作为B的右子树，原来C结点的右子树作为A的左子树</p></li><li><p>图11：LR型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131118813.png"></p></li></ul><ol start="4"><li>RL型调整</li></ol><ul><li><p>图12：RL型调整前示意图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131118548.png"></p></li><li><p>图13：RL型调整示例<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131119631.png"></p></li></ul><h2 id="7-4-哈希表的查找（散列表的查找）"><a href="#7-4-哈希表的查找（散列表的查找）" class="headerlink" title="7.4 哈希表的查找（散列表的查找）"></a>7.4 哈希表的查找（散列表的查找）</h2><h3 id="7-4-1-散列表的基本概念"><a href="#7-4-1-散列表的基本概念" class="headerlink" title="7.4.1 散列表的基本概念"></a>7.4.1 散列表的基本概念</h3><p>基本思想：<strong>记录的存储位置与关键字之间的存在对应关系</strong>，对应关系常成为hash函数。</p><p><strong>优点：查找效率高；缺点：空间效率低！</strong></p><p><strong>散列方法（杂凑法）</strong>：选取某个函数，依该函数按关键字<strong>计算元素的存储位置</strong>，并按此存放。查找时，<strong>由同一个函数对给定值k计算地址</strong>，将k与地址单元中元素关键码进行对比，确定查找是否成功。</p><p><strong>散列函数（杂凑函数）</strong>：散列方法中适用的<strong>转换函数</strong>。</p><p><strong>冲突</strong>：不同的关键码映射到同一个散列地址，则称为冲突。</p><h3 id="7-4-2-散列函数的构造方法"><a href="#7-4-2-散列函数的构造方法" class="headerlink" title="7.4.2 散列函数的构造方法"></a>7.4.2 散列函数的构造方法</h3><p>在散列查找方法中，冲突是不可避免的，只能尽可能避免。使用散列表要解决的两个主要为题包括：</p><ol><li><p>构造好的散列函数</p><ul><li><p>所选函数尽可能简单，以便提高转换速度；</p></li><li><p>所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。</p></li></ul></li><li><p>制定一个好的解决冲突的方案</p><ul><li>查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。</li></ul></li></ol><p>构造散列函数考虑的因素：执行速度、关键字的长度、散列表的大小、关键字的分布情况、查找频率。</p><p>根据元素集合的特性构造，<strong>要求一</strong>：n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的<strong>地址空间尽量小</strong>。<strong>要求二</strong>：无论用什么方法存储，目的都是尽量<strong>均匀</strong>地存放元素，以避免冲突。</p><p>常见构造方法包括有：直接定址法、数字分析法、平方取中法、折叠法、<strong>除留余数法</strong>、随机数法。</p><p><strong>直接定址法</strong>：以关键码key的某个线性函数值为散列地址，不会产生冲突。但是要占用连续地址空间，空间效率低。</p><p><strong>除留余数法</strong>：<code>Hash(key) = key mod p(其中p是一个整数)</code>，常见p值取小于表长的质数。</p><h3 id="7-4-3-处理冲突的方法"><a href="#7-4-3-处理冲突的方法" class="headerlink" title="7.4.3 处理冲突的方法"></a>7.4.3 处理冲突的方法</h3><ol><li><p>开放地址法（开地址法）</p><p> 当有冲突时就去寻找<strong>下一个</strong>空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。常见方法包括：<strong>线性探测法</strong>、<strong>二次探测法</strong>、<strong>伪随机探测法</strong>。<code>Hi = (Hash(key) + di) mod m, m是散列表长度, di是增量序列</code></p><p> 线性探测法：<code>di为1, 2, ..., m-1线性序列</code>，一旦冲突，就找下一个地址，直到找到空地址存入。</p><p> 二次探测法：<code>di为1^2, -1^2, 2^2, -2^2， ..., q^2二次序列</code>。</p><p> 伪随机探测法：<code>di为伪随机数序列</code>。</p></li><li><p>链地址法（拉链法）</p><p> 将相同散列地址的记录链成一个单链表，<strong>m个散列地址就设m个单链表</strong>，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。</p><p> 链地址法建立散列表步骤：</p><ol><li><p>取数据元素的关键字key，计算其散列函数值（地址）。若该地址对应的链表为空，则将该元素插入此链表；否则执行步骤2解决冲突。</p></li><li><p>根据选择的冲突处理方法，计算关键字key的下一个存储地址。若该地址对应的链表为不为空，则利用链表的前插法或后插法将该元素插入此链表。</p></li></ol><p> 连地址法的优点：非同义词<strong>不会冲突</strong>，无聚集现象；链表上结点空间动态申请，更适合于表长不确定的情况；</p></li><li><p>再散列法（双散列函数法）</p></li><li><p>建立一个公共溢出区</p></li></ol><h3 id="7-4-4-散列表的查找及性能分析"><a href="#7-4-4-散列表的查找及性能分析" class="headerlink" title="7.4.4 散列表的查找及性能分析"></a>7.4.4 散列表的查找及性能分析</h3><ul><li>图14：散列表查找流程图<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131119199.png"></li></ul><p>散列表的查找效率，如果使用平均查找长度ASL来衡量，则ASL取决于：散列函数、处理冲突的方法、散列表的<strong>装填因子</strong>α（<code>α=表中填入的记录数/哈希表的长度</code>）。</p><p>其中，α越大，表中记录的数据越多，说明表装填的越满，发生冲突的可能性越大，查找时比较次数就越多。</p><p>ASL与装填因子α有关，既不是严格的O(1)，也不是O(n)。</p><p><code>ASL≈1+α/2(拉链法);ASL≈1/2*(1+(1/(1-α)))(线性探测法);ASL≈-(1/α)*ln(1-α)(随机探测法)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图——王卓</title>
    <link href="/2022/10/13/%E5%9B%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E5%9B%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第6章-图"><a href="#第6章-图" class="headerlink" title="第6章 图"></a>第6章 图</h1><p>图是一种比线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层中的多个元素（即其孩子结点）相关，但只能和上一层中一个元素（即其双亲结点）相关；而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。在数据结构中，应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构，以及若于图的操作的实现。</p><h2 id="6-1-图的定义和基本术语"><a href="#6-1-图的定义和基本术语" class="headerlink" title="6.1 图的定义和基本术语"></a>6.1 图的定义和基本术语</h2><h3 id="6-1-1-图的定义"><a href="#6-1-1-图的定义" class="headerlink" title="6.1.1 图的定义"></a>6.1.1 图的定义</h3><p>图(Graph)G由两个集合V和E组成，记为G&#x3D;(V,E)：</p><ul><li><p>V(vertex)是顶点的<strong>有穷非空集合</strong>;</p></li><li><p>E(Edge)是V中顶点偶对的<strong>有穷集合</strong>，这些顶点偶对称为<strong>边</strong>。</p></li></ul><p>V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。</p><p>对于图G，若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。</p><p>对于图G，若图中任意两个点之间都有一条边相连，则称为<strong>完全图</strong>。对于n个顶点，则无向完全图有n(n-1)&#x2F;2条边，有向完全图有n(n-1)条边。</p><h3 id="6-1-2-图的基本术语"><a href="#6-1-2-图的基本术语" class="headerlink" title="6.1.2 图的基本术语"></a>6.1.2 图的基本术语</h3><p>用n表示图中顶点数目，用e表示边的数目，下面介绍图结构中的一些基本术语。</p><ol><li><p><strong>无向完全图</strong>和<strong>有向完全图</strong>：对于无向图，若具有n(n- 1)&#x2F;2条边，则称为无向完全图。对于有向图，若具有n(n-1)条弧，则称为有向完全图。</p></li><li><p><strong>稀疏图</strong>和<strong>稠密图</strong>：有很少条边或弧(如e &lt; nlogn)的图称为稀疏图，反之称为稠密图。</p></li><li><p><strong>权</strong>和<strong>网</strong>：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。<strong>这种带权的图通常称为网</strong>。</p></li><li><p><strong>邻接</strong>：描述图中两个顶点之间的关系，有边&#x2F;弧相连的两个顶点，称为两顶点邻接。</p></li><li><p><strong>邻接点</strong>：对于无向图G，如果图的边(v, v’)∈E，则称顶点v和v’互为邻接点，即v和v’相邻接。边(v, v’)<strong>依附于</strong>顶点v和v’，或者说边(v, v’)与顶点v和v’<strong>相关联</strong>。在有向图中，存在<code>&lt;v, v&#39;&gt;</code>，则称<strong>v邻接到v’，v’邻接于v</strong>。</p></li><li><p><strong>度</strong>、<strong>入度</strong>和<strong>出度</strong>：顶点的度是指和v<strong>相关联的边的数目</strong>，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v),顶点v的度为TD(v) &#x3D; ID(v) + OD(v)。</p></li><li><p><strong>路径</strong>和<strong>路径长度</strong>：接续的边构成的顶点序列。在无向图G中，从顶点v到顶点v’的路径是一个顶点序列。如果G是有向图，则路径也是有向的。路径长度是一条路径上经过的边或弧的数目或权值之和。</p></li><li><p><strong>回路</strong>或<strong>环</strong>：第一个顶点和最后一个顶点相同的路径称为回路或环。</p></li><li><p><strong>简单路径</strong>、<strong>简单回路</strong>或<strong>简单环</strong>：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p></li><li><p><strong>连通</strong>、<strong>连通图</strong>和<strong>连通分量</strong>：在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的。如果对于图中任意两个顶点Vi、Vj，Vi和Vj都是连通的，则称G是连通图。所谓连通分量，指的是无向图中的极大连通子图。其中极大连通子图意思是：<strong>该子图是连通子图，将G的任何不在该子图中的顶点加入，子图不再连通</strong>。</p></li><li><p><strong>强连通图</strong>和<strong>强连通分量</strong>：在有向图G中，如果对于每一对Vi, Vj，从Vi到Vj和从Vj到Vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。</p></li><li><p>极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，该子图不再连通。</p></li><li><p><strong>连通图的生成树</strong>：包含无向图G所有顶点的极小连通图；一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边，这样的连通子图称为连通图的生成树。</p></li><li><p><strong>有向树</strong>和<strong>生成森林</strong>：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p></li></ol><h2 id="6-2-案例引入"><a href="#6-2-案例引入" class="headerlink" title="6.2 案例引入"></a>6.2 案例引入</h2><h2 id="6-3-图的类型定义"><a href="#6-3-图的类型定义" class="headerlink" title="6.3 图的类型定义"></a>6.3 图的类型定义</h2><p>图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。抽象数据类型图的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADTGraph&#123;<br>    数据对象： V是具有相同特性的数据元素的集合，称为顶点集。<br>数据关系：<br>    R = &#123;VR&#125;<br>    VR = &#123;&lt;v, w&gt;|v, w属于V，且<span class="hljs-built_in">P</span>(v, w) &lt;v, w&gt;表示从v到w的弧，谓词<span class="hljs-built_in">P</span>(v, w)定义了弧&lt;v, w&gt;的意义或信息&#125;<br>基本操作：<br>    图的创建、增删改查等。其中重要的包括有构造图、深度优先搜索、广度优先搜索。<br></code></pre></td></tr></table></figure><h2 id="6-4-图的存储结构"><a href="#6-4-图的存储结构" class="headerlink" title="6.4 图的存储结构"></a>6.4 图的存储结构</h2><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但<strong>可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法（数组表示法）</strong>。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有<strong>邻接表</strong>、<strong>十字链表</strong>和<strong>邻接多重表</strong>，应根据实际需要的不同选择不同的存储结构。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121945.png"></p><h3 id="6-4-1-邻接矩阵"><a href="#6-4-1-邻接矩阵" class="headerlink" title="6.4.1 邻接矩阵"></a>6.4.1 邻接矩阵</h3><ol><li><p>邻接矩阵表示法</p><p> 建立一个<strong>顶点表</strong>(记录哥各个顶点信息)和一个<strong>邻接矩阵</strong>(表示各个顶点之间关系)。</p><p> <strong>邻接矩阵</strong>(<strong>Adjacency Matrix</strong>)是表示顶点之间相邻关系的矩阵。设G(V, E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">A[i][j] = <span class="hljs-number">1</span>; 若&lt;i, j&gt;∈E或者(i, j)∈E<br>A[i][j] = <span class="hljs-number">0</span>; 否则<br></code></pre></td></tr></table></figure><ul><li>分析1：无向图的邻接矩阵是对阵的；</li><li>分析2：顶点i的度&#x3D;第i行(列)中的1的个数；</li><li>分析3：完全图的邻接矩阵中，对焦元素为0，其余为1。</li></ul><p> 有向图的邻接矩阵需考虑边的方向。</p><ul><li>分析1：有向图的邻接矩阵可能是不对称的；</li><li>分析2：顶点的出度&#x3D;第i行元素之和，顶点的入度&#x3D;第i列元素之和，顶点的度&#x3D;第i行元素之和+第i列元素之和。</li></ul><p> 网(即有权图)的邻接矩阵表示法：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">A[i][j] = Wij; 若&lt;vi, vj&gt;或(vi, vj)∈VR<br>A[i][j] = ∞; 无边(弧)<br>其中，Wij表示边上的权值；∞表示计算机允许的、大于所有边上权值的数。<br></code></pre></td></tr></table></figure><p> 用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。其形式说明如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//-----图的邻接矩阵存储表示－－－－－</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxInt  32767</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum   100         <span class="hljs-comment">// 最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VerTexType;    <span class="hljs-comment">// 设顶点的数据类型为字符型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ArcType;        <span class="hljs-comment">// 假设边的权值类型为整型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    VerTexType  vexs[MVNum];    <span class="hljs-comment">// 顶点表</span><br>    ArcType     arcs[MVNum][MVNum]; <span class="hljs-comment">// 邻接矩阵</span><br>    <span class="hljs-type">int</span> vexnum, arcnum; <span class="hljs-comment">// 图的当前点数和边数</span><br>&#125;AMGraph;<br></code></pre></td></tr></table></figure></li><li><p>采用邻接矩阵表示法创建无向网</p><p> 已知一个图的点和边，使用邻接矩阵表示法来创建此图的方法比较简单，下面以一个无向网为例来说明创建图的算法。</p><p> 算法步骤：</p><ol><li>输入总顶点数和总边数。</li><li>依次输入点的信息存入顶点表中。</li><li>初始化邻接矩阵，使每个权值初始化为极大值。</li><li>构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。</li></ol><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">CreateUDN</span><span class="hljs-params">(AMGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 采用邻接矩阵表示法，创建无向网G</span><br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;        <span class="hljs-comment">// 输入总顶点数，总边数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-comment">// 依次输入顶点信息</span><br>        cin &gt;&gt; G.vexs[i];<br>    &#125;<br>    <span class="hljs-comment">// 初始化邻接矩阵，边的权值均置为极大值MaxInt</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; i &lt; G.vexnum; j++)<br>        &#123;<br>            G.arcs[i][j] = MaxInt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 构造邻接矩阵</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++)<br>    &#123;<br>        <span class="hljs-comment">// 输人一条边依附的顶点及权值</span><br>        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<br>        <span class="hljs-comment">// 确定v1和v2在G中的位置，即顶点数组的下标</span><br>        i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        <span class="hljs-comment">// 边&lt;v1,v2&gt;的权值为w</span><br>        G.arcs[i][j] = w;<br>        G.arcs[j][i] = G.arcs[i][j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocatVex</span><span class="hljs-params">(AMGraph G, VerTexType u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(u == G.vexs[i])<br>        &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 该算法的时间复杂度是0(n^2)。</p><p> 若要建立无向图，只需对上述算法做两处小的改动：<strong>一是初始化邻接矩阵时，将边的权值均初始化为0；二是构造邻接矩阵时，将权值w改为常量值1即可</strong>。同样，将该算法稍做修改即可建立一个有向网或有向图，即邻接矩阵为非对称矩阵。</p></li><li><p>邻接矩阵表示法的优缺点</p><blockquote><p>优点</p></blockquote><ol><li><p>便于判断两个顶点之间是否有边，即根据A[i][j] &#x3D; 0或1来判断。</p></li><li><p>方便找任意顶点的所有邻接点；</p></li><li><p>便于计算各个顶点的度。对于无向图，邻接矩阵第i行元素之和就是顶点i的度；对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。</p></li></ol><blockquote><p>缺点</p></blockquote><ol><li><p>不便于增加和删除顶点。</p></li><li><p>不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2)</p></li><li><p>空间复杂度高。如果是有向图，n个顶点需要n^2个单元存储边。</p><p> 如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要n(n-1)&#x2F;2个单元即可。</p></li></ol></li></ol><h3 id="6-4-2-邻接表"><a href="#6-4-2-邻接表" class="headerlink" title="6.4.2 邻接表"></a>6.4.2 邻接表</h3><ol><li><p>邻接表表示法</p><p> <strong>邻接表</strong>(<strong>Adjacency List</strong>)是图的一种链式存储结构。在邻接表中，对图中每个顶点vi建立一个单链表，把与vi相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：<strong>表头结点表</strong>和<strong>边表</strong>。</p><ol><li><p><strong>表头结点表</strong>：由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。表头结点包括数据域(data)和链域(firstarc)两部分。其中，数据域用于存储顶点vi的名称或其他有关信息；链域用于指向链表中第一个结点（即与顶点vi邻接的第一个邻接点）。</p></li><li><p><strong>边表</strong>：由表示图中顶点间关系的2n个边链表组成。边链表中边结点包括<strong>邻接点域(adjvex)、数据域(info)和链域(nextarc)三部分</strong>。其中，邻接点域指示与顶点vi邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点vi邻接的下一条边的结点。</p></li></ol><p> 特点：</p><ul><li>邻接表不唯一；</li><li>若<strong>无向图</strong>中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适合存储稀疏图；</li><li><strong>无向图</strong>中顶点vi的度为第i个单链表中的结点数。</li></ul><p> 有向图的邻接表特点：</p><ul><li>顶点vi的出度为第i个单链表中的结点个数</li><li>顶点vi的入读为整个单链表中邻接点域值是i-1的结点个数。</li></ul><p> 反之，逆邻接表记录的是入度，所以找入度易，找出度难。</p><p> <strong>当邻接表的存储结构形成后，图便惟一确定</strong>。</p><p> 根据上述讨论，要定义一个邻接表，需要先定义其存放顶点的头结点和表示边的边结点。图的邻接表存储结构说明如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MVNum 100           <span class="hljs-comment">// 最大顶点数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcNode</span>      <span class="hljs-comment">// 边结点</span><br>&#123;<br>    <span class="hljs-type">int</span> adjvex;             <span class="hljs-comment">// 该边所指向的顶点的位置</span><br>    ArcNode* nextarc;       <span class="hljs-comment">// 指向下一条边的指针</span><br>    OtherInfo info;         <span class="hljs-comment">// 和边相关的信息</span><br>&#125;ArcNode;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">VNode</span>        <span class="hljs-comment">// 顶点信息</span><br>&#123;<br>    VerTexType data;<br>    ArcNode *firstarc;      <span class="hljs-comment">// 指向第一条依附于该顶点的边的指针</span><br>&#125;VNode, AdjList[MVNum];     <span class="hljs-comment">// AdjList表示邻接表类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ALGraph</span><br>&#123;<br>    AdjList vertices;       <span class="hljs-comment">// 邻接表数组</span><br>    <span class="hljs-type">int</span> vexnum, arcnum;     <span class="hljs-comment">// 图的当前定点数和边数</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>采用邻接表表示法创建无向图</p><p> 算法思想:</p><ol><li>输入总顶点数和总边数。</li><li>依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。</li><li>创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj对应的两个边链表的头部。</li></ol><blockquote><p>算法实现</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">CreateUDG</span><span class="hljs-params">(ALGraph &amp;G)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 采用邻接表表示法，创建无向图G</span><br>    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;    <span class="hljs-comment">// 输入总顶点数，总边数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)<br>    &#123;<span class="hljs-comment">// 输入各点，构造表头结点表</span><br>        cin &gt;&gt; G.vertices[i].data;  <span class="hljs-comment">// 输入顶点值</span><br>        G.vertices[i].firstarc = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 初始化各表头结点的指针域为NULL</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; G.arcnum; k++)<br>    &#123;<span class="hljs-comment">// 输入各边，构造邻接表</span><br>        cin &gt;&gt; v1 &gt;&gt; v2;<br>        <span class="hljs-comment">// 确定v1和v2在G中的位置，即顶点在G.vertices中的序号</span><br>        i = <span class="hljs-built_in">LocateVex</span>(G, v1);<br>        j = <span class="hljs-built_in">LocateVex</span>(G, v2);<br>        p1 = <span class="hljs-keyword">new</span> ArcNode;   <span class="hljs-comment">// 生成一个新的边结点</span><br>        p1-&gt;adjvex = j;     <span class="hljs-comment">// 邻接点序号为j</span><br>        <span class="hljs-comment">// 将新结点p1插入顶点vi的边表头部</span><br>        p1-&gt;nextarc = G.vertices[i].firstarc;<br>        G.vertices[i].firstarc = p1;<br>        p2 = <span class="hljs-keyword">new</span> ArcNode;   <span class="hljs-comment">// 生成另一个对称的新的边结点</span><br>        p2-&gt;adjvex = i;<br>        <span class="hljs-comment">// 将新结点p2插入顶点vj的边表头部</span><br>        p2-&gt;nextarc = G.vertices[j].firstarc;<br>        G.vertices[j].firstarc = p2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p> 该算法的时间复杂度是O(n + e)。</p><p> 建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号&lt;i,j&gt;，仅需生成一个邻接点序号为j的边表结点，并将其插入到vi；的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。</p></li><li><p>邻接表表示法的优缺点</p><p> 优点：</p><ol><li>便于增加和删除顶点。</li><li>便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n + e)。</li><li>空间效率高。对于一个具有n个顶点e条边的图G，若G是无向图，则在其邻接表表示中有n个顶点表结点和2e个边表结点；若G是有向图，则在它的邻接表表示或逆邻接表表示中均有n个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为O(n + e),适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。</li></ol><p> 缺点：</p><ol><li>不便于判断顶点之间是否有边，要判定vi和vj之间是否有边，就需扫描第i个边表，最坏情况下要耗费O(n)时间。</li><li>不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点vi的度是第i个边表中的结点个数。在有向图的邻接表中，第i个边表上的结点个数是顶点vi的出度，但求vi的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。</li></ol></li><li><p>邻接矩阵与邻接表示法的关系</p><ol><li><p><strong>联系</strong>：邻接表中每个链表对应邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。</p></li><li><p><strong>区别</strong>：</p><ul><li><p>对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。</p></li><li><p>邻接矩阵的空间复杂度为O(n^2)，而领接表的空间复杂度为O(n+e)；</p></li></ul></li><li><p><strong>用途</strong>：邻接矩阵多用于稠密图；而邻接表多用于稀疏图。</p></li></ol></li></ol><h3 id="6-4-3-十字链表"><a href="#6-4-3-十字链表" class="headerlink" title="6.4.3 十字链表"></a>6.4.3 十字链表</h3><p><strong>十字链表</strong>(<strong>Orthogonal List</strong>)是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。</p><p><strong>有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点</strong>。</p><p>在弧结点中有5个域：其中尾域(tailvex)和头域(headvex)分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink指向弧尾相同的下一条弧，info域指向该弧的相关信息。</p><p>头结点即顶点结点，它由3个域组成：其中data域存储和顶点相关的信息，如顶点的名称等；firstin和firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。</p><h3 id="6-4-4-邻接多重表"><a href="#6-4-4-邻接多重表" class="headerlink" title="6.4.4 邻接多重表"></a>6.4.4 邻接多重表</h3><p><strong>邻接多重表</strong>(<strong>Adjacency Multilist</strong>)是无向图的另一种链式存储结构。</p><p>邻接多重表的结构和十字链表类似。在邻接多重表中，每一条边用一个结点表示。其中，mark为标志域，可用以标记该条边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域。</p><p>每一个顶点也用一个结点表示，其中，data域存储和该顶点相关的信息，firstedge域指示第一条依附于该顶点的边。</p><h2 id="6-5-图的遍历"><a href="#6-5-图的遍历" class="headerlink" title="6.5 图的遍历"></a>6.5 图的遍历</h2><p>和树的遍历类似，图的遍历也是从图中某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。</p><p>为避免重复访问，可设置辅助数组visited[n]，用来标记每个被访问过的顶点。</p><ul><li>初始状态visited[i]为0；</li><li>顶点i被访问，改visited[i]为1，防止被多次访问</li></ul><p>根据搜索路径的方向，通常有两条遍历图的路径：深度优先搜索和广度优先搜索。它们对无向图和有向图都适用。</p><h3 id="6-5-1-深度优先搜索"><a href="#6-5-1-深度优先搜索" class="headerlink" title="6.5.1 深度优先搜索"></a>6.5.1 深度优先搜索</h3><ol><li><p>深度优先搜索遍历的过程</p><p> <strong>深度优先搜索</strong>(<strong>DepthFirst Search, DFS</strong>)遍历类似于树的先序遍历，是树的先序遍历的推广。对于一个连通图，深度优先搜索遍历的过程如下：</p><ol><li><p>从图中某个顶点v出发，访问v。</p></li><li><p>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。</p></li><li><p>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</p></li><li><p>重复步骤(2)和(3),直至图中所有顶点都被访问过，搜索结束。</p></li></ol></li><li><p>深度优先搜索遍历的算法实现</p><p> 显然，深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为”false，一旦某个顶点被访问，则其相应的分量置为”true”。</p><p> 算法6.3 深度优先搜索遍历连通图</p><p> 算法步骤：</p><ol><li><p>从图中某个顶点v出发，访问v，并置visited[v]的值为true。</p></li><li><p>依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历，直到图中所有顶点都被访问过。</p></li></ol> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> visited[MVNum];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(w = <span class="hljs-built_in">FitstAdjVex</span>(G, v); w &gt;= <span class="hljs-number">0</span>; w = <span class="hljs-built_in">NextAdjVex</span>(G, v, w))<br>        <span class="hljs-keyword">if</span>(!visited[w])<br>            <span class="hljs-built_in">DFS</span>(G, w);<br>&#125;<br></code></pre></td></tr></table></figure><p> 算法6.4 深度优先搜索遍历非连通图</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFSTracerse</span><span class="hljs-params">(Graph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v &lt; G.vexnum; ++v)<br>    &#123;<br>        visited[v] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(v = <span class="hljs-number">0</span>; v &lt; G.vexnum; ++v)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!visited[v])<br>            <span class="hljs-built_in">DFS</span>(G, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 算法6.5 采用邻接矩阵表示图的深度优先搜索遍历</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFs</span><span class="hljs-params">(AMGraph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> w = <span class="hljs-number">0</span>; w &lt; G.vexnum; w++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((G.arcs[v][w] != <span class="hljs-number">0</span>) &amp;&amp; (!visited[w]))<br>        &#123;<br>            <span class="hljs-built_in">DFS</span>(G, w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在的行，时间复杂度为O(n^2)。</p><p> 算法6.6 采用邻接表表示图的深度优先搜索遍历</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS_AL</span><span class="hljs-params">(ALGraph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// 图G为邻接表类型，从第v个顶点出发深度优先搜索遍历图G</span><br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    p = G.vertices[v].firstarc;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        w = p-&gt;adjvex;      <span class="hljs-comment">// 表示w是v的邻接点</span><br>        <span class="hljs-keyword">if</span>(!visited[w])<br>            <span class="hljs-built_in">DFS</span>(G,w);<br>        p = p-&gt;nextarc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问个头结点的时间，时间复杂度为O(n+e)。</p><p> 因此，<strong>稠密图适于在邻接矩阵上进行深度遍历</strong>，<strong>稀疏图适于在邻接表上进行深度遍历</strong>。</p></li></ol><h3 id="6-5-2-广度优先搜索"><a href="#6-5-2-广度优先搜索" class="headerlink" title="6.5.2 广度优先搜索"></a>6.5.2 广度优先搜索</h3><ol><li><p>广度优先搜索遍历的过程</p><p> <strong>广度优先搜索</strong>(<strong>Breadth First Search, BFS</strong>)遍历类似于树的按层次遍历的过程。广度优先搜索遍历的过程如下：</p><ol><li><p>从图中某个顶点v出发，访问v。</p></li><li><p>依次访问v的各个未曾访问过的邻接点。</p></li><li><p>分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤(3)，直至图中所有已被访问的顶点的邻接点都被访问到。</p></li></ol></li><li><p>广度优先搜索遍历的算法实现</p><p> 算法6.7 广度优先搜索遍历连通图</p><p> 算法步骤：</p><ol><li><p>从图中某个顶点v出发，访问v，并置visited[v]的值为true，然后将v进队。</p></li><li><p>只要队列不空，则重复下述操作：</p><ul><li><p>队头顶点u出队；</p></li><li><p>依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。</p></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; v;<br>    visited[v] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">InitQueue</span>(Q);<br>    <span class="hljs-built_in">EnQueue</span>(Q, v);  <span class="hljs-comment">//v入队</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(Q))<br>    &#123;<br>        <span class="hljs-built_in">DeQueue</span>(Q, u);  <span class="hljs-comment">// 队首元素出队并置为u</span><br>        <span class="hljs-keyword">for</span>(w = <span class="hljs-built_in">FirstAdjVex</span>(G, u); w &gt;= <span class="hljs-number">0</span>; <span class="hljs-built_in">NextAdjVex</span>(G, u, w))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[w])<br>            &#123;<br>                cout &lt;&lt; w;<br>                visited[w] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">EnQueue</span>(Q, w);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 遍历图的过程实质上是通过边找邻接点的过程，因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，即当用邻接矩阵存储时，时间复杂度为O(n^2)；用邻接表存储时，时间复杂度为O(n+e)。</p></li></ol><h3 id="6-5-3-DFS与BFS算法效率比较"><a href="#6-5-3-DFS与BFS算法效率比较" class="headerlink" title="6.5.3 DFS与BFS算法效率比较"></a>6.5.3 DFS与BFS算法效率比较</h3><ul><li><p>空间复杂度相同，都是O(n)（借用了堆栈或队列）；</p></li><li><p>时间复杂度只与存储结构、（邻接矩阵或邻接表）有关，而与搜索路径无关。</p></li></ul><h2 id="6-6-图的应用"><a href="#6-6-图的应用" class="headerlink" title="6.6 图的应用"></a>6.6 图的应用</h2><h3 id="6-6-1-最小生成树"><a href="#6-6-1-最小生成树" class="headerlink" title="6.6.1 最小生成树"></a>6.6.1 最小生成树</h3><p>生成树的共同特点：</p><ul><li><p>顶点个数与图的顶点个数相同；</p></li><li><p>是图的极小连通子图，去掉一条边则非连通；</p></li><li><p>一个有n个顶点的连通图的生成树有n-1条边；</p></li><li><p><strong>在生成树中再加一条边必然形成回路</strong>；</p></li><li><p>生成树中的任意两个顶点间的路径是惟一的。</p></li></ul><p>在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的<strong>最小代价生成树</strong>(<strong>Minimum Cost Spanning Tree</strong>)，简称为<strong>最小生成树</strong>。</p><p>构造最小生成树有多种算法，其中多数算法利用了最小生成树的下列一种简称为MST的性质：假设N&#x3D;(V, E)是一个连通网，U是顶点集V的一个非空子集。若(u, v)是一条具有最小权值（代价）的边，其中u∈U，v∈V-U，则必存在一棵包含边(u, v)的最小生成树。</p><p>MST性质解释：</p><p>在生成树的构造过程中，图中n个顶点分属两个集合：</p><ul><li><p>已落在生成树上的顶点集：U</p></li><li><p>尚未落在生成树上的顶点集：V-U</p></li></ul><p>接下来则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。</p><p>普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法是两个利用MST性质构造最小生成树的算法。下面先介绍普里姆算法。</p><ol><li><p>普里姆算法</p><p> 普里姆算法的构造过程：</p><p> 假设N&#x3D;(V,E)是连通网，TE是N上最小生成树中边的集合。</p><ol><li><p>U &#x3D; {u0}(u0∈V), TE &#x3D; {}。</p></li><li><p>在所有u∈U, v∈V- U的边(u,v)∈E中找一条权值最小的边(u0,v0)并入集合TE，同时v0并入U。</p></li><li><p>重复步骤2，直至U &#x3D; V为止。</p></li></ol><p> 此时TE中必有n-1条边，则T&#x3D; (V, TE)为N的最小生成树。</p><p> 普里姆算法的算法实现：</p><p> 假设一个无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，要求输出T的各条边。为实现这个算法需附设一个辅助数组closedge，以记录从U到V-U具有最小权值的边。对每个顶点vi∈V- U，在辅助数组中存在一个相应分量closedge[i-1], 它包括两个域：lowcost和adjvex，其中Iowcost存储最小边上的权值，adjvex存储最小边在U中的那个顶点。显然，closedge[i-1].lowcost &#x3D; Min{ cost(u, vi)|u∈U}，其中cost(u,v)表示赋于边(u,v)的权。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边</span><br><br><span class="hljs-keyword">struct</span><br>&#123;<br>    VerTexType adjvex;      <span class="hljs-comment">// 最小边在U中的那个顶点</span><br>    ArcType lowcost;        <span class="hljs-comment">// 最小边上的权值</span><br>&#125;closedge[MVNum];<br></code></pre></td></tr></table></figure><p> 算法6.8 普里姆算法</p><ol><li><p>首先将初始顶点u加入U中，对其余的每一个顶点Vj，将closedge[j]均初始化为到u的边息。</p></li><li><p>循环n - 1次，做如下处理：</p><ul><li><p>从各组边closedge中选出最小边closedge[k]，输出此边；</p></li><li><p>将k加入U中；</p></li><li><p>更新剩余的每组最小边信息closedge[j]，对于V-U中的边，新增加了一条从k到j的边，如果新边的权值比closedge[i].lowcost小，则将closedge[j].lowcost 更新为新边的权值。</p></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree_Prim</span><span class="hljs-params">(AMGraph G, VerTexType u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边</span><br>    k = <span class="hljs-built_in">LocateVex</span>(G, u);        <span class="hljs-comment">// k为顶点u的下标</span><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(j != k) closedge[j] = &#123;u, G.arcs[k][j]&#125;;<br>        closedge[k].lowcost = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 初始，U=&#123;u&#125;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; G.vexnum; ++i)<br>        &#123;<br>            <span class="hljs-comment">// 求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边</span><br>            u0 = closedge[k].adjvex;    <span class="hljs-comment">// u0为最小边的一个顶点</span><br>            v0 = G.vexs[k];             <span class="hljs-comment">// v0为最小边的另一个顶点</span><br>            cout &lt;&lt; u0 &lt;&lt; v0;<br>            closedge[k].lowcost = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(G.arcs[k][j] &lt; closedge[j].lowcost)<br>                &#123;<br>                    closedge[j] = &#123;G.vexs[k], G.arcs[k][j]&#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>克鲁斯卡尔算法</p><p> 算法步骤：</p><ol><li><p>将数组Edge中的元素按权值从小到大排序。</p></li><li><p>依次查看数组Edge中的边，循环执行以下操作：</p><ul><li><p>依次从排好序的数组Edge中选出一条边(U1,U2)；</p></li><li><p>在Vexset中分别查找V1和V2所在的连通分量vs1和vs2，进行判断：</p><ul><li><p>如果vs1和vs2不等，表明所选的两个顶点分属不同的连通分量，输出此边，并合并vs1和vs2两个连通分量；</p></li><li><p>如果vs1和vs2相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。</p></li></ul></li></ul></li></ol><p> 算法描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree_Kruskal</span><span class="hljs-params">(AMGraph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Sort</span>(Edge); <span class="hljs-comment">// 将数组Edge中的元素按权值从小到大排序</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; G.arcnum; i++)<br>    &#123;<br>        v1 = <span class="hljs-built_in">LocateVex</span>(G, Edge[i].Head);    <span class="hljs-comment">// v1为边的始点Head的下标</span><br>        v2 = <span class="hljs-built_in">LocateVex</span>(G, Edge[i].Tail);    <span class="hljs-comment">// v2为边的始点Head的下标</span><br>        vs1 = Vexset[v1];   <span class="hljs-comment">// 获取边Edge[i]的始点所在的连通分量vs1</span><br>        vs2 = Vexset[v2];   <span class="hljs-comment">// 获取边Edge[i]的始点所在的连通分量vs2</span><br>        <span class="hljs-keyword">if</span>(vs1 != vs2)<br>        &#123;<br>            cout &lt;&lt; Edge[i].Head &lt;&lt; Edge[i].Tail;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; G.vexnum; ++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(Vexset[j] == vs2)<br>                    Vexset[j] = vsl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302141915180.png"></p><h3 id="6-6-2-最短路径"><a href="#6-6-2-最短路径" class="headerlink" title="6.6.2 最短路径"></a>6.6.2 最短路径</h3><p>问题抽象：在有向网中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。</p><p>在带权有向网中，习惯上称路径上的第一个顶点为源点(Source)，最后一个顶点为终点(Destination)。</p><p>针对单源最短路径一用Dijkstra(迪杰断特拉)算法；针对所有顶点间的最短路径一用Floyd(弗洛伊德)算法。</p><ol><li><p>Dijistra算法</p><ol><li><p>初始化：先找出从源点v0到各终点vk的直达路径(v0,vk)，即通过一条弧到达的路径；</p></li><li><p>选择：从这些路径中找出一条长度最短的路径(v0,u)；</p></li><li><p>更新：然后对其余各条路径进行适当调整：</p><p> 若在图中存在弧(u,vk)，且(v0,u)+(u,vk)&lt;(v0,vk)，则以路径(v0,u，vk)代替(v0,vk)。</p></li></ol><p> 在调整后的各条路径中，再找长度最短的路径，依此类推。</p><p> <strong>Dijistra算法：按照长度递增次序产生最短路径。</strong></p><ol><li><p>把V分成两组：</p><p> (1) S：已求出最短路径的顶点的集合；</p><p> (2)T&#x3D;V - S：尚未确定最短路径的顶点解和。</p></li><li><p>将T中顶点按最短路径递增的次序加入到S中</p><p> 保证：a. 从源点v0到S中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。</p><p> b. 每个顶点对应一个距离值：S中顶点：从v0到此顶点的最短路径；T中顶点：从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。</p></li></ol></li><li><p>Floyd算法</p><ol><li><p>初始时设置一个n阶方阵，令其对角线元素为0，若存在弧&lt;vi, vj&gt;，则对应元素为全职，否则为正无穷。</p></li><li><p>逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之；否则，维持原值。所有顶点试探完毕，算法结束。</p></li></ol></li></ol><h3 id="6-6-3-拓扑排序"><a href="#6-6-3-拓扑排序" class="headerlink" title="6.6.3 拓扑排序"></a>6.6.3 拓扑排序</h3><p>拓扑排序针对有向无环图。<strong>有向无环图</strong>：无环的有向图，简称DAG图（Directed Acycline Graph）。</p><p>有向无环图常用来描述一个工程或系统的进行过程。（通常把计划、施工、生产、程序流程等当成是一个工程）一个工程可以分为若干个子工程，只要完成了这些子工程（活动），就可以导致整个工程的完成。</p><p><strong>AOV网</strong>（拓扑排序）：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以<strong>顶点表示活动</strong>，<strong>弧表示活动之间的优先制约关系</strong>，称这种有向图为<strong>顶点表示活动的网</strong>，简称AOV网（Activity On Vertex network）。</p><p><strong>AOE网</strong>（关键路径）：用一个有向图表示一个工程的各子工程及其相互制约的关系，<strong>以弧表示活动</strong>，<strong>以顶点表示活动的开始或结束事件</strong>，称这种有向图为<strong>边表示活动的网</strong>，简称为AOE网（Activity On Edge）。</p><ol><li><p>AOV网的特点</p><ul><li><p>若从i到j有一条有向路径，则i是j的前驱，j是i的后继；</p></li><li><p>若&lt;i, j&gt;是网中有向边，则i是j的直接前驱，j是i的直接后继；</p></li><li><p>AOV网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。</p></li></ul></li><li><p>拓扑排序</p><p> 在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若AOV网中有弧&lt;i, j&gt;存在，则在这个序列中，i一定排在j的前面，具有这种性质的线性序列称为<strong>拓扑有序序列</strong>，相应的拓扑有序排序的算法称为<strong>拓扑排序</strong>。</p><p> 拓扑排序方法：</p><ul><li><p>在有向图中选一个没有前驱的顶点且输出之；</p></li><li><p>从图中删除该顶点和所有以它为尾的弧；</p></li><li><p>重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止。</p></li></ul><p> 检测AOV网中是否存在环：对有向图构造其顶点得拓扑有序序列，若网中所有顶点都在它得拓扑有序序列中，则该AOV网必定不存在环。</p></li><li><p>关键路径</p><p> 把工程计划表示为<strong>边表示活动的网络</strong>，即<strong>AOE网</strong>，用<strong>顶点表示事件</strong>，<strong>弧表示活动</strong>，<strong>弧的权表示活动持续时间</strong>。</p><p> 针对AOE网，主要关心两方面问题：完成整项工程至少需要多少时间；哪些活动是影响工程进度的关键。</p><p> 确定关键路径的4个描述量：ve(vj)表示事件vj的最早发生时间；vl(vj)表示事件vj的最晚发生时间；e(i)表示活动ai的最早开始时间；l(i)表示活动ai的最迟开始时间，则l(i)-e(i)表示完成活动ai的时间余量。</p><p> <strong>关键活动</strong>：关键路径上的活动，即l(i)&#x3D;&#x3D;e(i)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树和二叉树——王卓</title>
    <link href="/2022/10/13/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第5章-树和二叉树"><a href="#第5章-树和二叉树" class="headerlink" title="第5章 树和二叉树"></a>第5章 树和二叉树</h1><h2 id="5-1-树与二叉树的定义"><a href="#5-1-树与二叉树的定义" class="headerlink" title="5.1 树与二叉树的定义"></a>5.1 树与二叉树的定义</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><p>树(非线性结构)是以分支关系定义的层次结构：结点之间有分支、具有层次关系。</p><blockquote><p>树的定义</p></blockquote><p>树(Tree)是n(n≥0)个结点的<strong>有限集</strong>。</p><ul><li><p>若n&#x3D;0，称为空树；</p><ul><li>若n&gt;0，则它满足如下两个条件：</li></ul><ol><li><p><strong>有且仅有一个</strong>特定的称为根(Root)的结点；</p></li><li><p><strong>其余结点</strong>可分m(m≥0)个互不相交的有限集T1，T2，T3…Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)。</p></li></ol></li></ul><p>树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还可有其他的表示形式：嵌套集合表示<br>（即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）；广义表的形式表示，根作为由子树森林组成的表的名字写在表的左边；凹入表示法（类似书的编目）。</p><h3 id="5-1-2-树的基本术语"><a href="#5-1-2-树的基本术语" class="headerlink" title="5.1.2 树的基本术语"></a>5.1.2 树的基本术语</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121460.png"></p><ol><li><p><strong>根节点</strong>：非空树中无前驱结点的结点；</p></li><li><p><strong>结点</strong>：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支，如图中的A 、B 、C 、D等。</p></li><li><p><strong>结点的度</strong>：结点拥有的子树数称为结点的度。例如，A的度为3，C的度为1，F的度为0。</p></li><li><p><strong>树的度</strong>：树的度是树内各结点度的最大值。图中所示的树的度为3。</p></li><li><p><strong>叶子</strong>：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。</p></li><li><p><strong>非终端结点</strong>：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。</p></li><li><p><strong>父亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的父亲。例如，B的双亲为A，B的孩子有E和F。</p></li><li><p><strong>兄弟</strong>：同一个父亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。</p></li><li><p><strong>祖先</strong>：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。</p></li><li><p><strong>子孙</strong>：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。</p></li><li><p><strong>层次</strong>：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其父亲结点的层次加1。</p></li><li><p><strong>堂兄弟</strong>：父亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。</p></li><li><p><strong>树的深度</strong>：树中结点的最大层次称为<strong>树的深度或高度</strong>。图中所示的树的深度为4。</p></li><li><p><strong>有序树和无序树</strong>：如果将树中结点的各子树从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</p></li><li><p><strong>森林</strong>：是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。</p></li></ol><blockquote><p>树结构和线性结构的比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131122180.png"></p><h3 id="5-1-3-二叉树的定义"><a href="#5-1-3-二叉树的定义" class="headerlink" title="5.1.3 二叉树的定义"></a>5.1.3 二叉树的定义</h3><p>引入二叉树的原因：</p><ul><li><p>二叉树的结构最简单，规律性最强；</p></li><li><p>可以证明，所有树都能转为唯一对应的二叉树，不失一般性。</p></li></ul><p>二叉树是n(n≥0)个结点的有限集，它或者是空集(n&#x3D;0)，或者由一个根结点及<strong>两棵互不相交</strong>的分别称作这个根的左子树和右子树的二又树组成。</p><ol><li><p>每个结点最多有俩孩子，二叉树中不存在度大于2的结点。</p></li><li><p>子树有左右之分，其次序不能颠倒。</p></li><li><p>二叉树可以是空集合，根可以有空的左子树或空的右子树。</p></li></ol><p>二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。</p><p>需要注意的是：<strong>二叉树不是树的特殊情况，与树是两个概念</strong>。</p><p>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要区分，说明它是左子树，还是右子树。</p><p>树中当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</p><p>因此，考虑到二叉树的特点，思考：具有三个结点的二叉树可能有几种不同形态？普通树有几种不同形态？</p><p>二叉树有五种形态；树有两种形态：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123376.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123841.png"></p><blockquote><p>二叉树的5种基本形态</p></blockquote><p>二叉树的5种基本形态包括有：空二叉树、根和空的左右子树、根和左子树、根和右子树、根和左右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131124877.png"></p><p>似于二叉树，因此可以利用二叉树来表示表达式。</p><h2 id="5-3-树和二叉树的抽象数据类型定义"><a href="#5-3-树和二叉树的抽象数据类型定义" class="headerlink" title="5.3 树和二叉树的抽象数据类型定义"></a>5.3 树和二叉树的抽象数据类型定义</h2><p>根据树的结构定义，加上树的一组基本操作就构成了树的抽象数据类型定义。</p><pre><code class="hljs">ADT BinaryTree&#123;    // 数据对象D：    // 数据关系R：    // 基本操作P：&#125;ADT BinaryTree;</code></pre><h2 id="5-4-二叉树的性质和存储结构"><a href="#5-4-二叉树的性质和存储结构" class="headerlink" title="5.4 二叉树的性质和存储结构"></a>5.4 二叉树的性质和存储结构</h2><h3 id="5-4-1-二叉树的性质"><a href="#5-4-1-二叉树的性质" class="headerlink" title="5.4.1 二叉树的性质"></a>5.4.1 二叉树的性质</h3><p>性质1：在二叉树的第i层上至多有2^(i-1)个结点(i≥1)</p><p>性质2：深度为k的二叉树一共至多有2^k-1 个结点(k≥1)</p><p>性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 &#x3D; n2+1。即叶子结点的数目等于度为2的结点数为n2，再加1。</p><blockquote><p>两种特殊形式的二叉树</p></blockquote><ol><li><p>满二叉树</p><p> 满二叉树：深度为k且含有2^k-1个结点的二叉树。</p><p> 特点：</p><ul><li><p>每一层上的结点数都是最大结点数（即每层都满）</p></li><li><p>叶子节点全部在最底层。</p></li></ul><p> 对满二叉树结点位置进行编号，按照从根结点开始，自<strong>上而下，自左而右</strong>进行编号，可以发现每一结点位置都有元素。</p><p> 满二叉树在同样深度的二叉树中<strong>结点个数最多</strong>。</p><p> 满二叉树在同样深度的二叉树中<strong>叶子结点个数最多</strong>。</p></li><li><p>完全二叉树</p><p> 完全二叉树：深度为k的，有n个结点的二叉树，当且仅当其<strong>每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时</strong>，称之为完全二叉树。</p><p> 同理，在满二叉树中，从最后一个结点开始，<strong>连续去掉任意</strong>个结点，即是一棵完全二叉树。</p><p> 完全二叉树的特点是：</p><ul><li><p>叶子结点只可能在层次最大的两层上出现；</p></li><li><p>对任一结点，若其右分支下的子孙(即右子树)的最大层次为i，则其左分支下的子孙(左子树)的最大层次必为i或i+1。</p></li></ul></li></ol><p>性质4：具有n个结点的完全二叉树的深度为⌊log2n⌋ + 1。<br>注：⌊x⌋ 称作x的底，表示不大于x的最大整数</p><p>性质5：如果对一棵有n个结点的完全二叉树(其深度为⌊log2n⌋+ 1)的结点按层序编号(从第1层到第⌊log2n⌋+1层，每层从左到右)，则对任一结点i(1≤i≤n)，有：</p><ol><li><p>如果i&#x3D;1，则结点1是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点⌊i&#x2F;2⌋。</p></li><li><p>如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i。</p></li><li><p>如果2i+1&gt;n，则结点无右孩子；否则其右孩子是结点2i+1。</p></li></ol><p>性质5表明了完全二叉树中<strong>双亲结点编号与孩子结点编号</strong>之间的关系。</p><h3 id="5-4-2-二叉树的存储结构"><a href="#5-4-2-二叉树的存储结构" class="headerlink" title="5.4.2 二叉树的存储结构"></a>5.4.2 二叉树的存储结构</h3><p>二叉树的存储结构主要有顺序存储结构和链式存储结构，其中链式存储结构又分为二叉链表和三叉链表。</p><p>二叉树的顺序存储实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树顺序存储表示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br>Typedef TElemType SqBiTree[MAXSIZE];<br>SqBiTree bt;<br></code></pre></td></tr></table></figure><p>二叉树的顺序存储缺点：存储密度低，适合存储满二叉树和完全二叉树。</p><blockquote><p>二叉树的链式存储结构</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span>&#123;<br>    TElemType data;<br>    BiNode *lchild, *rchild;<br>&#125;BiNode, *BiTree;<br></code></pre></td></tr></table></figure><p>在n个结点的二叉表中，有n+1个空指针域。</p><p>三叉链表即在二叉链表的基础上增加一个指向父节点的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriNode</span>&#123;<br>    TElemType data;<br>    TriNode *lchild, *parent, *rchild;<br>&#125;TriNode, *TriTree;<br></code></pre></td></tr></table></figure><h2 id="5-5-遍历二叉树和线索二叉树"><a href="#5-5-遍历二叉树和线索二叉树" class="headerlink" title="5.5 遍历二叉树和线索二叉树"></a>5.5 遍历二叉树和线索二叉树</h2><h3 id="5-5-1-遍历二叉树"><a href="#5-5-1-遍历二叉树" class="headerlink" title="5.5.1 遍历二叉树"></a>5.5.1 遍历二叉树</h3><ul><li><p>遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。</p></li><li><p>遍历目的：得到树中所有结点的一个线性排列。</p></li><li><p>遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p></li><li><p>遍历方法：规定在先左后右的情况下，主要遍历方法有三种：先序遍历、中序遍历、后序遍历。</p></li></ul><ol><li>三种遍历方法描述如下：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131125028.png"></p><ol><li><p>先序遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>访问根节点；</p></li><li><p>先续遍历左子树；</p></li><li><p>先续遍历右子树。</p></li></ol></li><li><p>中序遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>中序遍历左子树；</p></li><li><p>访问根结点；</p></li><li><p>中序遍历右子树。</p></li></ol></li><li><p>后续遍历</p><p>  访问步骤，若二叉树为空，则空操作；否则：</p><ol><li><p>后续遍历左子树；</p></li><li><p>后续遍历右子树；</p></li><li><p>访问根结点。</p></li></ol></li><li><p>根据遍历顺序确定二叉树</p><ul><li><p>若二叉树中各结点的值均不同，则二叉树结点的先序序列、中序序列、后序列都是唯一的。</p></li><li><p>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树（一定要有中序序列）</p></li></ul><p> 例题：已知二叉树的先序和中序序列，构造出相应的二叉树：<strong>可以先由先序序列确定根，由中序确定左右子树</strong>。</p><p> 已知中序序列和后序序列，<strong>由后序遍历可知，根结点必在后续序列尾部</strong>。</p></li><li><p>遍历的算法实现——先序遍历</p><p> 二叉树先续遍历算法（递归）</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历算法实现——中序遍历</p><p> 二叉树中序遍历算法（递归）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>遍历算法实现——后序遍历</p><p> 二叉树后序遍历算法（递归）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li><p>遍历算法分析</p><ul><li><p>如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。</p></li><li><p>时间效率：O(n)；每个结点只访问一次</p></li><li><p>空间效率：O(n)；栈占用的最大辅助空间</p></li></ul></li><li><p>遍历二叉树的非递归算法</p><p> 中序遍历非递归算法：二叉树中序遍历的非递归算法的关键在于：<strong>在中序遍历过某节点的整个左子树后，如何找到该接点的根以及右子树</strong>。</p><p> 基本思想：</p><ul><li><p>建立一个空栈S，指针p指向根结点</p></li><li><p>申请一个结点空间q，用来存放栈顶弹出的元素。</p></li><li><p>当p非空或者栈S非空时，循环执行以下操作：</p><ul><li><p>如果p非空，则将p进栈，p指向该结点的左孩子；</p></li><li><p>如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。</p></li></ul></li></ul><p> 中序遍历非递归算法实现：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    BiTree p; <span class="hljs-built_in">InitStack</span>(S); p = T;<br>    <span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 不为空</span><br>            <span class="hljs-built_in">Push</span>(S, p);<br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">Pop</span>(S, q);<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%c&quot;</span>, q-&gt;data);<br>            p = q-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。</code></pre><ol start="8"><li><p>二叉树的层次遍历</p><p> 对于一颗二叉树，从根结点开始，按<strong>从上到下、从左到右</strong>的顺序访问每一个结点。每一个结点仅仅访问一次。</p><p> 算法思路：</p><ul><li><p>将根结点入队；</p></li><li><p>队不为空时循环：从队列中出列一个结点*p，访问它：</p><ul><li><p>若它右左孩子结点，将左孩子结点入队；</p></li><li><p>若它有右孩子结点，将右孩子结点入队。</p></li></ul></li></ul><p> 二叉树层次遍历算法实现：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    BTNode data[MaxSize];   <span class="hljs-comment">// 存放队中元素</span><br>    <span class="hljs-type">int</span> front, rear;        <span class="hljs-comment">// 队头和队尾指针</span><br>&#125;SqQueue;   <span class="hljs-comment">// 顺序循环队列类型</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BTNode *b)</span></span>&#123;<br>    BTNode* p;<br>    SqQueue* qu;<br>    <span class="hljs-built_in">InitQueue</span>(sqQueue); <span class="hljs-comment">// 初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(qu, b);     <span class="hljs-comment">// 根结点指针入队</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;<br>        <span class="hljs-comment">// 队不为空，则循环</span><br>        <span class="hljs-built_in">deQueue</span>(qu, p); <span class="hljs-comment">// 出队结点p</span><br>        cout &lt;&lt; p-&gt;data;<br>        <span class="hljs-keyword">if</span>(p-&gt;lchild != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 有左孩子时将其入队</span><br>            <span class="hljs-built_in">enQueue</span>(qu, p-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;rchild != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 有右孩子时将其入队</span><br>            <span class="hljs-built_in">enQueue</span>(qi, p-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li><p>二叉树遍历算法的应用——二叉树的建立(算法5.3)</p><p> 按照先续遍历序列建立二叉树的二叉链表</p><p> 算法步骤：</p><ul><li><p>扫描字符序列，读入字符，建立二叉树的存储结构；</p></li><li><p>如果ch是一个”#”字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：在建立二叉树的过程中按照二叉树先序方式建立：</p><ul><li><p>申请一个结点空间T；</p></li><li><p>将ch赋给T-&gt;data；</p></li><li><p>递归创建T的左子树</p></li><li><p>递归创建T的右子树</p></li></ul></li></ul><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree&amp; T)</span></span>&#123;<br>    <span class="hljs-comment">// 按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span><br>    cin &gt;&gt; ch;<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&quot;#&quot;</span>) T = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 递归结束，建空树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 递归创建二叉树</span><br>        T = <span class="hljs-keyword">new</span> BiTree; <span class="hljs-comment">// 生成根结点</span><br>        T-&gt;data = ch;   <span class="hljs-comment">// 根结点数据域置为ch</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<span class="hljs-comment">// 递归创建左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<span class="hljs-comment">// 递归创建右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——复制二叉树(算法5.4)</p><p>算法步骤：</p><p>如果是空树，递归结束，否则执行以下操作：</p><ul><li><p>申请一个新结点空间， 复制根结点；</p></li><li><p>递归复制左子树；</p></li><li><p>递归复制右子树。</p></li></ul><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Copy</span><span class="hljs-params">(BiTree T, BiTree&amp; NewT)</span></span>&#123;<br>    <span class="hljs-comment">// 复制一棵和T完全相同的二叉树</span><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 如果是空树，递归结束</span><br>        newT = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        newT = <span class="hljs-keyword">new</span> BoTree;<br>        newT-&gt;data = T-&gt;data;<span class="hljs-comment">// 复制根结点</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;lchild, newT-&gt;lchild);<span class="hljs-comment">// 递归复制左子树</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;rchild, newT-&gt;rchild);<span class="hljs-comment">// 递归复制左子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——计算二叉树的深度(算法5.5)</p><p>如果是空树，递归结束，深度为0，否则执行以下操作：</p><ul><li><p>递归计算左子树的深度记为m；</p></li><li><p>递归计算右子树的深度记为n;</p></li><li><p>如果m大于n，二叉树的深度为m+1，否则为n+1。</p></li></ul><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-comment">// 计算二叉树T的深度</span><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m = <span class="hljs-built_in">Depth</span>(T-&gt;lchild);   <span class="hljs-comment">// 递归计算左子树的深度记为m</span><br>        n = <span class="hljs-built_in">Depth</span>(T-&gt;rchild);   <span class="hljs-comment">// 递归计算右子树的深度记为n</span><br>        <span class="hljs-keyword">if</span>(m &gt; n) <span class="hljs-keyword">return</span>(m+<span class="hljs-number">1</span>);  <span class="hljs-comment">// 二叉树深度为m与n的较大者加1</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">return</span> (n+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。</p></li><li><p>二叉树遍历算法的应用——统计二叉树结点的个数(算法5.6)</p><p>如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上1。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NodeCount</span>(T-&gt;lchild) + <span class="hljs-built_in">NodeCount</span>(T-&gt;rchild) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉树遍历算法的应用——统计二叉树叶子结点的个数(补充算法)</p><p>如果是空树，则结点个数为0；否则，结点个数为左子树的叶子结点个数加上右子树的叶子结点个数再加上1。</p><p>算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeafCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-comment">// 如果是叶子节点返回1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCount</span>(T-&gt;lchild) + <span class="hljs-built_in">LeafCount</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-2-线索二叉树"><a href="#5-5-2-线索二叉树" class="headerlink" title="5.5.2 线索二叉树"></a>5.5.2 线索二叉树</h3><ol><li><p>线索二叉树的基本概念</p><p> 遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。</p><p> 但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点<strong>在任一序列中的前驱和后继信息</strong>，这种信息只有在遍历的动态过程中才能得到，为此<strong>引入线索二叉树来保存这些在动态过程中得到的（任一序列中的）有关前驱和后继的信息</strong>。</p><p> 由于有n个结点的二叉链表中必定存在n+1个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息。可做如下规定：若结点有左子树，则其lchild域指示其左孩子，<strong>否则令lchild域指示其前驱</strong>；若结点有右子树，则其rchild域指示其右孩子，<strong>否则令rchild域指示其后继</strong>。同时，为了避免混淆，尚需改变结点结构，增加两个标志域：LTag和RTag，其中标志位为0表示存储的为左&#x2F;右孩子，为1表示存储的为前驱&#x2F;后继。</p><p> 这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树(Threaded Binary Tree)，对二叉树按某种遍历次序使其变为线索二叉树的过程叫<strong>线索化</strong>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树的二叉线索存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span><br>&#123;<br>    TElemType data;<br>    BiThrNode *lchild, *rchild;<br>    <span class="hljs-type">int</span> LTag, RTag;<br>&#125;BiThrNode, *BiThrTree;<br></code></pre></td></tr></table></figure><p> 以下为先序线索二叉树、中序线索二叉树、后序线索二叉树示意图。</p></li></ol><ul><li><p>先序线索二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131126344.png"></p></li><li><p>中序线索二叉树</p></li><li><p>后序线索二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127045.png"></p></li></ul><p>为了方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其<strong>lchild域的指针指向二叉树的根结点</strong>，其<strong>rchild域的指针指向遍历遍历时访问的最后一个结点</strong>；同时，<strong>令二叉树遍历序列中第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点</strong>。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。</p><pre><code class="hljs">即其中LTag = 0，lchild指向根结点；RTag = 1，rchild指向遍历序列中最后一个结点。</code></pre><ol start="2"><li><p>构造线索二叉树</p><p> TODO</p></li></ol><h2 id="5-6-树和森林"><a href="#5-6-树和森林" class="headerlink" title="5.6 树和森林"></a>5.6 树和森林</h2><p>树(Tree)是n(n≥0)个结点的有限集。若n&#x3D;0，称为空树。</p><p>若n&gt;0，当有且仅有一个特定的称为根(root)的结点；其余结点可分为m(m≥0)个互不相交的有限集T1，T2，T3，…，Tm</p><p>森林是m(m≥0)个互不相交的树的集合。</p><h3 id="5-6-1-树的存储结构"><a href="#5-6-1-树的存储结构" class="headerlink" title="5.6.1 树的存储结构"></a>5.6.1 树的存储结构</h3><ol><li><p>双亲表示法</p><p> 这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。</p></li></ol><ul><li>树的双亲表示法<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127885.png"></li></ul><p>双亲表示法特点：找双亲结点容易，找孩子结点难。</p><p>类型描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>    TElemType data;<br>    <span class="hljs-type">int</span> parent; <span class="hljs-comment">// parent结点位置</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTree</span>&#123;<br>    PTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> r, n;   <span class="hljs-comment">// 根结点的位置和节点个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>孩子表示法</p><p> 把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。</p><p> 特点：找孩子容易，找双亲难。</p><p> 类型描述：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 孩子结点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    CTNode* next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> CTNode *ChildPtr;<br><span class="hljs-comment">// 双亲结点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTBox</span>&#123;<br>    TElemType data;<br>    ChildPtr firstChild;    <span class="hljs-comment">// 孩子链表头指针</span><br>&#125;<br><span class="hljs-comment">// 树结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTree</span>&#123;<br>    CTBox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> n, r;<br>&#125;;<br></code></pre></td></tr></table></figure><pre><code class="hljs">可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起，称为带双亲的孩子链表。</code></pre><ol start="3"><li><p>孩子兄弟表示法(二叉树表示法、二叉链表表示法)</p><p> 又称二叉树表示法，或<strong>二叉链表表示法</strong>，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的<strong>第一个孩子结点</strong>和<strong>下一个兄弟结点</strong>，分别命名为firstchild域和nextsibling域。</p><p>  类型描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>&#123;<br>    ElemType data;<br>    CSNode *firstChild, *nextsibling;<br>&#125;;<br><span class="hljs-keyword">typedef</span> CSNode *CSTree;<br></code></pre></td></tr></table></figure><p> 这种存储结构的优点是它和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树的算法来实现对树的操作。因此孩子兄弟表示法是应用较为普遍的一种树的存储表示方法。</p></li></ol><h3 id="5-6-2-森林与二叉树的转换"><a href="#5-6-2-森林与二叉树的转换" class="headerlink" title="5.6.2 森林与二叉树的转换"></a>5.6.2 森林与二叉树的转换</h3><ul><li><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操T。</p></li><li><p>由于树和二叉树都可以用二叉链表作存储结构，则<strong>以二叉链表作媒介</strong>可以导出树与二叉树之间的一个对应关系。</p></li></ul><p>给定一棵树，可以找到唯一的以可二叉树与之对应。这个一一对应的关系说明<strong>森林或树与二叉树可以相互转换</strong>。</p><ol><li><p>将树转换为二叉树</p><ol><li><p>加线：在兄弟之间加一连线；</p></li><li><p>抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系；</p></li><li><p>旋转：以树的根结点为轴心，将整树顺时针转45°</p></li></ol><p> 树变二叉树：<strong>兄弟相连留长子</strong></p></li><li><p>将二叉树转换为树</p><ol><li><p>加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子……沿分支找到的所有右孩子，都p的双亲用线连起来；</p></li><li><p>抹线：抹掉原二叉树中双亲与右孩子之间的连线；</p></li><li><p>调整：将结点按层次排列，形成树结构</p></li></ol><p> 二叉树变树：<strong>左孩右右连双亲，去掉原来右孩线</strong></p></li><li><p>森林转换称二叉树</p><ol><li><p>将各棵树分别转换成二叉树</p></li><li><p>将每棵树的根结点用线相连</p></li><li><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p></li></ol><p> 森林变二叉树：<strong>树变二叉根相连</strong></p></li><li><p>二叉树转换成森林</p><ol><li><p>抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树；</p></li><li><p>还原：将孤立的二叉树还原成树</p></li></ol><p> 二叉树变森林：<strong>去掉全部右孩线，孤立二叉再还原</strong>。</p></li></ol><h3 id="5-6-3-树和森林的遍历"><a href="#5-6-3-树和森林的遍历" class="headerlink" title="5.6.3 树和森林的遍历"></a>5.6.3 树和森林的遍历</h3><ol><li><p>树的遍历（三种方式）</p><ol><li><p>先根(次序)遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。</p></li><li><p>后根(次序)遍历：若树不空，则先依次后根遍历各棵子树，然后再访问根结点。</p></li><li><p>层次遍历：若树不空，则自上而下自左至右访问树中每个结点。</p></li></ol></li><li><p>森林的遍历</p><p> 将森林看作由三部分构成：1、森林中第一棵树的根结点；2.森林中第一棵树的子树森林；3.森林中其它树构成的森林。</p><ol><li><p>先序遍历</p><p> 若森林不为空，则</p><ol><li><p><strong>访问森林中第一棵树的根结点</strong>；</p></li><li><p>先序遍历森林中第一棵树的子树森林；</p></li><li><p>先序遍历森林中（除第一棵树之外）其余树构成的森林。</p></li></ol></li><li><p>中序遍历</p><p> 若森林不为空，则</p><ol><li><p>中序遍历森林中第一棵树的子树森林；</p></li><li><p>访问森林中第一棵树的根结点；</p></li><li><p>中序遍历森林中（除第一棵树之外）其余树构成的森林。</p></li></ol></li></ol></li></ol><h2 id="5-7-哈夫曼树及其应用"><a href="#5-7-哈夫曼树及其应用" class="headerlink" title="5.7 哈夫曼树及其应用"></a>5.7 哈夫曼树及其应用</h2><h3 id="5-7-1-哈夫曼树的基本概念"><a href="#5-7-1-哈夫曼树的基本概念" class="headerlink" title="5.7.1 哈夫曼树的基本概念"></a>5.7.1 哈夫曼树的基本概念</h3><p>哈夫曼(Huffman)树又称<strong>最优树，是一类带权路径长度最短的树</strong>，哈夫曼树的定义，涉及路径、路径长度、权等概念。</p><ul><li><p><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。</p></li><li><p><strong>路径长度</strong>：路径上的<strong>分支数目</strong>称作路径长度。</p></li><li><p><strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。</p><p>  在结点数目相同的二叉树中，<strong>完全二叉树的路径长度最短的二叉树</strong>。但路径长度最短的二叉树不一定就是完全二叉树。</p></li><li><p><strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有<strong>结点权和边权</strong>。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。</p></li><li><p><strong>结点的带权路径长度</strong>：从该结点到树 根之间的<strong>路径长度与结点上权的乘积</strong>。</p></li><li><p><strong>树的带权路径长度</strong>：树中所有<strong>叶子结点</strong>的带权路径长度之和，通常记作WPL。</p></li><li><p><strong>哈夫曼树</strong>：假设有m个权值{w1, W2,…,Wm}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为W；则其中<strong>带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树</strong>。</p></li></ul><p>带权路径最短的树，比较的前提是所有树的度相同，即树的各结点度的最大值，即结点拥有的子树数。</p><p><strong>满二叉树不一定是曼哈夫树</strong>，哈夫曼树中权越大的叶子离根越近，具有相同带权结点的哈夫曼树不唯一。</p><h3 id="5-7-2-哈夫曼树的构造算法"><a href="#5-7-2-哈夫曼树的构造算法" class="headerlink" title="5.7.2 哈夫曼树的构造算法"></a>5.7.2 哈夫曼树的构造算法</h3><ol><li><p>哈夫曼树的构造过程</p><p> 在构造哈夫曼树时，<strong>首先选择权小的</strong>，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的<strong>贪心法</strong>。</p><ol><li><p>根据给定的n个权值{W1, W2, …, Wn}，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。<strong>构造森林全是根</strong>。</p></li><li><p>在森林F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。<strong>选用两小造新树</strong>。</p></li><li><p>在森林F中删除这两棵树，同时将新得到的二叉树加入F中。<strong>删除两小添新人</strong>。</p></li><li><p>重复（2）和（3），直到F只含一棵树为止。这棵树便是哈夫曼树。<strong>重复2、3剩单根</strong>。</p></li></ol><p> 特点：</p><p> 包含n棵树的森林要经过n-1次合并才能形成哈去曼树，共产生n-1新结点，且这n-1个新结点都是具有两个孩子的分支结点。。</p><ul><li><p><strong>包含n个叶子结点的哈夫曼树中共有2n-1个结点</strong>。</p></li><li><p><strong>哈夫曼树的结点的度数为0或2，没有度为1的结点</strong>。</p></li></ul></li><li><p>哈夫曼算法的实现</p><p> 哈夫曼树是一种二叉树，由于哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n-1个结点，可以存储在一个大小为2n-1的一维数组中。树中每个结点还要包含其<strong>双亲信息</strong>和<strong>孩子结点的信息</strong>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> parent, lch, rch;<br>&#125;HTNode, *HuffmanTree;<br></code></pre></td></tr></table></figure><p> 哈夫曼树中共有2n-1个结点不使用0下标，数组大小为2n。将叶子结点集中存储在前面部分1~n个位置，而后面的n-1个位置存储其余非叶子结点。</p><blockquote><p>构造哈夫曼树——算法5.10</p></blockquote><p> 构造哈夫曼树算法的实现可以分成两大部分。</p><ol><li><p>初始化：首先动态申请2n个单元；然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0；最后再循环n次，输入前n个单元中叶子结点的权值。</p></li><li><p>创建树：循环n-1次，通过n-1次的选择、删除与合并来创建哈夫曼树。</p><ul><li><p>选择是从当前森林中选择双亲为0且权值最小的两个树根结点s1和s2；</p></li><li><p>删除是指将结点s1和s2的双亲改为非0；</p></li><li><p>合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个新结点左孩子的下标为s1，右孩子的下标为s2。</p></li></ul></li></ol><p> 算法实现：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanTree</span><span class="hljs-params">(HuffmanTree HT, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;<br>    HT = <span class="hljs-keyword">new</span> HTNode[m+<span class="hljs-number">1</span>];   <span class="hljs-comment">// 0号单元未用，</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-comment">// 将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0</span><br>        HT[i].lch = <span class="hljs-number">0</span>;<br>        HT[i].rch = <span class="hljs-number">0</span>;<br>        HT[i].parent = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-comment">// 输入前n个元素的weight值</span><br>        cin &gt;&gt; HT[i].weight;<br>    &#125;<br>    <span class="hljs-comment">/*－初始化工作结束，下面开始创建哈夫曼树－*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n+<span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-built_in">Select</span>(HT, i<span class="hljs-number">-1</span>, s1, s2);<br>        <span class="hljs-comment">// 在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点，并返回它们在HT中的序号s1和s2</span><br>        HT[s1].parent = i;<br>        HT[s2].parent = i;<br>        <span class="hljs-comment">// 得到新结点i，从森林中删除s1和s2，将s1和s2的双亲域由0改为i</span><br>        HT[i].lch = s1;<br>        HT[i].rch = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-7-3-哈夫曼编码"><a href="#5-7-3-哈夫曼编码" class="headerlink" title="5.7.3 哈夫曼编码"></a>5.7.3 哈夫曼编码</h3><p>在进行数据压缩时，为了使压缩后的数据文件尽可能短，可采用不定长编码。其基本思想是：为出现次数较多的字符编以较短的编码。为确保对数据文件进行有效的压缩和对压缩文件进行正确的解码，可以利用哈夫曼树来设计二进制编码。</p><p>关键：要设计长度不等的编码，则必须使<strong>任一字符的编码都不是另一个字符的编码的前缀</strong>。上述编码方式又称为前缀编码。</p><p>前缀编码：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。</p><p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p><p>哈夫曼编码的性质：</p><ol><li><p><strong>哈夫曼编码是前缀编码</strong>。</p></li><li><p><strong>哈夫曼编码是最优前缀编码</strong>。</p></li></ol><p>哈夫曼编码实现方法：</p><ol><li><p>统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）。</p></li><li><p>利用哈夫曼树的特点：权越大的叶子离根越近；<strong>将每个字符的概率值作为权值，构造哈夫曼树</strong>。则概率越大的结点，路径越短。</p></li><li><p>在哈夫曼树的每个分支上标上0或1：</p><ul><li><p>结点的左分支标0，右分支标1</p></li><li><p>把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。</p></li></ul></li></ol><p>两个问题：</p><ol><li><p>为什么哈夫曼编码能够保证是前缀编码？。</p><p> 因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p></li><li><p>为什么哈夫曼编码能够保证字符编码总长最短？</p><p> 因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</p></li></ol><blockquote><p>哈夫曼编码的算法实现</p></blockquote><p>在构造哈夫曼树之后，求哈夫曼编码的主要思想是：<strong>依次以叶子为出发点，向上回溯至根结点为止</strong>。回溯时走左分支则生成代码0，走右分支则生成代码1。</p><p>算法步骤：</p><ol><li><p>分配存储n个字符编码的编码表空间HC，长度为n+1；分配临时存储每个字符编码的动态数组空间cd，cd[n-1]置为’\0’。</p></li><li><p>逐个求解n个字符的编码，循环n次，执行以下操作：</p><ul><li><p>设置变量start用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置n-1;</p></li><li><p>设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f用于记录i的双亲结点的下标；</p></li><li><p>从叶子结点向上回溯至根结点，求得字符i的编码，当f没有到达根结点时，循环执行以下操作：</p><ul><li><p>回溯一次start向前指一个位置，即–start;</p></li><li><p>若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在cd[start]中；</p></li><li><p>继续向上回溯，改变c和f的值。</p></li></ul></li><li><p>根据数组cd的字符串长度为第i个字符编码分配空间HC[i]，然后将数组cd中的编码复制到HC[i]中。</p></li></ul></li><li><p>释放临时空间cd。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanCode</span><span class="hljs-params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span><br>    HC = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>*[n+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 分配存储n个字符编码的编码表空间</span><br>    cd = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];           <span class="hljs-comment">// 分配临时存放每个字符编码的动态数组空间</span><br>    cd[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;             <span class="hljs-comment">// 编码结束符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 逐个字符求哈夫曼编码</span><br>    &#123;<br>        start = n<span class="hljs-number">-1</span>;            <span class="hljs-comment">// start开始时指向最后，即编码结束符位置</span><br>        c = i;<br>        f = HT[i].parent;       <span class="hljs-comment">// f指向结点c的双亲结点</span><br>        <span class="hljs-keyword">while</span>(f != <span class="hljs-number">0</span>)           <span class="hljs-comment">// 从叶子节点开始向上回溯，知道根结点</span><br>        &#123;<br>            --start;            <span class="hljs-comment">// 回溯一次start位置向前指一个位置</span><br>            <span class="hljs-keyword">if</span>(HT[f].lch == c)  <span class="hljs-comment">// 结点c是f的左孩子，则生成代码0</span><br>            &#123;<br>                cd[start] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// 结点c是f的右孩子，则生成代码1</span><br>            &#123;<br>                cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            &#125;<br>            c = f;<br>            f = HT[f].parent;   <span class="hljs-comment">// 继续向上回溯</span><br>        &#125;                       <span class="hljs-comment">// 求出第i个字符的编码</span><br>        HC[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n-start];  <span class="hljs-comment">// 为第i个字符编码分配空间</span><br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);<br>    &#125;<br>    <span class="hljs-keyword">delete</span> cd;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>文件的编码和译码</p></blockquote><ol><li><p>编码</p><p> 有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符c，在哈夫曼编码表HC中找到此字符，将字符c转换为编码表中存放的编码串。</p></li><li><p>译码</p><p> 对编码后的文件进行译码的过程必须借助于哈夫曼树。具体过程是：依次读入文件的二进制码，从哈夫曼树的根结点（即HT[m])出发，若当前读入0，则走向左孩子，否则走向右孩子。一旦到达某一叶子HT[i]时便译出相应的字符编码HC[i]。然后重新从根出发继续译码，直至文件结束。</p></li></ol><h2 id="5-8-案例分析与实现"><a href="#5-8-案例分析与实现" class="headerlink" title="5.8 案例分析与实现"></a>5.8 案例分析与实现</h2><h2 id="5-9-习题"><a href="#5-9-习题" class="headerlink" title="5.9 习题"></a>5.9 习题</h2><ol><li><p>利用二叉链表存储树， 则根结点的右指针()。</p><p> A. 指向最左孩子 B. 指向最右孩子 C. 为空 D. 非空</p><p> 解答：C，利用二叉链表存储树时，右指针指向兄弟结点，因为根节点没有兄弟结点，故根结点的右指针为空</p></li><li><p>一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足()。</p><p> A. 所有的结点均无左孩子 B. 所有的结点均无右孩子 C. 只有一个叶子结点 D. 是任意一棵二叉树</p><p> 解答：因为先序遍历结果是“中左右”， 序遍历结果是“左右中”，当没有左子树时，就是“中右”和“右中”；当没有右子树时，就是“中左”和“左中”。则所有的结点均无左孩子或所有的结点均无右孩子均可，所以A、B不能选，又所有的结点均无左孩子与所有的结点均无右孩子时，均只有一个叶子结点，故选C。</p></li><li><p>在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是( )</p><p> A．41 B．82 C．113 D．122</p><p> 解答：考查树结点数的特性。设树中度为i(i&#x3D;0，1，2，3，4)的结点数分别为Ni，树中结点总数为N，则树中各结点的度之和等于N-1，即N&#x3D;1+N1+2N2+3N3+4N4&#x3D;N0+N1+N2+N3+N4。根据题设中的数据，即可得到N0&#x3D;82，即树T的叶结点的个数是82。</p></li></ol><p>算法设计题：</p><ol><li><p>统计二叉树的叶结点个数。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>判别两棵树是否相等。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>交换二叉树每个结点的左孩子和右孩子。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>设计二叉树的双序遍历算法（双序遍历是指对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe4.cpp">算法设计题4</a></p></li><li><p>计算二叉树最大的宽度（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>用按层次顺序遍历二叉树的方法，统计树中度为1的结点数目。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li><li><p>求任意二叉树中第一条最长的路径长度，并输出此路径上各结点的值。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe7.cpp">算法设计题7</a></p></li><li><p>输出二叉树中从每个叶子结点到根结点的路径。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe8.cpp">算法设计题8</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>串、数组和广义表——王卓</title>
    <link href="/2022/10/13/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-串、数组和广义表"><a href="#第4章-串、数组和广义表" class="headerlink" title="第4章 串、数组和广义表"></a>第4章 串、数组和广义表</h1><p>字符串一般简称为串。串是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说，<strong>串是一种内容受限的线性表</strong>。</p><p>本章后两部分讨论的多维数组和广义表可以看成是线性表的一种扩充，即线性表的数据元素自身又是一个数据结构。高级语言都支持数组，但在高级语言中，重点介绍数组的使用，而本章重点介绍数组的内部实现，并介绍对于一些特殊的二维数组如何实现压缩存储。最后介绍广义表的基本概念和存储结构。</p><h2 id="4-1-串的定义"><a href="#4-1-串的定义" class="headerlink" title="4.1 串的定义"></a>4.1 串的定义</h2><p><strong>串</strong>(string)(或字符串)是由零个或多个字符组成的有限序列，一般记为：s &#x3D; “a1a2 … an”。</p><p>其中，s是串的名，用双引号括起来的字符序列是串的值；ai(1≤i≤n)可以是字母、数字或其他字符；串中字符的数目n称为串的长度。零个字符的串称为<strong>空串</strong>(null string)，其长度为零。</p><blockquote><p>相关术语</p></blockquote><ul><li><p><strong>子串</strong>：一个串中任意个连续的字符组成的子序列(含空串)称为该串的子串。</p></li><li><p><strong>主串</strong>：包含子串的串相应地称为主串。</p></li><li><p><strong>字符位置</strong>：通常称字符在序列中的序号为该字符在串中的位置。</p></li><li><p><strong>子串的位置</strong>：子串的第一个字符在主串中的位置。</p></li><li><p><strong>空格串</strong>：一个或多个空格组成的串，与空串不同。</p></li><li><p><strong>串相等</strong>：当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。</p></li><li><p>所有的空串都是相等的。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301301652448.png"><br>最后一个位b在d中位置</p><h2 id="4-2-案例的引入"><a href="#4-2-案例的引入" class="headerlink" title="4.2 案例的引入"></a>4.2 案例的引入</h2><h2 id="4-3-串的类型定义、存储结构及其运算"><a href="#4-3-串的类型定义、存储结构及其运算" class="headerlink" title="4.3 串的类型定义、存储结构及其运算"></a>4.3 串的类型定义、存储结构及其运算</h2><h3 id="4-3-1-串的抽象类型定义"><a href="#4-3-1-串的抽象类型定义" class="headerlink" title="4.3.1 串的抽象类型定义"></a>4.3.1 串的抽象类型定义</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301301700866.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT string&#123;<br>    数据对象：<br>    数据关系：<br>    基本操作：<br>        <span class="hljs-number">1.</span> <span class="hljs-built_in">StrAssign</span>(&amp;T, chars);    <span class="hljs-comment">// 串赋值</span><br>        <span class="hljs-number">2.</span> <span class="hljs-built_in">StrCompare</span>(S, T);        <span class="hljs-comment">// 串比较</span><br>        <span class="hljs-number">3.</span> <span class="hljs-built_in">StrLenght</span>(S);            <span class="hljs-comment">// 求串长</span><br>        <span class="hljs-number">4.</span> <span class="hljs-built_in">Concat</span>(&amp;T, S1, S2);      <span class="hljs-comment">// 串连结</span><br>        <span class="hljs-number">5.</span> <span class="hljs-built_in">SubString</span>(&amp;Sub, S, pos, len);    <span class="hljs-comment">// 求子串</span><br>        <span class="hljs-number">6.</span> <span class="hljs-built_in">StrCopy</span>(&amp;T, S);          <span class="hljs-comment">// 串拷贝</span><br>        <span class="hljs-number">7.</span> <span class="hljs-built_in">StrEmpty</span>(S);             <span class="hljs-comment">// 串判空</span><br>        <span class="hljs-number">8.</span> <span class="hljs-built_in">ClearString</span>(&amp;S);         <span class="hljs-comment">// 清空串</span><br>        <span class="hljs-number">9.</span> <span class="hljs-built_in">Index</span>(S, T, pos);        <span class="hljs-comment">// 子串的位置</span><br>        <span class="hljs-number">10.</span> <span class="hljs-built_in">Replace</span>(&amp;S, T, V);      <span class="hljs-comment">// 串替换</span><br>        <span class="hljs-number">11.</span> <span class="hljs-built_in">StrInsert</span>(&amp;S, pos, T);  <span class="hljs-comment">// 子串插入</span><br>        <span class="hljs-number">12.</span> <span class="hljs-built_in">StrDelete</span>(&amp;S, pos, len);    <span class="hljs-comment">// 子串删除</span><br>        <span class="hljs-number">13.</span> <span class="hljs-built_in">DestoryString</span>(&amp;S);      <span class="hljs-comment">// 串销毁</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-串的存储结构"><a href="#4-3-2-串的存储结构" class="headerlink" title="4.3.2 串的存储结构"></a>4.3.2 串的存储结构</h3><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构：<strong>顺序存储和链式存储</strong>。</p><ol><li><p>串的顺序存储结构</p><p> 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SString</span>&#123;<br>    <span class="hljs-type">char</span> ch[MAXLEN+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length;<br>&#125;;<br></code></pre></td></tr></table></figure><p> 其中，MAXLEN表示串的最大长度，ch是存储字符串的一维数组，每个分量存储一个字符，length表示字符串的当前长度。其中，后面算法描述当中所用到的顺序存储的字符串都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用。</p></li><li><p>串的链式存储结构</p><p> 顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。</p></li></ol><ul><li>串值的链表存储方式<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131129962.png"></li></ul><p>如图(a)中所示，结点大小为4，图(b)，结点大小为1。</p><ul><li><p>串的链式存储结构——块链结构</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80    <span class="hljs-comment">// 块的大小可自由定义</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Chunk</span>&#123;<br>    <span class="hljs-type">char</span> ch[CHUNKSIZE];<br>    Chunk* next;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LString</span>&#123;<br>    Chunk *head, *tail; <span class="hljs-comment">// 串的头指针和尾指针</span><br>    <span class="hljs-type">int</span> curlen; <span class="hljs-comment">// 串当前的长度</span><br>&#125;;  <span class="hljs-comment">// 字符串的块链结构</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-3-串的模式匹配算法"><a href="#4-3-3-串的模式匹配算法" class="headerlink" title="4.3.3 串的模式匹配算法"></a>4.3.3 串的模式匹配算法</h3><p>子串的定位运算通常称为串的<strong>模式匹配</strong>或<strong>串匹配</strong>。即算法目的：确定主串中所含子串（模式串）第一次出现得位置。</p><p>串的模式匹配设有两个字符串S和T，设S为主串，也称正文串；设T为子串，也称为模式。在主串S中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置。</p><p>算法种类包括有：BF算法、KMP算法。</p><ol><li><p>BF算法</p><p> Brute-Force简称BF算法，亦称简单匹配算法，采用穷举法的思路：从S的每一个字符开始依次与T的字符进行匹配。</p><blockquote><p>算法设计思想</p></blockquote><p> Index(S, T, pos)</p><ol><li><p>将主串的第pos个字符和模式串的第一个字符比较，</p><ul><li><p>若相等，继续逐个比较后续字符；</p></li><li><p>若不等，从主串的下一字符起，重新与模式串的第一个字符比较。</p></li></ul></li><li><p>直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。</p></li><li><p>否则，匹配失败，返回值0</p></li></ol><blockquote><p>算法4.1——BF算法描述</p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_BF</span><span class="hljs-params">(SString S, SString T)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= S.lenght &amp;&amp; j &lt;= T.length)&#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            ++j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 主串、子串指针回溯重新开始下一次匹配</span><br>            i = i - j + <span class="hljs-number">2</span>;<span class="hljs-comment">//可以看成（i-j+1）+1，i-j+1是把i退回到原来的位置，再加一移到后一个位置</span><br>            j = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt;= T.lenght) <span class="hljs-keyword">return</span> i - T.lenght;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 当m远小于n时，算法复杂度为O(n*m)，平均复杂度为O(nm&#x2F;2)。</p></li><li><p>KMP算法</p><p> KMP算法，利用已经部分匹配的结果而加快模式串的滑动速度，且主串S的指针i<strong>不必回溯</strong>！可提速到O(n+m)</p><p> 重点在于定义<code>next[j]</code>函数，表明当模式中第j个字符与主串中相应字符失配时，在模式中需要重新和主串中该字符进行比较的字符的位置。</p></li></ol><ul><li><p>next_j<br>  <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131135247.png"></p><blockquote><p>KMP算法</p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_KMP</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = pos, j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; S.length &amp;&amp; j &lt; T.length)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || S.ch[i] == T.ch[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];    <span class="hljs-comment">// i不变，j后退</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j &gt; T.length) <span class="hljs-keyword">return</span> i - T.length;   <span class="hljs-comment">// 匹配成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span>&amp; next[])</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; T.length)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || T.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            next[i] = j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>next计算</p></blockquote><p>  Next值就是字符串s的最长相同前缀和后缀子字符串的长度。</p><p>  默认第一个和第二个字符的next值为0、1。那么从第三个开始依次执行如下操作：</p><p>  找到<strong>当前要求next字符的前一个</strong>（称为这个字符），以它为标准，找到其next对应下标的字符（称为现在字符），<strong>和这个字符做比较</strong>。若相等，那么当前字符的next值就位此字符next<strong>加1</strong>；若不等，继续找现在字符next所指的下一个字符，还是和之前的字符比较，直到找到第一个位置为止，那么next为1。</p><blockquote><p>nextVal计算</p></blockquote><p>  NextVal值就是字符串s的的最长相同且满足后续字符不同的前缀和后缀子字符串的长度。</p><p>  在求出next的值的基础上，求nextval的方法其实很简单。默认第一个nextval的值是0，第二个字符如果和第一个字符相等，那么它的nextval的值就为0，不等就为1。之后遵循如下方法：</p><p>  <strong>找到当前要求nextval值的字符，看它的[next值]下标所指向的字符是否和它相等，相等那么nextval为当前所指下标的nextval值，不相等nextval的值就为本身字符的next值。</strong></p><p>  对next进行修正，改进：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_nextval</span><span class="hljs-params">(SString T, <span class="hljs-type">int</span>&amp; nextval[])</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, nextval[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; T.lenght)&#123;<br>        <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || T.ch[i] == T.ch[j])&#123;<br>            ++i;<br>            ++j;<br>            <span class="hljs-keyword">if</span>(T.ch[i] != T.ch[j]) nextval[i] = j;<br>            <span class="hljs-keyword">else</span> nextval[i] = nextval[j];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = nextval[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-4-数组"><a href="#4-4-数组" class="headerlink" title="4.4 数组"></a>4.4 数组</h2><h3 id="4-4-1-数组定义和特点"><a href="#4-4-1-数组定义和特点" class="headerlink" title="4.4.1 数组定义和特点"></a>4.4.1 数组定义和特点</h3><p>数组：按一定格式排列起来的具有相同类型的数据元素的集合。</p><blockquote><p>一维数组</p></blockquote><p>一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。</p><p>一维数组的逻辑结构：线性结构。定长的线性表。</p><p>声明格式：<code>数据类型 变量名称[长度]</code>；</p><blockquote><p>二维数组</p></blockquote><p>二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组。</p><p>二维数组的逻辑结构：</p><ul><li><p>非线性结构：每一个数据元素既在一个行表中，又在一个列表中。</p></li><li><p>线性结构定长的线性表：该线性表的每个数据元素也是一个定长的线性表。</p></li></ul><p>声明格式：<code>数据类型 变量名称[行数][列数]</code>；</p><blockquote><p>多维数组</p></blockquote><p>三维数组：若二维数组中的元素又是一个一维数组，则称作三维数组。</p><p>n维数组：若n-1维数组中的元素又是一个一维数组结构，则称作n维数组。</p><p>结论：线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。</p><p>数组特点：<strong>结构固定</strong>，定义后，维数和维界不再改变。</p><p>数组基本操作：除了结构的初始化和销毁之外，只有<strong>取元素</strong>和<strong>修改元素值</strong>的操作。</p><h3 id="4-4-2-数组的抽象数据类型定义"><a href="#4-4-2-数组的抽象数据类型定义" class="headerlink" title="4.4.2 数组的抽象数据类型定义"></a>4.4.2 数组的抽象数据类型定义</h3><p>以二维数组为例，二维数组的抽象数据类型的数据对象和数据关系的定义：</p><p>n&#x3D;2（维数为2，二维数组）</p><p>b1：第1维长度（行数）</p><p>b2：第2维长度（列数）</p><p>aj1j2：第1维下标为j1，第2维下标为j2</p><h3 id="4-4-3-数组的顺序存储"><a href="#4-4-3-数组的顺序存储" class="headerlink" title="4.4.3 数组的顺序存储"></a>4.4.3 数组的顺序存储</h3><p>在数组存储过程中，数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。</p><p>针对二维数组，可以以行序为主序(C、PASCAL、JAVA、Basic)；也可以是列序为主序(FORTRAN)。</p><ul><li>n维数组元素地址<br> <img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131133589.png"></li></ul><h3 id="4-4-4-特殊矩阵的压缩存储"><a href="#4-4-4-特殊矩阵的压缩存储" class="headerlink" title="4.4.4 特殊矩阵的压缩存储"></a>4.4.4 特殊矩阵的压缩存储</h3><p>矩阵的常规存储：将矩阵描述为一个二维数组。</p><p>矩阵的常规存储的特点：可以对其元素进行随机存取；矩阵运算非常简单；存储的密度为1。</p><p>但是对于不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多。特殊矩阵主要包括<strong>对称矩阵、三角矩阵和对角矩阵</strong>等，以及稀疏矩阵：矩阵中非零元素的个数较少（一般小于5%）</p><p>因此可以采用矩阵压缩存储：为多个相同的非零元素只分配一个存储空间，对零元素不分配空间。</p><ol><li><p>对称矩阵：</p><p> 特点：在nxn的矩阵a中，满足aij &#x3D; aji</p><p> 存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)&#x2F;2个元素空间。</p><p> 对称矩阵可以以行序为主序将元素存放在一个一维数组<code>sa[n(n+1)/2]</code>中，其中aij存放在(i*(i-1)&#x2F;2)+(j-1)位置。</p></li><li><p>三角矩阵</p><p> 特点：特点对角线以下（或者以上）的数据元素（不包括对角线全部为常数c。</p><p> 存储方法：重复元素c共享一个元素存储空间，共占用n(n+1)&#x2F;2+1个元素空间。</p></li><li><p>对角矩阵</p><p> 特点：在nxn的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。</p><p> 存储方法：可按某个原则（或以行为主，或以对角线的顺序）将其压缩存储到一维数组上。</p></li><li><p>稀疏矩阵存储</p><p> 稀疏矩阵：在mxn的矩阵中，有超过95%的元素位零，非零元素仅不到5%。</p><ul><li><p>三元组法：</p><p>  三元组顺序表，又称为<strong>有序的双下标法</strong></p><p>  压缩存储原则：可通过三元组法来表示稀疏矩阵，三元组：(i, j, aij)。即存各非零元素的值、行列位置和矩阵的行列数。</p><p>  其中，为更为可靠描述，通常会加上总体的描述信息：总行数、总列数、非零元素总个数。</p><p>  优点：非零元在表中按行序有序存储，因此<strong>便于进行依行顺序处理的矩阵运算</strong>。</p><p>  缺点：<strong>不能随机存取</strong>。若按行号存取某一行中的非零元，则需从头开始进行查找。</p></li><li><p>十字链表法</p><p>  稀疏矩阵的链式存储结构：</p><p>  优点：它能够<strong>灵活地插入</strong>因运算而产生的新的非零元素，<strong>删除</strong>因运算而产生的新的零元素，实现矩阵的各种运算。</p><p>  在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了(row, col, value)以外，还要有两个域：</p><ul><li><p>right：用于链接同一行中的下一个非零元素；</p></li><li><p>down：用以链接同一列中的下一个非零元素。</p></li></ul><p>  同时，为了方便元素查找，可为每一行、每一列添加头指针结点。</p></li></ul></li></ol><h2 id="4-5-广义表"><a href="#4-5-广义表" class="headerlink" title="4.5 广义表"></a>4.5 广义表</h2><h3 id="4-5-1-广义表的定义"><a href="#4-5-1-广义表的定义" class="headerlink" title="4.5.1 广义表的定义"></a>4.5.1 广义表的定义</h3><p>广义表是线性表的推广，也称为列表。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。</p><p>广义表(又称列表Lists)是n≥0个元素a0, a1, a2, …, an-1的有限序列，其中每一个ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。</p><p>广义表通常记作：LS&#x3D;(a1, a2, …, an)，其中：LS为表名，n为表的长度，每一个元素ai为表的元素。</p><p>习惯上，一般用大写字母表示广义表，小写字母表示原子。</p><p>表头：若LS非空，则第一个元素a1就是表头，记作head(LS)&#x3D;a1。其中，表头可以是原子，也可以是子表。</p><p>表尾：除表头外的其他元素组成的表。记作tail(LS) &#x3D; (a2,…,an)。其中表尾不是一个元素，而实一个子表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">A = ()  <span class="hljs-comment">// 空表，长度为零</span><br>B = (())    <span class="hljs-comment">// 长度为1，表头、表尾均为()</span><br>C = (a, (b, c)) <span class="hljs-comment">// 长度为2，由原子a和子表(b,c)构成，表头为a；表尾为((b, c))</span><br>D = (x, y, z)   <span class="hljs-comment">// 长度为3，每一项都是原子，表头为x，表尾为(y, z)</span><br>E = (C, D)  <span class="hljs-comment">// 长度为2，每一项都是子表，表头为C，表尾为(D)</span><br>F = (a, F)  <span class="hljs-comment">// 长度为2，第一项为原子，第二项为本身。表头为a；表尾为(F)</span><br></code></pre></td></tr></table></figure><blockquote><p>广义表的性质</p></blockquote><ol><li><p>广义表中的数据元素有相对次序；一个直接前驱和一个直接后继</p></li><li><p><strong>广义表的长度</strong>:定义为最外层所包含元素的个数；</p></li><li><p><strong>广义表的深度</strong>:定义为该广义表展开后所含括号的重数；其中，原子的深度为0，空表的深度为1。A&#x3D;(b,c)的深度为1，B&#x3D;(A,d)的深度为2，C&#x3D;（f，b，h）的深度为3</p></li><li><p>广义表可以为其他广义表共享；</p></li><li><p>广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302011349375.png"></p></li><li><p>广义表是一个多层次的结构，可以用图形象地表示。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202302011350760.png"></p></li></ol><blockquote><p>广义表与线性表的区别</p></blockquote><p><strong>广义表可以看成是线性表的推广，线性表是广义表的特例</strong>。</p><p>广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。</p><p><strong>当二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表</strong>。</p><p>另外，树和有向图也可以用广义表来表示。由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。</p><blockquote><p>广义表的运算</p></blockquote><ol><li><p>取表头GetHead(LS): 取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表。</p></li><li><p>取表尾GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。即<strong>表尾一定是一个广义表</strong>。</p></li></ol><h3 id="4-5-2-广义表的存储"><a href="#4-5-2-广义表的存储" class="headerlink" title="4.5.2 广义表的存储"></a>4.5.2 广义表的存储</h3><p>由 于广义表中的数据元素可以有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构。常用的链式存储结构有两种，<strong>头尾链表的存储结构</strong>和<strong>扩展线性链表的存储结构</strong>。</p><h2 id="4-6-案例分析与实现"><a href="#4-6-案例分析与实现" class="headerlink" title="4.6 案例分析与实现"></a>4.6 案例分析与实现</h2><h2 id="4-7-习题"><a href="#4-7-习题" class="headerlink" title="4.7 习题"></a>4.7 习题</h2><blockquote><p>算法设计题</p></blockquote><ol><li><p>写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符为A<del>Z这26个字母和0</del>9这10个数字）。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>写一个递归算法来实现字符串逆序存储，要求不另设串存储空间。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>编写算法，实现下面函数的功能。函数<code>void insert(char*s, char* t, int pos)</code>将字符串t插入到字符串s中，插入位置为pos。假设分配给字符串s的空间足够让字符串t插入。（说明：不得使用任何库函数）</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>已知字符串S1中存放一段英文，写出算法format(s1, s2, s3, n)，将其按给定的长度n格式化成两端对齐的字符串S2，其多余的字符送S3。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe4.cpp">算法设计题4</a></p></li><li><p>设二维数组a[1…m, l…n]含有m x n个整数。</p><ol><li><p>写一个算法判断a中所有元素是否互不相同？输出相关信息(yes&#x2F;no);</p></li><li><p>试分析算法的时间复杂度。</p></li></ol><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>设任意n个整数存放于数组A[1..n]中，试编写算法，将所有正数排在所有负数前面(要求：算法时间复杂度为O(n))。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/Chapter4Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列——王卓</title>
    <link href="/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><p>栈和队列是两种重要的线性结构。从数据结构角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为<strong>限定性的数据结构</strong>。但从数据类型角度看，它们是和线性表不相同的两类重要的抽象数据类型。</p><h2 id="3-1-栈和队列的定义和特点"><a href="#3-1-栈和队列的定义和特点" class="headerlink" title="3.1 栈和队列的定义和特点"></a>3.1 栈和队列的定义和特点</h2><h3 id="3-1-1-栈的定义和特点"><a href="#3-1-1-栈的定义和特点" class="headerlink" title="3.1.1 栈的定义和特点"></a>3.1.1 栈的定义和特点</h3><p><strong>栈</strong>(<strong>stack</strong>)是限定仅在<strong>表尾进行插入或删除</strong>操作的线性表。因此，对栈来说，表尾端有其特殊含义，称为<strong>栈顶</strong>(<strong>top</strong>)，相应地，表头端称为<strong>栈底</strong>(<strong>bottom</strong>)。不含元素的空表称为<strong>空栈</strong>。</p><p>栈的修改是按后进先出的原则进行的，因此，栈又称为<strong>后进先出</strong>(Last In First Out, LIFO)的线性表。</p><blockquote><p>栈与一般线性表的区别</p></blockquote><p>栈与一般线性表的区别：<strong>仅存在运算规则不同</strong>。</p><p>|一般线性表|栈|<br>|:—|:—:|:—:|<br>|逻辑结构|一对一|一对一|<br>|存储结构|顺序表、链表|顺序表、链表|<br>|运算规则|随机存取|后进先出(LIFO)|</p><h3 id="3-1-2-队列的定义和特点"><a href="#3-1-2-队列的定义和特点" class="headerlink" title="3.1.2 队列的定义和特点"></a>3.1.2 队列的定义和特点</h3><p><strong>队列</strong>(<strong>queue</strong>)是一种<strong>先进先出</strong>(<strong>First In First Out, FIFO</strong>)的线性表。它只允许在表的一端进行插入，而在另一端删除元素。</p><p>在队列中，允许插入的一端称为<strong>队尾</strong>(<strong>rear</strong>)，允许删除的一端则称为<strong>队头</strong>(<strong>front</strong>)。</p><h2 id="3-2-案例引入"><a href="#3-2-案例引入" class="headerlink" title="3.2 案例引入"></a>3.2 案例引入</h2><h3 id="案例3-1-进制转换"><a href="#案例3-1-进制转换" class="headerlink" title="案例3.1 进制转换"></a>案例3.1 进制转换</h3><ul><li>进制转换</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131135382.png"></p><h3 id="案例3-2-括号匹配的检验"><a href="#案例3-2-括号匹配的检验" class="headerlink" title="案例3.2 括号匹配的检验"></a>案例3.2 括号匹配的检验</h3><ul><li><p>假设表达式中允许包含两种括号：圆括号和方括号</p></li><li><p>其嵌套的顺序随意，即：</p><ol><li><p>([ ] ( ))或[ ( [ ] [ ] ) ]为正确格式；</p></li><li><p>[ ( ] )为错误格式；</p></li><li><p>( [ () )或(()])为错误格式。</p></li></ol></li><li><p>括号匹配<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131136898.png"></p></li></ul><h3 id="案例3-3-表达式求值"><a href="#案例3-3-表达式求值" class="headerlink" title="案例3.3 表达式求值"></a>案例3.3 表达式求值</h3><ul><li><p>表达式求值是程序设计语言编译中一个最基本的问题，它的实现需要运用栈。</p></li><li><p>这里介绍的算法是由运算符优先级确定运算顺序的对表达式求值算法——算符优先算法。</p></li><li><p>表达式的组成</p><ul><li><p>操作数(operand)：常数、变量。</p></li><li><p>运算符(operator)：算术运算符、关系运算符和逻辑运算符。</p></li><li><p>界限符(delimiter)：左右括弧和表达式结束符。</p></li></ul></li><li><p>任何一个算术表达式都由<strong>操作数</strong>(常数、变量)、算术<strong>运算符</strong>(+、-、* 、&#x2F;)和界限符(括号、表达式结束符’#’、虚设的表达式起始符’#’)组成。后两者统称为算符。</p></li><li><p>为了实现表达式求值。需要设置两个栈：</p><p>  一个是算符栈OPTR，用于寄存运算符。</p><p>  另一个称为操作数栈OPND，用于寄存运算数和运算结果。</p></li><li><p>求值的处理过程是自左至右扫描表达式的每一个字符</p><ul><li><p>当扫描到的是运算数，则将其压入栈OPND，</p></li><li><p>当扫描到的是运算符时</p><ul><li><p>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTR，继续向后处理</p></li><li><p>若这个运算符比OPTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从栈OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND。</p></li></ul></li><li><p>继续处理当前字符，直到遇到结束符为止。</p></li></ul></li></ul><h3 id="案例3-4-舞伴问题"><a href="#案例3-4-舞伴问题" class="headerlink" title="案例3.4 舞伴问题"></a>案例3.4 舞伴问题</h3><p>假设在舞会上，男士和女士各自排成一队。舞会开始时，依次从男队和女队的队买务出一人配成舞伴。如果两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一算法模拟上述舞伴配对问题。</p><p>显然，先入队的男士或女士先出队配成舞。因此该问题具有典型的先进先出特性，可以用队列作为算法的数据结构。</p><ul><li><p>首先构造两个队列</p></li><li><p>依次将从男元素出队配成舞伴</p></li><li><p>某队为空，则另外一队等待着则是下一舞曲第一个可获得舞伴的人。</p></li></ul><h2 id="3-3-栈的表示和操作的实现"><a href="#3-3-栈的表示和操作的实现" class="headerlink" title="3.3 栈的表示和操作的实现"></a>3.3 栈的表示和操作的实现</h2><h3 id="3-3-1-栈的抽象数据类型的类型定义"><a href="#3-3-1-栈的抽象数据类型的类型定义" class="headerlink" title="3.3.1 栈的抽象数据类型的类型定义"></a>3.3.1 栈的抽象数据类型的类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT Stack&#123;<br>数据对象：<br>    D = &#123;ai | ai ∈ ElemSet, i = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n, n≥<span class="hljs-number">0</span>&#125;<br>数据关系：<br>    R1 = &#123;&lt;ai<span class="hljs-number">-1</span>, ai&gt; | ai<span class="hljs-number">-1</span>, ai∈D, i = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...,n&#125;<br>    约定an端为栈顶，a1端为栈底<br>基本操作：<br>    初始化、进栈、出栈、取栈顶元素等<br>&#125;ADT Stack<br></code></pre></td></tr></table></figure><ul><li>栈的基本操作<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131137111.png"></li></ul><h3 id="3-3-2-顺序栈的表示和实现"><a href="#3-3-2-顺序栈的表示和实现" class="headerlink" title="3.3.2 顺序栈的表示和实现"></a>3.3.2 顺序栈的表示和实现</h3><p>存储方式：同一般线性表的顺序存储结构完全相同，<strong>利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素</strong>。栈底一般在低地址端。</p><ul><li><p>附设<strong>top指针</strong>，指示栈顶元素在顺序栈中的位置。</p></li><li><p>另设<strong>base指针</strong>，指示栈底元素在顺序栈中的位置。</p></li><li><p>用stacksize表示栈可使用的最大容量。</p></li></ul><p>但是，为了方便操作，通常top指示真正的<strong>栈顶元素之上</strong>的下标地址。</p><p>空栈：base &#x3D;&#x3D; top是栈空标志</p><p>栈满：top - base &#x3D;&#x3D; stacksize</p><ul><li><p>栈满时的处理方法：</p><ol><li><p>报错，返回操作系统</p></li><li><p>分配更大的空间，作为栈的存储空间，将原栈的内容移入新栈</p></li></ol></li></ul><p>使用数组作为顺序栈存储方式的特点：简单、方便、但易产生溢出（数组大小固定）</p><ul><li><p>上溢(overflow)：栈已经满，又要压入元素</p></li><li><p>下溢(underflow)：栈已经空，还要弹出元素</p></li></ul><p>注：上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题处理结束。</p><blockquote><p>顺序栈的表示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SqStack</span>&#123;<br>    SElemType *base;    <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;     <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;      <span class="hljs-comment">// 栈可用最大容量</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.1 顺序栈的初始化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 构造一个空栈</span><br><span class="hljs-function">State <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    S.base = <span class="hljs-keyword">new</span> SElemType[MAXSIZE];<br>    <span class="hljs-keyword">if</span>(!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>    S.top = S.base; <span class="hljs-comment">// 栈顶指针等于栈底指针</span><br>    S.stacksize = MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1 判断顺序栈是否为空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 若栈为空，返回TRUE；否则返回FALSE</span><br><span class="hljs-function">State <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top == S.base)<br>        <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法2 求顺序栈的长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> S.top - S.base;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3 清空顺序栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base) S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法4 销毁顺序栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base)&#123;<br>        <span class="hljs-keyword">delete</span> S.base;<br>        S.stacksize = <span class="hljs-number">0</span>;<br>        S.base = S.top = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.2 顺序栈的入栈</p></blockquote><ul><li><p>步骤：</p><ol><li><p>判断是否栈满，若满则出错</p></li><li><p>元素e压入栈顶</p></li><li><p>栈顶指针加1</p></li></ol></li></ul><p><strong>先压入元素，再移动栈顶指针，为什么？</strong><br>我的理解是，你得先通过top指针找到你要把元素压入哪个位置，然后再把top指针上移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top - S.base == S.stacksize)   <span class="hljs-comment">// 栈满</span><br>        <span class="hljs-keyword">return</span> ERROR;<br>    *S.top = e;<br>    S.top++;<br>    <span class="hljs-comment">// 两步加起来等同于</span><br>    <span class="hljs-comment">// *S.top++ = e;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.3 顺序栈的出栈</p></blockquote><ul><li><p>步骤：</p><ol><li><p>判断是否栈空，若空则出错</p></li><li><p>获取栈顶元素e</p></li><li><p>栈顶指针减1</p></li></ol></li></ul><p><strong>先移动栈底指针，再取出元素，为什么？</strong><br>我的理解是，你得先移动栈顶指针，才能找到你要取出的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.top  == S.base) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//判断是否栈空，若空则出错（下溢）</span><br>    S.top--;<br>    e = *S.top;<br><span class="hljs-comment">// 等同于e = *--S.top;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-链栈的表示和实现"><a href="#3-3-3-链栈的表示和实现" class="headerlink" title="3.3.3 链栈的表示和实现"></a>3.3.3 链栈的表示和实现</h3><p>链栈是运算受限的单链表，只能在链表头部进行操作。定义链栈的结构类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span>&#123;<br>    SElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackNode</span> *next;<br>&#125;StackNode， *LinkStack;<br>Link Stack S;<span class="hljs-comment">//创建栈S</span><br></code></pre></td></tr></table></figure><p><strong>注意：链栈中指针的方向</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211515685.png"></p><ul><li><p>链表的头指针就是栈顶</p></li><li><p>不需要头结点</p></li><li><p>基本不存在栈满的情况</p></li><li><p>空栈相当于，栈指针指向空</p></li><li><p>插入和删除仅在栈顶处执行</p></li></ul><blockquote><p>算法3.5 链栈的初始化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span></span>&#123;<br>    <span class="hljs-comment">// 构造一个空栈，栈顶指针置为空</span><br>    S = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1 判断链栈是否位空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(LinkList S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE;<br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p>算法3.6 链栈的入栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(LinkStack &amp;S, SElemType e)</span></span>&#123;<br>    p = <span class="hljs-keyword">new</span> StackNode;  <span class="hljs-comment">// 生成新结点p</span><br>    p-&gt;data = e;    <span class="hljs-comment">// 将新结点数据域置为e</span><br>    p-&gt;next = S;    <span class="hljs-comment">// 将新结点插入栈顶</span><br>    S = p;          <span class="hljs-comment">// 修改栈顶指针</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法3.7 链栈的出栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(LinkStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    e = S-&gt;data;把数据用e存储<br>    p = S;  <span class="hljs-comment">//存储原来的栈顶指针</span><br>    S = S-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211531419.png"><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211531360.png"></p><blockquote><p>算法3.8 取栈顶的元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SElemType <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkStack S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> S-&gt;data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-4-栈与递归"><a href="#3-4-栈与递归" class="headerlink" title="3.4 栈与递归"></a>3.4 栈与递归</h2><ul><li><p>递归的定义</p><ul><li><p>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的；</p></li><li><p>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。</p></li></ul></li><li><p>常用到递归方法的三种情况：</p><ul><li><p>递归定义的数学函数</p></li><li><p>具有递归特性的数据结构</p><ul><li><p>二叉树</p></li><li><p>广义表</p></li></ul></li><li><p>可递归求解的问题</p><ul><li><p>迷宫问题</p></li><li><p>汉诺塔问题</p></li></ul></li></ul></li><li><p>递归问题——用分治法求解</p><ul><li><p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解</p></li><li><p>用分治法必备的三个条件</p><ol><li><p>能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</p></li><li><p>可以通过上述转换而使得问题简化</p></li><li><p>必须有一个明确的递归出口，或称递归边界</p></li></ol></li><li><p>分治法求解递归问题算法的一般形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">(参数表)</span></span>&#123;<br>    <span class="hljs-comment">// 基本项</span><br>    <span class="hljs-keyword">if</span>(递归结束条件) 可直接求解步骤; <span class="hljs-comment">// 递归边界</span><br>    <span class="hljs-comment">// 归纳项</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">p</span>(较小的参数);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">例如：<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">Fact</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//基本项</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">Fact</span>(n<span class="hljs-number">-1</span>);  <span class="hljs-comment">//归纳项</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>函数调用过程</p><ul><li><p>调用前，系统完成</p><ul><li><p>将实参、返回地址等传递给被调函数</p></li><li><p>为被调函数的局部变量分配存储区</p></li><li><p>将控制转移到被调函数的入口</p></li></ul></li><li><p>调用后，系统完成：</p><ul><li><p>保存被调函数的计算结果</p></li><li><p>释放被调函数的数据区</p></li><li><p>依照被调函数保存的返回地址将控制转移到被调函数</p></li></ul></li></ul></li><li><p>当多个函数构成嵌套调用时</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211610264.png"><br><strong>遵循后调用的先返回</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211630096.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211633233.png"><br>工作记录包括实参，局部变量，返回地址<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211635394.png"></p><ul><li><p>递归的优缺点</p><ul><li><p>优点：结构清晰，程序易读</p></li><li><p>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</p></li></ul></li><li><p>实现递归转非递归</p><ul><li><p>方法1：尾递归、单向递归变为循环结构</p></li><li><p>方法2：自用栈模拟系统的运行时栈</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211642768.png"></p><h2 id="3-5-队列的表示和操作的实现"><a href="#3-5-队列的表示和操作的实现" class="headerlink" title="3.5 队列的表示和操作的实现"></a>3.5 队列的表示和操作的实现</h2><ul><li><p>队列描述</p><ul><li><p><strong>队列</strong>(<strong>Queue</strong>)是仅在表尾进行插入操作，在表头进行删除操作的线性表。</p></li><li><p>表尾即an端，称为队尾；表头即a1端，称为队头；</p></li><li><p>它是一种先进先出(FIFO)的线性表</p></li></ul></li><li><p>队列的常见应用</p><ul><li><p>脱机打印输出：按申请的先后顺序依次输出</p></li><li><p>多用户系统中，多个用户排成队，分时地循坏使用CPU和主存</p></li><li><p>按用户的优先级排成多个队，每个优先级一个队列</p></li><li><p>实时控制系统中，信号俺接受的先后顺序依次处理</p></li></ul></li></ul><h3 id="3-5-1-队列的抽象数据类型定义"><a href="#3-5-1-队列的抽象数据类型定义" class="headerlink" title="3.5.1 队列的抽象数据类型定义"></a>3.5.1 队列的抽象数据类型定义</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211647621.png"></p><h3 id="3-5-2-队列的顺序表示和实现"><a href="#3-5-2-队列的顺序表示和实现" class="headerlink" title="3.5.2 队列的顺序表示和实现"></a>3.5.2 队列的顺序表示和实现</h3><p>队列的物理存储可以用顺序存储结构，也可用链式存储结构。相应地队列的存储方式也分为两种，即<strong>顺序队列</strong>和<strong>链式队列</strong>。</p><p>队列的顺序表示——用一维数组<code>base[MAXQSIZE]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QElemType *base;    <span class="hljs-comment">// 初始化的动态分配存储空间</span><br>    <span class="hljs-type">int</span> front;  <span class="hljs-comment">// 头指针，即队头下标</span><br>    <span class="hljs-type">int</span> rear;   <span class="hljs-comment">// 尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211700806.png"></p><blockquote><p>顺序队列存在的问题</p></blockquote><p>顺序队列的真溢出问题：即front&#x3D;0，rear&#x3D;MAXQSIZE时，队列中存满，为真溢出；</p><p>而当入队、出队操作之后，随着front和rear移动，出现front!&#x3D;0，rear&#x3D;MAXQSIZE时，为假溢出。</p><blockquote><p>顺序队列假上溢解决办法</p></blockquote><ul><li><p>解决假上溢的方法 </p><ol><li><p>将队中元素依次向队头方向移动。缺点：浪费时间。每移动一次，队中元素都要移动。</p></li><li><p>将队空间设想成一个循环的表，即分配给队列的m个存储单元可以循环使用，当rear为maxqsize时，若向量的开始端空着，又可从头使用空着的空间。当front为maxqsize时，也是一样。</p></li></ol></li><li><p>引入循环队列——解决假上溢的问题</p><p>  <code>base[0]</code>接在<code>base[MAXQSIZE-1]</code>之后，若rear+1 &#x3D;&#x3D; M，则rear&#x3D;0；</p><p>  实现方法：利用模运算(mod, %)</p><p>  入队：(尾指针后移一位)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Q.base[Q.rear] = x;<br>Q.rear = (Q.rear+<span class="hljs-number">1</span>) % MAXQSIZE;<br></code></pre></td></tr></table></figure><p>  出队：(头指针后移一位)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">x = Q.base[Q.front];<br>Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE;<br></code></pre></td></tr></table></figure><p>  针对循环队列，判断队空、队满时，front都与rear相等，因此可解决的方案有：</p><ol><li><p>另外设一个标态以区别队空和队满</p></li><li><p>另设一个变量，记录循环队列中当前元素个数</p></li><li><p>少用一个元素空间</p></li></ol></li><li><p>循环队列解决队满时判断方法——少用一个元素空间</p><p>  队空时：front &#x3D;&#x3D; rear</p><p>  队满时：(rear+1)% MAXQSIZE &#x3D;&#x3D; front（为什么判断队满时还要取余，考虑尾指针再加一归零的情况）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202211211913147.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301231508757.png"></p><blockquote><p>循环队列的类型定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    QElemType *base;    <span class="hljs-comment">// 初始化的动态分配存储空间</span><br>    <span class="hljs-type">int</span> front;  <span class="hljs-comment">// 头指针，若队列不为空，指向队列头元素</span><br>    <span class="hljs-type">int</span> rear;   <span class="hljs-comment">// 尾指针，若队列不为空，指向队尾元素的下一个位置</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——队列的初始化(算法3.11)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span></span>&#123;<br>    Q.base = <span class="hljs-keyword">new</span> QElemType[MAXQSIZE]; <span class="hljs-comment">//分配数组空间</span><br>    <span class="hljs-comment">//等同于Q.base=(QElemType*)malloc(MAXQSIZE*sizeof(QElemType));</span><br>    <span class="hljs-keyword">if</span>(!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>    Q.front = Q.rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——求队列的长度(算法3.12)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QueueLength</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>队列中的元素个数&#x3D;(Q.rear - Q.front + MAXQSIZE) % MAXQSIZE</strong></p><blockquote><p>循环队列的操作——循环队列入队(算法3.13)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE == Q.front) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队满</span><br>    Q.base[Q.rear] = e; <span class="hljs-comment">// 新元素加入队尾</span><br>    Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXQSIZE;   <span class="hljs-comment">// 队尾指针+1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——循环队列出队(算法3.14)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear == Q.front) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队空</span><br>    e = Q.base[Q.front];    <span class="hljs-comment">// 保存队头元素</span><br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE; <span class="hljs-comment">// 队头指针+1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>循环队列的操作——取循环队列队头元素(算法3.15)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">QElemType <span class="hljs-title">GetHead</span><span class="hljs-params">(SqQueue Q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear != Q.front)&#123; <span class="hljs-comment">// 不为空</span><br>        <span class="hljs-keyword">return</span> Q.base[Q.front]; <span class="hljs-comment">// 返回队头指针元素的值，队头指针不变</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-3-链队——队列的链式表示和实现"><a href="#3-5-3-链队——队列的链式表示和实现" class="headerlink" title="3.5.3 链队——队列的链式表示和实现"></a>3.5.3 链队——队列的链式表示和实现</h3><p>若用户无法估计所用队列的长度，则宜采用链队列。</p><blockquote><p>链式队列的类型定义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">// 最大队列长度</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Qnode</span>&#123;<br>    QElemType data;<br>    Qnode *next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> Qnode *QueuePtr;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkQueue</span>&#123;<br>    QueuePtr front; <span class="hljs-comment">// 队头指针</span><br>    QueuePtr rear;  <span class="hljs-comment">// 队尾指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——链队列的初始化(算法3.16)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    Q.front = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueuePtr</span>();<br>    Q.rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueuePtr</span>();<br>    Q.front-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——销毁链队列(补充)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(Q.front)&#123;<br>        p = Q.front-&gt;next;<br>        <span class="hljs-built_in">delete</span> (Q.front);<br>        Q.front = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——将元素e入队(算法3.17)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;<br>    p = <span class="hljs-keyword">new</span> QueuePtr;<br>    <span class="hljs-keyword">if</span>(!p) <span class="hljs-built_in">exit</span>(OVERFLOW);  <span class="hljs-comment">// 存储分配失败</span><br>    p-&gt;data = e;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next = p;<br>    Q.rear = p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——链队列的出队(算法3.18)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 队空</span><br>    p = Q.front-&gt;next;<br>    e = p-&gt;data;<br>    Q.front-&gt;next = p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear == p) Q.rear = Q.front;<span class="hljs-comment">//此情况为删除的就是尾结点，此时队列为空，所以要使队尾指针等于队头指针</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>链队列的操作——求链队列的队头元素(算法3.19)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetHead</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>    e = Q.front-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-6-习题"><a href="#3-6-习题" class="headerlink" title="3.6 习题"></a>3.6 习题</h2><blockquote><p>选择题</p></blockquote><ol><li><p>设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5和e6依次进入栈s，一个元素出栈后即进入Q，若6个元素出队的序列是e2、e4、e3、e6、e5和e1，则栈S的容量至少应该是()</p><p> A. 2  <strong>B. 3</strong>  C. 4  D. 6</p></li><li><p>若一个栈以向量<code>V[1...n]</code>存储，初始栈顶指针top设为n+1，则元素x进栈的正确操作是()。</p><p> A. <code>top++; V[top]=x;</code> B. <code>V[top]=x; top++;</code> <strong>C.</strong> <code>top--; V[top]= x;</code> D. <code>V[top]=x; top--;</code></p><p> 答案：C；解释：初始栈顶指针top为n+1，说明元素从数组向量的高端地址进栈，又因为元素存储在向量空间<code>V[1...n]</code>中，所以进栈时top指针先下移变为n，之后将元素x存储在<code>V[n]</code>。</p></li></ol><blockquote><p>算法设计题</p></blockquote><ol><li><p>将编号为0和1的两个栈存放于一个数组空间<code>V[m]</code>中，栈底分别处于数组的两端。当第0号栈的栈顶指针<code>top[0]</code>等于-1时该栈为空；当第1号栈的栈顶指针<code>top[1]</code>等于m时，该栈为空。两个栈均从两端向中间增长(见图)。试编写双栈初始化，判断栈空、栈满、进栈和出栈等算法的函数。双栈数据结构的定义如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DblStack</span>&#123;<br>    <span class="hljs-type">int</span> top[<span class="hljs-number">2</span>], bot[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 栈顶和栈底指针</span><br>    SElemType* V;       <span class="hljs-comment">// 栈数组</span><br>    <span class="hljs-type">int</span> m;              <span class="hljs-comment">// 栈最大可容纳元素个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> <img src="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/%E5%8F%8C%E6%A0%88%E7%BB%93%E6%9E%84%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt="双栈结构的表示"></p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe1.cpp">算法设计题1</a></p></li><li><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。试写一个算法判定给定的字符序列是否为回文。（提示：将一半字符入栈）</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe2.cpp">算法设计题2</a></p></li><li><p>设从键盘输入一整数的序列：a1, a2, a3,…, an，试编写算法实现：用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai &#x3D; -1时，输出栈顶整数并出栈。算法应对异常情况(入栈满等)给出相应的信息。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe3.cpp">算法设计题3</a></p></li><li><p>从键盘上输入一个后缀表达式，试编写算法计算表达式的值。规定：逆波兰表达式的长度不超过一行，以”$”作为输入结束，操作数之间用空格分隔，操作符只可能有+、-、<em>、／四种运算。例如： 23434 + 2</em>$。</p></li><li><p>假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，称可以操作的序列为合法序列，否则称为非法序列。</p><ul><li>下面所示的序列中哪些是合法的？</li></ul><p> A. IOIIOIOO B. IOOIOIIO C. IIIOIOIO D. IIIOOIOO</p><ul><li>通过对上述的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false(假定被判定的操作序列已存入一维数组中)。</li></ul><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe5.cpp">算法设计题5</a></p></li><li><p>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意：不设头指针），试编写相应的置空队列、判断队列是否为空、入队和出队等算法。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe6.cpp">算法设计题6</a></p></li><li><p>假设以数组<code>Q[m]</code>存放循环队列中的元素，同时设置一个标志tag，以tag &#x3D; 0和tag &#x3D; 1来区别在队头指针(front)和队尾指针(rear)相等时，队列状态为“空”还是“满”。试编写与此结构相应的插入(enqueue)和删除(dequeue)算法。</p><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe7.cpp">算法设计题7</a></p></li><li><p>如果允许在循环队列的两端都可以进行插入和删除操作。要求：</p><ul><li><p>写出循环队列的类型定义；</p></li><li><p>写出“从队尾删除”和“从队头插入”的算法。</p></li></ul><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe8.cpp">算法设计题8</a></p></li><li><p>已知Ackermann函数定义如下：Ack(m, n) &#x3D;</p><ul><li><p>n + 1, 当m &#x3D; 0时</p></li><li><p>Ack(m-1, 1), 当m≠0, n&#x3D;0时</p></li><li><p>Ack(m-1, Ack(m, n-1)), 当m≠0, n≠0时</p></li></ul><ol><li><p>写出计算Ack(m, n)的递归算法，并根据此算法给出Ack(2, 1)的计算过程。</p></li><li><p>写出计算Ack(m,n)的非递归算法。</p></li></ol><p> <a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe9.cpp">算法设计题9</a></p></li><li><p>已知f为单链表的表头指针，链表中存储的都是整型数据，试写出实现下列运算的递归算法：</p><ol><li><p>求链表中的最大整数；</p></li><li><p>求链表的结点个数；</p></li><li><p>求所有整数的平均值。</p></li></ol><p><a href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter3%20StackAndQueue/Chapter3Exe/AlgoDesignExe10.cpp">算法设计题10</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表——王卓</title>
    <link href="/2022/10/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和特点"><a href="#2-1-线性表的定义和特点" class="headerlink" title="2.1 线性表的定义和特点"></a>2.1 线性表的定义和特点</h2><p><strong>线性表是具有相同特性的数据元素的一个有限序列</strong>。</p><blockquote><p>线性表(Linear List)：</p></blockquote><p>由n(n ≥ 0)个数据元素（结点）a1, a2, … an组成的<strong>有限序列</strong>。</p><ul><li><p>其中数据元素的个数n定义为表的<strong>长度</strong></p></li><li><p>当n&#x3D;0时称为<strong>空表</strong></p></li><li><p>将非空的线性表(n&gt;0)记作：(a1, az, … an)</p></li><li><p>这里的数据元素ai(1≤i≤n)只是一个抽象的符号，其具体含义在不同的情况下可以不同。</p></li></ul><blockquote><p>线性表的逻辑特征</p></blockquote><ul><li><p>在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2；</p></li><li><p>有且仅有一个终端结点an，它没有直接后继，而仅有一个直接前趋an-1；</p></li><li><p>其余的内部结点ai(2≤i≤n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1。</p></li></ul><h2 id="2-2-案例引入"><a href="#2-2-案例引入" class="headerlink" title="2.2 案例引入"></a>2.2 案例引入</h2><blockquote><p>顺序存储结构存在问题</p></blockquote><ul><li><p>存储空间分配不灵活</p></li><li><p>运算的空间复杂度高</p></li></ul><blockquote><p>总结</p></blockquote><ul><li><p>线性表中的数据元素的类型可以为<strong>简单类型</strong>，也可以为<strong>复杂类型</strong></p></li><li><p>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序</p></li><li><p>从具体应用中抽象出共性的<strong>逻辑结构和基本操作</strong>（抽象数据类型），然后实现其<strong>存储结构和基本操作</strong></p></li></ul><h2 id="2-3-线性表的定义"><a href="#2-3-线性表的定义" class="headerlink" title="2.3 线性表的定义"></a>2.3 线性表的定义</h2><blockquote><p>基本操作</p></blockquote><ul><li><p>InitList(&amp;L)</p><ul><li>操作结果：构造一个空的线性表L</li></ul></li><li><p>DestoryList(&amp;L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：销毁线性表L</p></li></ul></li><li><p>ClearList(&amp;L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：将线性表L重置为空表</p></li></ul></li><li><p>ListEmpty(L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若线性表L空表则返回TURE；否则返回FALSE。</p></li></ul></li><li><p>ListLength(L)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：返回线性表L中的数据元素个数。</p></li></ul></li><li><p>GetElem(L, i, &amp;e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</p></li><li><p>操作结果：用e返回线性表L中第个数据元素的值。</p></li></ul></li><li><p>LocateElem(L, e, compare())</p><ul><li><p>初始条件：线性表L已存在，compare()是数据元素判定函数</p></li><li><p>操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。</p></li></ul></li><li><p>PriorElem(L, cur_e, &amp;pre_e)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义。</p></li></ul></li><li><p>NextElem(L, cur_e, &amp;next_e)</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：若cur_e是L的数据元素，且不是第最后个，则用next_e返回它的后继，否则操作失败，next_e无意义。</p></li></ul></li><li><p>ListInsert(&amp;L, i, e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)+1</p></li><li><p>操作结果：在L的第i个位置<strong>之前</strong>插入新的数据元素e，L的长度加一。</p></li></ul></li><li><p>ListDelete(&amp;L, i, &amp;e)</p><ul><li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</p></li><li><p>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一。</p></li></ul></li><li><p>ListTraverse(&amp;L, visited())   &#x2F;&#x2F; 遍历</p><ul><li><p>初始条件：线性表L已存在</p></li><li><p>操作结果：依次对线性表中每个元素调用visited()。</p></li></ul></li></ul><h2 id="2-4-线性表的顺序表示和实现"><a href="#2-4-线性表的顺序表示和实现" class="headerlink" title="2.4 线性表的顺序表示和实现"></a>2.4 线性表的顺序表示和实现</h2><h3 id="2-4-1-线性表的顺序存储表示"><a href="#2-4-1-线性表的顺序存储表示" class="headerlink" title="2.4.1 线性表的顺序存储表示"></a>2.4.1 线性表的顺序存储表示</h3><p>线性表的顺序表示又称为<strong>顺序存储结构</strong>或<strong>顺序映像</strong>。</p><p>顺序存储定义：把<strong>逻辑上相邻的数据元素</strong>存储在<strong>物理上相邻的存储单元</strong>中的存储结构。</p><p>线形表顺序存储结构占用<strong>一片续的存储空间</strong>。知道某个元素的存储位置就可以计算其他元素的存储位置。</p><blockquote><p>数组静态分配</p></blockquote><p>这段代码就相当于一个模板<br>typedef是用来给数据类型起一个新的名字<br>ElemType是数组的数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 100  <span class="hljs-comment">//线性表存储空间初始分配量</span></span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType data[MaxSize];<br>    <span class="hljs-type">int</span> length;  <span class="hljs-comment">//线性表当前长度</span><br>  &#125; SqList; <span class="hljs-comment">// 顺序表类型</span><br></code></pre></td></tr></table></figure><p>数组存放的是第一个元素的地址，因此也可以写成以下动态分配形式，用指针代替第一个元素地址。</p><blockquote><p>数组动态分配</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 1000  <span class="hljs-comment">//线性表存储空间</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>  ElemType *data;  <span class="hljs-comment">//存储空间的基地址</span><br>  <span class="hljs-type">int</span> length;<br>&#125; SqList; <span class="hljs-comment">// 定义顺序表类型</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">SqList L;  <span class="hljs-comment">//定义变量L，L是SqList这种类型的，L是个线性表</span><br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ElemType) * MaxSize);<br></code></pre></td></tr></table></figure><p>（ElemType*）表示强制类型转换</p><p>在头文件stdlib.h中：</p><p>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址。</p><p>size of(x)运算，计算变量x的长度</p><p>free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量。</p><blockquote><p>补充：C++的动态存储分配</p></blockquote><p>new 类型名T （初值列表）<br>    功能：<br>        申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值<br>    结果值：<br>        成功：T类型的指针，指向新分配的内存<br>        失败：0（NULL)<br>例如：int * p1 &#x3D; new int;或int * p1 &#x3D; new int(10);<br>注意：new出来的空间是一个地址所以只能赋值给指针。</p><p>delete 指针p<br>    功能：<br>        释放指针p所指向的内存。p必须是new操作的返回值</p><blockquote><p>补充：C++的参数传递</p></blockquote><ul><li><p>函数调用时传送给形参表的实参必须与形参三个一致</p><ul><li>类型、个数、顺序</li></ul></li><li><p>参数传递有两种方式</p><ul><li>传值方式</li><li>传地址<ul><li>参数为指针变量</li><li>参数为引用类型</li><li>参数为数组名</li></ul></li></ul></li><li><p>传地址方式–引用类型作参数<br>什么是引用？？？<br>引用：它用来给一个对象提供一个替代的名字</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp;j=i;<br>i=<span class="hljs-number">7</span>;<br>cout&lt;&lt;<span class="hljs-string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j;<br>&#125;  <span class="hljs-comment">//j是一个引用类型，代表i的一个替代名i值改变时，j值也跟着改变，所以会输出i=7 j=7</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210192252376.png"></p><p>m是对a的引用，n是对b的引用，通过引用变量直接操作实参</p><p>可以这样理解：m和a用的是同一个地址，他们共用同一块空间</p><ul><li>引用类型作形参的三点说明<ul><li>传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化</li><li>引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作，而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值时实参变量的副本。因此当参数传递的<strong>数据量比较大</strong>时，用引用比用一般变量传递参数的时间和空间效率都好</li><li>指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“* 指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用的点出，必须用变量的地址作为实参</li></ul></li></ul><h3 id="2-4-2-顺序表基本操作的实现"><a href="#2-4-2-顺序表基本操作的实现" class="headerlink" title="2.4.2 顺序表基本操作的实现"></a>2.4.2 顺序表基本操作的实现</h3><blockquote><p>线性表L的初始化</p></blockquote><p>Status 是函数的类型，其值是函数结果状态代码，在本例中为int的别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<span class="hljs-comment">// 构造一个空的顺序表L   </span><br>L.elem=<span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">// 为顺序表分配空间</span><br><span class="hljs-keyword">if</span>(!L.elem) <br>    <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 空表长度为0</span><br><span class="hljs-keyword">return</span> OK；<br></code></pre></td></tr></table></figure><blockquote><p>销毁线性表L</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestoryList</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(L.elem) <br>      <span class="hljs-keyword">delete</span> L.elem; <span class="hljs-comment">// 释放存储空间</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>清空线性表L</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 将线性表的长度置为0</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>求线性表的长度</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> L.length;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>判断线性表是否为空</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>顺序表的取值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 取物理位置第i个元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt;= L.length) <span class="hljs-keyword">return</span> ERROR;<br><br>  e = L.elem[i<span class="hljs-number">-1</span>];<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是在主函数定义了变量e，并且通过引用的方式把值已经传给e了，所以不用return e，这样写代码是为了获取状态代码，判断此操作中传入的i值是否可在线性表中取到</p><blockquote><p>顺序表按值查找(顺序查找)</p></blockquote><ul><li><p>在线性表L中查找与指定值e相同的数据元素的位置</p></li><li><p>从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//顺序表的查找（按值查找）</span><br><span class="hljs-comment">//暂且先用最简单的查找方法，从表的一端开始，逐个进行记录的关键字和给定值比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在线性表L中查找值为e的元素，返回其序号（是第几个元素）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;  <span class="hljs-comment">//查找成功，返回序号</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//查找失败，返回0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>平均查找长度ASL(Average Search Length):</p><ul><li><p>为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的<strong>平均查找长度</strong>。</p></li><li><p><strong>数学期望&#x3D;平均查找长度</strong></p></li></ul><blockquote><p>顺序表插入</p></blockquote><p>插入不同位置的算法演示：插入位置在最后、插入位置在中间、插入位置在最前面</p><p>算法思想：</p><ol><li><p>判断插入位置i是否合理</p></li><li><p>判断顺序表的存储空间是否已满，若已满返回ERROR</p></li><li><p>将第n至第i位的元素一次向后移动一个位置，空出第i个位置</p></li><li><p>将要插入的新元素e放入第i个位置</p></li><li><p>表长加1，返回插入成功。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ListInsert_Sq</span>(SqList&amp; L, <span class="hljs-type">int</span> i, ElemType e)<br>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// i值不合法</span><br>  <span class="hljs-keyword">if</span>(L.length == MAXSIZE) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 当前存储已满</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = L.length<span class="hljs-number">-1</span>; j &gt;= i; j--)&#123;<br>    L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<br>  &#125;  <span class="hljs-comment">//把位置i后的元素都后移一个位置</span><br>  L.elem[i<span class="hljs-number">-1</span>] = e;<br>  L.length++;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表插入算法的平均时间复杂度为O(n)。</p><blockquote><p>顺序表的删除算法</p></blockquote><p>算法思想：</p><ol><li><p>判断删除位置i是否合法</p></li><li><p>将欲删除的元素保留在e中</p></li><li><p>将第i+1至第n位的元素依次向前移动一个位置</p></li><li><p>表长减1，删除成功返回OK</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ListInsert_Sq</span>(SqList&amp; L, <span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// i值不合法</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= L.length<span class="hljs-number">-1</span>; j++)&#123;<br>    L.elem[j<span class="hljs-number">-1</span>] = L.elem[j];<br>  &#125;<br>  L.length--;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125; <br><span class="hljs-comment">//注意算法里面的i是位置不是数组下标</span><br></code></pre></td></tr></table></figure><p>顺序表删除算法的平均时间复杂度为O(n)。</p><h3 id="2-4-3-顺序表小结"><a href="#2-4-3-顺序表小结" class="headerlink" title="2.4.3 顺序表小结"></a>2.4.3 顺序表小结</h3><ol><li><p>利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致</p></li><li><p>在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等</p><ul><li>这种存取元素的方法被称为<strong>随机存取法</strong></li></ul></li></ol><blockquote><p>顺序表的操作算法分析</p></blockquote><ul><li><p>时间复杂度</p><ul><li>查找、插入、删除算法的平均时间复杂度为O(n)</li></ul></li><li><p>空间复杂度</p><ul><li>顺序表操作算法的空间复杂度S(n) &#x3D; O(1)，没有占用辅助空间</li></ul></li></ul><blockquote><p>顺序表的优缺点</p></blockquote><ol><li><p>优点</p><ul><li><p>存储密度大（结点本身所占存储量&#x2F;结点结构所占存储量）</p></li><li><p>可以随机存取表中任一元素</p></li></ul></li><li><p>缺点</p><ul><li><p>在插入、删除某一元素时，需要移动大量元素</p></li><li><p>浪费存储空间</p></li><li><p>属于静态存储形式，数据元素的个数不能自由扩充</p></li></ul></li></ol><h2 id="2-5-线性表的链式表示和实现"><a href="#2-5-线性表的链式表示和实现" class="headerlink" title="2.5 线性表的链式表示和实现"></a>2.5 线性表的链式表示和实现</h2><ul><li><p>链式存储结构</p><ul><li>节点在存储器中的位置是任意的，即逻辑上相邻的数据在物理上不一定相邻</li></ul></li><li><p>线性表的链式表示又称为非顺序映像或链式映像。</p></li><li><p>用一组<strong>物理位置任意的存储单元</strong>来存放线性表的数据元素。</p></li></ul><p>单链表由头指针惟一确定，因此单链表可以用头指针的名字来命名。</p><p>各结点由两个域组成：</p><ul><li><p>数据域：存储元素数值数据</p></li><li><p>指针域：存储直接后继结点的存储位置</p></li></ul><blockquote><p>链式存储有关的术语</p></blockquote><ol><li><p>结点：数据元素的存储映像。由数据域和指针域两部分组成</p></li><li><p>链表：n个结点由<strong>指针链</strong>链接而成的一个链表</p></li><li><p>链表类型</p><p> 单链表：结点只有一个指针域的链表；</p><p> 双链表：结点有两个指针域的链表；</p><p> 循环链表：首尾相接的链表；</p></li><li><p>头指针、头结点和首元结点：</p><p> 头指针：是指向链表中第一个结点的指针，即指向头结点</p><p> 首元结点：是指链表中存储第一个数据元素a1的结点</p><p> 头结点：是在链表的首元结点之前附设的一个结点，一个附加结点。</p></li></ol><p><strong>以上三个概念一定要区分好</strong></p><blockquote><p>讨论1：如何表示空表</p></blockquote><ul><li><p>若无头结点时，头指针为空时表示空表</p></li><li><p>有头结点时，当头结点的指针域位空时表示空表</p></li></ul><blockquote><p>讨论2：在链表中设置头结点有什么好处？</p></blockquote><ol><li><p>便于首元结点的处理</p><p> 首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理</p></li><li><p>便于空表和非空表的统一处理</p><p> 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</p></li></ol><blockquote><p>讨论3：头结点的数据域内装的是什么？</p></blockquote><p>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</p><blockquote><p>链表的特点：</p></blockquote><ol><li><p>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻</p></li><li><p>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间<strong>不相同</strong></p></li><li><p><strong>链表是顺序存取的，顺序表是随机存取的</strong></p></li></ol><h3 id="2-5-1-单链表的定义和表示"><a href="#2-5-1-单链表的定义和表示" class="headerlink" title="2.5.1 单链表的定义和表示"></a>2.5.1 单链表的定义和表示</h3><blockquote><p>带头结点的单链表</p></blockquote><p>单链表是由<strong>表头</strong>唯一确定，因此单链表可以用头指针的名字来命名若头指针名是L，则把链表称为表L</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123; <span class="hljs-comment">// 声明结点的类型和指向结点的指针类型</span><br>  ElemType data;  <span class="hljs-comment">// 结点的数据域</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next;    <span class="hljs-comment">// 结点的指针域</span><br>&#125; Lnode, *LinkList; <span class="hljs-comment">// LinkList为指向结构体Lnode的指针类型，LinkList也就是别名</span><br></code></pre></td></tr></table></figure><p>定义链表L：LinkList L;  （指向头结点）</p><p>定义结点指针p：LNode * p等价于LinkList p;（指向中间结点，也就是结点的指针域）</p><h3 id="2-5-2-单链表基本操作的实现"><a href="#2-5-2-单链表基本操作的实现" class="headerlink" title="2.5.2 单链表基本操作的实现"></a>2.5.2 单链表基本操作的实现</h3><blockquote><p>算法2.6——单链表的初始化(带头结点的单链表)</p></blockquote><p>单链表的初始化即构造一个空表。</p><p>算法步骤：</p><ol><li><p>生成新结点作为头结点，用头指针L指向头结点</p></li><li><p>将头结点的指针域置空</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法1：判断链表是否为空</p></blockquote><p>空表：链表中无元素，称为空链表(头指针和头结点仍然在)</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123; <span class="hljs-comment">// 若L为空表，则返回1，否则返回0</span><br>  <span class="hljs-keyword">if</span>(L-&gt;next)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法2：单链表的销毁：链表销毁后不存在</p></blockquote><p>算法思路：从头指针开始，依次释放所有结点</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">// 销毁单链表L</span><br>  Lnode *p;<br>  <span class="hljs-keyword">while</span>(L)&#123; <span class="hljs-comment">// 直至L为空</span><br>    p = L;<br>    L = L-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>  &#125;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3：清空链表</p></blockquote><p>链表仍存在，但链表中无元素，成为空链表(头指针和头结点仍然在)</p><p>算法思路：依次释放所有结点，并将头结点指针域设置为空</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">// 将L重置为空表</span><br>  Lnode *p, *q<br>  p = L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p)&#123;<br>    q = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = q;<br>  &#125;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 头结点指针域为空</span><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>补充算法3：求单链表的表长</p></blockquote><p>算法思路：从首元结点开始，依次计数所有结点</p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>&#123; <span class="hljs-comment">// 返回L中数据元素个数</span><br>  LinkList p;<br>  p = L-&gt;next;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(p)&#123; <span class="hljs-comment">// 遍历单链表，统计结点数</span><br>    i++;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.7——取值(取单链表中第i个元素的内容)</p></blockquote><p>算法思路：从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止。因此，<strong>链表不是随机存取结构</strong>。</p><p>算法步骤：</p><ol><li><p>从第一个结点(L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p &#x3D; L-&gt;next;</p></li><li><p>j做计数器，累计当前扫描过的结点数，j初值为1；</p></li><li><p>当p指向扫描到的下一个结点时，计数器j加1；</p></li><li><p>当j &#x3D;&#x3D; i时，p所指的结点就是要找的第i个结点。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-comment">// 获取线性表L中的某个数据元素的内容，通过变量e返回</span><br>  p = L-&gt;next; j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(!p || j &gt; i) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 第i个元素不存在</span><br>  e = p-&gt;data;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找：</p><ul><li><p>按值查找：根据指定数据获取该数据所在的位置（该数据的地址）；</p></li><li><p>按值查找：根据指定数据获取该数据所在位置序号（是第几个元素）</p></li></ul><blockquote><p>算法2.8——按值查找：根据指定数据获取该数据所在的位置（地址）</p></blockquote><p>算法步骤：</p><ol><li><p>从第一个结点起，依次和e相比较</p></li><li><p>如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址；</p></li><li><p>如果查遍整个链表都没有找到其值和e相等的元素，则返回0或NULL。</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Lnode* <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 在线性表L中查找值e的数据元素</span><br>  <span class="hljs-comment">// 找到，则返回L中值为e的数据元素的地址，查找失败返回NULL</span><br>  p = L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.8 变化——按值查找：根据指定数据获取该数据所在的位置序号</p></blockquote><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 返回L中值为e的数据元素的位置序号，查找失败返回0</span><br>  p = L-&gt;next; j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>    p = p-&gt;next;<br>    j++;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(p) <span class="hljs-keyword">return</span> j;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.9 插入——在第i个结点前插入值为e的新结点</p></blockquote><p>算法步骤：</p><ol><li><p>首先找到ai-1的存储位置p</p></li><li><p>生成一个数据域为e的新结点s</p></li><li><p>插入新结点：</p><ol><li><p>新结点的指针域指向结点ai</p></li><li><p>结点ai-1的指针域指向新结点</p></li></ol></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;<br>  p = L; j = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 寻找第i-1个结点，p指向i-1结点</span><br>  <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i - <span class="hljs-number">1</span>)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-comment">// /i大于表长+1或者小于1，插入位置非法</span><br>  <span class="hljs-keyword">if</span>(!p || j &gt; i - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <br>  <span class="hljs-comment">// 生成新结点s，将结点s的数据域置为e</span><br>  s = <span class="hljs-keyword">new</span> LNode;<br>  s-&gt;data = e;<br>  <span class="hljs-comment">// 将结点s插入L中</span><br>  s-&gt;next = p-&gt;next;<span class="hljs-comment">//把p的指针域的指针（原本指向p后面一个结点的指针）赋值给s的指针域里的指针</span><br>  p-&gt;next = s;<span class="hljs-comment">//把指向s结点的指针赋值给p的指针域里的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.10 删除——删除第i个结点</p></blockquote><p>算法步骤：</p><ol><li><p>首先找到ai-1的存储位置p，保存要删除的ai的值</p></li><li><p>令p-&gt;next指向ai+1</p></li><li><p>释放结点ai的空间</p></li></ol><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// 将线性表L中第i个数据元素删除</span><br>  <span class="hljs-function">Status <span class="hljs-title">ListDelete_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType&amp;e)</span></span>&#123;<br>  p = L; j = <span class="hljs-number">0</span>; <br>  <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="hljs-number">-1</span>)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-comment">// 寻找第i个结点，并令p指向其前驱</span><br>  <span class="hljs-keyword">if</span>(!(p-&gt;next) || j &gt; i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR；<span class="hljs-comment">//删除位置不合理</span><br>  q = p-&gt;next;  <span class="hljs-comment">// 临时保存被删结点的地址以备释放</span><br>  <span class="hljs-comment">//让q指向p后面的一个结点</span><br>  p-&gt;next = q-&gt;next; <span class="hljs-comment">// 改变删除结点前驱结点的指针域</span><br>  <span class="hljs-comment">//让p指向q后面的一个结点，此时q变成了原来要删除的结点，而p跳过了q，指向q后面的一个结点</span><br>  e = q-&gt;data;  <span class="hljs-comment">// 保存删除结点的数据域</span><br>  <span class="hljs-keyword">delete</span> q;     <span class="hljs-comment">// 释放删除结点的空间</span><br>  <span class="hljs-keyword">return</span> OK;<br>&#125; <span class="hljs-comment">// ListDelete_L</span><br></code></pre></td></tr></table></figure><blockquote><p>算法2.11 建立单链表——头插法（倒位序）</p></blockquote><p>头插法：元素插入在链表头部，也叫前插法</p><p>算法步骤：</p><ol><li><p>从一个空表开始，重复读入数据；</p></li><li><p>生成新结点，将读入数据存放到新结点的数据域中</p></li><li><p><strong>从最后一个结点开始</strong>，依次将各结点插入到链表的前端</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142235433.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先建立一个带头结点的单链表</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; --i)&#123;<br>    p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点p</span><br>    cin &gt;&gt; p-&gt;data; <span class="hljs-comment">// 输入元素值</span><br>    p-&gt;next = L-&gt;next;  <span class="hljs-comment">// 插入到表头</span><br>    L-&gt;next = p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.11 建立单链表——尾插法（正位序）</p></blockquote><p>尾查法：元素插入在链表尾部，也叫后插法</p><p>算法步骤：</p><ol><li><p>从一个空表开始，正位序将新结点逐个插入到链表的尾部，尾指针r始终指向链表的尾结点。</p></li><li><p>初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142255418.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>;<br>  r = L;  <span class="hljs-comment">// 尾指针r指向头结点</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点，输入元素值</span><br>    cin &gt;&gt; p-&gt;data;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//新结点指针域先赋值为空</span><br>    r-&gt;next = p;<span class="hljs-comment">//把新的结点插入到链表尾部</span><br>    r = p;<span class="hljs-comment">//更新尾指针</span><br>  &#125;<br>&#125; <span class="hljs-comment">// CreateList_R</span><br></code></pre></td></tr></table></figure><h3 id="2-5-3-单链表的查找、插入、删除算法时间效率分析"><a href="#2-5-3-单链表的查找、插入、删除算法时间效率分析" class="headerlink" title="2.5.3 单链表的查找、插入、删除算法时间效率分析"></a>2.5.3 单链表的查找、插入、删除算法时间效率分析</h3><ol><li><p>因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为O(n)</p></li><li><p>插入和删除：</p><p> 因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为O(1)。</p><p> 但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)</p></li><li><p>头插法的时间复杂度是O(n)</p></li><li><p>尾插法的时间复杂度是O(n)</p></li></ol><h3 id="2-5-4-循环链表"><a href="#2-5-4-循环链表" class="headerlink" title="2.5.4 循环链表"></a>2.5.4 循环链表</h3><p>循环链表：是一种头尾相接的链表（即：表中最后一个结点的指针域指向头结点，整个链表形成一个环）。</p><p>优点：<strong>从表中任一结点出发均可找到表中其他结点</strong>。</p><p>循环链表的空表表示：头指针的指针域指向自己。</p><blockquote><p>注意：</p></blockquote><p>由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p-&gt;next是否为空，而是判断它们<strong>是否等于头指针</strong>。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151549155.png"></p><blockquote><p>头指针表示单循环链表</p></blockquote><p>找a1的时间复杂度：O(1)</p><p>找an的时间复杂度：O(n)</p><p>但考虑到表的操作常常是在表的首尾位置上进行，因此更过的是考虑用<strong>尾指针表示单循环链表</strong></p><blockquote><p>尾指针表示单循环链表</p></blockquote><p>设尾指针为R：</p><p>找a1的时间复杂度：O(1)，a1的存储位置是：R-&gt;next-&gt;next</p><p>找an的时间复杂度：O(1)，an的存储位置是：R</p><blockquote><p>带尾指针循环链表的合并（将Tb合并在Ta之后）</p></blockquote><p>操作步骤：</p><ol><li><p>p存表头结点：p &#x3D; Ta-&gt;next;</p></li><li><p>Tb表头连接到Ta表尾:Ta-&gt;next &#x3D; Tb-&gt;next-&gt;next;</p></li><li><p>释放Tb表头结点:delete Tb-&gt;next;</p></li><li><p>修改指针:Tb-&gt;next &#x3D; p;</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151601055.png"></p><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span></span>&#123;<br>  <span class="hljs-comment">// 假设Ta、Tb都是非空的单循环链表</span><br>  p = Ta-&gt;next;     <span class="hljs-comment">// 1. p存表头结点</span><br>  Ta-&gt;next = Tb-&gt;next-&gt;next;  <span class="hljs-comment">// Tb表头连接到Ta表尾</span><br>  <span class="hljs-keyword">delete</span> Tb-&gt;next;         <span class="hljs-comment">// 释放Tb表头结点</span><br>  Tb-&gt;next = p;           <span class="hljs-comment">// 修改指针</span><br>  <span class="hljs-keyword">return</span> Tb;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(1)</p><h3 id="2-5-5-双向链表"><a href="#2-5-5-双向链表" class="headerlink" title="2.5.5 双向链表"></a>2.5.5 双向链表</h3><p>双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了有两个方向不同的链，故称为双向链表。</p><p>双向链表结构定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>&#123;<br>  Elemtype data;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *prior, *next;<br>&#125;DuLNode, *DuLinkList;<br></code></pre></td></tr></table></figure><p>双向循环链表:</p><p>和单链的循环表类似，双向链表也可以有循环表</p><ul><li><p>让头结点的前驱指针指向链表的最后一个结点</p></li><li><p>让最后一个结点的后继指针指向头结点。</p></li></ul><p>在双向链表中有些操作（如：ListLength、GetElem等），因仅涉及一个方向的指针，故它们的算法与线性链表的相同。但在插入、删除时，则需同时修改两个方向上的指针，两者的操作的时间复杂度均为O(n)。</p><blockquote><p>算法2.13 双向链表的插入</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 在带头结点的双向循环链表L中第i个位置之前插入元素e</span><br>  <span class="hljs-keyword">if</span>(!(p = <span class="hljs-built_in">GetElemP_DuL</span>(L, i))) <span class="hljs-keyword">return</span> ERROR;<br>  s = <span class="hljs-keyword">new</span> DuLNode;<br>  s-&gt;data = e;<br>  s-&gt;prior = p-&gt;prior;<br>  p-&gt;prior-&gt;next = s;<br>  s-&gt;next = p;<br>  p-&gt;prior = s;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>算法2.14 双向链表的删除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListDelete_DuL</span><span class="hljs-params">(DuLinkList&amp; L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-comment">// 删除带头结点的双向循环链表L的第i个元素，并用e返回。</span><br>  <span class="hljs-keyword">if</span>(!(p = <span class="hljs-built_in">GetElemP_DuL</span>(L, i))) <span class="hljs-keyword">return</span> ERROR;<br>  e = p-&gt;data;<br>  p-&gt;prior-&gt;next = p-&gt;next;<br>  p-&gt;next-&gt;prior = p-&gt;prior;<br>  <span class="hljs-keyword">delete</span> p;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单链表、循环链表和双向链表的时间效率比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131139437.png"></p><h2 id="2-6-顺序表和链式表的比较"><a href="#2-6-顺序表和链式表的比较" class="headerlink" title="2.6 顺序表和链式表的比较"></a>2.6 顺序表和链式表的比较</h2><blockquote><p>链式存储结构的优点：</p></blockquote><ul><li><p>结点空间可以动态申请和释放；</p></li><li><p>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素。</p></li></ul><blockquote><p>链式存储结构的缺点</p></blockquote><ul><li><p>存储密度小：每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大。</p></li><li><p>链式存储结构是非随机存取结构。对任一结点的操作都需要从头指针依指针链查找到该结点，这增加了算法的复杂度。</p></li></ul><blockquote><p>顺序表和链式表的比较</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131138707.png"></p><h2 id="2-7-线性表的应用"><a href="#2-7-线性表的应用" class="headerlink" title="2.7 线性表的应用"></a>2.7 线性表的应用</h2><p>主要介绍线性表的合并和有序表的合并。</p><blockquote><p>线性表的合并 </p></blockquote><ul><li><p>问题描述：</p><p>假设利用两个线性表La和Lb分别表示两个集合A和B，现要求合一个新的集合A &#x3D; A∪B</p></li><li><p>算法步骤：</p><p>依次取出Lb中的每个元素，执行以下操作：</p><ol><li><p>在La中查找该元素</p></li><li><p>如果找不到，则将其插入La的最后</p></li></ol></li><li><p>算法描述：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(List &amp;La, List Lb)</span></span>&#123;<br>  La_len = <span class="hljs-built_in">ListLength</span>(La);<br>  Lb_len = <span class="hljs-built_in">ListLength</span>(Lb);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; Lb_len; i++)&#123;<br>    <span class="hljs-built_in">GetElem</span>(Lb, i, e);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">LocateElem</span>(La, e))&#123;<br>      <span class="hljs-built_in">ListInsert</span>(&amp;La, ++La_len, e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述算法时间复杂度为O(La_len*Lb_len)。</p><blockquote><p>有序表的合并</p></blockquote><ul><li><p>问题描述：</p><p>已知线性表La和Lb的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素仍按值非递减有序排列。</p></li><li><p>算法步骤：</p><ol><li><p>创建一个空表Lc</p></li><li><p>依次从La或Lb中“摘取”元素值较小的结点插入到Lc表的最后，直至其中一个表变空为止</p></li><li><p>继续将La或Lb其中一个表的剩余结点插入在Lc表的最后</p></li></ol></li></ul><blockquote><p>算法2.16 有序表合并——用顺序表实现</p></blockquote><ul><li>用顺序表实现</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_sq</span><span class="hljs-params">(SqList LA, SqList LB, SqList&amp; LC)</span></span>&#123;<br>  <span class="hljs-comment">// 指针pa和pb的初值分别指向两个表的第一个元素</span><br>  pa = LA.elem;<br>  pb = LB.elem;<br><br>  <span class="hljs-comment">// 新表长度为待合并两表的长度和</span><br>  LC.length = LA.length + LB.length;<br>  <span class="hljs-comment">// 为新表分配空间</span><br>  LC.elem = <span class="hljs-keyword">new</span> ElemType[LC.length];<br>  pc = LC.elem;<br><br>  <span class="hljs-comment">// 找到LA和LB的最后一个元素</span><br>  pa_last = LA.elem + LA.length - <span class="hljs-number">1</span>;<br>  pb_last = LB.elem + LB.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 两个表都非空</span><br>  <span class="hljs-keyword">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)&#123;<br>    <span class="hljs-keyword">if</span>(*pa &lt;= *pb)&#123;<br>      *pc++ = *pa++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      *pc++ = *pb++;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// LB已到达表尾，将LA中剩余元素加入LC</span><br>  <span class="hljs-keyword">while</span>(pa &lt;= pa_last) *pc++ = *pa++;<br><br>  <span class="hljs-comment">// LA已到达表尾，将LB中剩余元素加入LC</span><br>  <span class="hljs-keyword">while</span>(pb &lt;= pb_last) *pc++ = *pb++;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为：O(ListLength(LA)+ListLength(LB))</p><p>空间复杂度为：O(ListLength(LA)+ListLength(LB))</p><blockquote><p>算法2.17 有序表合并——用链表实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_L</span><span class="hljs-params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;<br>  pa = La-&gt;next;<br>  pb = Lb-&gt;next;<br>  <span class="hljs-comment">// pc指针指向头结点</span><br>  pc = Lc = La; <span class="hljs-comment">// 用La的头结点作为Lc的头结点</span><br>  <span class="hljs-keyword">while</span>(pa &amp;&amp; pb)&#123;<br>    <span class="hljs-keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;<br>      pc-&gt;next = pa;<br>      pc = pa;<br>      pa = pa-&gt;next;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      pc-&gt;next = pb;<br>      pc = pb;<br>      pb = pb-&gt;next;<br>    &#125;<br>  &#125;<br>  pc-&gt;next = pa ? pa : pb;  <span class="hljs-comment">// 插入剩余段</span><br>  <span class="hljs-keyword">delete</span> Lb;  <span class="hljs-comment">// 删除Lb的头结点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为：O(ListLength(La)+ListLength(Lb))</p><p>空间复杂度为：O(1)</p><h2 id="2-8-案例分析与实现"><a href="#2-8-案例分析与实现" class="headerlink" title="2.8 案例分析与实现"></a>2.8 案例分析与实现</h2><blockquote><p>案例2.1：一元多项式的运算，实现两个多项式的加、减、乘运算</p></blockquote><p>可用顺序表实现。</p><blockquote><p>案例2.2：稀疏多项式的运算</p></blockquote><p>对于稀疏多项式，可考虑创建一个新的结构体，分别保存指数和系数。</p><p>利用顺序表实现时存在<strong>存储空间分配不灵活、运算得空间复杂度高</strong>等缺点。可考虑利用链式存储结构实现。</p><p>定义新的链表结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span>&#123;<br>  <span class="hljs-type">float</span> coeff;  <span class="hljs-comment">// 系数</span><br>  <span class="hljs-type">int</span> expn;     <span class="hljs-comment">// 指数</span><br>  PNode *next;  <span class="hljs-comment">// 指针域</span><br>&#125;PNode， *Polynomial;<br></code></pre></td></tr></table></figure><ul><li><p>多项式相加</p><ul><li><p>多项式创建——算法步骤</p><ol><li><p>创建一个只有头结点的空链表；</p></li><li><p>根据多项式的项的个数n，循环n次执行以下操作：</p><ul><li><p>生成一个新结点*s；</p></li><li><p>输入多项式当前项的系数和指数赋给新结点*s的数据域；</p></li><li><p>设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点；</p></li><li><p>指针q初始化，指向首元结点；</p></li><li><p>循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点*q；</p></li><li><p>将输入项结点*s插入到结点q之前。</p></li></ul></li></ol></li><li><p>多项式创建——算法描述(头插法)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatePolyn</span><span class="hljs-params">(Polynomial &amp;P, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  <span class="hljs-comment">// 输入m项的系数和指数，建立表示多项式的有序链表P</span><br>  P = <span class="hljs-keyword">new</span> PNode;<br>  P-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先建立一个带头结点的单链表</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;  <span class="hljs-comment">// 依次输入n个非零项</span><br>    s = <span class="hljs-keyword">new</span> PNode;  <span class="hljs-comment">// 生成新结点</span><br>    cin &gt;&gt; s-&gt;coef &gt;&gt; s-&gt;expn;<br>    pre = p;      <span class="hljs-comment">// pre用于保存q的前驱，初值为头结点</span><br>    q = p-&gt;next;  <span class="hljs-comment">// q初始化，指向首元结点</span><br>    <span class="hljs-keyword">while</span>(q &amp;&amp; q-&gt;expn &lt; s-&gt;expn)&#123;  <span class="hljs-comment">// 找到第一个大于输入项指数的项*q</span><br>      pre = q;<br>      q = p-&gt;next;<br>    &#125;<br>    s-&gt;next = q;  <span class="hljs-comment">// 将输入项s插入到q和其前驱结点pre之间</span><br>    pre-&gt;next = s;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多项式相加——算法步骤</p><ol><li><p>指针p1和p2初始化，分别指向Pa和Pb的首元结点。</p></li><li><p>p3指向和多项式的当前结点，初值为Pa的头结点。</p></li><li><p>当指针p1和p2均未到达相应表尾时，则循环比较p1和p2所指结点对应的指值(p1-&gt;expn与p2-&gt;expn)，有下列三种情况：</p><ul><li><p>当p1-&gt;expn &#x3D;&#x3D; p2-&gt;expn时，则将两个结点中的系数相加</p><ul><li><p>若和不为零，则修改p1所指结点的系数值，同时删除p2所指结点</p></li><li><p>若和为零，则删除p1和p2所指结点</p></li></ul></li><li><p>当p1-&gt;expn &lt; p2-&gt;expn时，则应摘取p1所指结点插入到“和多项式”链表中表；</p></li><li><p>当p1-&gt;expn &gt; p2-&gt;expn时，则应摘取p2所指结点插入到“和多项式”链表中表；</p></li></ul></li><li><p>将非空多项式的剩余段浦入到p3所指结点之后</p></li><li><p>释放Pb的头结点。</p></li></ol></li></ul></li></ul><blockquote><p>案例2.3 图书信息管理系统</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构绪论——王卓</title>
    <link href="/2022/10/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/"/>
    <url>/2022/10/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-数据结构绪论"><a href="#第一章-数据结构绪论" class="headerlink" title="第一章 数据结构绪论"></a>第一章 数据结构绪论</h1><h2 id="1-1-数据结构的研究内容"><a href="#1-1-数据结构的研究内容" class="headerlink" title="1.1 数据结构的研究内容"></a>1.1 数据结构的研究内容</h2><p>计算机进行数值计算式，首先从具体问题抽象出数学模型，然后设计一个解此数学模型的算法，最后编写程序，进行测试、调试，直到解决问题。</p><p><strong>数据结构</strong>是一门研究<strong>非数值计算</strong>的程序设计中计算机的操作对象（表、树、图等）以及它们之间关系和操作的学科。</p><h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><h3 id="1-2-1-数据、数据元素、数据项和数据对象"><a href="#1-2-1-数据、数据元素、数据项和数据对象" class="headerlink" title="1.2.1 数据、数据元素、数据项和数据对象"></a>1.2.1 数据、数据元素、数据项和数据对象</h3><p><strong>数据</strong>(<strong>Data</strong>)：是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称。</p><p><strong>数据元素</strong>(<strong>Data Element</strong>)：是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、记录、结点或顶点等。</p><p><strong>数据项</strong>(<strong>Data Item</strong>)：是组成数据元素的、有独立含义的、不可分割的最小单位。</p><p><strong>数据对象</strong>(<strong>Data Object</strong>)：是性质相同的数据元素的集合，是数据的一个子集。不论数据元素集合是无限集（如整数集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生表）的集合，只要集合内元素的性质均相同，都可称之为一个数据对象。</p><blockquote><p>数据元素与数据对象：</p></blockquote><p>数据元素——组成数据的基本单位，与数据的关系是：集合的个体。</p><p>数据对象——性质相同的数据元素的集合，与数据的关系是：集合的子集。</p><h3 id="1-2-2-数据结构"><a href="#1-2-2-数据结构" class="headerlink" title="1.2.2 数据结构"></a>1.2.2 数据结构</h3><p><strong>数据结构</strong>(<strong>Data Structure</strong>)是<strong>相互之间存在一种或多种特定关系</strong>的数据元素的集合。</p><p>换而言之，数据元素之间不是孤立存在的，它们之间存在某种关系，<strong>数据元素相互之间的关系称为结构</strong>(<strong>structure</strong>)。</p><p>数据结构是带结构的数据元素的集合。</p><blockquote><p>数据结构包括以下三个方面的内容：</p></blockquote><ol><li><p>数据元素之间的逻辑关系，也称为<strong>逻辑结构</strong>。</p></li><li><p>数据元素及其关系在计算机构中的表示（又称为映像），称为数据的<strong>物理结构</strong>或数据的<strong>存储结构</strong>。</p></li><li><p>数据的<strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</p></li></ol><blockquote><p>数据结构的两个层次：</p></blockquote><ul><li><p>逻辑结构</p><ul><li>描述描述数据元素之间的逻辑关系</li><li>与数据的存储无关，独立于计算机</li><li>是从具体问题抽象出来的数学模型</li></ul></li><li><p>物理结构(存储结构)</p><ul><li>数据元素及其关系在计算机存储器中的结构（存储方式）</li><li>是数据结构在许算机中的表示</li></ul></li><li><p>逻辑结构与存储结构的关系</p><ul><li>存储结构是逻辑关系的映象与元素本身的映象</li><li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li><li>两者综合起来建立了数据元素之间的结构关系。</li></ul></li></ul><blockquote><p>逻辑结构的种类</p></blockquote><ol><li><p>划分方法一</p><ol><li><p>线性结构：有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。例如：线性表、栈、队列、串。</p></li><li><p>非线性结构：一个结点可能有多个直接前趋和直接后继例如：树、图。</p></li></ol></li><li><p>划分方法二——四类基本逻辑结构</p><ol><li><p>集合结构：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。</p></li><li><p>线性结构：结构中的数据元素之间存在着一对一的线性关系。</p></li><li><p>树形结构：结构中的数据元素之间存在着一对多的层次关系。</p></li><li><p>图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。</p></li></ol></li></ol><blockquote><p>存储结构的种类</p></blockquote><p>四种基本的存储结构：顺序存储结构、链式存储结构、索引存储结构、散列存储结构。</p><ul><li><p>顺序存储结构</p><ul><li><p>用一组<strong>连续</strong>的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的<strong>存储位置</strong>来表示。</p></li><li><p>C语言中用数组来实现顺序存储结构</p></li></ul></li><li><p>链式存储结构</p><ul><li><p>用一组<strong>任意</strong>的存储单元存储数据元素，数据元素之间的逻辑关系用<strong>指针</strong>来表示。</p></li><li><p>C语言中用指针来实现链式存储结构</p></li><li><p>存储一个元素的同时，还存储了下一个元素的地址。</p></li></ul></li><li><p>索引存储结构</p><ul><li>在存储节点信息的同时，还建立附加的<strong>索引表</strong>。</li></ul></li><li><p>散列存储结构</p><ul><li>根据结点的关键字直接计算处该结点的存储地址。</li></ul></li></ul><h3 id="1-2-3-数据类型和抽象数据类型"><a href="#1-2-3-数据类型和抽象数据类型" class="headerlink" title="1.2.3 数据类型和抽象数据类型"></a>1.2.3 数据类型和抽象数据类型</h3><p>高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的<strong>取值范围</strong>，以及在这些数值范围上所允许进行的<strong>操作</strong>。</p><blockquote><p>数据类型(Data Type)</p></blockquote><p>数据类型是一组性质相同的<strong>值的集合</strong>以及定义于这个值集合上的<strong>一组操作</strong>的总称。</p><p>数据类型 &#x3D; 值的集合 + 值集合上的一组操作</p><blockquote><p>抽象数据类型(Abstract Data Type, ADT)</p></blockquote><p><strong>指一个数学模型以及定义在此数学模型上的一组操作。</strong></p><ul><li><p>由用户定义，从问题抽象出的<strong>数据模型</strong>（逻辑结构）</p></li><li><p>还包括定义在数据模型上的一组<strong>抽象运算</strong>（相关操作）</p></li><li><p>不考虑计算机内的具体存储结构与运算的具体实现算法</p></li></ul><blockquote><p>抽象数据类型的形式定义</p></blockquote><p>抽象数据类型可用(D, S, P)三元组表示：</p><ul><li><p>D是数据对象</p></li><li><p>S是D上的关系集</p></li><li><p>P是对D的基本操作</p></li></ul><blockquote><p>抽象数据类型(ADT)定义举例：Circle的定义</p></blockquote><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT抽象数据类型名&#123;<br>  Data<br>    数据对象的定义<br>    数据元素之间的逻辑关系定义<br>  Operation<br>    操作<span class="hljs-number">1</span><br>      初始条件<br>      操作结果描述<br>    操作<span class="hljs-number">2</span><br>      ......<br>    操作n<br>      ......<br>&#125;ADT 抽象数据类型名<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">ADT Circle&#123;<br>  数据对象：D=&#123;r, x, y|r, x, y均为实数&#125;<br>  数据关系：R=&#123;&lt;r, x, y&gt;|r是半径, &lt;x, y&gt;是圆心坐标&#125;<br>  基本操作：<br>    <span class="hljs-built_in">Circle</span>(&amp;C, r, x, y)<br>      操作结果：构造一个圆<br>    <span class="hljs-type">double</span> <span class="hljs-built_in">Area</span>(C)<br>      初始条件：圆已存在<br>      操作结果：计算面积<br>&#125;ADT Circle<br></code></pre></td></tr></table></figure><h2 id="1-3-抽象数据类型的表示与实现"><a href="#1-3-抽象数据类型的表示与实现" class="headerlink" title="1.3 抽象数据类型的表示与实现"></a>1.3 抽象数据类型的表示与实现</h2><p>C语言实现抽象数据类型：</p><ul><li><p>用已有数据类型定义描述它的存储结构</p></li><li><p>用函数定义描述它的操作</p></li></ul><blockquote><p>抽象数据类型如何实现</p></blockquote><ul><li><p>抽象数据类型可以通过固有的数据类型（如整型、实型、字符型）来表示和实现。</p><ul><li>即利用处理器中已存在的数据类型来说明新的结构，用已实现的操作来组合新的操作。</li></ul></li></ul><h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><blockquote><p>算法的定义</p></blockquote><p>算法：对特定问题<strong>求解方法和步骤</strong>的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。</p><blockquote><p>算法的描述</p></blockquote><ul><li><p>自然语言</p></li><li><p>流程图</p></li><li><p>伪代码、类语言</p></li><li><p>程序代码</p></li></ul><blockquote><p>算法与程序</p></blockquote><p>程序 &#x3D; 数据结构 + 算法</p><ul><li><p>数据结构通过算法实现操作</p></li><li><p>算法根据数据结构设计程序</p></li></ul><blockquote><p>算法特性</p></blockquote><ul><li><p>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</p></li><li><p>确定性：对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，使算法的执行者或阅读者都能明确其含义及如何执行。</p></li><li><p>可行性：算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。</p></li><li><p>输入：一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。</p></li><li><p>输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。</p></li></ul><blockquote><p>算法设计的要求</p></blockquote><ul><li><p>正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。</p></li><li><p>可读性。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。</p></li><li><p>健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。</p></li><li><p>高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。</p></li></ul><blockquote><p>算法效率</p></blockquote><ul><li><p>时间效率：指的是算法所耗费的时间；</p></li><li><p>空间效率：指的是算法执行过程中所耗费的存储空间。</p></li></ul><p>时间效率和空间效率有时候是矛盾的。</p><blockquote><p>算法事件效率的度量</p></blockquote><ul><li><p>算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。</p></li><li><p>两种度量方法</p><ul><li><p>事后统计</p></li><li><p>事前分析</p></li></ul></li></ul><blockquote><p>事前分析算法</p></blockquote><p>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的<strong>时间</strong>与算法中进行的简单操作<strong>次数乘积</strong>。</p><p>算法运行时间 &#x3D; 一个简单操作所需的时间x简单操作次数</p><blockquote><p>算法时间复杂度的渐进表示法</p></blockquote><p>若有某个辅助函数f(n)，使得n趋近于无穷大时，T(n)&#x2F;f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)&#x3D;O(f(n))，称O(f(n))为<strong>算法的渐进时间复杂度</strong>(O是数量级的符号)，简称<strong>时间复杂度</strong>。</p><blockquote><p>分析算法时间复杂度的基本方法</p></blockquote><ol><li><p>找出<strong>语句频度最大</strong>的那条语句作为<strong>基本语句</strong></p></li><li><p>计算<strong>基本语句</strong>的频度得到问题规模n的某个函数f(n)</p></li><li><p>取其数量级用符号“O”表示</p></li></ol><p>有的情况下，算法中基本操作重复执行的次数还随问题的<strong>输入数据集</strong>不同而不同。</p><blockquote><p>算法时间复杂度</p></blockquote><ul><li><p>最坏时间复杂度：指在最坏情况下，算法的时间复杂度。</p></li><li><p>平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p></li><li><p>最好时间复杂度：指在最好情况下，算法的时间复杂度。</p></li></ul><p>对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度。</p><blockquote><p>算法时间效率的比较</p></blockquote><ul><li><p>当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊</p></li><li><p>时间复杂度按数量级递增顺序为：</p><ul><li><p>常数阶-&gt;对数阶-&gt;线性阶-&gt;线性对数阶-&gt;平方阶-&gt;立方阶-&gt;…-&gt;K次方阶-&gt;指数阶</p></li><li><p>O(1)-&gt;O(logn)-&gt;O(n)-&gt;O(nlogn)-&gt;O(n^2)-&gt;O(n^3)-&gt;…-&gt;O(n^K)-&gt;O(2^n)</p></li></ul></li></ul><blockquote><p>渐进空间复杂度</p></blockquote><p>空间复杂度：算法所需要的存储空间的度量。</p><p>算法要占据的空间：</p><ul><li><p>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</p></li><li><p>算法要使用的辅助空间</p></li></ul><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><blockquote><p>设计好算法的过程</p></blockquote><p>抽象数据类型 &#x3D; 数据的逻辑结构 + 抽象运算</p>]]></content>
    
    
    <categories>
      
      <category>数据结构王卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDL设计方法简介</title>
    <link href="/2022/09/30/HDL%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/09/30/HDL%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="HDL-设计与验证流程"><a href="#HDL-设计与验证流程" class="headerlink" title="HDL 设计与验证流程"></a>HDL 设计与验证流程</h2><p>虚线框表示的步骤可以根据项目的复杂度省略，而实线框表示的步骤为必须执行的步骤</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209300912607.png"></p><h3 id="关键设计步骤与概念"><a href="#关键设计步骤与概念" class="headerlink" title="关键设计步骤与概念"></a>关键设计步骤与概念</h3><h4 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h4><ul><li>RTL级：寄存器传输级</li><li>EDA工具：电子辅助设计工具</li></ul><h4 id="系统与功能模块定义"><a href="#系统与功能模块定义" class="headerlink" title="系统与功能模块定义"></a>系统与功能模块定义</h4><p>大型系统的设计与实现，首先要进行详细的系统规划和描述，此时HDL描述侧重整体系统的划分和实现对系统级的仿真侧重于对整个系统的功能和性能指标的考量。功能模块级设计时将系统整体功能划分为可实现的具体功能模块，大致确定模块间的接口，如时钟、读写信号、数据流、控制信号等。在有些情况下，还要根据系统要求，描述每个模块或进程的时序约束。另外在此层次，必须权衡整个系统多种的实现方式的优劣，选出系统性能指标优并且可以高效实现的设计方案</p><h4 id="行为级描述测试激励"><a href="#行为级描述测试激励" class="headerlink" title="行为级描述测试激励"></a>行为级描述测试激励</h4><p>最大特点是必须明确每个模块间的所有接口和边界。此时模块内部的功能已经明确，模块间的所有接口，顶层的输入、输出信号等在行为级已经被清晰地描述出来。</p><h4 id="寄存器传输级"><a href="#寄存器传输级" class="headerlink" title="寄存器传输级"></a>寄存器传输级</h4><p>寄存器传输级指不关注寄存器和组合逻辑的细节，通过描述寄存器到寄存器之间的逻辑功能描述电路的HDL层次。RTL级是比门级更高的抽象层次，一般使用RTL级语言描述硬件电路比门级描述电路简单、高效。寄存器传输级的最大特点是可以直接用综合工具综合为门级网表。RTL设计直接决定着设计的功能和效率</p><h4 id="对RTL级描述进行功能仿真"><a href="#对RTL级描述进行功能仿真" class="headerlink" title="对RTL级描述进行功能仿真"></a>对RTL级描述进行功能仿真</h4><p>一般来说需要对RTL级设计进行功能仿真，仿真的目的为验证RTL级描述是否与设计意图一致。</p><h4 id="逻辑综合（使用RTL级EDA工具）"><a href="#逻辑综合（使用RTL级EDA工具）" class="headerlink" title="逻辑综合（使用RTL级EDA工具）"></a>逻辑综合（使用RTL级EDA工具）</h4><p>RTL级综合指将RTL级HDL语言翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件。最重要的代码设计层次就是RTL级</p><h4 id="门级"><a href="#门级" class="headerlink" title="门级"></a>门级</h4><p>门级描述的特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述了设计的引脚、功能、时钟周期等所有信息。目前直接使用门级描述较少，直接使用门级描述的场合一般是ASIC和FPGA设计中某些面积或时序要求较高的模块</p><h4 id="综合后门级仿真"><a href="#综合后门级仿真" class="headerlink" title="综合后门级仿真"></a>综合后门级仿真</h4><p>综合完成后，如果需要检查综合结果是否与原设计一致，就需要做综合后仿真。<br>在仿真时，把综合生产的标准延时文件反标注到综合仿真模型中去，可估计门延时带来的影响。<br>综合仿真虽然比功能仿真精确一些，但是只能估计门延时，不能估计线延时，仿真结果与布线后的实际情况还有一定的差距，并不十分准确<br>这种仿真的主要目的在于检查综合器的综合结果是否与设计输入一致，如果设计者确信自己表述明确，没有综合歧义发生，则可以省略这一步</p><h4 id="布局规划与布局布线"><a href="#布局规划与布局布线" class="headerlink" title="布局规划与布局布线"></a>布局规划与布局布线</h4><p>综合的门级结果最终要映射到目标库或目标器件</p><h4 id="布局布线后时序仿真与验证"><a href="#布局布线后时序仿真与验证" class="headerlink" title="布局布线后时序仿真与验证"></a>布局布线后时序仿真与验证</h4><p>将最终的布局规划或者布局布线的时延信息反标注到设计网表中，所进行的仿真就叫时序仿真或布局规划与布局布线后仿真，<strong>简称后仿真</strong><br>时序仿真包含的信息最全，所以最准确，能较好反映芯片的实际工作情况<br>一般来说建议进行此步骤，检查设计时序与芯片的实际运行情况是否一致<br>时序仿真主要目的在于发现时序违规</p>]]></content>
    
    
    <categories>
      
      <category>Verilog HDL实用精解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章-常用半导体器件</title>
    <link href="/2022/09/13/%E6%A8%A1%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%B8%B8%E7%94%A8%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6/"/>
    <url>/2022/09/13/%E6%A8%A1%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%B8%B8%E7%94%A8%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1半导体基础知识"><a href="#1-1半导体基础知识" class="headerlink" title="1.1半导体基础知识"></a>1.1半导体基础知识</h1><h2 id="本征半导体"><a href="#本征半导体" class="headerlink" title="本征半导体"></a>本征半导体</h2><ul><li>半导体<ul><li>概念：导电能力介于导体与绝缘体之间</li><li>本征半导体：纯净的、具有晶体结构的半导体</li></ul></li><li>本征半导体的晶体结构<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131118308.png"></li></ul></li><li>载流子<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131122995.png"></li><li>运载电荷的粒子称为载流子，导体导电只有一种载流子，即自由电子导电</li><li>而本征半导体有两种载流子，即自由电子和空穴均参与导电，这是半导体导电的特殊性质<ul><li>自由电子</li><li>空穴，注意空穴的移动是相对的，是由于价电子按一定方向填补空穴，导致空穴相对移动</li></ul></li><li>本征激发：半导体在<strong>热激发</strong>下产生<strong>自由电子</strong>和<strong>空穴对</strong>的现象称为本征激发<ul><li>速度与温度有关，温度越高，本征激发越快</li></ul></li><li>复合：<strong>自由电子</strong>在运动过程中如果<strong>与空穴相遇</strong>就会<strong>填补空穴</strong>，<strong>使两者同时消失</strong>，这种现象称为复合，这是与本征激发相反的一个运动<ul><li>与载流子浓度有关</li></ul></li></ul></li><li>载流子的浓度（导电性能与什么有关？？–载流子的浓度）<ul><li><strong>温度升高</strong>时，<strong>本征激发速度加快</strong>，<strong>载流电子变多</strong>，载流子浓度升高，<strong>复合加快</strong>，最后达到一个动态平衡，<strong>本征激发的速度与复合的速度相等</strong></li><li>但是加热并不是一个很好的提高导电性能的方法，加热到70度以上，材料本身就不行了，那么用什么办法来提高导电性能呢？？–杂质半导体</li></ul></li></ul><h2 id="杂质半导体"><a href="#杂质半导体" class="headerlink" title="杂质半导体"></a>杂质半导体</h2><ul><li>杂质半导体<ul><li>概念：在本征半导体中<strong>掺入少量合适的杂质元素</strong>。按掺入的杂质元素不同，可形成N型半导体和P型半导体，控制掺入杂质元素的浓度，就可以控制杂质半导体的导电性能</li><li><strong>N型半导体</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131204033.png"></li><li><strong>掺入少量五价元素磷</strong></li><li>五价磷进入，代替硅原子，四个电子形成共价对，还有一个电子很容易就出来，变成自由电子，这就使得半导体内自由电子大大增加</li><li><strong>多数载流子（多子</strong>）：N型半导体中自由电子的浓度大于空穴的浓度，故称自由电子为多子</li><li><strong>少数载流子（少子）</strong>：空穴，空穴少</li><li>导电主要靠自由电子，电子带负电，而<strong>N型半导体的N就代表negative，代表电子是多子</strong>（<strong>注意即使这样，半导体还是不带电，因为失去电子的磷离子带正电，正好和磷原子产生的自由电子数目一样，互相抵消</strong>）</li><li>此时温度因素对自由电子影响就很小了，温度升高而产生出的自由电子太少了，但是对少子影响很大</li><li><strong>N型半导体主要靠自由电子导电</strong>，掺入的杂质越多，多子（自由电子）的浓度就越高，导电性能也就越强</li><li>磷原子可提供电子，因此被称为<strong>施主原子</strong></li></ul></li><li>P型半导体<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131406422.png"></li><li>在纯净硅晶体中掺入少量三价杂质原子，比如硼</li><li><strong>P代表Positive，表示多子是带正电的空穴</strong></li><li>硼原子最外层有三个价电子，当它们与周围的硅原子形成共价键时，就产生了一个“空位”，空位为电中性，当硅原子的外层电子填补此空位时，其共价键中便产生一个空穴，而杂质原子成为不可移动的负离子</li><li>P型半导体，空穴为多子，自由电子为少子，主要靠空穴导电，掺入杂质越多，空穴的浓度就越高，使得导电性能越强</li><li>因为杂质原子中的空位吸收电子，故被称之为<strong>受主原子</strong></li></ul></li><li>由以上分析可知，由于掺入的杂质使多子的数目大大增加，从而使多子与少子复合的机会大大增多。因此，对于杂质半导体，多子的浓度越高，少子的浓度就越低。<strong>可以认为，多子的浓度约等于所掺杂质原子的浓度，因而它受温度的影响很小，而少子是本征激发形成的，所以尽管其浓度很低，却对温度非常敏感，这将影响半导体器件的性能</strong></li></ul></li></ul><h2 id="PN结的形成"><a href="#PN结的形成" class="headerlink" title="PN结的形成"></a>PN结的形成</h2><ul><li><p>采用不同的掺杂工艺，将P型半导体与N型半导体制作在同一块硅片上，在它们的交界面就形成PN结。PN结具有单向导电性</p></li><li><p>PN结的形成</p><ul><li><strong>扩散运动</strong>：物质总是从浓度高的地方向浓度低的地方运动，这种由于浓度差而产生的运动称为扩散运动。<strong>针对多子</strong><ul><li>P型半导体和N型半导体制作在一起时，在它们的交界面，两种载流子的浓度差很大，因而P区的空穴必然向N区扩散，与此同时，N区的自由电子也必然向P区扩散。<strong>扩散到P区的自由电子与空穴复合</strong>（这导致了负离子的出现），而<strong>扩散到N区的空穴与自由电子复合</strong>（这导致了正离子的出现），所以交界面附近多子的浓度下降，<strong>P区出现负离子区</strong>，<strong>N区出现正离子区</strong>，它们是不能移动的，称为空间电荷区，从而形成内电场。随着扩散运动的进行，空间电荷区加宽，内电场增强，其方向由N区指向P区，正好阻止扩散运动的进行。</li></ul></li><li><img src="C:\Users\86152\AppData\Roaming\Typora\typora-user-images\image-20230705223441129.png" alt="image-20230705223441129"></li><li>空间电荷区：可称为耗尽层，阻挡层，PN结 。称为耗尽层的原因是：绝大部分空间电荷区内自由电子和空穴部都非常少，在分析PN结特性时常忽略载流子的作用，而只考虑离子区的电荷，这种方法称为“耗尽层近似”，故称空间电荷区为耗尽层</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307111630885.png" alt="image-20230711163031826"></li><li><strong>漂移运动</strong>：载流子在电场力的作用下的运动。在PN结中，<strong>漂移运动是针对少子来说的</strong>。内电场作用下，少子产生漂移运动，空穴从N区向P区运动，而自由电子从P区向N区运动。</li><li>在无外电场和其他激发作用下，参与扩散运动的多子数目等于参与漂移运动的少子数目，从而达到动态平衡，形成PN结。</li><li>对称结、不对称结：不对称结指两边掺杂浓度不一样，浓度高的地方空间电荷区（离子区）窄，浓度低的地方空间电荷区宽。<strong>两种结的外部特性是相同的。</strong></li></ul></li></ul><h2 id="PN结的单向导电性"><a href="#PN结的单向导电性" class="headerlink" title="PN结的单向导电性"></a>PN结的单向导电性</h2><ul><li>把PN结的两端外加正向电压<ul><li>PN结外加正向电压时处于导通状态。当<strong>电源正极接到PN结的P端</strong>，且<strong>电源的负极接到PN结的N端时</strong>，称<strong>PN结外加正向电压</strong>，也称正向接法或正向偏置</li><li>此时<strong>外电场将多数载流子推向空间电荷区</strong>，使其变窄，<strong>削弱了内电场</strong>，破坏了原来的平衡，使<strong>扩散运动加剧</strong>，<strong>漂移运动减弱</strong>。由于电源的作用，扩散运动将源源不断地进行，从而形成正向电流，PN结导通</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141201475.png"></li><li><strong>外电场削弱内电场</strong>，随着内电场慢慢被削弱，<strong>电流猛猛增长</strong>，所以要对电流加一个限制，于是电路中有一个限流电阻R，使得电路中电流最大也不会超过U&#x2F;R</li></ul></li><li>PN结外加反向电压，此时<strong>外电场使空间电荷区变宽</strong>，<strong>加强了内电场</strong>，<strong>阻止扩散运动的进行</strong>，而<strong>加剧漂移运动的进行</strong>，形成反向电流，也称为漂移电流。因为<strong>少子的数目极少</strong>，即使<strong>所有少子都参与漂移运动</strong>，<strong>反向电流也非常小</strong>，所以在近似分析中常将它忽略不计，认为PN结外加反向电压时处于<strong>截止状态</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141208161.png"></li><li>PN结越来越厚，阻碍作用越来越强，最后截止</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141430450.png"></li></ul><h2 id="PN结的电流方程"><a href="#PN结的电流方程" class="headerlink" title="PN结的电流方程"></a>PN结的电流方程</h2><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209141431775.png"></li><li>锗管0.2V-0.3V     硅管0.6-0.7V</li></ul><h2 id="PN结的伏安特性"><a href="#PN结的伏安特性" class="headerlink" title="PN结的伏安特性"></a>PN结的伏安特性</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307111728836.png" alt="image-20230711172825783"></p><ul><li>正向特性（u&gt;0）<ul><li>i随u按指数规律变化</li><li>死区</li></ul></li><li>反向特性(u&lt;0)</li><li>反向击穿:当反向电压超过一定数值后，反向电流急剧增加，称之为反向击穿。<ul><li><strong>雪崩击穿</strong>（掺杂浓度低）：掺杂浓度低，耗尽层宽度较宽，当反向电压增加到较大数值时，耗尽的电场使少子加快漂移速度，从而与共价键的价电子相碰撞，把价电子撞出共价键，产生电子-空穴对。新产生的电子与空穴被电场加速后又撞出其它价电子，载流子雪崩式倍增，致使电流急剧增加。温度越高，需要的击穿电压越高</li><li><strong>齐纳击穿</strong>（掺杂浓度高）：掺杂浓度高，耗尽层宽度很窄，不大的反向电压，就可在耗尽层形成很强的电场，而直接破坏共价键，使价电子脱离共价键束缚，产生电子-空穴对，致使电流急剧增大。温度越高，需要的击穿电压越低</li><li><strong>反向击穿，PN结不一定就坏了，反向击穿电压可以通过掺杂浓度控制。如果能控制其不过热，那么它还可以从通过降低反向电压将击穿状态逆回去，但是一旦过热发生二次击穿，那PN结就彻底坏了</strong></li><li>PN结的伏安图中，U（BR）这个地方，<strong>电流变化极大，而电压基本不变</strong>，利用这一特性可以做出<strong>稳压二极管</strong>。</li></ul></li></ul><h2 id="PN结的电容效应"><a href="#PN结的电容效应" class="headerlink" title="PN结的电容效应"></a>PN结的电容效应</h2><p>在一定条件，PN结具有电容效应</p><ul><li><p><strong>势垒电容</strong>：可以做可变电容</p><ul><li>当PN结的外加电压变化时，空间电荷区的宽度将随之变化，即耗尽层的电荷量随外加电压而增大或减小，这种现象<strong>与电容器的充放电过程相同</strong>。</li><li><strong>耗尽层宽窄变化所等效的电容</strong>称为势垒电容$C_b$</li><li>$C_b$具有非线性，它与结面积、耗尽层宽度、半导体的介电常数及外加电压有关</li><li>利用PN结加反向电压时$C_b$随u变化的特性，可以制成各种变容二极管</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307120917594.png" alt="image-20230712091655414"></li></ul></li><li><p><strong>扩散电容</strong>：非平衡少子和电压之间的关系 </p><ul><li><strong>平衡少子</strong>：PN结处于平衡状态时的少子常称为平衡少子。</li><li><strong>非平衡少子</strong>：PN结处于正向偏置时，从P区扩散到N区的空穴和N区扩散到P区的自由电子均称为非平衡少子</li><li>当外加正向电压一定时，<strong>靠近耗尽层交界面的地方非平衡少子的浓度高</strong>，而远离交界面的地方浓度低，<strong>且浓度自高到底逐渐衰减，直到零。</strong>形成一定的浓度梯度（即浓度差），从而形成扩散电流。</li><li>当<strong>外加正向电压增大</strong>时，<strong>非平衡少子的浓度增大</strong>且<strong>浓度梯度也增大</strong>，从外部看<strong>正向电流（即扩散电流）增大</strong>；外加正向电压减少时，则相反</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307120930230.png" alt="image-20230712093015174"></li><li>上图是不同正向电压下P去少子浓度的分布情况</li><li>各个曲线与$n_P &#x3D; n_{P0}$所对应的水平线之间的面积代表了非平衡少子在扩散区域的数目</li><li>当外加电压增大时，曲线由①变为②，非平衡少子数目增多；当外加电压减小时，曲线由①变为③，非平衡少子数目减少</li><li>扩散区内，电荷的积累与释放过程与电容器充放电过程相同，这种电容效应就称为扩散电容$C_d$</li><li>与$C_b$一样，$C_d$也具有非线性，它与流过PN结的正向电流i、温度的电压当量$U_T$以及非平衡少子的寿命$\gamma$有关。i越大，$\gamma$越大，$U_T$越小，$C_d$就越大</li></ul></li></ul><p>由此可见PN结的结电容$C_j$是$C_b$与$C_d$之和，即$$C_j &#x3D; C_b + C_d$$</p><p>由于$C_b$与$C_d$一般都很小（结面积小的为1pF左右，结面积大的为几十至几百皮法），对于低频信号程序很大的容抗，其作用可以忽略不计，因而只有在信号频率较高时才考虑结电容的作用</p><blockquote><p>什么是电压当量</p></blockquote><ul><li><p>电压当量是指在电路中，具有相同电流和功率特性的电源或电路元件之间可以相互替代的概念。换句话说，电压当量是指在给定电路中，不同电源或元件的电压可以被视为相等的情况。</p></li><li><p>电压当量的概念是基于基尔霍夫电压定律（KVL）和欧姆定律（Ohm’s Law）。根据基尔霍夫电压定律，沿着闭合电路的任意路径，电压的代数和为零。根据欧姆定律，电流与电压之间存在线性关系。</p></li><li><p>考虑一个简单的电路，由两个并联的电阻组成，连接到一个电源。如果两个电阻具有相同的电阻值，那么它们之间的电压分配也是相同的。这意味着两个电阻可以被视为电压当量，因为它们在电路中具有相同的电压特性。</p></li><li><p>电压当量的概念对于电路分析和设计非常有用。通过将电路元件或电源替换为其电压当量，可以简化电路分析，并且在设计中可以选择不同的元件或电源进行替代，以满足特定的需求。</p></li></ul><h1 id="1-2半导体二极管"><a href="#1-2半导体二极管" class="headerlink" title="1.2半导体二极管"></a>1.2半导体二极管</h1><ul><li>将PN结用外壳封装起来，并加上电极引线就构成了半导体二极管，简称二极管。</li><li>由P区引出的电极为阳极，由N区引出的电极为阴极</li><li>常见的外形如下图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307120956962.png" alt="image-20230712095650910"></p><h2 id="半导体二级管的几种常见结构"><a href="#半导体二级管的几种常见结构" class="headerlink" title="半导体二级管的几种常见结构"></a>半导体二级管的几种常见结构</h2><p><strong>知识补充</strong></p><blockquote><p>什么是整流</p></blockquote><ul><li><p>整流是指将交流电转换为直流电的过程。交流电是周期性变化的电流，其方向在正负值之间来回变换。而直流电是电流方向恒定的电流。整流的目的是将交流电中的负半周（负电流）或正半周（正电流）转换为单一方向的直流电流。</p></li><li><p>整流通常通过使用二极管或整流器件来实现。二极管是一种电子元件，具有只允许电流在一个方向上通过的特性。在半波整流中，只有正半周的电流通过，负半周的电流被阻塞。而在全波整流中，通过使用桥式整流器等设备，可以将正负半周的电流都转换为正向的直流电流。</p></li><li><p>整流在电力转换、电子设备以及电力供应等领域中非常重要。直流电在许多电子设备和系统中是必需的，例如电脑、手机充电器、电子器件等。通过整流，交流电可以被有效地转换为适合这些设备使用的直流电。</p></li><li><p>二极管的几种常见结构(a~c)</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191116543.png"></li><li><strong>a是点接触型</strong>，由一根金属丝经过特殊工艺与半导体表面相接形成PN结。因而结面积小，不能通过较大的电流。但其结电容较小，一般在1pF以下，工作频率可达100MHz以上，因此<strong>适用于高频电路和小功率整流</strong></li><li>b是面接触型，采用合金法工艺制成，结面积大，能够流过较大的电流，但其结电容大，因而只能在较低频率下工作，一般仅作为整流管</li><li>c是平面型，采用扩散法制成的。结面积较大的可用于大功率整流，结面积小的可作为脉冲数字电路中的开关管</li></ul></li></ul><h2 id="伏安特性"><a href="#伏安特性" class="headerlink" title="伏安特性"></a>伏安特性</h2><p><strong>知识补充</strong></p><blockquote><p>什么是压降</p></blockquote><ul><li><p>压降是指电路中电压在通过电阻、导线或其他元件时的降低量。当电流通过一个电阻或导线时，由于其电阻性质，会导致电压降低。这种电压降低被称为压降。</p></li><li><p>根据欧姆定律，电压和电流之间存在线性关系，即 V &#x3D; I * R，其中 V 表示电压，I 表示电流，R 表示电阻。当电流通过电阻或导线时，根据欧姆定律，电压将按照电流和电阻的乘积进行降低。</p></li><li><p>压降在电路中是普遍存在的，特别是在长导线、电阻、电路连接器和其他电路元件中。这是由于这些元件的电阻性质引起的。在大多数情况下，电压降低是不可避免的，而且在一些特定的应用中，精确地控制和减小电压降低是非常重要的。</p></li><li><p>在电路设计和分析中，了解和考虑压降是必要的。通过计算和预测电路中的压降，可以评估元件的性能，确保电路的稳定工作，并避免潜在的问题。此外，对于长距离输电或高电流应用，需要特别关注电压降低，以确保电路中的电压不会降低到不可接受的水平。</p></li></ul><blockquote><p>什么是二极管的漏电流</p></blockquote><ul><li><p>二极管的漏电流是指在正向偏置或反向偏置时，未被阻止而通过二极管的电流。二极管在正向偏置时，允许电流流过，而在反向偏置时，应该阻止电流通过。然而，实际上，即使在反向偏置时，仍然存在一小部分电流通过二极管，这就是漏电流。</p></li><li><p>漏电流的大小取决于二极管的类型、制造质量和工作温度等因素。在正常工作条件下，漏电流通常很小，一般以纳安（nA）或皮安（pA）为单位。但在某些特殊情况下，例如高温、高电压或受损的二极管，漏电流可能会增加。</p></li><li><p>对于大多数应用而言，漏电流的影响可以忽略不计。但在某些特殊应用中，例如低功耗电路、高精度测量和高阻抗电路，漏电流可能会对电路性能产生影响。因此，在设计和选择二极管时，需要考虑漏电流的值，并根据特定应用的需求进行适当的选择。</p></li><li><p>值得注意的是，正常工作条件下，二极管的漏电流应该是非常小的。如果漏电流显著增加或超出了二极管规格，那可能表示二极管存在问题，如损坏或老化，可能需要进行更换。</p></li><li><p>与PN结一样，<strong>二极管具有单向导电性</strong>。但是，由于<strong>二极管存在半导体体电阻和引线电阻</strong>，所以当<strong>外加正向电压</strong>时，在<strong>电流相同的情况下</strong>，<strong>二极管的端电压大于PN结上的压降</strong>；或者说，在<strong>外加正向电压相同的情况下</strong>，<strong>二极管的正向电流要小于PN结的电流</strong>；在大电流情况下，这种影响更加明显。</p></li><li><p>另外，由于<strong>二极管表面漏电流</strong>存在，使<strong>外加反向电压时的反向电流增大。</strong></p></li><li><p>伏安特性曲线</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191123558.png"></li><li>实测二极管的伏安特性时发现，只有在正向电压足够大时，正向电流才从零随端电压按指数规律增大。使二极管开始导通的临界电压称为开启电压$U_{on}$</li><li>当二极管所加反向电压的数值足够大时，反向电流为$I_S$</li><li>反向电压太大将使二极管击穿</li></ul></li><li><p>与PN结的区别</p><ul><li>由于体电阻的存在，相同电压下，电流比PN结小</li><li>反向电流大一些</li></ul></li><li><p>温度的影响</p><ul><li><p>温度升高，二极管的正向特性曲线左移，反向特性曲线下移（图中虚线）</p></li><li><p>在室温的情况下，每升高1摄氏度，正向电压降2-2.5毫伏，每升高10摄氏度，反向电流增大一倍 </p></li><li><p>可见，二极管特性对温度很敏感，可做温度传感器</p></li></ul></li></ul><h2 id="二极管的主要参数"><a href="#二极管的主要参数" class="headerlink" title="二极管的主要参数"></a>二极管的主要参数</h2><h3 id="最大整流电流-I-F"><a href="#最大整流电流-I-F" class="headerlink" title="最大整流电流$I_F$"></a>最大整流电流$I_F$</h3><ul><li>$I_F$正向导通电流，应该要比工作要求大一些</li><li>$I_F$是二极管长期运行时允许通过的最大正向平均电缆，其值与PN结面积及外部散热条件等有关。在规定散热条件下，二极管正向平均电流若超过此值，则将因结温升（上升的温度）过高而烧坏</li></ul><h3 id="最高反向工作电压-U-R"><a href="#最高反向工作电压-U-R" class="headerlink" title="最高反向工作电压$U_R$"></a>最高反向工作电压$U_R$</h3><ul><li><p>$U_R$最高反向工作电压，一般为$U_{BR}$的百分之五十</p></li><li><p>超过$U_R$，二极管可能因反向击穿而损坏</p></li></ul><h3 id="反向电流-I-R"><a href="#反向电流-I-R" class="headerlink" title="反向电流$I_R$"></a>反向电流$I_R$</h3><ul><li>$I_R$是二极管未击穿时的反向电流，越小反向截止特性越好（导电性越好）</li><li>$I_R$对温度非常敏感</li></ul><h3 id="最高工作频率-f-M"><a href="#最高工作频率-f-M" class="headerlink" title="最高工作频率$f_M$"></a>最高工作频率$f_M$</h3><ul><li>$f_M$最高工作频率，超过此值，二极管的单向导电性会被破坏，电流会在二极管里面的电容出现。</li></ul><h2 id="二极管的等效电路"><a href="#二极管的等效电路" class="headerlink" title="二极管的等效电路"></a>二极管的等效电路</h2><p>二极管的伏安特性是非线性的，为了便于分析，在一定条件下，用线性元件构成的电路来近似模拟二极管的特性，并用之取代电路中的二极管。能够模拟二极管特性的电路称为二极管的<strong>等效电路（等效模型）</strong></p><h3 id="用伏安特性折线化得到的等效电路"><a href="#用伏安特性折线化得到的等效电路" class="headerlink" title="用伏安特性折线化得到的等效电路"></a>用伏安特性折线化得到的等效电路</h3><p><strong>图中粗直线为折线化的伏安特性，虚线表示实际伏安特性，下边为等效电路</strong></p><ul><li>（均为直流情况下）左为理想二极管，中为理想二级管加电源，正向导通时端电压为常量，右为理想二极管加电源和电阻，正向导通时端电压与电流成线性关系</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209241238831.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261036042.png"></li></ul><h3 id="二极管的微变等效电路（听下课）"><a href="#二极管的微变等效电路（听下课）" class="headerlink" title="二极管的微变等效电路（听下课）"></a>二极管的微变等效电路（听下课）</h3><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261052851.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261053878.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261053039.png"><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261054083.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261146863.png"></li></ul><h2 id="稳压二极管"><a href="#稳压二极管" class="headerlink" title="稳压二极管"></a>稳压二极管</h2><ul><li>稳压二极管是一种硅材料制成的面接触型晶体二极管，简称稳压管</li><li>稳压管在反向击穿时，在一定的电流范围内（或者说在一定的功率损耗范围内），端电压几乎不变，表现出稳压特性。因而广泛用于稳压电源与限幅电路之中</li></ul><h3 id="稳压管的伏安特性"><a href="#稳压管的伏安特性" class="headerlink" title="稳压管的伏安特性"></a>稳压管的伏安特性</h3><ul><li>与普通二极管类似，正向特性为指数曲线。当稳压管外加反向电压的数值大到一定程度时则击穿，击穿区的曲线很陡，几乎平行于纵轴，表现其具有稳压特性。</li><li>只要控制反向电流不超过一定值，管子就不会因过热而损坏</li><li>在图（b）的等效电路中，二极管$D_1$表示稳压管加正向电压与虽加反向电压但未击穿时的情况。理想二极管、电压源$U_Z$和电阻$r_d$的串联支路表示稳压管反向击穿时的等效电路</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307121452315.png" alt="image-20230712145230224"></li></ul><h3 id="稳压管的主要参数"><a href="#稳压管的主要参数" class="headerlink" title="稳压管的主要参数"></a>稳压管的主要参数</h3><ul><li>**稳定电压$U_Z$**：$U_Z$是在规定电流下稳压管的反向击穿电压。</li><li>**稳定电流$I_Z$**：$I_Z$是稳压管工作在稳压状态时的参考电流，电流低于此值时稳压效果变坏，甚至根本不稳压，故也常将$I_Z$基座$I_{Zmin}$</li><li>**额定功耗$P_{ZM}$<strong>：$P_{ZM}$等于稳压管的稳定电压$U_Z$与</strong>最大稳定电流$I_{ZM}$**（或记作$I_{Zmax}$）的乘积。稳压管的功耗超过此值时，会因结温升过高而损坏。只要不超过稳压管的额定功率，电流越大，稳压效果越好</li><li>**动态电阻$r_z$**：$r_z$是稳压管工作在稳压区时，端电压变化量与其电流变化量之比，即$r_{\mathrm{z}}&#x3D;\Delta U_{\mathrm{Z}} &#x2F; \Delta I_{\mathrm{Z}}$。$r_z$越小，电流变化时$U_Z$的变化越小，即稳压管的稳压特性越好。</li><li>**温度系数$\alpha$**：$\alpha$表示温度每变化1摄氏度，稳压值的变化量，即$\alpha&#x3D;\Delta U_{\mathrm{Z}} &#x2F; \Delta T$。稳定电压小于4V的管子具有负温度系数（属于齐纳击穿），即温度升高时稳定电压值下降；稳定电压大于7V的管子具有正温度系数（属于雪崩击穿），即温度升高时稳定电压值上升；而稳定电压在4~7V之间的管子，温度系数非常小，近似为零（齐纳击穿和雪崩击穿均有）</li></ul><p>由于稳压管的反向电流小于$I_{Zmin}$时不稳压，大于$I_{Zmax}$时会因超过额定功耗而损坏，所以在稳压管电路中必须串联一个电阻来限制电流，从而保证稳压管正常工作，故称这个电阻为限流电阻。</p><h2 id="其他类型二极管"><a href="#其他类型二极管" class="headerlink" title="其他类型二极管"></a>其他类型二极管</h2><h3 id="发光二极管"><a href="#发光二极管" class="headerlink" title="发光二极管"></a>发光二极管</h3><ul><li>发光二极管包括可见光、不可见光、激光等不同类型，这里只对可见光发光二极管做一简单介绍。发光二极管的发光颜色决定于所用材料。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307121530866.png" alt="image-20230712153001794"></p><ul><li>发光二极管也具有单向导电性。只有当<strong>外加的正向电压使得正向电流足够大时才发光</strong>，它的<strong>开启电压比普通二极管的大</strong>，红色的在1.6~1.8V之间，绿色的约为2V。正向电流越大，发光越强，使用时，应特别注意<strong>不要超过最大功耗、最大正向电流和反向击穿电压等极限参数</strong></li><li>发光二极管因其驱动电压低、功耗小、寿命长、可靠性高等优点广泛用于显示电路中</li></ul><h3 id="光电二极管"><a href="#光电二极管" class="headerlink" title="光电二极管"></a>光电二极管</h3><ul><li>光电二极管是<strong>远红外线接收管</strong>，是一种<strong>光能与电能进行转换</strong>的器件。PN结光电二极管充分利用<strong>PN结的光敏特性</strong>，将接收到的光变化转换成电流的变化。它的几种常见外形如图（a），符号见图（b）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307121539676.png" alt="image-20230712153907609"></p><p>下图（a）所示为光电二极管的伏安特性。无光照时，与普通二极管一样，具有单向导电性。外加正向电压时，电流与端电压成指数关系，见特性曲线的第一象限；外加反向电压时，反向电流称为暗电流，通常小于0.2微安</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202307121545637.png" alt="image-20230712154517567"></p><p>当有<strong>光照</strong>时，<strong>特性曲线下移</strong>，它们分布在第三、四象限内。在反向电压的一定范围内，即在第三象限，特性曲线是一组横轴的平行线。光电二极管在反压下受到光照而产生的电流称为光电流，<strong>光电流受入射照度的控制</strong>。照度一定时，光电二极管可等效成恒流源。照度越大，光电流越大，在光电流大于几十微安时，与照度成线性关系。这种特性可广泛用于<strong>遥控、报警及光电传感器</strong>中。</p><p>特性曲线在第四象限时呈光电池特性</p><p>图（b）、（c）、（d）分别是光电二极管在特性曲线的第一、三、四象限时的原理电路。</p><p>图（b）所示电路与普通二极管加正向电压的情况相同。</p><p>图（c）中的电流仅决定于光电二极管受光面的入射照度，电阻R将电流的变化转换成电压的变化，$u_R&#x3D;iR$</p><p>图（d）中，当R一定时，入射照度越大，i越大，R上获得的能力也越大，此时光电二极管作为微型光电池</p><p>由于光电二极管的光电流较小，所以当将其用于测量及控制等电路中时，需首先进行<strong>放大和处理</strong></p><p>除上述特殊二极管外，还有<strong>利用PN结势垒电容制成的变容二极管</strong>，可用于<strong>电子调谐</strong>、<strong>频率的自动控制</strong>、<strong>调频调幅</strong>、<strong>调相和滤波</strong>等电路中；利用<strong>高掺杂材料形成PN结的隧道效应制成的隧道二极管</strong>，可用于<strong>振荡</strong>、<strong>过载保护</strong>、<strong>脉冲数字电路</strong>中；利用<strong>金属与半导体之间的接触势垒而制成的肖特基二极管</strong>，因其正向导通电压小、结电容小而用于<strong>微波混频</strong>、<strong>检测</strong>，<strong>集成化数字电路</strong>等场合</p><h2 id="晶体三极管"><a href="#晶体三极管" class="headerlink" title="晶体三极管"></a>晶体三极管</h2>]]></content>
    
    
    <categories>
      
      <category>龙芯</category>
      
      <category>模拟电子技术基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正逻辑和负逻辑</title>
    <link href="/2022/09/12/%E6%AD%A3%E9%80%BB%E8%BE%91%E5%92%8C%E8%B4%9F%E9%80%BB%E8%BE%91/"/>
    <url>/2022/09/12/%E6%AD%A3%E9%80%BB%E8%BE%91%E5%92%8C%E8%B4%9F%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单逻辑门电路</title>
    <link href="/2022/09/12/%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/"/>
    <url>/2022/09/12/%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E9%97%A8%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191032272.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191034597.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191036993.png"></p><h2 id="二极管与门电路"><a href="#二极管与门电路" class="headerlink" title="二极管与门电路"></a>二极管与门电路</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191410568.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191412395.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191412148.png"></p><h2 id="二极管或门电路"><a href="#二极管或门电路" class="headerlink" title="二极管或门电路"></a>二极管或门电路</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418343.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418004.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191418583.png"></p><h2 id="非门电路-反相器"><a href="#非门电路-反相器" class="headerlink" title="非门电路-反相器"></a>非门电路-反相器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191419553.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191419536.png"><br>椭圆处相当于断开</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191420754.png"><br>三极管导通，接地</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半导体器件的开关特性</title>
    <link href="/2022/09/12/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7/"/>
    <url>/2022/09/12/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%99%A8%E4%BB%B6%E7%9A%84%E5%BC%80%E5%85%B3%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="半导体器件的开关特性"><a href="#半导体器件的开关特性" class="headerlink" title="半导体器件的开关特性"></a>半导体器件的开关特性</h1><ul><li><p>半导体</p><ul><li>常温下导电性能介于导体和绝缘体之间的材料</li><li>特性：半导体是一种导电性可受控制，范围可从绝缘体至导体之间的材料</li><li>常见的半导体材料：硅、砷化镓、锗</li><li>常见半导体元件：晶体二极管、晶体三极管</li></ul></li><li><p>半导体器件的开关特性</p><ul><li>以开关方式运用 </li><li>运用在开关频率十分高的电路中</li><li>静态特性<ul><li>半导体器件处于导通和截止两种稳定状态下的特性</li></ul></li><li>动态特性<ul><li>半导体器件在导通和截止两种状态转换过程中的特性</li><li>反向恢复时间<ul><li>让电路截止时，不是马上截止的，有一个恢复时间，这个恢复时间越短，电路变化的次数才可能做到越快，决定了元件的性能</li><li>从开通变成截止的时间</li></ul></li><li>开通时间</li><li>从截止变成导通的时间</li></ul></li></ul></li><li><p>晶体二极管的开关特性</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131022934.png"></li><li>静态特性<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121811012.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121811597.png"><ul><li>Vth是门槛电压，当电压等于门槛电压时，管子开始导通；大于门槛电压时，彻底导通</li><li>Vbr是反向击穿电压，随着反向电压增加，反向电流猛增，二极管被击穿</li></ul></li><li>单向导电性</li><li>正向导通</li><li>反向截止<ul><li>正向导通时可能因为电流过大而导致二极管烧坏</li><li>组成实际电路时，通常串接一只电阻R，以限制二极管正向电流</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121818009.png"></li></ul></li></ul></li><li><p>动态特性</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121819846.png"></p><ul><li>加了反向电压后，并不是马上是电路为0，而是一个过程</li><li>ts叫做存储时间</li><li>tt加做渡越时间</li><li>反向恢复时间tre&#x3D;ts+tt</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121823049.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131014962.png"><ul><li>当它的电压相反时，空间电荷区发生变化，使得电流方向互反</li></ul></li><li>还有个概念叫开通时间，相对于反向恢复时间，非常短<ul><li>不需要重点讨论，但需要把物理上原因搞清楚，为什么开通时间很短？模拟电路的知识能搞明白！！！找一本模拟电路的书看看</li><li>截止转为正向导通所需的时间</li><li>主要由外电路参数决定</li><li>加入输入电压后，回路电流几乎是立即达到最大值</li><li>开通时间与反向恢复时间相比很小，可以忽略不计</li></ul></li></ul></li><li><p>晶体三级管的开关特性</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209131021557.png"></li><li>三种状态<ul><li>截止、放大、饱和</li></ul></li><li>三极管的静态特性（在截止和饱和这两种稳态下的特性） <ul><li>由基极信号控制的无触点开关，其作用对应与开关的闭合和断开</li></ul></li><li>三级管的动态特性（三极管在饱和与截止两种状态转换过程中的具有的特性）<ul><li>三极管内部存在着电荷的建立与消失过程</li><li>饱和和截止两种状态的转换需要一定的时间才能完成</li></ul></li></ul></li></ul></li><li><p>简单逻辑门电路</p><ul><li>二极管与门电路</li><li>二极管或门电路</li><li>非门电路-反相器</li><li>非门电路-BJT反相器</li></ul></li><li><p>典型TLL与非门电路</p><ul><li>电路结构<ul><li>输入级<ul><li>多发射极T1和电阻R1</li><li>3个输入信号通过的发射结实现与功能</li></ul></li><li>中间级<ul><li>晶体管T2和电阻R2和R3组成</li><li>T2集电极和发射极分别控制T3和T4</li></ul></li></ul></li><li>输出级（推拉式）<br> - 晶体管T3、T4、二极管D4和电阻R4<br> - 优点：提高开关速度和负载能力</li><li>工作原理<ul><li>输入电压为高、输出电压为低</li><li>输入电压有低、输出电压为高</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字集成电路的分类（了解即可）</title>
    <link href="/2022/09/12/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <url>/2022/09/12/%E6%95%B0%E5%AD%97%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h1><ul><li><p>集成电路</p><ul><li>一个电路中所需的晶体管、二极管、电阻、电容和电感等元件及布线互连一起，制作在一小块或几小块半导体晶片或介质基片上</li><li>通过引脚与外部联系</li><li>特点<ul><li>可靠性高</li><li>可维护性好</li><li>功耗低 </li><li>成本低</li><li>大大简化设计和调试过程</li></ul></li></ul></li><li><p>数字集成电路分类</p><ul><li>根据半导体器件进行分类<ul><li>双极型集成电路<ul><li>采用双极型半导体器件作为元件</li><li>速度快、负载能力强，功耗较大、集成度较低</li><li>双极型集成电路又包括：<ul><li>TTL：三极管-三极管电路</li><li>ECL：射极耦合电路</li><li>$I^2$L:集成注入电路</li></ul></li></ul></li><li>单极型集成电路<ul><li>金属-氧化物半导体场效应管作为元件</li><li>结构简单、制造方便、集成度高、功耗低，速度较慢</li></ul></li></ul></li><li>根据集成电路规模的大小进行分类<ul><li>SSI（小规模集成电路）<ul><li>逻辑门小于10门或元件数小于100个</li></ul></li><li>MSI（中规模集成电路）<ul><li>逻辑门10门<del>99门或元件数100个</del>999</li></ul></li><li>LSI（大规模集成电路）<ul><li>逻辑门数为100门<del>9999门或元件数1000个</del>9999个</li></ul></li><li>VLSI（超大规模集成电路）<ul><li>逻辑门数大于10000门或元件数大于100000个</li></ul></li></ul></li><li>根据设计方法和功能定义分类<ul><li>非用户定制电路：标准集成电路<ul><li>特点：生产量大、使用方便、价格便宜</li><li>各种小、中、大规模通用集成电路</li></ul></li><li>全用户定制电路：专用集成电路ASIC<ul><li>为了满足用户特殊应用要求而专门生产的集成电路</li><li>特点：可靠性高、保密性好；设计费用高、销量小</li></ul></li><li>半用户定制电路<ul><li>厂家生产出功能不确定的集成电路，用户对已有的芯片进行功能定义将通用产品专用化</li><li>可编程逻辑器件</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>集成门电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2022/09/11/Git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/11/Git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ul><li><p>常用命令</p><ul><li>git init<ul><li>初始化，在本地git bash使用此命令后创建.git文件夹，使本地文件夹成为仓库，即每次版本的代码都会在里面</li></ul></li><li>git clone &lt;链接&gt; 将所需要的东西下载到本地，且用此命令下载的是仓库，里面的每次修改也在里面，而直接download zip 只是最新版本</li><li>git add<ul><li>git add 后可跟文件名也可直接git add -A 表示将所有文件送入暂存区</li></ul></li><li>git commit<ul><li>git commit -m “引号里面输入你对提交的信息的描述”    用于提交信息</li></ul></li><li>git checkout &lt;文件名&gt;<ul><li>在工作区中的更改给打回去</li></ul></li><li>git reset HEAD^<ul><li>提交后撤回</li></ul></li><li>git push 推送当前分支的最新提交到远程</li><li>git pull   拉取远程分支最新的提交到本地</li><li>本地远程双向更新先pull后push</li></ul></li><li><p>分支</p><ul><li>git checkout -b  &lt;分支名&gt; 从当前节点新建分支 </li><li>git branch 列举所有分支</li><li>git checkout &lt;分支名&gt; 单纯切换到某个分支</li><li>git branch -D &lt;分支名&gt; 删掉特定的分支</li><li>git merge &lt;分支名&gt; 合并分支</li></ul></li><li><p>远程</p><ul><li>命令git remote add origin <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#x6d;</a>:Nick-JY&#x2F;Loongson_FirstLogs.git  </li><li>git push origin 本地分支名:远程分支名</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209112251180.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121048470.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121055062.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121128369.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121131666.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209121456714.png"></p>]]></content>
    
    
    <categories>
      
      <category>龙芯</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>龙芯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逻辑函数化简</title>
    <link href="/2022/09/11/%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E5%8C%96%E7%AE%80/"/>
    <url>/2022/09/11/%E9%80%BB%E8%BE%91%E5%87%BD%E6%95%B0%E5%8C%96%E7%AE%80/</url>
    
    <content type="html"><![CDATA[<h2 id="逻辑函数化简法"><a href="#逻辑函数化简法" class="headerlink" title="逻辑函数化简法"></a>逻辑函数化简法</h2><h3 id="代数化简法"><a href="#代数化简法" class="headerlink" title="代数化简法"></a>代数化简法</h3><ul><li>代数化简法<ul><li>参考离散数学</li></ul></li></ul><h3 id="卡诺图化简法"><a href="#卡诺图化简法" class="headerlink" title="卡诺图化简法"></a>卡诺图化简法</h3><ul><li>卡诺图化简法<ul><li><p>卡诺图是一个平面的方格图，每一个小方格代表一个最小项</p></li><li><p>2变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111007414.png"></p></li><li><p>3变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111013107.png"></p></li><li><p>11和10为什么换了位置呢？–对于01和11只有一个变量不同，同样，对于11和10也只有一个变量不同，对于00和10也只有一个变量不同，这样排列能够让相邻最小项挨在一起</p></li><li><p>4变量卡诺图</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111013379.png"></p></li><li><p>卡诺图特点</p><ul><li>n个变量的卡诺图由2的n次方个小方格构成</li><li>几何图形上处在相邻、相对、相重位置的小方格代表的最小项为相邻最小项</li><li>卡诺图中最小项排列方案不是惟一的</li><li>但是任何一种方案都应保证能清楚反映最小项的相邻关系</li><li>相邻关系最小项只有一位相反</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111019097.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111019517.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111020055.png"></li></ul></li><li><p>逻辑函数在卡诺图上的表示</p><ul><li>标准与-或表达式在卡诺图上的表示<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111022838.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111022041.png"></li></ul></li><li>一般与-或表达式的卡诺图<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111024909.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111026972.png"></li><li>AB取11，CD取11，所在行和列填1，A非B非C,再补充填1</li></ul></li></ul></li><li><p>卡诺图上最小项的合并规律</p><ul><li>理论依据：并项定理</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111121375.png"></li><li>两个相邻最小项有一个变量互反，可以合并为一项，消去一个变量</li><li>卡诺图的重要特征：直观、清晰地反映了最小项的相邻关系</li><li>卡诺图化简逻辑函数的基本原理<ul><li>将逻辑依据和图形特征结合起来</li><li>将卡诺图上表征相邻最小项的相邻小方格“圈”在一起进行合并</li><li>达到用一个简单与项代替若干最小项的目的</li><li>用来包围那些能由一个简单与项代替的若干最小项的圈称为“卡诺圈”</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111142393.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111222401.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111223287.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111224274.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111226921.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111228271.png"></li><li>总结<ul><li>卡诺图中小方格的个数必须为$2^m$个，m为小于或等于n的整数</li><li>卡诺图中的$2^m$个小方格含有m个不同变量,（n-m）个相同变量</li><li>卡诺图中的$2^m$个小方格对应的最小项可用（n-m）个变量的“与”项表示，该“与项”由这些最小项中的相同变量构成</li><li>当m&#x3D;n时，卡诺圈包围了整个卡诺图，可用1表示，即n个变量的全部最小项之和为1</li></ul></li></ul></li><li><p>卡诺图化简逻辑函数的步骤</p><ul><li>几个术语<ul><li>蕴涵项：“与-或”表达式中，每个与项被称为该函数的蕴涵项<ul><li>注：在函数卡诺图中，任何一个1方格所对应的最小项或者卡诺圈中的$2^m$各1方格对应的与项都是函数的蕴涵项</li></ul></li><li>质蕴涵项：若函数的一个蕴涵项不是该函数中其他蕴涵项的子集，则称为质蕴涵项，简称为质项<ul><li>在函数卡诺图中，按照最小项合并规律</li><li>如果某个卡诺圈不可能被其他更大的卡诺圈包含</li><li>该卡诺圈所对应的与项为质蕴涵项</li></ul></li><li>必要质蕴涵项：若函数的一个质蕴涵项包含有不被函数的其他任何质蕴涵项所包含的最小项，则此质蕴涵项被称为必要质蕴涵项，简称为必要质项<ul><li>在函数卡诺图中，若某个卡诺圈包含了不可能被任何其他卡诺圈包含的1方格</li><li>该卡诺圈所对应的与项为必要质蕴涵项</li></ul></li></ul></li><li>求逻辑函数最简与-或表达式的一般步骤<ul><li>第一步：作出函数的卡诺图</li><li>第二步：在卡诺图上圈出函数的全部质蕴涵项</li><li>第三步：从全部质蕴涵项中找出所有必要质蕴涵项</li><li>第四步：求函数的最简质蕴涵项集<ul><li>当函数的所有必要质蕴涵项尚不能覆盖卡诺图上的所有1方格时</li><li>从剩余质蕴涵项中找出最简的所需质蕴涵项</li><li>使它和必要质蕴涵项一起构成函数的最小覆盖</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111316319.png"><ul><li>最小项标1，这些最小项就是蕴涵项</li><li>找出质蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111318159.png"></li><li>找出必要质蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111318523.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111319387.png"></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111346588.png"><ul><li>覆盖m10?–找到的必要质蕴涵项所在的卡诺圈应该覆盖所有蕴涵项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111347349.png"></li><li>两个与-或式的复杂程度相同</li><li>一个函数的最简与-或表达式不一定是唯一的</li></ul></li></ul></li><li>卡诺图化简的原则<ul><li>在覆盖函数中所有最小项前提下，卡诺圈的个数应达到最少</li><li>在满足合并规律的前提下卡诺圈应达到最大</li><li>根据合并的需要，每个最小项可以被多个卡诺圈包围</li></ul></li><li>求逻辑函数最简或-与表达式的一般步骤”两次取反法“<ul><li>情况一：当给定逻辑函数为“与-或”表达式或者标准“与-或表达式”时 <ul><li>作出函数F的卡诺图</li><li>合并卡诺图上的0方格，求出反函数F‘的最简与-或表达式</li><li>对F’的最简与或表达式取反，得到或-与表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111403894.png"></li></ul></li><li>情况二：当给定逻辑函数为或-与表达式或标准或-与表达式时<ul><li>求出函数F的反函数F‘，并作出F’的卡诺图</li><li>合并卡诺图上的1方格，求出F‘最简与或表达式</li><li>对F’的最简与-或表达式取反，得到F的最简或-与表达式</li></ul></li></ul></li></ul></li><li><p>卡诺图化简的优缺点</p><ul><li>优点：方便、直观、容易掌握</li><li>缺点：受到变量个数的约束，当变量个数大于6时，画图以及对图形的识别都变得相当复杂</li></ul></li></ul></li></ul><h3 id="列表化简法"><a href="#列表化简法" class="headerlink" title="列表化简法"></a>列表化简法</h3><ul><li>列表化简法<ul><li>通过约定的表格形式，按照一定规则完成化简过程</li><li>通过找出函数F的全部质蕴涵项，必要质蕴涵项以及最简质蕴涵项集来求得最简表达式</li><li>列表化简法的步骤<ul><li>第一步：将函数表示成“最小项之和”形式，并用二进制码表示每一个最小项</li><li>第二步：做出质蕴涵项产生表，找出函数的全部质蕴涵项</li><li>第三步：做出必要质蕴涵产生表，找出函数的必要质蕴涵项</li><li>第四步：当必要质蕴涵项不能覆盖所有最小项时，借助所需的质蕴涵项产生表，找出函数的最小覆盖</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111456360.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111502526.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111503537.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209111503587.png"></li><li>列表化简法特点<ul><li>优点：规律性强，对变量数较多的函数，可经过反复比较、合并，得到最简结果</li><li>适用：计算机处理</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>数字逻辑基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路设计实例</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071712386.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713039.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713450.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713896.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071713270.png"></p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714955.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714333.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714011.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714851.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714578.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071714124.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071715706.png"></p><h2 id="自启动问题"><a href="#自启动问题" class="headerlink" title="自启动问题"></a>自启动问题</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716529.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716582.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716894.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071716984.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717729.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717060.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717475.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071717771.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071718045.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071718022.png"></p><p>要讨论在无效状态时，电路输出和状态转移</p><ul><li>讨论<ul><li>电路是否具有自恢复功能<ul><li>电路万一偶然进入无效状态，如果能在输入信号时和时钟脉冲作用下自动进入有效状态，则称为具有自恢复功能，否则称为“挂起”</li><li>存在挂起，必须修正</li></ul></li><li>电路是否会产生错误输出信号<ul><li>电路万一处在无效状态，是否会在输入信号和时钟脉冲作用下产生错误输出信号</li><li>存在错误输出信号，必须修正</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071721689.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071721579.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722229.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722721.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722919.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071722408.png"><br>对于无效序列，如果在某种输入情况下，电路可以回到正常序列中去，电路就不存在挂起问题了</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723138.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723171.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071723035.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路设计过程</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="同步时序逻辑电路的设计步骤"><a href="#同步时序逻辑电路的设计步骤" class="headerlink" title="同步时序逻辑电路的设计步骤"></a>同步时序逻辑电路的设计步骤</h1><p>用尽可能少的触发器和逻辑门实现预定的逻辑要求</p><ul><li>完全确定同步时序逻辑电路<ul><li>电路在不同输入取值下都有确定的次态和输出</li></ul></li><li>不 完全确定同步时序逻辑电路<ul><li>电路中存在不确定的次态或输出，即某些状态在输入取值下的次态或输出是随意的<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071608587.png"></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071609288.png"></p><ul><li>第一步作原始状态图状态表的首要任务<ul><li>正确反映题意</li><li>是否最简不做要求</li></ul></li></ul><h1 id="原始状态图"><a href="#原始状态图" class="headerlink" title="原始状态图"></a>原始状态图</h1><ul><li>根据对设计要求的文字描述，抽象出电路的输入、输出以及状态之间的关系，形成状态图和状态表</li><li>先画状态图后画状态表</li></ul><h2 id="建立原始状态图步骤"><a href="#建立原始状态图步骤" class="headerlink" title="建立原始状态图步骤"></a>建立原始状态图步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071612910.png"></p><ul><li>确定各时刻电路的输出<ul><li>时序逻辑电路的功能是通过输出对输入的响应来体现的</li><li>在建立原始状态图时，必须确定各时刻的输出值<ul><li>在Moore型电路中，应指明每周状态下对应的输出</li><li>在Mealy型电路中应指明从每一个状态出发，在不同输入作用下的输出值</li></ul></li></ul></li><li>注意：<ul><li>状态数目能否达到最少无关紧要，因为可以再化简</li><li>设计者应把清晰、正确地描述设计要求放在第一位</li><li>一般用字母或数字表示状态</li></ul></li></ul><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616693.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616515.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071616857.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617938.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617064.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617070.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071617849.png"></p><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618569.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618950.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071618908.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071619460.png"></p><ul><li>总结<ul><li>一个序列检测器所需要的状态数与要识别的序列长度相关<ul><li>序列越长，需要记忆的代码位数越多，状态数也就越多</li></ul></li><li>Mealy型一般比Moore型所需状态数少</li></ul></li></ul><h2 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071621929.png"></p><p>代码检测器的特点是输入信号是按位分组的，每组的监测过程相同，即一组检测完后，电路回到初始状态，接着进行下一组的监测</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071622810.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071624175.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071624469.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071625568.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071625820.png"></p><h1 id="状态化简"><a href="#状态化简" class="headerlink" title="状态化简"></a>状态化简</h1><p>从原始状态表中消去多余状态，的到一个描述给定的逻辑功能的包含状态数目达到最少的状态表，即最简状态表或最小化状态表</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071628802.png"></p><ul><li>化简方法<ul><li>观察法</li><li>输出分类法</li><li>隐含表法</li></ul></li></ul><p>等效状态：<br>设S和J是完全确定状态表中的两个状态，若对于所有可能的输入序列，分别从S和J出发所得到的输出响应序列完全相同，则称它们是等效的</p><ul><li>等效状态的判断方法<ul><li>输出相同</li><li>次态输入下列情况之一<ul><li>次态相同</li><li>次态交错或为各自的现态</li><li>次态循环或为等效对</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071633310.png"></p><p>等效状态的性质：<br>等效状态具有传递性<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071634046.png"></p><p>等效类</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071634807.png"></p><p>最大等效类：</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071635236.png"></p><h2 id="状态化简步骤"><a href="#状态化简步骤" class="headerlink" title="状态化简步骤"></a>状态化简步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636882.png"></p><h3 id="做隐含表"><a href="#做隐含表" class="headerlink" title="做隐含表"></a>做隐含表</h3><p>直角三角形阶梯网格<br>每个方格代表一个状态对</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636855.png"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636466.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636817.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071636262.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637536.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637832.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071637191.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071638004.png"></p><h1 id="状态编码"><a href="#状态编码" class="headerlink" title="状态编码"></a>状态编码</h1><p>给最小化状态表中用字母或数字表示的状态指定一个二进制代码，形成二进制状态表，也称状态分配，或者状态赋值</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640804.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640753.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640308.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640926.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640003.png"></p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071640697.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641903.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641938.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641862.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071641772.png"></p><h1 id="确定激励函数和输出函数"><a href="#确定激励函数和输出函数" class="headerlink" title="确定激励函数和输出函数"></a>确定激励函数和输出函数</h1><ul><li>触发器的激励表<ul><li>反映了触发器从现态转移到某种次态时，对输入条件的要求</li><li>把触发器的现态和次态作为自变量，而把触发器的输入作为因变量</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071643187.png"></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>列出激励函数和输出函数的真值表</li><li>用卡诺图化简后写出最简表达式</li><li>熟练时刻直接根据激励函数和输出函数真值表，作出激励函数和输出函数卡诺图化简</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071644897.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645942.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645674.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071645148.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646456.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646483.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646182.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646374.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646346.png"><br>回答–确实<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646227.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071646762.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071647300.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071647004.png"></p><p>注意：<br>在同步时序逻辑电路的设计中，采用不同的触发器，会导致激励函数不同，使得设计出来的检录的组合电路部分的复杂程度会不同。因此，在具体的设计中，要进行分析、对比，选择合适的存储元件，从而使最终设计的电路最简单</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步时序逻辑电路分析</title>
    <link href="/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/27/%E5%90%8C%E6%AD%A5%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="同步时序逻辑的表格分析法"><a href="#同步时序逻辑的表格分析法" class="headerlink" title="同步时序逻辑的表格分析法"></a>同步时序逻辑的表格分析法</h1><p>分析的关键在于找出电路状态和输出随输入变化而变化的规律，以便确定其逻辑功能</p><h2 id="表格法分析步骤"><a href="#表格法分析步骤" class="headerlink" title="表格法分析步骤"></a>表格法分析步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071547947.png"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071548977.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071548315.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071549737.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550747.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550693.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550446.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550589.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071550986.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071551959.png"></p><p>加1计数<br>2位二进制数逆计数器</p><h2 id="作时间图的一般步骤"><a href="#作时间图的一般步骤" class="headerlink" title="作时间图的一般步骤"></a>作时间图的一般步骤</h2><p>在时序逻辑电路分析中，除了状态图和状态表，通常还用到时间图</p><ul><li>作时间图的一般步骤<ul><li>假设电路初始状态，并拟定一典型输入序列</li><li>作出状态和输出响应序列</li><li>根据响应序列画出波形图</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071555605.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071555131.png"></p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071600116.png"></p><p>两个D触发器–相同时钟端，同步时序逻辑逻辑电路<br>三个或非门<br>输入：x<br>输出：z<br>电路的状态：<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602074.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602033.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602708.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602577.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602984.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071602048.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071603845.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071603296.png"></p><p>实际问题分析时，可视具体情况灵活运用，根据给定逻辑电路的复杂程度不同，通常可以省去某些步骤，例如列次态真值表或画时间图等</p><h1 id="同步时序逻辑电路的代数分析法"><a href="#同步时序逻辑电路的代数分析法" class="headerlink" title="同步时序逻辑电路的代数分析法"></a>同步时序逻辑电路的代数分析法</h1><h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071557564.png"></p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558378.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558630.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558346.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071558844.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071559344.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时序逻辑电路基础</title>
    <link href="/2022/07/27/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/07/27/%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="时序逻辑电路概述"><a href="#时序逻辑电路概述" class="headerlink" title="时序逻辑电路概述"></a>时序逻辑电路概述</h1><ul><li>若逻辑电路在任何时候产生的稳定输出信号不仅与电路该时刻的输入信号有关，还与电路过去的输入信号有关，则称为时序逻辑电路</li></ul><h2 id="时序逻辑电路一般结构"><a href="#时序逻辑电路一般结构" class="headerlink" title="时序逻辑电路一般结构"></a>时序逻辑电路一般结构</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071510178.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051005132.png"><br>这是图左的电路分析</p><ul><li><p>状态</p><ul><li>时序逻辑电路的状态是存储电路对过去输入信号记忆的结果</li><li>随着外部信号的作用而变化</li><li>在对电路功能进行研究时，通常将某一时刻的现状称为现态</li><li>在某一状态下，外部信号发生变化后达到的新的状态称为次态</li></ul></li><li><p>时序逻辑电路的特点</p><ul><li>电路又组合电路和存储电路组成，具有对过去输入进行记忆的功能</li><li>电路中包含反馈回路，通过反馈使电路功能与时序相关</li><li>电路的输出由电路当时的输入和状态共同决定</li></ul></li></ul><h2 id="时序逻辑电路的分类"><a href="#时序逻辑电路的分类" class="headerlink" title="时序逻辑电路的分类"></a>时序逻辑电路的分类</h2><h3 id="按照电路的工作方式分类"><a href="#按照电路的工作方式分类" class="headerlink" title="按照电路的工作方式分类"></a>按照电路的工作方式分类</h3><ul><li><p>同步时序逻辑电路</p><ul><li>电路中有统一的定时信号，存储器件采用时钟控制触发器，电路状态在时钟脉冲控制下同时发生转换</li></ul></li><li><p>异步时序逻辑电路</p><ul><li>电路中没有统一的时钟信号同步，电路输入信号的变化将直接导致电路状态的变化</li></ul></li><li><p>电路状态的改变依赖于输入信号和时钟脉冲信号</p><ul><li>状态变化时间—-取决于时钟信号</li><li>状态如何变化—-取决于输入信号</li><li>每个状态维持时间—-取决于时钟脉冲的周期</li></ul></li></ul><p>研究同步时序逻辑电路时，通常不把同步时钟信号作为输入信号处理，而是将它当成一种默认的时间基准</p><p>同步时序逻辑电路中的现态与次态时针对某个时钟脉冲而言的</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071521085.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071521436.png"></p><ul><li>同步时序逻辑电路对时钟的要求（为了稳定可靠工作）<ul><li>脉冲的宽度—-必须保证触发器可靠翻转</li><li>脉冲的频率—-必须保证前一个脉冲引起的电路响应完全结束后，后一个脉冲才能到来</li></ul></li></ul><h3 id="按照电路输出与输入的依存关系分类"><a href="#按照电路输出与输入的依存关系分类" class="headerlink" title="按照电路输出与输入的依存关系分类"></a>按照电路输出与输入的依存关系分类</h3><ul><li>Mealy型—-时序逻辑电路的输出是电路输入和电路状态的函数</li><li>Moore型—-时序逻辑电路的输出仅仅是电路状态的函数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071525968.png"><br>X是输入<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071525889.png"></p><ul><li><p>两者区别</p><ul><li><p>Mealy型电路的输入和输出之间存在直接联系</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051026577.png"></li></ul></li><li><p>Moore型电路则是将全部输入转换为电路状态后再和输出建立联系</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210051026338.png"></li></ul></li></ul></li><li><p>Moore型电路的特殊状况</p><ul><li>时序逻辑电路没有专门的外部输入信号，而是以电路状态作为输出</li></ul></li></ul><h3 id="按照电路输入信号形式划分"><a href="#按照电路输入信号形式划分" class="headerlink" title="按照电路输入信号形式划分"></a>按照电路输入信号形式划分</h3><ul><li>脉冲型<ul><li>有相同的间隔</li></ul></li><li>电平型<ul><li>0和1间隔是不等的，是任意的</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071529650.png"></p><h2 id="时序逻辑电路的描述"><a href="#时序逻辑电路的描述" class="headerlink" title="时序逻辑电路的描述"></a>时序逻辑电路的描述</h2><ul><li>逻辑函数表达式<ul><li>输出函数表达式</li><li>激励函数表达式</li><li>次态函数表达式</li></ul></li><li>状态图</li><li>状态表</li><li>时间表</li></ul><h3 id="逻辑函数表达式"><a href="#逻辑函数表达式" class="headerlink" title="逻辑函数表达式"></a>逻辑函数表达式</h3><ul><li>激励函数表达式<ul><li>反映了存储电路的输入与外部的输入和电路状态之间的关系</li></ul></li><li>输出函数表达式<ul><li>反映电路输出与外部输入和状态之间关系</li></ul></li><li>次态函数表达式<ul><li>同步时序电路的次态与激励函数和电路现态之间的关系</li></ul></li></ul><h4 id="Moore型电路"><a href="#Moore型电路" class="headerlink" title="Moore型电路"></a>Moore型电路</h4><h5 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071534670.png"></p><h5 id="个例"><a href="#个例" class="headerlink" title="个例"></a>个例</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071536531.png"></p><h4 id="Mealy型电路"><a href="#Mealy型电路" class="headerlink" title="Mealy型电路"></a>Mealy型电路</h4><h5 id="范式-1"><a href="#范式-1" class="headerlink" title="范式"></a>范式</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071537820.png"></p><h5 id="个例-1"><a href="#个例-1" class="headerlink" title="个例"></a>个例</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071537364.png"></p><h3 id="状态表"><a href="#状态表" class="headerlink" title="状态表"></a>状态表</h3><ul><li>状态转移表</li><li>反映同步时序电路输出、次态与电路输入与现态之间关系的表格</li><li>状态表示同步时序电路分析和实际中常用的工具</li><li>非常清晰给出了同步时序电路在不同输入和现态下的次态和输出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071539807.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071540681.png"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>反映同步时序电路状态转换规律及相应输入、输出取值关系的有向图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071541443.png"></p><ul><li>优点<ul><li>直观、形象</li></ul></li><li>状态图和状态表对比<ul><li>状态表更规范</li><li>状态图更形象</li></ul></li></ul><p>时间图—-表示输入信号、输出信号和电路状态的取值在各时刻的对应关系的波形图，通常又称作为工作波形图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202208071543391.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>同步时序逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>维持阻塞触发器</title>
    <link href="/2022/07/27/%E7%BB%B4%E6%8C%81%E9%98%BB%E5%A1%9E%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E7%BB%B4%E6%8C%81%E9%98%BB%E5%A1%9E%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="维持阻塞触发器"><a href="#维持阻塞触发器" class="headerlink" title="维持阻塞触发器"></a>维持阻塞触发器</h1><h2 id="典型维持阻塞D触发器"><a href="#典型维持阻塞D触发器" class="headerlink" title="典型维持阻塞D触发器"></a>典型维持阻塞D触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271100068.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271100886.png"><br>输入$R_D$ ,$S_D$</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>CP&#x3D;0<ul><li>RS&#x3D;11</li><li>Q不变</li></ul></li><li>CP&#x3D;1<ul><li>D&#x3D;0  Q&#x3D;0</li><li>D&#x3D;1   Q&#x3D;1</li><li>D: 0–&gt;1–&gt;0<ul><li>无空翻</li></ul></li><li>D: 1–&gt;0–&gt;1<ul><li>无空翻</li></ul></li></ul></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>结论<ul><li>CP&#x3D;0<ul><li>RS&#x3D;11</li><li>Q不变</li></ul></li><li>CP&#x3D;1<ul><li>Q&#x3D;D</li><li>无空翻<br>也就是逻辑功能和钟控D触发器一样</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271106444.png"><br>仅仅在时钟脉冲上升沿响应输入变化</p><ul><li>边沿触发器：仅在时钟脉冲的上升或下降的时刻相应输入信号的触发器<ul><li>只在时钟脉冲的边沿进行采样并确定触发器的状态</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031054950.png"></li><li>大大提高了抗干扰性<br>以后没有特殊说明，我们一般采用的就是维持阻塞触发器</li></ul></li></ul><h2 id="触发器的对比"><a href="#触发器的对比" class="headerlink" title="触发器的对比"></a>触发器的对比</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271108435.png"></p><h2 id="TTL集成JK触发器——74LS76"><a href="#TTL集成JK触发器——74LS76" class="headerlink" title="TTL集成JK触发器——74LS76"></a>TTL集成JK触发器——74LS76</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271109582.png"></p><ul><li>集成触发器的性能参数<ul><li>直流参数<ul><li>电源电流</li><li>低电平输入电流</li><li>高电平输入电流</li><li>输出高电平</li><li>输出低电平</li><li>扇出系数</li></ul></li><li>开关参数<ul><li>最高时钟频率</li><li>时钟信号的延迟时间</li><li>直接置0端的延迟</li><li>直接置1端的延迟</li></ul></li></ul></li></ul><p><strong>熟记触发器的功能表、状态表、激励表、次态方程</strong></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主从J-K触发器</title>
    <link href="/2022/07/27/%E4%B8%BB%E4%BB%8EJ-K%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E4%B8%BB%E4%BB%8EJ-K%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="主从JK触发器"><a href="#主从JK触发器" class="headerlink" title="主从JK触发器"></a>主从JK触发器</h1><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031022993.png"><br>由主从RS触发器演变而来<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271052522.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271052718.png"></p><ul><li>优点<ul><li>输入信号J和K无约束</li><li>无空翻</li><li>功能全</li><li>使用方便</li></ul></li><li>缺点<ul><li>存在“一次翻转”问题</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271056877.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271056271.png"><br>t7和t11时刻为什么没有变化呢</p><ul><li>一次翻转：指在时钟脉冲作用（CP&#x3D;1）期间，主触发器的状态只能根据输入信号的变化改变一次<ul><li>主触发器在接收输入信号发生一次翻转之后，状态保持不变，不再受J、K变化的影响</li><li>和空翻不同，一次翻转会导致触发器的状态转移与触发器的逻辑功能不一致，这是不允许的</li></ul></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>造成一次翻转现象的原因是什么呢？<br>是因为我们引入了两个反馈线。<br>而钟控JK触发器也引入了两根反馈线，为什么就没事呢？<br>因为钟控JK触发器钟，J、K发生变化时，触发器的状态会跟着发生变化，因此每次J、K发生变化，反馈回来的都是上次J、K发生变化后的状态<br>而在主从JK触发器里，由于从触发器被锁，因此JK发生变化时，从触发器不能跟着变化，因此，反馈回来的不是JK当前的状态，而是从前的状态<br>当输入端JK出现干扰信号的时候，就可能破幻触发器的正常逻辑功能，为了客服这一缺点，就要求在时钟脉冲作用期间，输入JK的值不能发生变化，这就降低了它的抗干扰能力。<br>而且和主从RS触发器一样，这种对输入端的约束，就失去了主从结构的意义，因此主从JK触发器是不能使用的</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主从R-S触发器</title>
    <link href="/2022/07/27/%E4%B8%BB%E4%BB%8ER-S%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E4%B8%BB%E4%BB%8ER-S%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="主从RS触发器"><a href="#主从RS触发器" class="headerlink" title="主从RS触发器"></a>主从RS触发器</h1><p>为了解决空翻问题引入</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270933441.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270934220.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270935644.png"></p><ul><li>输入端$R_D$：直接置0端<ul><li>$R_D$等于0时，会使得Q等于0</li></ul></li><li>输入端$S_D$：直接置1端<ul><li>$S_D$等于0时，Q就等于1</li></ul></li><li>在正常工作时，它们都不能等于0，因为它一旦等于0，直接置0或者置1了。都等于0，又违背了约束条件，所以正常工作时，一般让它们都为1</li><li>因为它们都为1，对与非门是不起作用的，于是分析的时候可以不看它们</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270942684.png"><br>主触发器的输出是从触发器的输入<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270942377.png"><br>主触发器和从触发器时钟反相</p><ul><li>CP&#x3D;1<ul><li>从触发器锁定</li><li>主触发器响应</li></ul></li><li>CP&#x3D;0<ul><li>主触发器锁定</li><li>从触发器响应</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270948578.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>总结<ul><li>前沿采样</li><li>后沿定局</li><li>状态变化是在时钟脉冲的后沿</li><li>状态变化锁定在一个时间点，而不是一个时间段，过了这个状态，无论它怎么变化，主触发器的状态是被锁定的，因此不会导致从触发器发生变化（就是图中一点的例子），因此无“空翻”<br>对于此触发器而言。它的状态变化是发生在CP的下降沿，因此称它为下降沿触发器<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031013494.png"><br>加了一个小圆圈，加了表示下降沿触发，不加便是上升沿触发</li></ul></li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>主触发器输出</li><li>从触发器输入</li><li>与钟控触发器功能一致</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210031015139.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271050266.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207271050046.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时钟控制触发器</title>
    <link href="/2022/07/27/%E9%92%9F%E6%8E%A7%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2022/07/27/%E9%92%9F%E6%8E%A7%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="钟控触发器"><a href="#钟控触发器" class="headerlink" title="钟控触发器"></a>钟控触发器</h1><ul><li>具有时钟脉冲控制的触发器<ul><li>时钟控制触发器</li><li>定时触发器</li><li>clocked flip-flop</li></ul></li><li>工作特点<ul><li>何时转换？<ul><li>由时钟脉冲确定状态转换的时刻</li></ul></li><li>如何转换？<ul><li>由输入信号确定触发器状态转换的方向</li></ul></li></ul></li></ul><h2 id="钟控R-S触发器"><a href="#钟控R-S触发器" class="headerlink" title="钟控R-S触发器"></a>钟控R-S触发器</h2><p>加入两个与非门和一个时钟端CP<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917441.png"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917659.png"></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270917694.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918772.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918396.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>钟控R-S触发器受时间脉冲信号控制，只有在CP&#x3D;1时，才会和或非门构成的R-S触发器功能相同。<br>但是它的输入信号仍然存在约束—-引入钟控D触发器</p><h2 id="钟控D触发器"><a href="#钟控D触发器" class="headerlink" title="钟控D触发器"></a>钟控D触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270918114.png"><br><strong>在钟控RS触发器的基础上加了一根线，可以这样理解：原来的R变成现在的S’，而S’它等于（CP与D）的非，这样输入就变成一组互补的输入，不存在约束了</strong><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919484.png"></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919524.png"></p><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270919432.png"><br>钟控D触发器解除了钟控RS触发器对输入的约束，也就没有约束方程了<br><strong>钟控D触发器在时钟脉冲作用后，它的次态和它输入的值相同，所以我们也叫他锁存器</strong><br>但是它功能比较单一，所以我们引入钟控JK触发器</p><h2 id="钟控J-K触发器"><a href="#钟控J-K触发器" class="headerlink" title="钟控J-K触发器"></a>钟控J-K触发器</h2><p>在钟控RS触发器上进行改造，首先把输入端变成K、J，然后 加入两根反馈线<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021521328.png"></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922866.png"><br>根据R’+S’&#x3D;1推出的最后表达式，恒等于1，所以输入也不存在约束的问题</p><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922796.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922638.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270922916.png"></p><h2 id="钟控T触发器"><a href="#钟控T触发器" class="headerlink" title="钟控T触发器"></a>钟控T触发器</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210021533308.png"><br>在JK触发器上进行调整，将J端和K端连在一起用一个新的输入端T表示</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270923088.png"></p><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270923617.png"></p><h2 id="总结与补充"><a href="#总结与补充" class="headerlink" title="总结与补充"></a>总结与补充</h2><ul><li>电位控制触发器（上述的钟控触发器均有这些共性，它们都是电位控制触发器）<ul><li>CP&#x3D;0，也就是低电平，触发器保持状态不变</li><li>CP&#x3D;1，也就是高电平，触发器在输入信号作用下发生状态变化</li><li>触发器状态转移被控制在一个约定的时间间隔内，而不是控制在某一时刻</li><li>但是有一个缺陷是会产生空翻现象</li></ul></li></ul><p>空翻：同一个时钟脉冲作用期间触发器状态发生两次或两次以上变化的现象</p><ul><li>空翻原因<ul><li>时钟脉冲作用期间，输入信号直接控制着触发器状态的变化<ul><li>CP&#x3D;1时，输入信号发生变化，触发器状态会跟着变化</li></ul></li><li>时钟宽度控制不够<ul><li>CP为1的时间过长，输入的多次变化得到完全响应，使得一个时钟脉冲作用期间触发器多次翻转</li></ul></li></ul></li></ul><p>空翻将造成状态的不确定和系统工作的混乱，这是不允许的</p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路险象</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E9%99%A9%E8%B1%A1/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E9%99%A9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="组合逻辑电路中的险象"><a href="#组合逻辑电路中的险象" class="headerlink" title="组合逻辑电路中的险象"></a>组合逻辑电路中的险象</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>信号经过任何逻辑门和导线都会产生时间延迟<ul><li>当电路所有输入达到稳定状态时，输出并不是立即达到稳定状态</li><li>延迟时间<ul><li>与信号经过的门的级数有关</li><li>与具体逻辑门的时延大小有关</li><li>与导线的长短有关</li></ul></li><li>延迟时间对数字系统是一个有害的因素<ul><li>使得系统操作速度下降</li><li>引出电路中信号的波形参数变坏</li><li>产生竞争险象</li></ul></li></ul></li><li>竞争<ul><li>由于延迟时间的影响，输入信号经过不同路径到达输出端的时间有先有后的现象</li><li>广义理解：多个信号到达某一点有时差的现象</li><li>竞争的类型<ul><li>非临界竞争：不产生错误输出的竞争</li><li>临界竞争：导致错误输出的竞争</li></ul></li></ul></li><li>险象<ul><li>由竞争导致的错误输出信号<ul><li>组合电路中的险象是一种瞬态现象</li><li>表现为在输出端产生不应有的尖脉冲，暂时地破坏正常逻辑关系</li><li>一旦瞬态过程结束，即可恢复正常逻辑关系</li></ul></li><li>险象分类<ul><li>静态险象：输入变化而输出不应发生变化的情况下，输出端产生的短暂错误输出</li><li>动态险象：在输入变化而输出应该发生变化的情况下，输出在变化过程中产生的短暂的错误输出</li><li>按错误输出脉冲信号的极性划分<ul><li>错误输出信号为负脉冲（0型险象）</li><li>错误输出信号为正脉冲（1型险象）</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251227911.png"></li></ul></li></ul></li></ul><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251222912.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251223478.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251223015.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251224198.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251224711.png"></p><h2 id="险象的判断"><a href="#险象的判断" class="headerlink" title="险象的判断"></a>险象的判断</h2><p>卡诺图法和代数法</p><h3 id="代数法"><a href="#代数法" class="headerlink" title="代数法"></a>代数法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210932027.png"></p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221200831.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221200684.png"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201503.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201279.png"></p><h3 id="卡诺图法"><a href="#卡诺图法" class="headerlink" title="卡诺图法"></a>卡诺图法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221201026.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209221206150.png"></p><p><strong>注意：判断组合逻辑电路中的竞争和险象时，一定不能改变电路的结构，即不对原来的电路做任何的化简、变换等</strong></p><h2 id="险象的消除"><a href="#险象的消除" class="headerlink" title="险象的消除"></a>险象的消除</h2><h3 id="增加冗余项法"><a href="#增加冗余项法" class="headerlink" title="增加冗余项法"></a>增加冗余项法</h3><p>或上冗余的与项<br>与上冗余的或项</p><p>代数法&#x2F;卡诺图法</p><h4 id="例（代数法）"><a href="#例（代数法）" class="headerlink" title="例（代数法）"></a>例（代数法）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630116.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630288.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261630070.png"></p><h4 id="卡诺图法-1"><a href="#卡诺图法-1" class="headerlink" title="卡诺图法"></a>卡诺图法</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261631128.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261631075.png"></p><h4 id="例（卡诺图法）"><a href="#例（卡诺图法）" class="headerlink" title="例（卡诺图法）"></a>例（卡诺图法）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261632893.png"></p><p><strong>注意：用增加冗余项的方法消除险象时，一定不能改变电路的功能，即增加冗余项后电路的真值表不会发生改变</strong></p><h3 id="增加惯性延时环节法"><a href="#增加惯性延时环节法" class="headerlink" title="增加惯性延时环节法"></a>增加惯性延时环节法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634006.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634308.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634516.png"></p><h3 id="选通法"><a href="#选通法" class="headerlink" title="选通法"></a>选通法</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261634582.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209261635125.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路设计</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="组合逻辑电路设计"><a href="#组合逻辑电路设计" class="headerlink" title="组合逻辑电路设计"></a>组合逻辑电路设计</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241825036.png"></p><ul><li>分析设计要求</li><li>列出真值表</li><li>得到最简逻辑表达式</li><li>表达式变换</li><li>修正表达式</li><li>得到逻辑电路图</li></ul><h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><ul><li>正确理解要求</li><li>确定电路的输入和输出</li><li>确定函数与变量之间的逻辑关系</li></ul><h3 id="例1：设计三变量“多数表决电路”"><a href="#例1：设计三变量“多数表决电路”" class="headerlink" title="例1：设计三变量“多数表决电路”"></a>例1：设计三变量“多数表决电路”</h3><ul><li>定义：三变量多数表决电路是指三个人对一件事进行表决，根据大家投票的结果来决定这件事的最终结果</li><li>分析<ul><li>输入：A、B、C为代表参加表决的三个成员，0表示反对，1表示赞成</li><li>输出：F：表决结果，0表示决议被否定，1表示决议通过</li><li>逻辑关系：当3个变量中有两个及以上取值为1时，函数F的值为1，其它情况下F的值为0</li></ul></li></ul><h4 id="真值表-逻辑表达式"><a href="#真值表-逻辑表达式" class="headerlink" title="真值表+逻辑表达式"></a>真值表+逻辑表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241830432.png"></p><h4 id="函数化简-器件选择"><a href="#函数化简-器件选择" class="headerlink" title="函数化简+器件选择"></a>函数化简+器件选择</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191632069.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241830926.png"></p><h4 id="逻辑电路图"><a href="#逻辑电路图" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p>用与非门实现<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241831005.png"></p><h3 id="例2：设计一个比较两个三位二进制数是否相等的数值比较器"><a href="#例2：设计一个比较两个三位二进制数是否相等的数值比较器" class="headerlink" title="例2：设计一个比较两个三位二进制数是否相等的数值比较器"></a>例2：设计一个比较两个三位二进制数是否相等的数值比较器</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li>输入：<ul><li>A &#x3D; a0a1a2, B &#x3D; b0b1b2</li><li>6个输入变量</li></ul></li><li>输出：<ul><li>F：比较结构</li><li>当A&#x3D;B时，F为1，否则F为0</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241835015.png"></p><h4 id="逻辑电路图-1"><a href="#逻辑电路图-1" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241836396.png"><br>三个异或门和一个或非门</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>真值表法<ul><li>优点：规整、清晰</li><li>缺点：不方便，尤其当变量较多时十分麻烦</li></ul></li><li>分析法<ul><li>通过对设计要求的分析、理解，直接写出逻辑表达式</li></ul></li></ul><h2 id="包含无关条件的组合逻辑电路设计"><a href="#包含无关条件的组合逻辑电路设计" class="headerlink" title="包含无关条件的组合逻辑电路设计"></a>包含无关条件的组合逻辑电路设计</h2><ul><li>无关最小项<ul><li>由于输入变量之间存在的相互制约，问题的某种特殊限定，使得逻辑函数与输入变量的某些取值组合无关，这些取值组合称为无关最小项，也叫无关项，任意项</li><li>描述包含无关条件的逻辑问题的逻辑函数称为包含无关条件的逻辑函数</li></ul></li></ul><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241840396.png"></p><ul><li>分析<ul><li>只能取值：000，001，010，100</li><li>不允许出现：011，101，110，111</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191650832.png"></li><li>包含无关条件的逻辑函数</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201049010.png"></p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201049013.png"></p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>输入：4个<br>输出：4个<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201050121.png"></p><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241841489.png"></p><p><strong>如何由真值表求得逻辑函数表达式？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209201125808.png"><br>找输出端的1，对应的输入相乘，再把每一个相加，就是逻辑函数表达式<br>或者找输出端的0，对应的输入相加，再把每一项相乘</p><h4 id="表达式化简"><a href="#表达式化简" class="headerlink" title="表达式化简"></a>表达式化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241841445.png"></p><p>左图是普通的卡诺图化简，右图是用d把无关最小项表示了出来，因为它无关，所以取0取1都没关系，为了化简方便，我们给它取1，然后再圈出卡诺圈化简，发现得到的函数表达式简单了不少</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842385.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842972.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842183.png"></p><h4 id="逻辑电路图-2"><a href="#逻辑电路图-2" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241842741.png"></p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241843960.png"></p><ul><li>分析<ul><li>输入变量：ABCD</li><li>输出函数：F</li><li>逻辑关系：当ABCD表示的十进制数为合数(4、6、8、9)时，输出F为1，否则F为0</li><li>无关项：0000、0001、0010、1101、1110、1111</li></ul></li></ul><h4 id="真值表-1"><a href="#真值表-1" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241845454.png"></p><h4 id="表达式化简-1"><a href="#表达式化简-1" class="headerlink" title="表达式化简"></a>表达式化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846423.png"></p><h4 id="表达式变换"><a href="#表达式变换" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846951.png"></p><h4 id="逻辑电路图-3"><a href="#逻辑电路图-3" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241846105.png"></p><h2 id="多输出函数的组合逻辑电路设计"><a href="#多输出函数的组合逻辑电路设计" class="headerlink" title="多输出函数的组合逻辑电路设计"></a>多输出函数的组合逻辑电路设计</h2><ul><li>由同一组输入变量产生多个输出函数</li><li>应该将多个输出函数当作一个整体考虑，而不应该将其截然分开</li><li>关键：在函数化简时找出各输出函数的公用项，实现对逻辑门的共享</li></ul><h3 id="例子：设计一个全加器"><a href="#例子：设计一个全加器" class="headerlink" title="例子：设计一个全加器"></a>例子：设计一个全加器</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241858665.png"></p><ul><li><p>全加器可以用于实现两个n尾数相加<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241903918.png"></p></li><li><p>分析</p><ul><li>输入端：<ul><li>Ai：被加数</li><li>Bi：加数</li><li>Ci-1：来自低位的进位输入</li></ul></li><li>输出端<ul><li>Si：本位和</li><li>Ci：向高位的进位</li></ul></li></ul></li></ul><h4 id="真值表-2"><a href="#真值表-2" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241903645.png"></p><h4 id="函数化简"><a href="#函数化简" class="headerlink" title="函数化简"></a>函数化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241904386.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241904066.png"></p><h4 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905696.png"></p><h4 id="函数化简-1"><a href="#函数化简-1" class="headerlink" title="函数化简"></a>函数化简</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905944.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241905997.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241915420.png"></p><p>多输出组合逻辑电路达到最简的关键是在函数化简时找到各输出函数的公用项，以便在逻辑电路中实现对逻辑门的共享 </p><h4 id="电路图-1"><a href="#电路图-1" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241916670.png"></p><h3 id="例子：设计一个乘法器，用于产生两个2位二进制数相乘的积"><a href="#例子：设计一个乘法器，用于产生两个2位二进制数相乘的积" class="headerlink" title="例子：设计一个乘法器，用于产生两个2位二进制数相乘的积"></a>例子：设计一个乘法器，用于产生两个2位二进制数相乘的积</h3><ul><li>分析<ul><li>输入：A1A0和B1B0</li><li>输出函数：4<ul><li>Max（A1A0）&#x3D; 11  Max（B1B0）&#x3D; 11</li><li>Max（A1A0xB1B0）&#x3D; 1011</li><li>相乘的积为M3M2M1M0</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251015731.png"></p><h4 id="真值表-3"><a href="#真值表-3" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251023898.png"></p><h4 id="表达式变换-1"><a href="#表达式变换-1" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024596.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024133.png"></p><h4 id="电路图-2"><a href="#电路图-2" class="headerlink" title="电路图"></a>电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251024192.png"></p><h4 id="用全加器如何实现？"><a href="#用全加器如何实现？" class="headerlink" title="用全加器如何实现？"></a>用全加器如何实现？</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251025693.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251025509.png"></p><h2 id="无反变量提供的组合逻辑电路设计"><a href="#无反变量提供的组合逻辑电路设计" class="headerlink" title="无反变量提供的组合逻辑电路设计"></a>无反变量提供的组合逻辑电路设计</h2><ul><li>问题提出（为什么有这个东西？）<ul><li>为了减少各部件之间的连线，在某些问题的设计中，不提供反变量</li><li>若直接用非门将原变量转换成相应的反变量，则处理结果往往是不经济的</li><li>通常进行适当的变换，以便在无反变量提供的前提下，尽可能减少非门数量，使逻辑电路尽可能的简化</li></ul></li></ul><h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251031672.png"></p><ul><li>分析<ul><li>F已经是最简的“与-或“表达式，可直接变换成“与非-与非”表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251033415.png"></li></ul></li></ul><h4 id="逻辑电路图-4"><a href="#逻辑电路图-4" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251033919.png"></p><h4 id="对函数F表达式整理变换"><a href="#对函数F表达式整理变换" class="headerlink" title="对函数F表达式整理变换"></a>对函数F表达式整理变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251034854.png"></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251034826.png"></p><h3 id="例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容"><a href="#例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容" class="headerlink" title="例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容"></a>例2：设计一个组合逻辑电路，用来判断献血者与受血者血型是否相容</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251042018.png"></p><ul><li>分析<ul><li>电路输入变量为献血者和受血者血型</li><li>血型共4种 <ul><li>可以用两个变量的4种编码进行区分</li><li>WX表现献血者血型，YZ表示受血者血型</li></ul></li></ul></li></ul><h4 id="血型编码"><a href="#血型编码" class="headerlink" title="血型编码"></a>血型编码</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251046277.png"></p><h4 id="电路输出用F表示"><a href="#电路输出用F表示" class="headerlink" title="电路输出用F表示"></a>电路输出用F表示</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049530.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049491.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251049919.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251050103.png"></p><h4 id="逻辑电路图-5"><a href="#逻辑电路图-5" class="headerlink" title="逻辑电路图"></a>逻辑电路图</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207251050665.png"></p><h4 id="怎么让电路图更简单呢？"><a href="#怎么让电路图更简单呢？" class="headerlink" title="怎么让电路图更简单呢？"></a>怎么让电路图更简单呢？</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844664.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844722.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210844771.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845072.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845845.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209210845235.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合逻辑电路的分类及其分析</title>
    <link href="/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/25/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="逻辑电路的分类（按照对电路的记忆）"><a href="#逻辑电路的分类（按照对电路的记忆）" class="headerlink" title="逻辑电路的分类（按照对电路的记忆）"></a>逻辑电路的分类（按照对电路的记忆）</h2><ul><li>组合逻辑电路<ul><li>电路输出仅取决于当时的输入，而与过去的输入情况无关</li><li>可以完成各种复杂的逻辑功能</li><li>是时序逻辑电路的组成部分</li></ul></li><li>时序逻辑电路<ul><li>电路输出不仅取决于当时的输入，而且也与过去的输入情况有关，即与过去的电路状态有关</li></ul></li></ul><h3 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h3><h4 id="一般结构"><a href="#一般结构" class="headerlink" title="一般结构"></a>一般结构</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241715622.png"></p><h4 id="组合逻辑电路特点"><a href="#组合逻辑电路特点" class="headerlink" title="组合逻辑电路特点"></a>组合逻辑电路特点</h4><ul><li>由逻辑门电路组成</li><li>不包含任何记忆元件</li><li>信号是单向传输的，不存在反馈电路</li></ul><h3 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h3><ul><li>若逻辑电路在任何时刻产生的稳定输出信号不仅与电路该时刻的输入信号有关还与电路过去的输入信号有关，则称为时序逻辑电路<ul><li>比如电话，电子密码锁这样的</li></ul></li></ul><h4 id="一般结构-1"><a href="#一般结构-1" class="headerlink" title="一般结构"></a>一般结构</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241732878.png"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>电路由组合电路和存储电路组成，具有对过去输入进行记忆的功能</li><li>电路中包含反馈回路，通过反馈是电路功能与时序相关</li><li>电路的输出由电路当时的输入和状态共同决定</li></ul><h4 id="分类（按照电路的工作方式）"><a href="#分类（按照电路的工作方式）" class="headerlink" title="分类（按照电路的工作方式）"></a>分类（按照电路的工作方式）</h4><ul><li>同步时序逻辑电路<ul><li>电路中有统一的定时信号，存储器件采用时钟控制触发器，电路状态在时钟脉冲控制下同时发生转换</li></ul></li><li>异步时序逻辑电路<ul><li>电路汇总没有统一的时钟信号同步，电路输入信号的变化将直接导致电路状态的变化</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241742394.png"></p><h2 id="组合逻辑电路的分析"><a href="#组合逻辑电路的分析" class="headerlink" title="组合逻辑电路的分析"></a>组合逻辑电路的分析</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>画&#x2F;看逻辑电路图找出电路的输入、输出</li><li>写出输出逻辑函数表达式<ul><li>根据电路逐级写出各门的输出表达式，直至写出整个电路的输出逻辑表达式</li></ul></li><li>表达式化简</li><li>画出真值表</li><li>分析逻辑功能</li><li>改进电路</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241815864.png"></p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241817244.png"></p><p>三个输入A B C<br>一个输出F<br>七个与非门</p><h4 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241817680.png"></p><h4 id="逻辑功能"><a href="#逻辑功能" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p>ABC 的输入相同时，输出为0，输入不同时，输出为1.此电路逻辑功能为三变量非一致电路</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241818293.png"><br>一个非门<br>一个或门<br>四个与非门</p><h4 id="表达式-1"><a href="#表达式-1" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241818421.png"><br>A异或B或上A异或C</p><h4 id="真值表-1"><a href="#真值表-1" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819550.png"></p><h4 id="逻辑功能-1"><a href="#逻辑功能-1" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p>仍是三变量非一致电路</p><h4 id="改进电路"><a href="#改进电路" class="headerlink" title="改进电路"></a>改进电路</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819507.png"></p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>**<img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241819630.png"></p><h4 id="表达式-2"><a href="#表达式-2" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820248.png"></p><h4 id="真值表-2"><a href="#真值表-2" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820115.png"></p><h4 id="逻辑功能-2"><a href="#逻辑功能-2" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p><strong>半加器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241820531.png"></p><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241821866.png"><br>或门和异或门</p><h4 id="表达式-3"><a href="#表达式-3" class="headerlink" title="表达式"></a>表达式</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822156.png"></p><h4 id="表达式变换"><a href="#表达式变换" class="headerlink" title="表达式变换"></a>表达式变换</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822649.png"></p><h4 id="真值表-3"><a href="#真值表-3" class="headerlink" title="真值表"></a>真值表</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822587.png"></p><h4 id="逻辑功能-3"><a href="#逻辑功能-3" class="headerlink" title="逻辑功能"></a>逻辑功能</h4><p><strong>二进制变补器</strong><br><strong>16变补器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241822920.png"></p>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>组合逻辑电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本概念和基本R-S结构</title>
    <link href="/2022/07/24/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%ACR-S%E7%BB%93%E6%9E%84/"/>
    <url>/2022/07/24/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%ACR-S%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="触发器结构"><a href="#触发器结构" class="headerlink" title="触发器结构"></a>触发器结构</h2><ul><li>有两个互补的输出端Q和“非Q”</li><li>有两个稳定状态1和0<ul><li>1状态：Q&#x3D;1    非Q&#x3D;0</li><li>0状态：Q&#x3D;0   非Q&#x3D;1</li></ul></li><li>输入信号不发生变化时， 触发器状态稳定不变</li><li>在一定输入信号作用下，触发器可以从一个稳定状态转移到另一个稳定状态，输入信号撤销后，保持新的状态不变</li></ul><h2 id="触发器状态"><a href="#触发器状态" class="headerlink" title="触发器状态"></a>触发器状态</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261722903.png"></p><h2 id="触发器常用描述方法"><a href="#触发器常用描述方法" class="headerlink" title="触发器常用描述方法"></a>触发器常用描述方法</h2><ul><li>功能表</li><li>状态表</li><li>状态图</li><li>次态方程</li><li>激励表</li><li>卡诺图</li></ul><h3 id="功能表"><a href="#功能表" class="headerlink" title="功能表"></a>功能表</h3><p>反映了触发器在不同输入下对应的表格</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261725285.png"><br>不定，是说明不允许这种输入</p><h3 id="状态表"><a href="#状态表" class="headerlink" title="状态表"></a>状态表</h3><p>反映了触发器在输入作用下现态和次态之间的转移关系</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261726923.png"></p><h3 id="激励表"><a href="#激励表" class="headerlink" title="激励表"></a>激励表</h3><p>反映了触发器从现态Q转移到某种次态时，对输入信号的要求</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261727016.png"></p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><ul><li>反映触发器两种状态之间转移关系的有向图 </li><li>圆圈表示稳定状态</li><li>有向线段表示状态转移的方向<ul><li>起点：现态</li><li>终点：次态</li><li>触发条件</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261740349.png"><br>两个稳定状态：0和1</p><h3 id="卡诺图"><a href="#卡诺图" class="headerlink" title="卡诺图"></a>卡诺图</h3><p>根据触发器的功能表或状态表所得到的反映触发器次态和现态以及输入关系的卡诺图</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261741176.png"></p><h3 id="次态方程"><a href="#次态方程" class="headerlink" title="次态方程"></a>次态方程</h3><p>反映触发器次态和现态以及输入关系的表达式（常与约束方程一起使用）</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207261742329.png"></p><h2 id="基本R-S触发器"><a href="#基本R-S触发器" class="headerlink" title="基本R-S触发器"></a>基本R-S触发器</h2><h3 id="与非门构成的基本R-S触发器"><a href="#与非门构成的基本R-S触发器" class="headerlink" title="与非门构成的基本R-S触发器"></a>与非门构成的基本R-S触发器</h3><p>两个与非门和两根反馈线耦合而成</p><ul><li>直接复位置位触发器</li><li>构成各种功能触发器的基本部件</li><li>R：置0端或者复位端</li><li>S：置1端或置位端</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270834974.png"></p><h4 id="RS-x3D-11"><a href="#RS-x3D-11" class="headerlink" title="RS&#x3D;11"></a>RS&#x3D;11</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270835009.png"></p><h4 id="RS-x3D-01"><a href="#RS-x3D-01" class="headerlink" title="RS&#x3D;01"></a>RS&#x3D;01</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270836978.png"></p><h4 id="RS-x3D-10"><a href="#RS-x3D-10" class="headerlink" title="RS&#x3D;10"></a>RS&#x3D;10</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270837587.png"></p><h4 id="RS-x3D-00"><a href="#RS-x3D-00" class="headerlink" title="RS&#x3D;00"></a>RS&#x3D;00</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270837625.png"></p><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280832129.png"></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><h5 id="功能表-状态表"><a href="#功能表-状态表" class="headerlink" title="功能表+状态表"></a>功能表+状态表</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853274.png"><br>d表示不确定</p><h5 id="激励表-1"><a href="#激励表-1" class="headerlink" title="激励表"></a>激励表</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853981.png"></p><h5 id="次态方程（重要点）"><a href="#次态方程（重要点）" class="headerlink" title="次态方程（重要点）"></a>次态方程（重要点）</h5><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270853185.png"></p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>当与非门构成的基本R-S触发器的同一输入端连续出现多个负脉冲信号，仅第一个使触发器状态发生改变</li><li>可以用来消除毛刺</li></ul><h3 id="或非门构成的基本R-S触发器"><a href="#或非门构成的基本R-S触发器" class="headerlink" title="或非门构成的基本R-S触发器"></a>或非门构成的基本R-S触发器</h3><p>两个或非门与两根反馈线耦合而成</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270858725.png"></p><h4 id="RS-x3D-00-1"><a href="#RS-x3D-00-1" class="headerlink" title="RS&#x3D;00"></a>RS&#x3D;00</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270858912.png"></p><h4 id="RS-x3D-01-1"><a href="#RS-x3D-01-1" class="headerlink" title="RS&#x3D;01"></a>RS&#x3D;01</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859900.png"></p><h4 id="RS-x3D-10-1"><a href="#RS-x3D-10-1" class="headerlink" title="RS&#x3D;10"></a>RS&#x3D;10</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859879.png"></p><h4 id="RS-x3D-11-1"><a href="#RS-x3D-11-1" class="headerlink" title="RS&#x3D;11"></a>RS&#x3D;11</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270859918.png"></p><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280857367.png"></p><h4 id="描述（重点注意次态方程和约束方程）"><a href="#描述（重点注意次态方程和约束方程）" class="headerlink" title="描述（重点注意次态方程和约束方程）"></a>描述（重点注意次态方程和约束方程）</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900970.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900245.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207270900132.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209280903090.png"></p><ul><li><p>与非门构成的，输入端加圈，只有R、S等于0时，才可以改变状态，因此称对低电平有效</p></li><li><p>而或非门构成的，输入端没有加圈只有R、S等于1时，才可以改变状态，因此称对高电平有效</p></li><li><p>优点（两种共有的优点）</p><ul><li>结构简单</li><li>可作为记忆元件独立使用</li><li>被作为各种性能完善的触发器的基本组成部分<ul><li>具有直接复位、置位的功能</li></ul></li></ul></li><li><p>缺点</p><ul><li>R、S之间具有约束关系</li><li>不能进行定时控制</li><li>使用受到一定限制</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>触发器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路径问题</title>
    <link href="/2022/07/24/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/24/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="最短路径问题的抽象"><a href="#最短路径问题的抽象" class="headerlink" title="最短路径问题的抽象"></a>最短路径问题的抽象</h1><ul><li><p>在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径</p><ul><li>这条路径就是两点之间的最短路径</li><li>第一个顶点为源点</li><li>最后一个顶点为终点</li></ul></li><li><p>问题分类</p><ul><li>单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径<ul><li>（有向）无权图</li><li>（有向）有权图</li></ul></li><li>多源最短路径问题：求任意两顶点间的最短路径</li></ul></li></ul><h1 id="实现的算法"><a href="#实现的算法" class="headerlink" title="实现的算法"></a>实现的算法</h1><h2 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h2><ul><li>无权图的单源最短路算法<ul><li>按照递增（非递减）的顺序找到各个顶点的最短路</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241414319.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241414328.png"></li></ul></li></ul><h2 id="有权图的单源最短路算法"><a href="#有权图的单源最短路算法" class="headerlink" title="有权图的单源最短路算法"></a>有权图的单源最短路算法</h2><ul><li>有权图的单源最短路算法<ul><li>按照递增的顺序找出到各个顶点的最短路</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241415387.png"></li><li>Dijkstra算法<ul><li>令S&#x3D;{源点s + 已经确定了最短路径的顶点Vi}</li><li>对任意未收录的顶点v，定义dist[v]为s到b的最短路径长度，但该路径仅经过S中的顶点。</li><li>若路径是按照递增（非递减）的顺序生成的，则<ul><li>真正的最短路必须只经过s中的顶点</li><li>每次从未收录的顶点中选一个dist最小的收录（贪心）</li><li>增加一个v进入s，可能影响另外一个w的dist值<ul><li>dist[w] &#x3D; min{ dist[w],dist[v] +&lt;v,w&gt;的权重) }</li></ul></li></ul></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241421373.png"></p><ul><li>有权图的单源最短路径算法<ul><li><p>方法一：直接扫描所有为收录顶点</p><ul><li>对于稠密图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425725.png"></li></ul></li><li><p>方法二：将dist存在最小堆中</p><ul><li>对于稀疏图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425297.png"></li></ul></li></ul></li></ul><h2 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h2><ul><li><p>多源最短路算法</p><ul><li><p>方法一：直接将单源最短路算法调用|V|遍</p><ul><li>对于稀疏图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425954.png"></li></ul></li><li><p>方法二：Floyd算法</p><ul><li>对于稠密图效果好</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241425387.png"></li></ul></li></ul></li><li><p>Floyd算法</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241427841.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241428522.png"></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="邻接表存储-无权图的单源最短路算法"><a href="#邻接表存储-无权图的单源最短路算法" class="headerlink" title="邻接表存储 - 无权图的单源最短路算法"></a>邻接表存储 - 无权图的单源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接表存储 - 无权图的单源最短路算法 */</span> <br><br><span class="hljs-comment">/* dist[]和path[]全部初始化为-1 */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Unweighted</span> <span class="hljs-params">( LGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> path[], Vertex S )</span> <br>&#123;     <br>Queue Q;     <br>Vertex V;     <br>PtrToAdjVNode W;          <br>Q = CreateQueue( Graph-&gt;Nv ); <span class="hljs-comment">/* 创建空队列, MaxSize为外部定义的常数 */</span>     <br>dist[S] = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 初始化源点 */</span>     <br>AddQ (Q, S);     <br><br><span class="hljs-keyword">while</span>( !IsEmpty(Q) )&#123;         <br>V = DeleteQ(Q);         <br><span class="hljs-keyword">for</span> ( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="hljs-comment">/* 对V的每个邻接点W-&gt;AdjV */</span>             <span class="hljs-keyword">if</span> ( dist[W-&gt;AdjV]==<span class="hljs-number">-1</span> ) &#123; <span class="hljs-comment">/* 若W-&gt;AdjV未被访问过 */</span>                 <br>        dist[W-&gt;AdjV] = dist[V]+<span class="hljs-number">1</span>; <span class="hljs-comment">/* W-&gt;AdjV到S的距离更新 */</span>     path[W-&gt;AdjV] = V; <span class="hljs-comment">/* 将V记录在S到W-&gt;AdjV的路径上 */</span>       AddQ(Q, W-&gt;AdjV);             <br>&#125;     <br>&#125; <span class="hljs-comment">/* while结束*/</span><br> &#125;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵存储-有权图的单源最短路算法"><a href="#邻接矩阵存储-有权图的单源最短路算法" class="headerlink" title="邻接矩阵存储 - 有权图的单源最短路算法"></a>邻接矩阵存储 - 有权图的单源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储 - 有权图的单源最短路算法 */</span> <br><br>Vertex <span class="hljs-title function_">FindMinDist</span><span class="hljs-params">( MGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> collected[] )</span> <br>&#123; <span class="hljs-comment">/* 返回未被收录顶点中dist最小者 */</span>     <br>Vertex MinV, V;     <br><span class="hljs-type">int</span> MinDist = INFINITY;     <br><br><span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++) &#123;         <span class="hljs-keyword">if</span> ( collected[V]==<span class="hljs-literal">false</span> &amp;&amp; dist[V]&lt;MinDist) &#123;             <span class="hljs-comment">/* 若V未被收录，且dist[V]更小 */</span>             MinDist = dist[V]; <span class="hljs-comment">/* 更新最小距离 */</span>             MinV = V; <span class="hljs-comment">/* 更新对应顶点 */</span>         <br>    &#125;     <br>&#125;     <br><span class="hljs-keyword">if</span> (MinDist &lt; INFINITY) <span class="hljs-comment">/* 若找到最小dist */</span>         <span class="hljs-keyword">return</span> MinV; <span class="hljs-comment">/* 返回对应的顶点下标 */</span>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">/* 若这样的顶点不存在，返回错误标记 */</span> &#125; <br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Dijkstra</span><span class="hljs-params">( MGraph Graph, <span class="hljs-type">int</span> dist[], <span class="hljs-type">int</span> path[], Vertex S )</span> <br>&#123;     <br>    <span class="hljs-type">int</span> collected[MaxVertexNum];     <br>    Vertex V, W;     <br>    <span class="hljs-comment">/* 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示 */</span>     <span class="hljs-keyword">for</span> ( V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++ ) &#123;         dist[V] = Graph-&gt;G[S][V];         <br>        <span class="hljs-keyword">if</span> ( dist[V]&lt;INFINITY )             <br>        path[V] = S;         <br>        <span class="hljs-keyword">else</span>             <br>        path[V] = <span class="hljs-number">-1</span>;         <br>    collected[V] = <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-comment">/* 先将起点收入集合 */</span>     <br>dist[S] = <span class="hljs-number">0</span>;     <br>collected[S] = <span class="hljs-literal">true</span>;     <br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;         <br><span class="hljs-comment">/* V = 未被收录顶点中dist最小者 */</span>         V = FindMinDist( Graph, dist, collected );         <span class="hljs-keyword">if</span> ( V==ERROR ) <span class="hljs-comment">/* 若这样的V不存在 */</span>             <span class="hljs-keyword">break</span>;      <span class="hljs-comment">/* 算法结束 */</span>         collected[V] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">/* 收录V */</span>         <span class="hljs-keyword">for</span>( W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="hljs-comment">/* 对图中的每个顶点W */</span>             <br><span class="hljs-comment">/* 若W是V的邻接点并且未被收录 */</span>             <span class="hljs-keyword">if</span> ( collected[W]==<span class="hljs-literal">false</span> &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;                 <br><span class="hljs-keyword">if</span> ( Graph-&gt;G[V][W]&lt;<span class="hljs-number">0</span> ) <span class="hljs-comment">/* 若有负边 */</span>                     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 不能正确解决，返回错误标记 */</span>                 <br><span class="hljs-comment">/* 若收录V使得dist[W]变小 */</span>                 <br><span class="hljs-keyword">if</span> ( dist[V]+Graph-&gt;G[V][W] &lt; dist[W] ) &#123;                     dist[W] = dist[V]+Graph-&gt;G[V][W]; <span class="hljs-comment">/* 更新dist[W] */</span>                     path[W] = V; <span class="hljs-comment">/* 更新S到W的路径 */</span>                 &#125;             &#125;     <br>&#125; <span class="hljs-comment">/* while结束*/</span>    <br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br> <span class="hljs-comment">/* 算法执行完毕，返回正确标记 */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="邻接矩阵存储-多源最短路算法"><a href="#邻接矩阵存储-多源最短路算法" class="headerlink" title="邻接矩阵存储 - 多源最短路算法"></a>邻接矩阵存储 - 多源最短路算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储 - 多源最短路算法 */</span> <br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Floyd</span><span class="hljs-params">( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )</span> <br>&#123;     <br>Vertex i, j, k;     <span class="hljs-comment">/* 初始化 */</span>     <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Nv; i++ )         <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;Graph-&gt;Nv; j++ ) &#123;            <br> D[i][j] = Graph-&gt;G[i][j];             path[i][j] = <span class="hljs-number">-1</span>;         <br> &#125;     <br><span class="hljs-keyword">for</span>( k=<span class="hljs-number">0</span>; k&lt;Graph-&gt;Nv; k++ )         <span class="hljs-keyword">for</span>( i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Nv; i++ )             <span class="hljs-keyword">for</span>( j=<span class="hljs-number">0</span>; j&lt;Graph-&gt;Nv; j++ )                 <span class="hljs-keyword">if</span>( D[i][k] + D[k][j] &lt; D[i][j] ) &#123;                     D[i][j] = D[i][k] + D[k][j];                     <span class="hljs-keyword">if</span> ( i==j &amp;&amp; D[i][j]&lt;<span class="hljs-number">0</span> ) <span class="hljs-comment">/* 若发现负值圈 */</span>                         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">/* 不能正确解决，返回错误标记 */</span>                     path[i][j] = k;                 &#125;     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br><span class="hljs-comment">/* 算法执行完毕，返回正确标记 */</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡二叉树</title>
    <link href="/2022/07/24/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/07/24/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是平衡二叉树"><a href="#什么是平衡二叉树" class="headerlink" title="什么是平衡二叉树"></a>什么是平衡二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241012577.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241015263.png"><br><strong>判断关键，任一结点左右子树高度差的绝对值是否超过1</strong></p><h2 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h2><h3 id="RR旋转（右单旋）"><a href="#RR旋转（右单旋）" class="headerlink" title="RR旋转（右单旋）"></a>RR旋转（右单旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241018029.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241018405.png"></p><h3 id="LL旋转（左单旋）"><a href="#LL旋转（左单旋）" class="headerlink" title="LL旋转（左单旋）"></a>LL旋转（左单旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241020782.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241021910.png"></p><h3 id="LR旋转（左-右双旋）"><a href="#LR旋转（左-右双旋）" class="headerlink" title="LR旋转（左-右双旋）"></a>LR旋转（左-右双旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241022482.png"><br>中间图的OR表示两种情况：<br>一种情况是C为发现者<br>另一种是$C_L$为发现者<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241025084.png"></p><h3 id="RL旋转（右-左双旋）"><a href="#RL旋转（右-左双旋）" class="headerlink" title="RL旋转（右-左双旋）"></a>RL旋转（右-左双旋）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241026477.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241026015.png"></p><p>注意：<br><strong>有时插入元素不需要调整结构，但一些平衡因子需要重新计算</strong></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h3 id="AVL树的旋转与插入"><a href="#AVL树的旋转与插入" class="headerlink" title="AVL树的旋转与插入"></a>AVL树的旋转与插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span> *<span class="hljs-title">Position</span>;</span> <br><span class="hljs-keyword">typedef</span> Position AVLTree; <span class="hljs-comment">/* AVL树类型 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span>&#123;</span>     <br>ElementType Data; <span class="hljs-comment">/* 结点数据 */</span>     <br>AVLTree Left;     <span class="hljs-comment">/* 指向左子树 */</span>     <br>AVLTree Right;    <span class="hljs-comment">/* 指向右子树 */</span>     <br><span class="hljs-type">int</span> Height;       <span class="hljs-comment">/* 树高 */</span> <br>&#125;; <br><span class="hljs-type">int</span> <span class="hljs-title function_">Max</span> <span class="hljs-params">( <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b )</span> <br>&#123;     <br><span class="hljs-keyword">return</span> a &gt; b ? a : b; <br>&#125;<br>AVLTree <span class="hljs-title function_">SingleLeftRotation</span> <span class="hljs-params">( AVLTree A )</span> <br>&#123; <span class="hljs-comment">/* 注意：A必须有一个左子结点B */</span>   <br>  <span class="hljs-comment">/* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */</span>          AVLTree B = A-&gt;Left;     <br>    A-&gt;Left = B-&gt;Right;     <br>    B-&gt;Right = A;     <br>    A-&gt;Height = Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + <span class="hljs-number">1</span>;     B-&gt;Height = Max( GetHeight(B-&gt;Left), A-&gt;Height ) + <span class="hljs-number">1</span>;       <span class="hljs-keyword">return</span> B; <br>&#125;<br><br>AVLTree <span class="hljs-title function_">DoubleLeftRightRotation</span> <span class="hljs-params">( AVLTree A )</span> <br>&#123; <span class="hljs-comment">/* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */</span>   <br>  <span class="hljs-comment">/* 将A、B与C做两次单旋，返回新的根结点C */</span>          <br>  <br>  <span class="hljs-comment">/* 将B与C做右单旋，C被返回 */</span>     <br>  A-&gt;Left = SingleRightRotation(A-&gt;Left);     <br>  <span class="hljs-comment">/* 将A与C做左单旋，C被返回 */</span>     <br>  <span class="hljs-keyword">return</span> SingleLeftRotation(A); <br>&#125; <br><br><br>AVLTree <span class="hljs-title function_">Insert</span><span class="hljs-params">( AVLTree T, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 将X插入AVL树T中，并且返回调整后的AVL树 */</span>     <br><span class="hljs-keyword">if</span> ( !T ) &#123; <span class="hljs-comment">/* 若插入空树，则新建包含一个结点的树 */</span>         T = (AVLTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AVLNode));         <br>T-&gt;Data = X;         <br>T-&gt;Height = <span class="hljs-number">0</span>;         <br>T-&gt;Left = T-&gt;Right = <span class="hljs-literal">NULL</span>;     <br>&#125; <span class="hljs-comment">/* if (插入空树) 结束 */</span>     <br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( X &lt; T-&gt;Data ) &#123;         <br><span class="hljs-comment">/* 插入T的左子树 */</span>         <br>T-&gt;Left = Insert( T-&gt;Left, X);         <br><span class="hljs-comment">/* 如果需要左旋 */</span>         <br><span class="hljs-keyword">if</span> ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == <span class="hljs-number">2</span> )             <span class="hljs-keyword">if</span> ( X &lt; T-&gt;Left-&gt;Data )                 T = SingleLeftRotation(T);      <span class="hljs-comment">/* 左单旋 */</span>             <span class="hljs-keyword">else</span>                 T = DoubleLeftRightRotation(T); <span class="hljs-comment">/* 左-右双旋 */</span>     &#125; <span class="hljs-comment">/* else if (插入左子树) 结束 */</span>          <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( X &gt; T-&gt;Data ) &#123;         <br><span class="hljs-comment">/* 插入T的右子树 */</span>         <br>T-&gt;Right = Insert( T-&gt;Right, X );        <br> <span class="hljs-comment">/* 如果需要右旋 */</span>         <br> <span class="hljs-keyword">if</span> ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) == <span class="hljs-number">-2</span> )             <br> <span class="hljs-keyword">if</span> ( X &gt; T-&gt;Right-&gt;Data )                 <br> T = SingleRightRotation(T);     <span class="hljs-comment">/* 右单旋 */</span>             <br><span class="hljs-keyword">else</span>                 <br>T = DoubleRightLeftRotation(T); <span class="hljs-comment">/* 右-左双旋 */</span>     <br>&#125; <span class="hljs-comment">/* else if (插入右子树) 结束 */</span>     <br><span class="hljs-comment">/* else X == T-&gt;Data，无须插入 */</span>    <br> <span class="hljs-comment">/* 别忘了更新树高 */</span>     <br> T-&gt;Height = Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + <span class="hljs-number">1</span>;          <br> <span class="hljs-keyword">return</span> T; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/2022/07/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/07/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240942238.png"><br>左边小，右边大</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240944509.png"></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240943255.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240945111.png"><br>什么是尾递归？？？<br>就是在最后返回这一步用到了递归<br>而尾递归可用循坏代替，提高效率<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240947234.png"></p><h4 id="查找最大和最小元素"><a href="#查找最大和最小元素" class="headerlink" title="查找最大和最小元素"></a>查找最大和最小元素</h4><p>利用二叉树的性质<br>最大元素一定在树的最右分支的端结点上<br>最小元素一定在树的最左分支的端结点上<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240948853.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240950565.png"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>关键是要找到元素应该插入的位置</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951332.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951767.png"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240951648.png"><br>以字母顺序来排<br>JAN为根节点<br>FEB，F在J前面所以放JAN左子树<br>MAR，M比J大放在JAN右子树<br>APR，比JAN小，往左走，比FEB小，继续往左走，就放到了FEB左子树<br>……</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>考虑三种情况</p><h4 id="要删除的是叶结点"><a href="#要删除的是叶结点" class="headerlink" title="要删除的是叶结点"></a>要删除的是叶结点</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240955228.png"><br>删除35，把33的指针置为NULL</p><h4 id="要删除的结点只有一个孩子结点"><a href="#要删除的结点只有一个孩子结点" class="headerlink" title="要删除的结点只有一个孩子结点"></a>要删除的结点只有一个孩子结点</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240956621.png"><br>把41的左子树指针指向35</p><h4 id="要删除的结点有左、右子树"><a href="#要删除的结点有左、右子树" class="headerlink" title="要删除的结点有左、右子树"></a>要删除的结点有左、右子树</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240957122.png"><br>1 把50放到原来41的位置<br>2 把35放到原来41的位置，34接到33上</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241001874.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Insert</span><span class="hljs-params">( BinTree BST, ElementType X )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( !BST )&#123; <span class="hljs-comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span>         BST = (BinTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TNode));         <br>BST-&gt;Data = X;         <br>BST-&gt;Left = BST-&gt;Right = <span class="hljs-literal">NULL</span>;     <br>&#125;    <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 开始找要插入元素的位置 */</span>         <br><span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data )             <br>BST-&gt;Left = Insert( BST-&gt;Left, X );   <span class="hljs-comment">/*递归插入左子树*/</span>         <span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data )            <br>BST-&gt;Right = Insert( BST-&gt;Right, X ); <span class="hljs-comment">/*递归插入右子树*/</span>         <br><span class="hljs-comment">/* else X已经存在，什么都不做 */</span>     <br>&#125;     <br><span class="hljs-keyword">return</span> BST; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="二叉搜索树的删除"><a href="#二叉搜索树的删除" class="headerlink" title="二叉搜索树的删除"></a>二叉搜索树的删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Delete</span><span class="hljs-params">( BinTree BST, ElementType X )</span>  <br>&#123;      <br>Position Tmp;      <br><span class="hljs-keyword">if</span>( !BST )          <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的元素未找到&quot;</span>);      <br><span class="hljs-keyword">else</span> &#123;         <br><span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data )              <br>BST-&gt;Left = Delete( BST-&gt;Left, X );   <span class="hljs-comment">/* 从左子树递归删除 */</span>         <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data )              <br>BST-&gt;Right = Delete( BST-&gt;Right, X ); <span class="hljs-comment">/* 从右子树递归删除 */</span>         <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* BST就是要删除的结点 */</span>             <br><span class="hljs-comment">/* 如果被删除结点有左右两个子结点 */</span>              <br><span class="hljs-keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;                 <br><span class="hljs-comment">/* 从右子树中找最小的元素填充删除结点 */</span>                 <br>Tmp = FindMin( BST-&gt;Right );                         BST-&gt;Data = Tmp-&gt;Data;                  <br>                        <span class="hljs-comment">/* 从右子树中删除最小元素 */</span>                  <br>                        BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data );             <br>                    &#125;             <br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 被删除结点有一个或无子结点 */</span>                            Tmp = BST;                  <br>                           <span class="hljs-keyword">if</span>( !BST-&gt;Left )       <br>                           <span class="hljs-comment">/* 只有右孩子或无子结点 */</span>                               BST = BST-&gt;Right;                   <br>                           <span class="hljs-keyword">else</span>                   <br>                           <span class="hljs-comment">/* 只有左孩子 */</span>                      <br>                              BST = BST-&gt;Left;                 <span class="hljs-built_in">free</span>( Tmp );             <br>                    &#125;         <br>            &#125;     <br>        &#125;     <br>        <span class="hljs-keyword">return</span> BST; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2022/07/24/%E5%9B%BE/"/>
    <url>/2022/07/24/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h2><ul><li>表示“多对多”的关系</li><li>包含<ul><li>一组顶点，通常用V表示顶点集合</li><li>一组边，通常用E表示边的集合<ul><li><p>边是顶点对，（v,w）</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241304379.png"></p></li><li><p>有向边&lt;v,w&gt;表示从v指向w的边(单行线)</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241305424.png"></p></li><li><p>不考虑重边和自回路</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241305953.png"></p></li></ul></li></ul></li></ul><h2 id="抽象数据类型定义"><a href="#抽象数据类型定义" class="headerlink" title="抽象数据类型定义"></a>抽象数据类型定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241306801.png"></p><h2 id="怎么在程序中表示一个图"><a href="#怎么在程序中表示一个图" class="headerlink" title="怎么在程序中表示一个图"></a>怎么在程序中表示一个图</h2><h3 id="用邻接矩阵"><a href="#用邻接矩阵" class="headerlink" title="用邻接矩阵"></a>用邻接矩阵</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241306436.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241307505.png"></p><ul><li>邻接矩阵有什么好处？<ul><li>直观、简单、好理解</li><li>方便检查任意一对顶点间是否存在边</li><li>方便找任一顶点的度（出度、入度）<ul><li>无向图的度：对应行或列非0元素的个数</li><li>有向图的度：对应行非0元素的个数是出度，对应列非0元素的个数是入度</li></ul></li></ul></li><li>邻接矩阵有什么不好？<ul><li>浪费空间<ul><li>存稀疏图（点多边少）有大量无效元素</li><li>但对稠密图还是合算的</li></ul></li><li>浪费时间<ul><li>统计稀疏图中一共有多少边</li></ul></li></ul></li></ul><h3 id="用邻接表"><a href="#用邻接表" class="headerlink" title="用邻接表"></a>用邻接表</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241312979.png"><br><strong>一定要够稀疏才合算</strong></p><ul><li>邻接表<ul><li>方便找任一顶点的所有邻接点</li><li>节约稀疏图的空间<ul><li>需要N个头指针加2E个结点（每个结点至少两个域）</li></ul></li><li>方便计算任一顶点的度？<ul><li>对于无向图：是的</li><li>对于有向图：只能计算出度，需要构造逆邻接表（存储指向自己的边）来方便计算入度</li><li>不方便检查任意一对顶点间是否存在边</li></ul></li></ul></li></ul><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><ul><li>深度优先搜索</li><li>广度优先搜索</li></ul><p>图不连通怎么办？</p><ul><li>连通：如果从v到w存在一条无向路径，则称v和w连通</li><li>路径：从v到w的路径是一系列顶点的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中边数。如果v到w之间的所有顶点都不同，则称简单路径</li><li>回路：起点等于终点的路径</li><li>连通图：图中任意两顶点均相同</li><li>连通分量：无向图的极大连通子图<ul><li>极大顶点数：再加1个顶点就不连通了</li><li>极大边数：包含子图中所有顶点相连的所有边</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241400121.png"></li><li>强连通：有向图中顶点v和w之间存在双向路径，则称v和w是强连通的</li><li>强连通图：有向图中任意两顶点均强连通</li><li>强连通分量：有向图的极大强连通子图</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241402102.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241402099.png"></li></ul></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="邻接矩阵表示"><a href="#邻接矩阵表示" class="headerlink" title="邻接矩阵表示"></a>邻接矩阵表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 图的邻接矩阵表示法 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100    <span class="hljs-comment">/* 最大顶点数设为100 */</span> #<span class="hljs-keyword">define</span> INFINITY 65535        <span class="hljs-comment">/* ∞设为双字节无符号整数的最大值65535*/</span> </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Vertex;         <span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> WeightType;        <span class="hljs-comment">/* 边的权值设为整型 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> DataType;        <span class="hljs-comment">/* 顶点存储的数据类型设为字符型 */</span> <br><span class="hljs-comment">/* 边的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span>     <br>Vertex V1, V2;      <span class="hljs-comment">/* 有向边&lt;V1, V2&gt; */</span>     <br>WeightType Weight;  <span class="hljs-comment">/* 权重 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToENode Edge;         <br><br><span class="hljs-comment">/* 图结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span>     <br><span class="hljs-type">int</span> Nv;  <span class="hljs-comment">/* 顶点数 */</span>     <br><span class="hljs-type">int</span> Ne;  <span class="hljs-comment">/* 边数   */</span>     <br>WeightType G[MaxVertexNum][MaxVertexNum]; <span class="hljs-comment">/* 邻接矩阵 */</span>     <br>DataType Data[MaxVertexNum];      <span class="hljs-comment">/* 存顶点的数据 */</span>     <br><span class="hljs-comment">/* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToGNode MGraph; <span class="hljs-comment">/* 以邻接矩阵存储的图类型 */</span> <br><br><br>MGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">( <span class="hljs-type">int</span> VertexNum )</span> <br>&#123; <span class="hljs-comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span>     Vertex V, W;     MGraph Graph;          Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode)); <span class="hljs-comment">/* 建立图 */</span>      <br>      Graph-&gt;Nv = VertexNum;     <br>      Graph-&gt;Ne = <span class="hljs-number">0</span>;     <br>      <span class="hljs-comment">/* 初始化邻接矩阵 */</span>     <br>      <span class="hljs-comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span>      <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)          <br>          <span class="hljs-keyword">for</span> (W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++)               Graph-&gt;G[V][W] = INFINITY;                  <span class="hljs-keyword">return</span> Graph;  <br>&#125;         <br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">( MGraph Graph, Edge E )</span> <br>&#123;      <br>    <span class="hljs-comment">/* 插入边 &lt;V1, V2&gt; */</span>      <br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;          <br>    <span class="hljs-comment">/* 若是无向图，还要插入边&lt;V2, V1&gt; */</span>      <br>    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight; <br>&#125; <br><br>MGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span> <br>&#123;     <br>    MGraph Graph;     <br>    Edge E;     <br>    Vertex V;     <br>    <span class="hljs-type">int</span> Nv, i;          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Nv);   <span class="hljs-comment">/* 读入顶点个数 */</span>     Graph = CreateGraph(Nv); <span class="hljs-comment">/* 初始化有Nv个顶点但没有边的图 */</span>           <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));   <span class="hljs-comment">/* 读入边数 */</span>     <span class="hljs-keyword">if</span> ( Graph-&gt;Ne != <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">/* 如果有边 */</span>          E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode)); <span class="hljs-comment">/* 建立边结点 */</span>          <br>    <span class="hljs-comment">/* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span>         <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++) &#123;             <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);              <br>    <span class="hljs-comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span>             InsertEdge( Graph, E );         <br>    &#125;     <br>&#125;      <br><span class="hljs-comment">/* 如果顶点有数据的话，读入数据 */</span>     <br><span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)         <br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;(Graph-&gt;Data[V]));     <br><span class="hljs-keyword">return</span> Graph; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="邻接表表示"><a href="#邻接表表示" class="headerlink" title="邻接表表示"></a>邻接表表示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 图的邻接表表示法 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexNum 100    <span class="hljs-comment">/* 最大顶点数设为100 */</span> typedef int Vertex;         <span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span> typedef int WeightType;        <span class="hljs-comment">/* 边的权值设为整型 */</span> typedef char DataType;        <span class="hljs-comment">/* 顶点存储的数据类型设为字符型 */</span> </span><br><span class="hljs-comment">/* 边的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span>     <br>    Vertex V1, V2;      <span class="hljs-comment">/* 有向边&lt;V1, V2&gt; */</span>     WeightType Weight;  <span class="hljs-comment">/* 权重 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToENode Edge; <br><br><span class="hljs-comment">/* 邻接点的定义 */</span> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span> *<span class="hljs-title">PtrToAdjVNode</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span>&#123;</span>     <br>    Vertex AdjV;        <span class="hljs-comment">/* 邻接点下标 */</span>     WeightType Weight;  <span class="hljs-comment">/* 边权重 */</span>     PtrToAdjVNode Next;    <span class="hljs-comment">/* 指向下一个邻接点的指针 */</span> <br>&#125;; <br><br><span class="hljs-comment">/* 顶点表头结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vnode</span>&#123;</span>     <br>    PtrToAdjVNode FirstEdge;<span class="hljs-comment">/* 边表头指针 */</span>     DataType Data;            <span class="hljs-comment">/* 存顶点的数据 */</span>     <br>    <span class="hljs-comment">/* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */</span> &#125; AdjList[MaxVertexNum];    <span class="hljs-comment">/* AdjList是邻接表类型 */</span> <br>    <br>    <br><span class="hljs-comment">/* 图结点的定义 */</span> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span>       <br>    <span class="hljs-type">int</span> Nv;     <span class="hljs-comment">/* 顶点数 */</span>     <br>    <span class="hljs-type">int</span> Ne;     <span class="hljs-comment">/* 边数   */</span>     <br>    AdjList G;  <span class="hljs-comment">/* 邻接表 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> PtrToGNode LGraph; <span class="hljs-comment">/* 以邻接表方式存储的图类型 */</span> <br><br><br>LGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">( <span class="hljs-type">int</span> VertexNum )</span> <br>&#123; <span class="hljs-comment">/* 初始化一个有VertexNum个顶点但没有边的图 */</span>     <br>    Vertex V;     <br>    LGraph Graph;          Graph = (LGraph)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode) ); <span class="hljs-comment">/* 建立图 */</span>     <br>    <br>    Graph-&gt;Nv = VertexNum;     <br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;     <br>    <span class="hljs-comment">/* 初始化邻接表头指针 */</span>     <br>    <span class="hljs-comment">/* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */</span>        <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)         <br>        Graph-&gt;G[V].FirstEdge = <span class="hljs-literal">NULL</span>;                  <span class="hljs-keyword">return</span> Graph;  <br>&#125;         <br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">( LGraph Graph, Edge E )</span> &#123;     PtrToAdjVNode NewNode;                          <br>      <span class="hljs-comment">/* 插入边 &lt;V1, V2&gt; */</span>     <br>      <span class="hljs-comment">/* 为V2建立新的邻接点 */</span>     NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));     <br>      NewNode-&gt;AdjV = E-&gt;V2;     <br>      NewNode-&gt;Weight = E-&gt;Weight;     <br>      <span class="hljs-comment">/* 将V2插入V1的表头 */</span>     <br>      NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;      <br>      Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;               <br>      <span class="hljs-comment">/* 若是无向图，还要插入边 &lt;V2, V1&gt; */</span>     <br>      <span class="hljs-comment">/* 为V1建立新的邻接点 */</span>     NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));     <br>      NewNode-&gt;AdjV = E-&gt;V1;     <br>      NewNode-&gt;Weight = E-&gt;Weight;     <br>      <span class="hljs-comment">/* 将V1插入V2的表头 */</span>     <br>      NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;     Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode; <br>&#125; <br>LGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span> <br>&#123;     <br>    LGraph Graph;     <br>    Edge E;     <br>    Vertex V;     <br>    <span class="hljs-type">int</span> Nv, i;          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Nv);   <span class="hljs-comment">/* 读入顶点个数 */</span>     Graph = CreateGraph(Nv); <span class="hljs-comment">/* 初始化有Nv个顶点但没有边的图 */</span>           <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;(Graph-&gt;Ne));   <span class="hljs-comment">/* 读入边数 */</span>     <span class="hljs-keyword">if</span> ( Graph-&gt;Ne != <span class="hljs-number">0</span> ) &#123; <span class="hljs-comment">/* 如果有边 */</span>          E = (Edge)<span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode) ); <span class="hljs-comment">/* 建立边结点 */</span>          <br>        <span class="hljs-comment">/* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span>         <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++) &#123;             <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);              <span class="hljs-comment">/* 注意：如果权重不是整型，Weight的读入格式要改 */</span>             <br>        InsertEdge( Graph, E );         <br>        &#125;     <br>    &#125;      <span class="hljs-comment">/* 如果顶点有数据的话，读入数据 */</span>     <span class="hljs-keyword">for</span> (V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)          <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>, &amp;(Graph-&gt;G[V].Data));     <span class="hljs-keyword">return</span> Graph; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS-邻接表存储"><a href="#DFS-邻接表存储" class="headerlink" title="DFS-邻接表存储"></a>DFS-邻接表存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接表存储的图 - DFS */</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">Visit</span><span class="hljs-params">( Vertex V )</span> <br>&#123;     <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正在访问顶点%d\n&quot;</span>, V); &#125; <br>    <span class="hljs-comment">/* Visited[]为全局变量，已经初始化为false */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">( LGraph Graph, Vertex V, <span class="hljs-type">void</span> (*Visit)(Vertex) )</span> <br>&#123;   <span class="hljs-comment">/* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */</span>     PtrToAdjVNode W;          <br>    Visit( V ); <span class="hljs-comment">/* 访问第V个顶点 */</span>     Visited[V] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记V已访问 */</span>     <br>    <span class="hljs-keyword">for</span>( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) <span class="hljs-comment">/* 对V的每个邻接点W-&gt;AdjV */</span>         <br>        <span class="hljs-keyword">if</span> ( !Visited[W-&gt;AdjV] )    <span class="hljs-comment">/* 若W-&gt;AdjV未被访问 */</span>             DFS( Graph, W-&gt;AdjV, Visit );    <span class="hljs-comment">/* 则递归访问之 */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS-邻接矩阵存储"><a href="#BFS-邻接矩阵存储" class="headerlink" title="BFS-邻接矩阵存储"></a>BFS-邻接矩阵存储</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 邻接矩阵存储的图 - BFS */</span> <br><br><span class="hljs-comment">/* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  */</span> <br><span class="hljs-comment">/* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*/</span> <br><span class="hljs-comment">/* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         */</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">IsEdge</span><span class="hljs-params">( MGraph Graph, Vertex V, Vertex W )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> Graph-&gt;G[V][W]&lt;INFINITY ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>; <br>&#125; <br><br><span class="hljs-comment">/* Visited[]为全局变量，已经初始化为false */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span> <span class="hljs-params">( MGraph Graph, Vertex S, <span class="hljs-type">void</span> (*Visit)(Vertex) )</span> <br>&#123;   <span class="hljs-comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span>     Queue Q;          <br>    Vertex V, W;     <br>    Q = CreateQueue( MaxSize ); <span class="hljs-comment">/* 创建空队列, MaxSize为外部定义的常数 */</span>     <br>    <span class="hljs-comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span>     Visit( S );     <br>    Visited[S] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记S已访问 */</span>     AddQ(Q, S); <span class="hljs-comment">/* S入队列 */</span>          <span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;         V = DeleteQ(Q);  <span class="hljs-comment">/* 弹出V */</span>         <span class="hljs-keyword">for</span>( W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="hljs-comment">/* 对图中的每个顶点W */</span>             <br>            <span class="hljs-comment">/* 若W是V的邻接点并且未访问过 */</span>             <span class="hljs-keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;                 <span class="hljs-comment">/* 访问顶点W */</span>                 Visit( W );                 Visited[W] = <span class="hljs-literal">true</span>; <span class="hljs-comment">/* 标记W已访问 */</span>                 AddQ(Q, W); <span class="hljs-comment">/* W入队列 */</span>             &#125;     &#125; <span class="hljs-comment">/* while结束*/</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合及运算</title>
    <link href="/2022/07/24/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
    <url>/2022/07/24/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h1><ul><li>集合运算：交、并、补、差，判定一个元素是否属于某一集合</li><li>并查集：集合并、查某元素属于什么集合</li><li>并查集问题中集合存储如何实现？<ul><li>用树结构表示集合，树的每个结点代表一个集合元素</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241251680.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241252797.png"></p><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="查找某元素所在集合（用根节点表示）"><a href="#查找某元素所在集合（用根节点表示）" class="headerlink" title="查找某元素所在集合（用根节点表示）"></a>查找某元素所在集合（用根节点表示）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241253516.png"></p><h3 id="集合的并运算"><a href="#集合的并运算" class="headerlink" title="集合的并运算"></a>集合的并运算</h3><ul><li>分别找到X1和X2两个元素所在集合树的根结点</li><li>如果它们不同根，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标</li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241254732.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241255267.png"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1000                  <span class="hljs-comment">/* 集合最大元素个数 */</span> typedef int ElementType;           <span class="hljs-comment">/* 默认元素可以用非负整数表示 */</span> typedef int SetName;               <span class="hljs-comment">/* 默认用根结点的下标作为集合名称 */</span> </span><br><span class="hljs-keyword">typedef</span> ElementType SetType[MAXN]; <span class="hljs-comment">/* 假设集合元素下标从0开始 */</span> <span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType S, SetName Root1, SetName Root2 )</span> <br>&#123; <span class="hljs-comment">/* 这里默认Root1和Root2是不同集合的根结点 */</span>     <br>    <span class="hljs-comment">/* 保证小集合并入大集合 */</span>     <br>    <span class="hljs-keyword">if</span> ( S[Root2] &lt; S[Root1] ) &#123; <br>    <span class="hljs-comment">/* 如果集合2比较大 */</span>         <br>    S[Root2] += S[Root1];     <br>    <span class="hljs-comment">/* 集合1并入集合2  */</span>         <br>    S[Root1] = Root2;     <br>    &#125;     <br>    <span class="hljs-keyword">else</span> &#123;                         <br>    <span class="hljs-comment">/* 如果集合1比较大 */</span>         <br>    S[Root1] += S[Root2];     <br>    <span class="hljs-comment">/* 集合2并入集合1  */</span>         <br>    S[Root2] = Root1;     &#125; &#125; SetName <span class="hljs-title function_">Find</span><span class="hljs-params">( SetType S, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 默认集合元素全部初始化为-1 */</span>     <br>    <span class="hljs-keyword">if</span> ( S[X] &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">/* 找到集合的根 */</span>         <br>    <span class="hljs-keyword">return</span> X;     <br>    <span class="hljs-keyword">else</span>         <br>    <span class="hljs-keyword">return</span> S[X] = Find( S, S[X] ); <span class="hljs-comment">/* 路径压缩 */</span> <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <link href="/2022/07/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <url>/2022/07/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241227734.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241229585.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241229037.png"></p><p><strong>问题来了：如何根据结点不同的查找频率构造更有效的搜索树？</strong></p><h2 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231882.png"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231185.png"></p><h2 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241231082.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241233586.png"></p><h2 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241233573.png"></p><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><p>给定一段字符串，如何对字符串进行编码，可以使得该字符串的编码存储空间最少？</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241235132.png"></p><p>怎么进行不等长编码？</p><p>如何避免二义性？<br>用前缀码<br>前缀码：任何字符的编码都不是另一字符编码的前缀<br>这样就可以无二义地解码</p><h2 id="二叉树用于编码"><a href="#二叉树用于编码" class="headerlink" title="二叉树用于编码"></a>二叉树用于编码</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241238663.png"></p><p><strong>怎样构造一棵编码代价最小的二叉树？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241240737.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2022/07/24/%E5%A0%86/"/>
    <url>/2022/07/24/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241122025.png"><br>如何组织优先队列？<br>用一般的数组、链表？<br>有序的数组或者链表？<br>二叉搜索树？AVL树？</p><h3 id="采用数组或链表？"><a href="#采用数组或链表？" class="headerlink" title="采用数组或链表？"></a>采用数组或链表？</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241123470.png"></p><h3 id="采用二叉树？"><a href="#采用二叉树？" class="headerlink" title="采用二叉树？"></a>采用二叉树？</h3><ul><li>采用二叉搜索树？<ul><li>需要树的高度适合，而二叉搜索树，经过删除操作容易歪掉</li></ul></li><li>更应该关注插入还是删除？  <ul><li>更应该关注删除，因为删除操作更难实现</li></ul></li><li>树结点顺序怎么安排？<ul><li>最值放在树根</li></ul></li><li>树结构怎么样？     <ul><li>用完全二叉树，会更加平衡一点</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241125555.png"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241126397.png"><br>判断是不是堆<br>条件一：看它是不是完全二叉树<br>条件二：任一子树的根是不是该子树的最大值或者最小值<br>图中左边两个都不是完全二叉树<br>而右边两个虽然是完全二叉树，但不满足第二个条件</p><h2 id="堆的抽象数据类型描述"><a href="#堆的抽象数据类型描述" class="headerlink" title="堆的抽象数据类型描述"></a>堆的抽象数据类型描述</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241127568.png"></p><h3 id="最大堆的操作"><a href="#最大堆的操作" class="headerlink" title="最大堆的操作"></a>最大堆的操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241219352.png"><br>把MaxData换成小于堆中所有元素的MiniData，同样适合于创建最小堆</p><ul><li>将已存在的N个元素按最大堆的要求存放在一个一维数组中<ul><li>方法一：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为o（N logN）</li><li>方法二：在线性时间复杂度下建立最大堆<ul><li>将N个元素按输入顺序存入，先满足完全二叉树的结构特性</li><li>调整各结点位置，以满足最大堆的有序特性</li></ul></li></ul></li></ul><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221880.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221708.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241221259.png"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241222284.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207241222831.png"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> *<span class="hljs-title">Heap</span>;</span> <span class="hljs-comment">/* 堆的类型定义 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> &#123;</span>     <br>ElementType *Data; <span class="hljs-comment">/* 存储元素的数组 */</span>     <span class="hljs-type">int</span> Size;          <span class="hljs-comment">/* 堆中当前元素个数 */</span>     <span class="hljs-type">int</span> Capacity;      <span class="hljs-comment">/* 堆的最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> Heap MaxHeap; <span class="hljs-comment">/* 最大堆 */</span> <br><span class="hljs-keyword">typedef</span> Heap MinHeap; <span class="hljs-comment">/* 最小堆 */</span> <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXDATA 1000  <span class="hljs-comment">/* 该值应根据具体情况定义为大于堆中所有可能元素的值 */</span> </span><br>MaxHeap <span class="hljs-title function_">CreateHeap</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> <br>&#123; <span class="hljs-comment">/* 创建容量为MaxSize的空的最大堆 */</span><br><br>MaxHeap H = (MaxHeap)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> HNode));     <br>H-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>((MaxSize+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(ElementType));     H-&gt;Size = <span class="hljs-number">0</span>;     <br>    H-&gt;Capacity = MaxSize;     <br>    H-&gt;Data[<span class="hljs-number">0</span>] = MAXDATA; <span class="hljs-comment">/* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*/</span>     <span class="hljs-keyword">return</span> H; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> (H-&gt;Size == H-&gt;Capacity); <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( MaxHeap H, ElementType X )</span> <br>&#123;   <span class="hljs-comment">/* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span>     <br><span class="hljs-type">int</span> i;       <br><span class="hljs-keyword">if</span> ( IsFull(H) ) &#123;          <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br>i = ++H-&gt;Size; <span class="hljs-comment">/* i指向插入后堆中的最后一个元素的位置 */</span>     <span class="hljs-keyword">for</span> ( ; H-&gt;Data[i/<span class="hljs-number">2</span>] &lt; X; i/=<span class="hljs-number">2</span> )         <br>H-&gt;Data[i] = H-&gt;Data[i/<span class="hljs-number">2</span>]; <span class="hljs-comment">/* 上滤X */</span>     <br>H-&gt;Data[i] = X; <span class="hljs-comment">/* 将X插入 */</span>     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125; <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1 <span class="hljs-comment">/* 错误标识应根据具体情况定义为堆中不可能出现的元素值 */</span> </span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123;     <br>    <span class="hljs-keyword">return</span> (H-&gt;Size == <span class="hljs-number">0</span>); <br>&#125; <br>ElementType <span class="hljs-title function_">DeleteMax</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123; <span class="hljs-comment">/* 从最大堆H中取出键值为最大的元素，并删除一个结点 */</span>     <span class="hljs-type">int</span> Parent, Child;     <br>    ElementType MaxItem, X;     <br>    <span class="hljs-keyword">if</span> ( IsEmpty(H) ) &#123;         <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已为空&quot;</span>);         <br>    <span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br>MaxItem = H-&gt;Data[<span class="hljs-number">1</span>]; <span class="hljs-comment">/* 取出根结点存放的最大值 */</span>     <br><span class="hljs-comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span>     <br>X = H-&gt;Data[H-&gt;Size--]; <span class="hljs-comment">/* 注意当前堆的规模要减小 */</span>     <span class="hljs-keyword">for</span>( Parent=<span class="hljs-number">1</span>; Parent*<span class="hljs-number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;         Child = Parent * <span class="hljs-number">2</span>;         <br>    <span class="hljs-keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="hljs-number">1</span>]) )             Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span>         <span class="hljs-keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>         <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>             <br>        H-&gt;Data[Parent] = H-&gt;Data[Child];     &#125;     <br>        H-&gt;Data[Parent] = X;     <span class="hljs-keyword">return</span> MaxItem; &#125;  <br>        <span class="hljs-comment">/*----------- 建造最大堆 -----------*/</span> <span class="hljs-type">void</span> <span class="hljs-title function_">PercDown</span><span class="hljs-params">( MaxHeap H, <span class="hljs-type">int</span> p )</span> <br>&#123; <br>    <span class="hljs-comment">/* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 */</span>     <span class="hljs-type">int</span> Parent, Child;     <br>    ElementType X;     <br>    X = H-&gt;Data[p]; <span class="hljs-comment">/* 取出根结点存放的值 */</span>     <br>    <span class="hljs-keyword">for</span>( Parent=p; Parent*<span class="hljs-number">2</span>&lt;=H-&gt;Size; Parent=Child ) <br>    &#123;         <br>    Child = Parent * <span class="hljs-number">2</span>;         <br>    <span class="hljs-keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="hljs-number">1</span>]) )             Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span>         <span class="hljs-keyword">if</span>( X &gt;= H-&gt;Data[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span>         <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span>             <br>    H-&gt;Data[Parent] = H-&gt;Data[Child];     <br>&#125;     <br>H-&gt;Data[Parent] = X; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildHeap</span><span class="hljs-params">( MaxHeap H )</span> <br>&#123; <br><span class="hljs-comment">/* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  */</span>   <br><span class="hljs-comment">/* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 */</span>    <br>    <span class="hljs-type">int</span> i;     <span class="hljs-comment">/* 从最后一个结点的父节点开始，到根结点1 */</span>     <span class="hljs-keyword">for</span>( i = H-&gt;Size/<span class="hljs-number">2</span>; i&gt;<span class="hljs-number">0</span>; i-- )         <br>    PercDown( H, i ); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的基本概念及相关</title>
    <link href="/2022/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240856336.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240856794.png"></p><p> 完美二叉树就是除了最后一层，其余每个子树都有左右子树</p><p> 完全二叉树是指按序号位置排列不中断，不空缺，可以少后面的编号，但前面一定不能断开  </p><h2 id="二叉树几个重要性质"><a href="#二叉树几个重要性质" class="headerlink" title="二叉树几个重要性质"></a>二叉树几个重要性质</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240857254.png"></p><p>可用来粗略判断是不是二叉树</p><h2 id="二叉树的抽象数据类型定义"><a href="#二叉树的抽象数据类型定义" class="headerlink" title="二叉树的抽象数据类型定义"></a>二叉树的抽象数据类型定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240858122.png"></p><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240859721.png"></p><p>依靠数组来实现</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240900427.png"></p><p>一般二叉树的顺序存储结构会造成空间浪费<br>不好！！！</p><h3 id="链表存储"><a href="#链表存储" class="headerlink" title="链表存储"></a>链表存储</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240901673.png"></p><p>仍然是父子兄弟表示法</p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>有先序遍历、中序遍历、后序遍历三种<br>先、中、后都是指向对根的访问<br>先序就是根左右<br>中序就是左根右<br>后序就是左右根</p><h2 id="三种递归调用实现的遍历"><a href="#三种递归调用实现的遍历" class="headerlink" title="三种递归调用实现的遍历"></a>三种递归调用实现的遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907236.png"></p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907401.png"></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240907322.png"></p><h3 id="三种遍历的区分"><a href="#三种遍历的区分" class="headerlink" title="三种遍历的区分"></a>三种遍历的区分</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240909169.png"></p><p>**经过结点的路线一样，只是访问各结点的时机不同</p><h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><p>**基本思路：堆栈</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240912811.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240912008.png"></p><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240913587.png"><br>**核心问题是要记住访问的结点，怎么记住？堆栈或队列！！！</p><h4 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240914981.png"><br>A先入队然后出队<br>A的儿子B和C入队<br>B出队，B的儿子D和F入队<br>C出队，C的儿子G和I入队<br>D出队<br>F出队，F的儿子E入队<br>G出队，G的儿子H入队<br>I出队<br>E出队<br>H出队<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240922079.png"></p><h2 id="遍历二叉树的应用"><a href="#遍历二叉树的应用" class="headerlink" title="遍历二叉树的应用"></a>遍历二叉树的应用</h2><h3 id="输出二叉树中的叶子结点"><a href="#输出二叉树中的叶子结点" class="headerlink" title="输出二叉树中的叶子结点"></a>输出二叉树中的叶子结点</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240923837.png"></p><h3 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240923052.png"></p><h3 id="二元运算表达式树及其遍历"><a href="#二元运算表达式树及其遍历" class="headerlink" title="二元运算表达式树及其遍历"></a>二元运算表达式树及其遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240924502.png"></p><p>中序遍历不一定得到中缀表达式<br>因为会受到运算符优先级的影响<br>可以引入括号来解决</p><h3 id="由两种遍历序列确定二叉树"><a href="#由两种遍历序列确定二叉树" class="headerlink" title="由两种遍历序列确定二叉树"></a>由两种遍历序列确定二叉树</h3><p>这两种遍历中必须要有中序遍历，如果只有先序和后序则无法确定</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240925601.png"><br>不断分割<br>先用先序遍历找到根<br>然后去中序序列的找到已知的根<br>进而找到已知根的左子树和右子树的中序序列<br>我们可以得到左子树的元素个数，那么再去先序序列中，往后对应个数的元素就是左子树的先序序列<br>右子树与左子树同理<br>这样就不断循环分割，确定出一颗二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240925919.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span> *<span class="hljs-title">Position</span>;</span> <br><span class="hljs-keyword">typedef</span> Position BinTree; <span class="hljs-comment">/* 二叉树类型 */</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TNode</span>&#123;</span> <br><span class="hljs-comment">/* 树结点定义 */</span>     <br>ElementType Data; <span class="hljs-comment">/* 结点数据 */</span>     <br>BinTree Left;     <span class="hljs-comment">/* 指向左子树 */</span>     <br>BinTree Right;    <span class="hljs-comment">/* 指向右子树 */</span> <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二叉树的四种遍历"><a href="#二叉树的四种遍历" class="headerlink" title="二叉树的四种遍历"></a>二叉树的四种遍历</h3><p>中序、先序、后序、层序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InorderTraversal</span><span class="hljs-params">( BinTree BT )</span> &#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br>InorderTraversal( BT-&gt;Left );         <br><span class="hljs-comment">/* 此处假设对BT结点的访问就是打印数据 */</span>         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data); <span class="hljs-comment">/* 假设数据为整型 */</span>         InorderTraversal( BT-&gt;Right );     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">PreorderTraversal</span><span class="hljs-params">( BinTree BT )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data );         <br>PreorderTraversal( BT-&gt;Left );         PreorderTraversal( BT-&gt;Right );     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">PostorderTraversal</span><span class="hljs-params">( BinTree BT )</span> <br>&#123;     <br><span class="hljs-keyword">if</span>( BT ) &#123;         <br>PostorderTraversal( BT-&gt;Left );         PostorderTraversal( BT-&gt;Right );         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, BT-&gt;Data);     <br>&#125; <br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">LevelorderTraversal</span> <span class="hljs-params">( BinTree BT )</span> <br>&#123;      <br>Queue Q;      <br>BinTree T;     <br><span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span>          Q = CreatQueue(); <span class="hljs-comment">/* 创建空队列Q */</span>     <br>AddQ( Q, BT );     <br><span class="hljs-keyword">while</span> ( !IsEmpty(Q) ) &#123;         <br>T = DeleteQ( Q );         <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, T-&gt;Data); <span class="hljs-comment">/* 访问取出队列的结点 */</span>          <br>    <span class="hljs-keyword">if</span> ( T-&gt;Left )   AddQ( Q, T-&gt;Left );         <br>    <span class="hljs-keyword">if</span> ( T-&gt;Right )  AddQ( Q, T-&gt;Right );     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/07/18/%E9%98%9F%E5%88%97/"/>
    <url>/2022/07/18/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>什么是队列？<ul><li>具有一定操作约束的线性表</li><li>只能在一端插入，而在另一端删除</li><li>数据插入：入队列</li><li>数据删除：出队列</li><li>先来先服务</li><li>先进先出：FIFO</li></ul></li><li>队列的抽象数据类型描述<ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的队列Q$\in$Qyeue,队列元素item$\in$ElementType</li><li>基本操作<ul><li>Queue CreatQueue(int MaxSize)：生成长度为MaxSize的空队列</li><li>int IsFullQ(Queue Q,int MaxSize)：判断队列Q是否已满</li><li>void AddQ(Queue Q, ElementType item)：将数据元素item插入队列Q中</li><li>int IsEmptyQ(Queue Q)：判断队列Q是否为空</li><li>ElementType DeleteQ(Queue Q)：将队头数据元素从队列中删除并返回</li></ul></li></ul></li><li>队列的顺序存储实现<ul><li>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成的顺环队列</li></ul></li><li>队列的链式存储实现<ul><li>可以用一个单链表实现，插入和删除操作分别在链表的两头进行</li><li>注意：队列指针front应在单向链表的开头rear在尾（尾部删除操作找不到前面的元素，所有不能把front放在尾）</li></ul></li><li>应用实例（多项式加法）<ul><li>主要思路：相同指数项系数相加，不同指数项系数进行拷贝</li><li>采用不带头结点的单向链表，按照指数递减的顺序排列各项</li><li>两个指针P1和P2分别指向这两个多项式的第一个结点，不断循环<ul><li>P1指向的项如果指数等于P2指向的项的指数：系数相加，若结果不为0，则作为结果多项式对应项的系数。同时，P1和P2都分别指向下一项<ul><li>P1所指指数大于P2：将P1的当前项存入结果多项式，并使P1指向下一项</li><li>P1所指指数小于P2：将P2的当前项存入结果多项式，并使P2指向下一项</li><li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去</li></ul></li></ul></li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span>     Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> &#123;     Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));     Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;     <br>Q-&gt;MaxSize = MaxSize;         <br><span class="hljs-keyword">return</span> Q;      <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span> &#123;     <br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;   Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>&#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear); &#125; <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">if</span> ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span>  <br>&#123;   Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;         <br><span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-comment">/* 队列中的结点 */</span>     <br>ElementType Data;     <br>PtrToNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToNode Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> &#125;; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>); &#125; ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br>Position FrontCell;      <br>ElementType FrontElem;          <br><span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;    FrontCell = Q-&gt;Front;         <br><span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span>                 Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span> <br>            <span class="hljs-keyword">else</span>                                  <br> Q-&gt;Front = Q-&gt;Front-&gt;Next;         <br> FrontElem = FrontCell-&gt;Data;         <br> <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span>         <br> <span class="hljs-keyword">return</span>  FrontElem;     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多项式加法用队列实现"><a href="#多项式加法用队列实现" class="headerlink" title="多项式加法用队列实现"></a>多项式加法用队列实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆栈</title>
    <link href="/2022/07/18/%E5%A0%86%E6%A0%88/"/>
    <url>/2022/07/18/%E5%A0%86%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>中缀表达式：运算符号位于两个运算数之间，如a+b*c-d&#x2F;e</p></li><li><p>后缀表达式：运算符号位于两个运算数之后，如abc*+de&#x2F;-</p></li><li><p>前缀表达式：运算符号位于两个运算数之前，如-+a*bc&#x2F;de</p></li><li><p>前缀表达式怎么求值？？？</p></li><li><p>后缀表达式求值策略：从左往右扫描，逐个处理运算数和运算符号</p><ul><li>遇到运算数怎么办？–把运算数记住</li><li>遇到运算符号怎么办？–把最近记住的两个数拿来做对应的运算</li></ul></li><li><p>这就给我们带来启示，需要有种存储方法，能顺序存储运算数，并在需要时“倒序”输出</p></li><li><p>于是，堆栈的意义也就出来了，先放进去的后拿出来，后放进去的先拿出来运算</p></li><li><p>堆栈的抽象数据类型描述</p><ul><li>具有一定操作约束的线性表</li><li>只在一端（栈顶，Top）做插入、删除</li><li>插入数据：入栈（Push）</li><li>删除数据：出栈（Pop）</li><li>后入先出：Last In First Out(LIFO)</li></ul></li><li><p>堆栈的操作</p><ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的堆栈S $\in$ Stack,堆栈元素item$\in$ ElementType</li><li>Stack CreateStack( int MaxSize )：生成空堆栈，其最大长度为MaxSize</li><li>bool IsFull( Stack S )：判断堆栈S是否已满</li><li>bool Push( Stack S, ElementType item )：将元素item压入堆栈</li><li>bool IsEmpty ( Stack S )：判断堆栈S是否为空</li><li>ElementType Pop( Stack S )：删除并返回栈顶元素</li></ul></li><li><p>栈的顺序储存实现</p><ul><li>xxxxxxxxxx typedef struct HNode <em>Heap; &#x2F;</em> 堆的类型定义 <em>&#x2F; struct HNode {         ElementType <em>Data; &#x2F;</em> 存储元素的数组 <em>&#x2F;     int Size;          &#x2F;</em> 堆中当前元素个数 <em>&#x2F;     int Capacity;      &#x2F;</em> 堆的最大容量 <em>&#x2F; }; typedef Heap MaxHeap; &#x2F;</em> 最大堆 <em>&#x2F; typedef Heap MinHeap; &#x2F;</em> 最小堆 <em>&#x2F; ​#define MAXDATA 1000  &#x2F;</em> 该值应根据具体情况定义为大于堆中所有可能元素的值 <em>&#x2F; MaxHeap CreateHeap( int MaxSize ) { &#x2F;</em> 创建容量为MaxSize的空的最大堆 <em>&#x2F;​MaxHeap H &#x3D; (MaxHeap)malloc(sizeof(struct HNode));     H-&gt;Data &#x3D; (ElementType <em>)malloc((MaxSize+1)<em>sizeof(ElementType));     H-&gt;Size &#x3D; 0;         H-&gt;Capacity &#x3D; MaxSize;         H-&gt;Data[0] &#x3D; MAXDATA; &#x2F;</em> 定义”哨兵”为大于堆中所有可能元素的值</em>&#x2F;     return H; } bool IsFull( MaxHeap H ) {         return (H-&gt;Size &#x3D;&#x3D; H-&gt;Capacity); } bool Insert( MaxHeap H, ElementType X ) {   &#x2F;</em> 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 <em>&#x2F;         int i;           if ( IsFull(H) ) {                  printf(“最大堆已满”);                 return false;         }         i &#x3D; ++H-&gt;Size; &#x2F;</em> i指向插入后堆中的最后一个元素的位置 <em>&#x2F;     for ( ; H-&gt;Data[i&#x2F;2] &lt; X; i&#x2F;&#x3D;2 )                 H-&gt;Data[i] &#x3D; H-&gt;Data[i&#x2F;2]; &#x2F;</em> 上滤X <em>&#x2F;             H-&gt;Data[i] &#x3D; X; &#x2F;</em> 将X插入 <em>&#x2F;             return true;     } #define ERROR -1 &#x2F;</em> 错误标识应根据具体情况定义为堆中不可能出现的元素值 <em>&#x2F; bool IsEmpty( MaxHeap H ) {         return (H-&gt;Size &#x3D;&#x3D; 0); } ElementType DeleteMax( MaxHeap H ) { &#x2F;</em> 从最大堆H中取出键值为最大的元素，并删除一个结点 <em>&#x2F;     int Parent, Child;         ElementType MaxItem, X;         if ( IsEmpty(H) ) {                 printf(“最大堆已为空”);                 return ERROR;         }         MaxItem &#x3D; H-&gt;Data[1]; &#x2F;</em> 取出根结点存放的最大值 <em>&#x2F;         &#x2F;</em> 用最大堆中最后一个元素从根结点开始向上过滤下层结点 <em>&#x2F;         X &#x3D; H-&gt;Data[H-&gt;Size–]; &#x2F;</em> 注意当前堆的规模要减小 <em>&#x2F;     for( Parent&#x3D;1; Parent</em>2&lt;&#x3D;H-&gt;Size; Parent&#x3D;Child ) {         Child &#x3D; Parent * 2;                 if( (Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]<H->Data[Child+1]) )             Child++;  &#x2F;</em> Child指向左右子结点的较大者 <em>&#x2F;         if( X &gt;&#x3D; H-&gt;Data[Child] ) break; &#x2F;</em> 找到了合适位置 <em>&#x2F;         else  &#x2F;</em> 下滤X <em>&#x2F;                         H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];     }                 H-&gt;Data[Parent] &#x3D; X;     return MaxItem; }              &#x2F;</em>———– 建造最大堆 ———–<em>&#x2F; void PercDown( MaxHeap H, int p ) {     &#x2F;</em> 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 <em>&#x2F;     int Parent, Child;         ElementType X;         X &#x3D; H-&gt;Data[p]; &#x2F;</em> 取出根结点存放的值 <em>&#x2F;         for( Parent&#x3D;p; Parent</em>2&lt;&#x3D;H-&gt;Size; Parent&#x3D;Child )     {                 Child &#x3D; Parent * 2;                 if( (Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]<H->Data[Child+1]) )             Child++;  &#x2F;* Child指向左右子结点的较大者 <em>&#x2F;         if( X &gt;&#x3D; H-&gt;Data[Child] ) break; &#x2F;</em> 找到了合适位置 <em>&#x2F;         else  &#x2F;</em> 下滤X <em>&#x2F;                     H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];         }         H-&gt;Data[Parent] &#x3D; X; } void BuildHeap( MaxHeap H ) { &#x2F;</em> 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  <em>&#x2F;   &#x2F;</em> 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 <em>&#x2F;        int i;     &#x2F;</em> 从最后一个结点的父节点开始，到根结点1 *&#x2F;     for( i &#x3D; H-&gt;Size&#x2F;2; i&gt;0; i– )                 PercDown( H, i ); }c</li></ul></li><li><p>堆栈的链式储存实现</p><ul><li>实际上就是一个单链表，叫做链栈。插入和删除操作只能在栈的栈顶进行。栈顶指针只能在链表的开头，不能用结尾做top</li></ul></li><li><p>中缀表达式转化为后缀表达式</p><ul><li>从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理</li><li>运算数直接输出</li><li>左括号压入堆栈</li><li>右括号将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）</li><li>运算符<ul><li>若优先级大于栈顶运算符，就把它压栈</li><li>若优先级小于等于栈顶运算符，就把栈顶运算符弹出并输出，再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈</li></ul></li><li>若各对象处理完毕，就把堆栈中存留的运算符一并输出</li></ul></li><li><p>堆栈的一些其他应用</p><ul><li>函数调用及递归实现</li><li>深度优先搜索</li><li>回溯算法</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3></li></ul><h4 id="堆栈的定义与操作——顺序存储"><a href="#堆栈的定义与操作——顺序存储" class="headerlink" title="堆栈的定义与操作——顺序存储"></a>堆栈的定义与操作——顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> </span><br><span class="hljs-class">&#123;</span>     <br> ElementType *Data; <br> <span class="hljs-comment">/* 存储元素的数组 */</span>     <br> Position Top;      <br> <span class="hljs-comment">/* 栈顶指针 */</span>     <br> <span class="hljs-type">int</span> MaxSize;       <br> <span class="hljs-comment">/* 堆栈最大容量 */</span> &#125;; <br> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span> <br> Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> <br> &#123;     <br> Stack S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br> S-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));    <br> S-&gt;Top = <span class="hljs-number">-1</span>;     <br> S-&gt;MaxSize = MaxSize;     <br> <span class="hljs-keyword">return</span> S; <br> &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Stack S )</span> &#123;     <span class="hljs-keyword">return</span> (S-&gt;Top == S-&gt;MaxSize<span class="hljs-number">-1</span>); &#125; <span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span> <br>&#123;     <span class="hljs-keyword">if</span> ( IsFull(S) ) <br>  &#123;   <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;     <br>      <span class="hljs-keyword">else</span> <br>      &#123;         <br>      S-&gt;Data[++(S-&gt;Top)] = X;         <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>      &#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Stack S )</span> &#123;     <span class="hljs-keyword">return</span> (S-&gt;Top == <span class="hljs-number">-1</span>); &#125; ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span><br>&#123;     <span class="hljs-keyword">if</span> ( IsEmpty(S) ) <br>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);         <br> <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* ERROR是ElementType的特殊值，标志错误 */</span>     <br>&#125;     <br>   <span class="hljs-keyword">else</span>          <br>         <span class="hljs-keyword">return</span> ( S-&gt;Data[(S-&gt;Top)--] ); <br> &#125;<br></code></pre></td></tr></table></figure><h4 id="堆栈的定义与操作——链式存储"><a href="#堆栈的定义与操作——链式存储" class="headerlink" title="堆栈的定义与操作——链式存储"></a>堆栈的定义与操作——链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">PtrToSNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> &#123;</span>     <br>ElementType Data;     <br>PtrToSNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToSNode Stack; <br>Stack <span class="hljs-title function_">CreateStack</span><span class="hljs-params">( )</span>  &#123; <br><span class="hljs-comment">/* 构建一个堆栈的头结点，返回该结点指针 */</span>     <br>Stack S;     <br>S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br>S-&gt;Next = <span class="hljs-literal">NULL</span>;     <br><span class="hljs-keyword">return</span> S; &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span> <span class="hljs-params">( Stack S )</span> <br>&#123; <span class="hljs-comment">/* 判断堆栈S是否为空，若是返回true；否则返回false */</span>     <br><span class="hljs-keyword">return</span> ( S-&gt;Next == <span class="hljs-literal">NULL</span> ); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">( Stack S, ElementType X )</span> <br>&#123; <span class="hljs-comment">/* 将元素X压入堆栈S */</span>     <br>PtrToSNode TmpCell;     TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> SNode));     <br>TmpCell-&gt;Data = X;     <br>TmpCell-&gt;Next = S-&gt;Next;     <br>S-&gt;Next = TmpCell;     <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125; <br>ElementType <span class="hljs-title function_">Pop</span><span class="hljs-params">( Stack S )</span>   <br>&#123; <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span>     <br>PtrToSNode FirstCell;     <br>ElementType TopElem;     <br><span class="hljs-keyword">if</span>( IsEmpty(S) ) <br>        &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>);          <br><span class="hljs-keyword">return</span> ERROR;     <br>    &#125;    <br><span class="hljs-keyword">else</span> <br>   &#123;         <br>  FirstCell = S-&gt;Next;          <br>  TopElem = FirstCell-&gt;Data;        <br>   S-&gt;Next = FirstCell-&gt;Next;         <br>   <span class="hljs-built_in">free</span>(FirstCell);         <br>   <span class="hljs-keyword">return</span> TopElem;     <br>   &#125; <br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的基本概念</title>
    <link href="/2022/07/18/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/07/18/%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h1><ul><li>查找<ul><li>静态查找<ul><li>没有插入和删除操作，只有查找</li></ul></li><li>动态查找<ul><li>除查找，还有插入和删除操作</li></ul></li></ul></li></ul><h2 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h2><h4 id="方法一-顺序查找"><a href="#方法一-顺序查找" class="headerlink" title="方法一 顺序查找"></a>方法一 顺序查找</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240828985.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240828985.png"></p><p>哨兵的作用？<br>        可以在数组的最后或者边界上面设置一个值，不需要每次去判断下标的值是不是达到边界，而只要按照循环一般的规则，当碰到放置的值时，循环就会退出来了<br>哨兵的目的？<br>        简化代码，写循环时可以少写一个判断的分支</p><h4 id="方法二-二分查找"><a href="#方法二-二分查找" class="headerlink" title="方法二 二分查找"></a>方法二 二分查找</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240833949.png"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834711.png"></p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><h6 id="查找成功"><a href="#查找成功" class="headerlink" title="查找成功"></a>查找成功</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834403.png"></p><p>mid&#x3D;(left+right)&#x2F;2,比较后，如果在右半部分，则right不动，left变为mid加一，然后再求mid，直到找到关键字</p><h6 id="查找失败的例子"><a href="#查找失败的例子" class="headerlink" title="查找失败的例子"></a>查找失败的例子</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240834592.png"></p><p>最后left大于right则查找失败，所要找的关键字不在所给的范围内</p><h6 id="十一个元素的二分查找判定树"><a href="#十一个元素的二分查找判定树" class="headerlink" title="十一个元素的二分查找判定树"></a>十一个元素的二分查找判定树</h6><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240838860.png"></p><p>二分查找引出二叉树</p><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240840764.png"></p><h3 id="树与非树（什么样的不是树？）"><a href="#树与非树（什么样的不是树？）" class="headerlink" title="树与非树（什么样的不是树？）"></a>树与非树（什么样的不是树？）</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240841898.png"><br>左：C和D为A的子树，他们相交了<br>中：E有了B和C两个父亲结点<br>右：多了一条AG边</p><h3 id="树的一些术语"><a href="#树的一些术语" class="headerlink" title="树的一些术语"></a>树的一些术语</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240844812.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240844048.png"><br>    图中A结点的度数为3<br>    图所示树的度为3<br>    图中F为叶结点<br>    图中A在第一层<br>    树的深度为4</p><h3 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h3><h4 id="单纯用链表表示"><a href="#单纯用链表表示" class="headerlink" title="单纯用链表表示"></a>单纯用链表表示</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240846604.png"></p><p>这样的形式不够好，每个结点的结构不统一，且很多空间会被浪费</p><h4 id="儿子-兄弟表示法"><a href="#儿子-兄弟表示法" class="headerlink" title="儿子-兄弟表示法"></a>儿子-兄弟表示法</h4><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240847688.png"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207240847052.png"><br>      每个结点结构都一样，且空间浪费不大</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科目二窍门</title>
    <link href="/2022/07/17/%E7%A7%91%E7%9B%AE%E4%BA%8C%E7%AA%8D%E9%97%A8/"/>
    <url>/2022/07/17/%E7%A7%91%E7%9B%AE%E4%BA%8C%E7%AA%8D%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h1><ul><li>驶入弯道前，打转向灯</li><li>然后点对线</li><li>视野里车头与前方黄线三十公分左右，轻拔转向灯，使取消</li><li>视角里看到开门地方一指距离对准黄线尖角，方向盘左打死</li><li>等到点再擦到黄线边缘时，立马回正</li></ul><h1 id="S弯曲线行驶"><a href="#S弯曲线行驶" class="headerlink" title="S弯曲线行驶"></a>S弯曲线行驶</h1><p>S弯的步骤<br>1：看见弯口向弯口打方向，打半圈180度，仪表盘12点钟对弯口中间回正方向盘。<br>2：用左镜架子的点碰左边黄线右边缘进弯。<br>3：看左镜架子最低的点碰右边黄线内边缘向左打一圈+90°方向盘。<br>4：看左镜架子的点离黄线2个拳头宽（一部手机长）的距离回90°方向盘。<br>5：看左镜架子的点碰左边黄线回一圈方向盘。<br>6：看右镜架子最低点离左边黄线一拳距离向右打一圈+90°方向盘。<br>7：看右镜架子的点离左边黄线2只筷子长的距离回90°方向盘。<br>8：握着一圈方向盘就出弯了。</p><h1 id="侧方停车"><a href="#侧方停车" class="headerlink" title="侧方停车"></a>侧方停车</h1><ul><li>1肩膀与参照物平行，向右打一圈。</li><li>2看左后视镜看到三个轮胎回一圈。</li><li>3左后视镜看见左后轮压上黄线向左打死。</li><li>4前进左前角与黄线重合停车。</li><li>5换一档转向灯前进左筋与黄线交接回一圈半。</li><li>6车头三分之二与黄线交接向右打一圈</li></ul><h1 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h1><ul><li>肩膀与线平行，向右打死</li><li>车身到30厘米回半圈</li><li>车身与线平行回一圈</li><li>肩膀于线平行停车</li><li>伸头看左前轮与黄线保持30公分，适当调整</li><li>肩膀过线25厘米，打左一圈加90度</li><li>窗条过黄线上口停车</li><li>倒车，从左后视镜看自己的左后轮压白线10厘米回90度</li><li>如果车轮压不到线左打死</li><li>将轮胎压上线回半圈</li><li>将车尾对上后面一个底座回一圈</li><li>肩膀与黄线平行停车</li><li>车头看不到黄线右打死</li></ul>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>学车</category>
      
    </categories>
    
    
    <tags>
      
      <tag>驾照考试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游武汉美术馆的一些收获</title>
    <link href="/2022/07/13/%E6%B8%B8%E6%AD%A6%E6%B1%89%E7%BE%8E%E6%9C%AF%E9%A6%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/"/>
    <url>/2022/07/13/%E6%B8%B8%E6%AD%A6%E6%B1%89%E7%BE%8E%E6%9C%AF%E9%A6%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<p>武汉美术馆是我第一次游览的美术馆，这一次游览不仅让我领略了许多美丽，更让我看到了艺术家们深邃的思想</p><p>先从史金淞个展说起， 他用枯木和自己加工的一些材料制造出摩托车，并用落叶点缀。他用不同人所收集的一些铁质材料，比如：螺丝、小刀、废铁，自己熔铸、锻造、磨砺，制造出了一把大刀，小小螺丝也可以变成削铁如泥的刀。他分别用1500摄氏度，和2500摄氏度点燃木炭，相差一千摄氏度的火焰燃烧得各有各的风采。他用捡来的垃圾做成了漂亮的屏风，并赋“如心中有垃圾，花鸟矣垃圾；如心中有花鸟，垃圾矣花鸟”。</p><p>他的作品《铁丝人偶》，铁丝人偶在被设计的宿命中挣扎，于无形的系统中机械舞动，他用缠绕身体的铁丝形成人偶，肉身幻化为线条，让人们不禁思考“什么是人？”“人在此刻何为？”</p><p>看完个展后，去了三楼还有两个作品让我印象十分深刻，一个是卜桦导演的电影作品《LV森林》，一对全身赤裸的女孩，正在窃窃私语，她们耳语着对面水塘里的女人。这些长发女人，全身裸体，搔首弄姿。形如男性生殖器的怪异巨兽，背上驮着户型各异的“空中楼阁”。他们对每个女人品头论足，垂涎欲滴于美貌妖娆的丽人，无视于面貌普通的女人，甚至于鄙视唾弃。同样的，女人们也用相同的方法丈量评判这些巨兽们。她们关注的，无非是巨兽们背上的“空中楼阁”。第一个美女选择了雕栏玉砌的珍楼宝屋，第二个女人选择了面目清秀的“俊男”……剩下的名额越来越少，只剩下又矮又胖的女孩一人。选择“俊男”的女孩来到了极度繁华而又糜烂的世界里，她跟胖女孩炫耀自己是如何的挥金如土。最终，被这一切所冷落的胖女孩，独自一人划着船，观看岸上的女人们过着所谓的幸福的生活。还有一个是黄彦的《活标本》，夸张、怪诞的人形象放在玻璃器皿里，形成了活标本，我望着这一个个标本，竟好像看到了自己。</p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181240851.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241810.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241202.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242446.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181241033.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242507.jpg"><br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202207181242471.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>出去玩</category>
      
    </categories>
    
    
    <tags>
      
      <tag>武汉美术馆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑基本知识</title>
    <link href="/2022/07/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/07/12/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-基本知识"><a href="#第一讲-基本知识" class="headerlink" title="第一讲 基本知识"></a>第一讲 基本知识</h1><h2 id="数字信号与系统"><a href="#数字信号与系统" class="headerlink" title="数字信号与系统"></a>数字信号与系统</h2><ul><li>模拟信号：信号的变换在时间上和数值上都是<strong>连续</strong>的</li><li>离散信号（数字信号）：信号的变化在时间上和数值上都是<strong>离散</strong>的，或者说<strong>断续</strong>的</li><li>离散信号的变化可以用不同的数字反映，所以又称为数字信号</li><li>数字系统<ul><li>数字系统是一个能对数字信号进行加工，传递和存储的实体，它由实现各种功能的数字逻辑电路相互连接而成</li><li>比如MP3、手机、数字计算机</li></ul></li><li>模拟信号与数字信号的相互转换<ul><li>A&#x2F;D-模数转换（Analog-Digital）</li><li>D&#x2F;A-数模转换（Digital-Analog）</li></ul></li><li>模拟信号数字化<ul><li>采样</li><li>量化与编码</li></ul></li><li>数字逻辑电路<ul><li>数字电路是用来处理数字信号的电子线路</li><li>由于数字电路的各种电路是通过逻辑运算和逻辑判断来实现的，所以数字电路又称为数字逻辑电路或者逻辑电路</li><li>数字逻辑电路的特点<ul><li>电路的基本工作信号是二值信号</li><li>电路中的半导体器件一般都工作在开、关状态</li><li>电路结构简单、功耗低、便于集成制造和系列化生产、产品价格低廉、使用方便、通用性好</li><li>工作速度快、精度高、功能强、可靠性好</li></ul></li><li>数字逻辑电路的类型（根据一个电路有无记忆功能划分）<ul><li>组合逻辑电路：无记忆功能<ul><li>在任何时刻稳定输出仅取决于该时刻的输入，而与电路的过去无关</li><li>类比行李箱的密码锁</li></ul></li><li>时序逻辑电路：有记忆功能<ul><li>在任何时刻的稳定输出不仅取决于该时刻的输入，而且与过去的输入相关</li><li>类比电话、电子密码锁</li><li>时序逻辑电路按照是否有统一的时钟信号进行同步可分为<ul><li>同步时序逻辑电路</li><li>异步时序逻辑电路</li></ul></li></ul></li></ul></li></ul></li><li>数字系统的层次结构<ul><li>第1级：电子元件，如二极管、三极管、电阻、电容</li><li>第2级：基本逻辑器件，如逻辑门、触发器 （SSI级）</li><li>第3级：逻辑功能部件，如加法器、计数器、乘法器（MSI、LSI级）</li><li>第4级：复杂逻辑功能部件，如微处理器（VLSI级）</li><li>第5级：复杂数字系统，含第2级到第4级的逻辑部件</li></ul></li><li>数字逻辑电路的研究方法<ul><li>两个任务<ul><li>逻辑设计<ul><li>根据提出的逻辑功能，在给定条件下构造出实现预定功能的逻辑电路</li></ul></li><li>逻辑分析 <ul><li>对一个已有的数字逻辑电路，研究它的工作性能和逻辑功能</li></ul></li></ul></li><li>传统方法<ul><li>以逻辑代数作为基本理论，从逻辑抽象到功能实现</li><li>建立在小规模集成电路基础之上</li><li>以技术经济指标作为评价一个设计方案优劣的主要性能指标</li><li>设计时追求的是如何使一个电路达到最简</li></ul></li><li>注意：一个最简的方案并不等于一个最佳的方案</li></ul></li></ul><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><ul><li>原码不能直接进行减法运算<ul><li>当对两个数求和时，如果符号相异，则先比较绝对值大小，然后做减法</li><li>绝对值大的符号是结果的符号</li><li>绝对值的差值是结果的数值位</li><li>用原码进行加减法较为麻烦！！！</li></ul></li><li>怎么解决？？？<ul><li>减法变加法，符号位直接参与运算</li></ul></li><li>反码做加减法运算<ul><li>产生的进位移到末位才等于正确结果</li><li>并且反码也有正0和负0</li><li>这种机器码还是不能很好进行加减法运算</li></ul></li><li>模的概念<ul><li>模指一个计量系统的计数范围</li><li>模实质上是计量系统产生“溢出”的量，它的值在计量系统上表示不出来，计量系统上只能表示出模的余数</li><li>任何有模的计量系统，均可化减法为加法运算</li><li>计算机也可以看成一个计量系统，有一个模</li></ul></li><li>补码的意义<ul><li>计算机中的数据受字长限制，数据的运算属于有模运算</li><li>计算结果直接丢掉进位</li><li>可以将减法转为加法运算</li><li>计算机中可只设置加法器，简化设计、降低成本</li></ul></li></ul><h2 id="几种常用的编码"><a href="#几种常用的编码" class="headerlink" title="几种常用的编码"></a>几种常用的编码</h2><ul><li><p>十进制数的二进制编码（BCD码）</p><ul><li>8421码（有权码）<ul><li>权值 8 4 2 1</li><li>和十进制转化为二进制是一样的</li></ul></li><li>2421码（有权码）<ul><li>权值 2 4 2 1</li></ul></li><li>余3码（无权码）<ul><li>在8421码的基础上加3</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191553202.png"></li></ul></li><li><p>十进制数在机器中的两种表示</p><ul><li>字符串形式<ul><li>一个字节存放一个十进制位</li><li>符号位用8421码中未选用的编码，正号1100，负号1101</li></ul></li><li>压缩的十进制数串<ul><li>一个字节存放两个十进制位</li><li>符号位用8421码中未选用的编码，正号1100，负号1101</li></ul></li></ul></li><li><p>可靠性编码</p><ul><li>减少或者发现代码在形成和传送过程中可能发生的错误</li><li>提高系统的可靠性</li><li>两种可靠性编码<ul><li>奇偶校验码</li><li>格雷码</li></ul></li></ul></li><li><p>奇偶校验</p><ul><li>奇校验：让整个校验码（有效的信息位和校验位）中1的个数为偶数</li><li>偶校验：让整个校验码中1的个数为奇数</li><li>有效信息（被校验的信息）部分可能是奇性（1的个数为奇数），也可能是偶性</li><li>奇偶两种校验都只需配一个校验位，就可以使整个校验码满足指定的奇偶性要求</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191600341.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191600048.png"></li></ul></li><li><p>奇偶校验特点</p><ul><li>一种常见的简单校验，只需1位校验码</li><li>只具有发现错误的能力，不具备对错误定位和纠正错误的能力</li><li>只具有发现一串二进制代码中，同时出现奇数个代码出错的能力</li><li>如果同时发生偶数个代码出错，奇偶校验失效</li></ul></li><li><p>格雷码</p><ul><li>特点：任意两个相邻的数，其格雷码只有一位不同</li><li>作用：避免代码形成和变换过程中产生的错误</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191601819.png"></li></ul></li><li><p>二进制到格雷码的转换</p><ul><li>$G_{n-1}&#x3D;B_{n-1}$ （最高位不变）     $G_i&#x3D;B_{i+1}\bigoplus B_i$</li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209191610080.png"></p></li><li><p>字符编码</p><ul><li>ASCII码</li></ul></li></ul><h1 id="第二讲-逻辑代数基础"><a href="#第二讲-逻辑代数基础" class="headerlink" title="第二讲 逻辑代数基础"></a>第二讲 逻辑代数基础</h1><h2 id="逻辑代数的基本概念"><a href="#逻辑代数的基本概念" class="headerlink" title="逻辑代数的基本概念"></a>逻辑代数的基本概念</h2><p><strong>加号表示或（析取），点乘号表示与（合取）</strong></p><ul><li><p>逻辑代数定义</p><ul><li>逻辑代数L是一个封闭的代数系统</li><li>由一个逻辑变量集K，常量0和1，以及或、与、非三种基本运算所构成</li></ul></li><li><p>逻辑代数公理</p><ul><li>交换律</li><li>结合律</li><li>分配律</li><li>0-1律<ul><li>A+0&#x3D;A        A+1&#x3D;1</li><li>A * 0&#x3D;0       A * 1&#x3D;A</li></ul></li><li>互补律<ul><li>对任意逻辑变量A，存在唯一B，使得A+B&#x3D;1,A * B&#x3D;0</li></ul></li></ul></li><li><p>逻辑变量及基本运算</p><ul><li><p>或运算</p><ul><li>实现或运算关系的逻辑电路称为或门</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101159454.png"></li></ul></li><li><p>与运算</p><ul><li>实现与运算关系的逻辑电路称为与门</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101200522.png"></li></ul></li><li><p>非运算</p><ul><li>实现非运算关系的逻辑电路称为非门或者<strong>反相器</strong></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101203717.png"></li></ul></li></ul></li><li><p>逻辑函数</p><ul><li>定义：随自变量变化的因变量</li><li>与普通代数函数概念相比，逻辑函数的特点：<ul><li>逻辑函数和逻辑变量一样，取值只有0和1两种可能</li><li>函数和变量之间的关系由或、与、非三种基本运算决定</li></ul></li></ul></li><li><p>逻辑函数相等</p><ul><li>两个因变量a和b随自变量变化，任何自变量的值对应的a值和b值都相同，则称a和b相等</li><li>判断方法<ul><li>真值表法</li><li>代数法</li></ul></li></ul></li><li><p>逻辑功能的表示法</p><ul><li>逻辑表达式<ul><li>逻辑函数的简写<ul><li>非运算符下可不加括号</li><li>与运算符一般可省略</li><li>既有与又有或，先与后或</li><li>运算优先法则：括号&gt;非&gt;与&gt;异或&gt;或</li><li>与运算和或运算均满足结合律</li></ul></li></ul></li><li>真值表</li><li>卡诺图<ul><li>由表示逻辑变量所有取值组合的小方格构成的平面图</li><li>图形化描述逻辑函数</li></ul></li></ul></li></ul><h2 id="逻辑表达式的形式与转换"><a href="#逻辑表达式的形式与转换" class="headerlink" title="逻辑表达式的形式与转换"></a>逻辑表达式的形式与转换</h2><h3 id="与或-x2F-或与表达式"><a href="#与或-x2F-或与表达式" class="headerlink" title="与或&#x2F;或与表达式"></a>与或&#x2F;或与表达式</h3><ul><li>与-或表达式<ul><li>若干与项进行或运算构成的表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101228547.png"></li></ul></li><li>或-与表达式<ul><li>若干或项进行与运算构成的表达式</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101230829.png"></li></ul></li></ul><h3 id="最小项-x2F-最大项"><a href="#最小项-x2F-最大项" class="headerlink" title="最小项&#x2F;最大项"></a>最小项&#x2F;最大项</h3><ul><li><p>最小项定义</p><ul><li>具有n个变量的函数的“与项”包含全部n个变量（所有变量全都出现）</li><li>每个变量都以原变量或反变量形式出现一次，且仅出现一次 </li><li>该与项被称为最小项，有时称为标准与项</li></ul></li><li><p>最小项数目</p><ul><li>n个变量可以构成2的n次方个最小项</li></ul></li><li><p>简写$m_i$</p><ul><li>i的取值规则<ul><li>按照变量顺序将最小项中的原变量用1表示，反变量用0表示，由此得到一个二进制数，与该二进制数对应的十进制数即下标i的值</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101238970.png"></li><li>A为原变量用1表示，B为反变量用0表示，C为原变量用1表示，得到101，把101看成二进制数，转化为十进制就得到5</li></ul></li></ul></li><li><p>用最小项表示函数</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101243927.png"></li></ul></li><li><p>最小项性质</p><ul><li>任意一个最小项，其相应变量有且仅有一种取值使这个最小项的值为1，最小项不同，使其值为1的变量取值也不同，任何一种变量取值都不可能使两个不同的最小项同时为1<ul><li>在由n个变量构成的任意与项中，最小项是使其值为1的变量取值组合数最少的一种与项 </li><li>上面这点也是最小项名字的由来</li></ul></li><li>相同变量构成的两个不同最小项，相与为0</li><li>n个变量的全部最小项，相或为1</li><li>n个变量构成的最小项有n个相邻最小项<ul><li>相邻最小项：除一个变量相反外，其余变量均相同的最小项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101248868.png"></li></ul></li></ul></li><li><p>最大项定义</p><ul><li>具有n个变量的函数的”或项” 包含全部n个变量</li><li>每个变量都以原变量或反变量形式出现一次，且仅出现一次</li><li>该或项被称为最大项，有时称为标准或项</li></ul></li><li><p>最大项数目</p><ul><li>n个变量可以构成2的n次方个最小项</li></ul></li><li><p>简写$M_i$</p><ul><li>按照变量顺序将最大项中的原变量用0表示，反变量用1表示</li><li>由此得到一个二进制数，与该二进制数对应的十进制数就是下标i的取值</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101254386.png"></li></ul></li><li><p>最大项表示函数</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101319638.png"></li></ul></li><li><p>最大项性质</p><ul><li><p>任意一个最大项，其相应变量有且仅有一种取值使这个最大项的值为0，最大项不同，使其值为0的变量取值也不同</p><ul><li>在由n个变量构成的任意或项中，最大项是使其值为1的变量取值组合数最大的一种或项</li><li>上面这点也是最大项名字的由来</li></ul></li><li><p>相同变量构成的两个不同最大项，相或为1</p></li><li><p>n个变量的全部最大项，相与为0</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101325216.png"></li></ul></li><li><p>n个变量构成的最大项有n个相邻最大项</p><ul><li>相邻最大项：除一个变量相反外，其余变量均相同的最大项</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101326271.png"></li></ul></li></ul></li><li><p>最小项和最大项的关系</p><ul><li>在同一个问题中，下标相同的最小项和最大项互为反函数</li><li>相同变量构成的最小项$m_i$和最大项$M_i$之间存在互补关系</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101328075.png"></li></ul></li></ul><h3 id="标准与或-x2F-或与表达式"><a href="#标准与或-x2F-或与表达式" class="headerlink" title="标准与或&#x2F;或与表达式"></a>标准与或&#x2F;或与表达式</h3><ul><li>标准与-或表达式<ul><li>由若干最小项相或构成的逻辑表达式</li><li>最小项表达式</li></ul></li><li>标准或-与表达式<ul><li>由若干最大项相与构成的逻辑表达式</li><li>最大项表达式<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209101330732.png"></li></ul></li></ul><h3 id="逻辑函数表达式的转换方法"><a href="#逻辑函数表达式的转换方法" class="headerlink" title="逻辑函数表达式的转换方法"></a>逻辑函数表达式的转换方法</h3><p><strong>定理？？？？（记得补充）</strong></p><ul><li>逻辑函数表达式的转换方法<ul><li>代数转换法<ul><li>求标准与或表达式<ul><li>第一步，将函数表达式变换成一般与-或表达式</li><li>第二步，反复使用 <strong>X&#x3D;X(Y+(-Y))</strong> 即X等于X与上Y或非Y，将表达式中所有非最小项的与项扩展成最小项</li><li>注意：当给出的函数表达式已经是与或表达式，可直接第二步</li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110913767.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110914559.png"></li></ul></li><li>求标准或与表达式<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110917671.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110918477.png"></li></ul></li></ul></li><li>真值表转换法<ul><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110919193.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110919404.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110928135.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202209110928485.png"><br> 任何一个逻辑函数的两种标准形式唯一</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数字逻辑</category>
      
      <category>数字逻辑基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2022/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2022/07/12/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第一讲-基本概念"><a href="#第一讲-基本概念" class="headerlink" title="第一讲 基本概念"></a>第一讲 基本概念</h1><ul><li><p>什么是数据结构？（抽象数据类型的物理实现）</p><ul><li>解决问题方法的效率，和数据的组织方式是直接相关的，与空间的利用效率有关，与算法的巧妙程度相关</li></ul></li><li><p>什么是算法？（一系列解决问题的清晰指令）</p></li><li><p>什么是好的算法？（综合看空间复杂度和时间复杂度）</p></li><li><p>最大子列和的几种算法</p><ul><li>分而治之</li><li>在线处理<ul><li>在线的意思是指每输入一个数据就进行即时处理，在任何一个地方终止输出，算法都可以正确给出当前解</li></ul></li></ul></li></ul><h1 id="第二讲-线性结构"><a href="#第二讲-线性结构" class="headerlink" title="第二讲 线性结构"></a>第二讲 线性结构</h1><h2 id="线性表及其实现"><a href="#线性表及其实现" class="headerlink" title="线性表及其实现"></a>线性表及其实现</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>什么是线性表<ul><li>由同类型数据元素构成有序序列的线性结构<ul><li>表中元素个数称为线性表的长度</li><li>线性表没有元素时，称为空表</li><li>表起始位置称表头，结束位置表尾</li></ul></li></ul></li><li>线性表怎么存储？<ul><li>顺序存储（数组）</li><li>链式存储（链表）</li></ul></li><li>线性表的主要操作<br>- 初始化<br>- 根据位序返回相应元素<br>- 查找<br>- 插入<br>- 删除<br>- 返回线性表长度</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="线性表的定义与操作——顺序表"><a href="#线性表的定义与操作——顺序表" class="headerlink" title="线性表的定义与操作——顺序表"></a>线性表的定义与操作——顺序表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span>     ElementType Data[MAXSIZE];     Position Last; &#125;;<br><br><span class="hljs-comment">/* 初始化 */</span><br>List <span class="hljs-title function_">MakeEmpty</span><span class="hljs-params">()</span> &#123;     List L;     L = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>L-&gt;Last = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> L; &#125; <br><br><br><br><br><span class="hljs-comment">/* 查找 */</span> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR -1 Position Find( List L, ElementType X ) </span><br>&#123; Position i = <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">while</span>( i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i]!= X )  <br>       i++;    <br>       <span class="hljs-keyword">if</span> ( i &gt; L-&gt;Last )  <br>         <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">/* 如果没找到，返回错误信息 */</span>    <br>       <span class="hljs-keyword">else</span><br>         <span class="hljs-keyword">return</span> i;  <span class="hljs-comment">/* 找到后返回的是存储位置 */</span> &#125; <br><br><br><br><br><span class="hljs-comment">/* 插入 */</span> <span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span><br>&#123; <span class="hljs-comment">/* 在L的指定位置P前插入一个新元素X */</span> <br>Position i;    <br><span class="hljs-keyword">if</span> ( L-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>) <br>&#123; <span class="hljs-comment">/* 表空间已满，不能插入 */</span>   <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表满&quot;</span>);   <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;       <br><span class="hljs-keyword">if</span> ( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last+<span class="hljs-number">1</span> )<br>&#123; <span class="hljs-comment">/* 检查插入位置的合法性 */</span> <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置不合法&quot;</span>);  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;   <br><span class="hljs-keyword">for</span>( i=L-&gt;Last; i&gt;=P; i-- )  <br>L-&gt;Data[i+<span class="hljs-number">1</span>] = L-&gt;Data[i]; <span class="hljs-comment">/* 将位置P及以后的元素顺序向后移动 */</span>  <br>L-&gt;Data[P] = X;  <span class="hljs-comment">/* 新元素插入 */</span>   <br>L-&gt;Last++;       <span class="hljs-comment">/* Last仍指向最后元素 */</span>  <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  &#125; <br><br><br><br><br><span class="hljs-comment">/* 删除 */</span> <span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*/</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span> <br>&#123; <span class="hljs-comment">/* 从L中删除指定位置P的元素 */</span>  <br>Position i;  <br><span class="hljs-keyword">if</span>( P&lt;<span class="hljs-number">0</span> || P&gt;L-&gt;Last ) &#123; <span class="hljs-comment">/* 检查空表及删除位置的合法性 */</span>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置%d不存在元素&quot;</span>, P ); <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;      &#125;   <br> <span class="hljs-keyword">for</span>( i=P+<span class="hljs-number">1</span>; i&lt;=L-&gt;Last; i++ ) <br> L-&gt;Data[i<span class="hljs-number">-1</span>] = L-&gt;Data[i]; <br> <span class="hljs-comment">/* 将位置P+1及以后的元素顺序向前移动 */</span> <br>L-&gt;Last--; <span class="hljs-comment">/* Last仍指向最后元素 */</span> <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线性表的定义与操作——链式表"><a href="#线性表的定义与操作——链式表" class="headerlink" title="线性表的定义与操作——链式表"></a>线性表的定义与操作——链式表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">PtrToLNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> &#123;</span>     ElementType Data;     PtrToLNode Next; &#125;; <br>   <span class="hljs-keyword">typedef</span> PtrToLNode Position;<br>   <span class="hljs-keyword">typedef</span> PtrToLNode List; <br>   <span class="hljs-comment">/* 查找 */</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR NULL Position Find( List L, ElementType X )</span><br>     &#123;     <br>     Position p = L; <span class="hljs-comment">/* p指向L的第1个结点 */</span>     <br>     <span class="hljs-keyword">while</span> ( p &amp;&amp; p-&gt;Data!=X )         <br>     p = p-&gt;Next;     <br>     <span class="hljs-comment">/* 下列语句可以用 return p; 替换 */</span>     <br>     <span class="hljs-keyword">if</span> ( p )         <br>      <span class="hljs-keyword">return</span> p;     <br>     <span class="hljs-keyword">else</span>         <br>      <span class="hljs-keyword">return</span> ERROR; &#125; <br><span class="hljs-comment">/* 带头结点的插入 */</span> <span class="hljs-comment">/*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 */</span> <br>   <span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">( List L, ElementType X, Position P )</span> <br>   &#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span>     <br>   Position tmp, pre;     <br>   <span class="hljs-comment">/* 查找P的前一个结点 */</span>             <br>   <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) <br>   ;                 <br>   <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> ) &#123; <br>   <span class="hljs-comment">/* P所指的结点不在L中 */</span>         <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置参数错误\n&quot;</span>);         <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     &#125;     <br>   <span class="hljs-keyword">else</span> &#123; <br>   <span class="hljs-comment">/* 找到了P的前一个结点pre */</span>         <br>   <span class="hljs-comment">/* 在P前插入新结点 */</span>     tmp = (Position)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> LNode));<br>   <span class="hljs-comment">/* 申请、填装结点 */</span><br>   tmp-&gt;Data = X;          <br>   tmp-&gt;Next = P;         <br>   pre-&gt;Next = tmp;         <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>    &#125; <br>   &#125; <br>   <span class="hljs-comment">/* 带头结点的删除 */</span> <span class="hljs-comment">/*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 */</span> <br>   <span class="hljs-type">bool</span> <span class="hljs-title function_">Delete</span><span class="hljs-params">( List L, Position P )</span><br>    &#123; <span class="hljs-comment">/* 这里默认L有头结点 */</span>     <br>    Position pre;     <br>    <span class="hljs-comment">/* 查找P的前一个结点 */</span>             <br>    <span class="hljs-keyword">for</span> ( pre=L; pre&amp;&amp;pre-&gt;Next!=P; pre=pre-&gt;Next ) <br>    ;                 <br>    <span class="hljs-keyword">if</span> ( pre==<span class="hljs-literal">NULL</span> || P==<span class="hljs-literal">NULL</span>)<br>     &#123; <span class="hljs-comment">/* P所指的结点不在L中 */</span>         <br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除位置参数错误\n&quot;</span>);         <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     &#125;     <br>     <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 找到了P的前一个结点pre */</span>         <br>     <span class="hljs-comment">/* 将P位置的结点删除 */</span>         <br>     pre-&gt;Next = P-&gt;Next;         <br>     <span class="hljs-built_in">free</span>(P);         <br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>       &#125; <br>     &#125;<br></code></pre></td></tr></table></figure><h2 id="广义表与多重链表"><a href="#广义表与多重链表" class="headerlink" title="广义表与多重链表"></a>广义表与多重链表</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>广义表<ul><li>广义表是线性表的推广</li><li>对于线性表而言，n个元素都是基本的单元素</li><li>而广义表中，这些元素不仅可以是单元素也可以是另一个广义表</li></ul></li><li>多重链表（链表中的节点可能同时隶属于多个链）<ul><li>多重链表中结点的指针域会有多个，如前面例子包含了Next和SubList两个指针域</li><li>但包含两个指针域的链表并不一定是多重链表，比如双向链表不是多重链表</li><li>多重链表用途广泛：树、图这样相对复杂的数据结构可以采用多重链表方式实现存储</li></ul></li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*广义表*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">GList</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br><span class="hljs-type">int</span> Tag;   <span class="hljs-comment">/*标志域：0表示结点是单元素，1表示结点是广义表*/</span><br><span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br><span class="hljs-comment">/*子表指针域Sublist与单元素数据域Data复用，即共用存储空间*/</span><br>ElementType Data;<br>GList Sublist;<br><br>&#125;URegion;<br>GList Next;  <span class="hljs-comment">/*指向后继结点*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>什么是队列？<ul><li>具有一定操作约束的线性表</li><li>只能在一端插入，而在另一端删除</li><li>数据插入：入队列</li><li>数据删除：出队列</li><li>先来先服务</li><li>先进先出：FIFO</li></ul></li><li>队列的抽象数据类型描述<ul><li>数据对象集：一个有0个或多个元素的有穷线性表</li><li>操作集：长度为MaxSize的队列Q$\in$Qyeue,队列元素item$\in$ElementType</li><li>基本操作<ul><li>Queue CreatQueue(int MaxSize)：生成长度为MaxSize的空队列</li><li>int IsFullQ(Queue Q,int MaxSize)：判断队列Q是否已满</li><li>void AddQ(Queue Q, ElementType item)：将数据元素item插入队列Q中</li><li>int IsEmptyQ(Queue Q)：判断队列Q是否为空</li><li>ElementType DeleteQ(Queue Q)：将队头数据元素从队列中删除并返回</li></ul></li></ul></li><li>队列的顺序存储实现<ul><li>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成</li><li>顺环队列</li></ul></li><li>队列的链式存储实现<ul><li>可以用一个单链表实现，插入和删除操作分别在链表的两头进行</li><li>注意：队列指针front应在单向链表的开头rear在尾（尾部删除操作找不到前面的元素，所有不能把front放在尾）</li></ul></li><li>应用实例（多项式加法）<ul><li>主要思路：相同指数项系数相加，不同指数项系数进行拷贝</li><li>采用不带头结点的单向链表，按照指数递减的顺序排列各项</li><li>两个指针P1和P2分别指向这两个多项式的第一个结点，不断循环<ul><li>P1指向的项如果指数等于P2指向的项的指数：系数相加，若结果不为0，则作为结果多项式对应项的系数。同时，P1和P2都分别指向下一项<ul><li>P1所指指数大于P2：将P1的当前项存入结果多项式，并使P1指向下一项</li><li>P1所指指数小于P2：将P2的当前项存入结果多项式，并使P2指向下一项</li><li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中去</li></ul></li></ul></li></ul></li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span>     Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> <br>&#125;; <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br>Queue <span class="hljs-title function_">CreateQueue</span><span class="hljs-params">( <span class="hljs-type">int</span> MaxSize )</span> &#123;     Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> QNode));<br>Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-keyword">sizeof</span>(ElementType));     Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;     <br>Q-&gt;MaxSize = MaxSize;         <br><span class="hljs-keyword">return</span> Q;      <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsFull</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize == Q-&gt;Front); &#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span> &#123;     <br>    <span class="hljs-keyword">if</span> ( IsFull(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;   Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        Q-&gt;Data[Q-&gt;Rear] = X;         <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>&#125; <br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear); &#125; <br>ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br><span class="hljs-keyword">if</span> ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span>  <br>&#123;   Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;         <br><span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <br><span class="hljs-comment">/* 队列中的结点 */</span>     <br>ElementType Data;     <br>PtrToNode Next; &#125;; <br><span class="hljs-keyword">typedef</span> PtrToNode Position; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span>     <br>Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span>     <span class="hljs-type">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span> &#125;; <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span> <br><span class="hljs-type">bool</span> <span class="hljs-title function_">IsEmpty</span><span class="hljs-params">( Queue Q )</span> &#123;     <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>); &#125; ElementType <span class="hljs-title function_">DeleteQ</span><span class="hljs-params">( Queue Q )</span> &#123;     <br>Position FrontCell;      <br>ElementType FrontElem;          <br><span class="hljs-keyword">if</span>  ( IsEmpty(Q) ) <br>&#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);         <br><span class="hljs-keyword">return</span> ERROR;     <br>&#125;     <br><span class="hljs-keyword">else</span> <br>&#123;    FrontCell = Q-&gt;Front;         <br><span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span>                 Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span> <br>            <span class="hljs-keyword">else</span>                                  <br> Q-&gt;Front = Q-&gt;Front-&gt;Next;         <br> FrontElem = FrontCell-&gt;Data;         <br> <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span>         <br> <span class="hljs-keyword">return</span>  FrontElem;     <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多项式加法用队列实现"><a href="#多项式加法用队列实现" class="headerlink" title="多项式加法用队列实现"></a>多项式加法用队列实现</h4>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>线性结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
