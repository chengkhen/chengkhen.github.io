

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ChengKhen">
  <meta name="keywords" content="">
  
    <meta name="description" content="第二章 线性表2.1 线性表的定义和特点线性表是具有相同特性的数据元素的一个有限序列。  线性表(Linear List)：  由n(n ≥ 0)个数据元素（结点）a1, a2, … an组成的有限序列。  其中数据元素的个数n定义为表的长度  当n&#x3D;0时称为空表  将非空的线性表(n&gt;0)记作：(a1, az, … an)  这里的数据元素ai(1≤i≤n)只是一个抽象的符号，其">
<meta property="og:type" content="article">
<meta property="og:title" content="Blog of ChengKhen">
<meta property="og:url" content="http://example.com/2022/10/13/%E7%BA%BF%E6%80%A7%E8%A1%A8%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/index.html">
<meta property="og:site_name" content="Blog of ChengKhen">
<meta property="og:description" content="第二章 线性表2.1 线性表的定义和特点线性表是具有相同特性的数据元素的一个有限序列。  线性表(Linear List)：  由n(n ≥ 0)个数据元素（结点）a1, a2, … an组成的有限序列。  其中数据元素的个数n定义为表的长度  当n&#x3D;0时称为空表  将非空的线性表(n&gt;0)记作：(a1, az, … an)  这里的数据元素ai(1≤i≤n)只是一个抽象的符号，其">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210192252376.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142235433.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142255418.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151549155.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151601055.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131139437.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131138707.png">
<meta property="article:published_time" content="2022-10-13T02:55:12.000Z">
<meta property="article:modified_time" content="2023-01-23T07:11:44.983Z">
<meta property="article:author" content="ChengKhen">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210192252376.png">
  
  
  
  <title>Blog of ChengKhen</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ChengKhen</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-13 10:55" pubdate>
          2022年10月13日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          124 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和特点"><a href="#2-1-线性表的定义和特点" class="headerlink" title="2.1 线性表的定义和特点"></a>2.1 线性表的定义和特点</h2><p><strong>线性表是具有相同特性的数据元素的一个有限序列</strong>。</p>
<blockquote>
<p>线性表(Linear List)：</p>
</blockquote>
<p>由n(n ≥ 0)个数据元素（结点）a1, a2, … an组成的<strong>有限序列</strong>。</p>
<ul>
<li><p>其中数据元素的个数n定义为表的<strong>长度</strong></p>
</li>
<li><p>当n&#x3D;0时称为<strong>空表</strong></p>
</li>
<li><p>将非空的线性表(n&gt;0)记作：(a1, az, … an)</p>
</li>
<li><p>这里的数据元素ai(1≤i≤n)只是一个抽象的符号，其具体含义在不同的情况下可以不同。</p>
</li>
</ul>
<blockquote>
<p>线性表的逻辑特征</p>
</blockquote>
<ul>
<li><p>在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2；</p>
</li>
<li><p>有且仅有一个终端结点an，它没有直接后继，而仅有一个直接前趋an-1；</p>
</li>
<li><p>其余的内部结点ai(2≤i≤n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1。</p>
</li>
</ul>
<h2 id="2-2-案例引入"><a href="#2-2-案例引入" class="headerlink" title="2.2 案例引入"></a>2.2 案例引入</h2><blockquote>
<p>顺序存储结构存在问题</p>
</blockquote>
<ul>
<li><p>存储空间分配不灵活</p>
</li>
<li><p>运算的空间复杂度高</p>
</li>
</ul>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><p>线性表中的数据元素的类型可以为<strong>简单类型</strong>，也可以为<strong>复杂类型</strong></p>
</li>
<li><p>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序</p>
</li>
<li><p>从具体应用中抽象出共性的<strong>逻辑结构和基本操作</strong>（抽象数据类型），然后实现其<strong>存储结构和基本操作</strong></p>
</li>
</ul>
<h2 id="2-3-线性表的定义"><a href="#2-3-线性表的定义" class="headerlink" title="2.3 线性表的定义"></a>2.3 线性表的定义</h2><blockquote>
<p>基本操作</p>
</blockquote>
<ul>
<li><p>InitList(&amp;L)</p>
<ul>
<li>操作结果：构造一个空的线性表L</li>
</ul>
</li>
<li><p>DestoryList(&amp;L)</p>
<ul>
<li><p>初始条件：线性表L已存在</p>
</li>
<li><p>操作结果：销毁线性表L</p>
</li>
</ul>
</li>
<li><p>ClearList(&amp;L)</p>
<ul>
<li><p>初始条件：线性表L已存在</p>
</li>
<li><p>操作结果：将线性表L重置为空表</p>
</li>
</ul>
</li>
<li><p>ListEmpty(L)</p>
<ul>
<li><p>初始条件：线性表L已存在</p>
</li>
<li><p>操作结果：若线性表L空表则返回TURE；否则返回FALSE。</p>
</li>
</ul>
</li>
<li><p>ListLength(L)</p>
<ul>
<li><p>初始条件：线性表L已存在</p>
</li>
<li><p>操作结果：返回线性表L中的数据元素个数。</p>
</li>
</ul>
</li>
<li><p>GetElem(L, i, &amp;e)</p>
<ul>
<li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</p>
</li>
<li><p>操作结果：用e返回线性表L中第个数据元素的值。</p>
</li>
</ul>
</li>
<li><p>LocateElem(L, e, compare())</p>
<ul>
<li><p>初始条件：线性表L已存在，compare()是数据元素判定函数</p>
</li>
<li><p>操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。</p>
</li>
</ul>
</li>
<li><p>PriorElem(L, cur_e, &amp;pre_e)</p>
<ul>
<li><p>初始条件：线性表L已存在</p>
</li>
<li><p>操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义。</p>
</li>
</ul>
</li>
<li><p>NextElem(L, cur_e, &amp;next_e)</p>
<ul>
<li><p>初始条件：线性表L已存在</p>
</li>
<li><p>操作结果：若cur_e是L的数据元素，且不是第最后个，则用next_e返回它的后继，否则操作失败，next_e无意义。</p>
</li>
</ul>
</li>
<li><p>ListInsert(&amp;L, i, e)</p>
<ul>
<li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)+1</p>
</li>
<li><p>操作结果：在L的第i个位置<strong>之前</strong>插入新的数据元素e，L的长度加一。</p>
</li>
</ul>
</li>
<li><p>ListDelete(&amp;L, i, &amp;e)</p>
<ul>
<li><p>初始条件：线性表L已存在，1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</p>
</li>
<li><p>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一。</p>
</li>
</ul>
</li>
<li><p>ListTraverse(&amp;L, visited())   &#x2F;&#x2F; 遍历</p>
<ul>
<li><p>初始条件：线性表L已存在</p>
</li>
<li><p>操作结果：依次对线性表中每个元素调用visited()。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-4-线性表的顺序表示和实现"><a href="#2-4-线性表的顺序表示和实现" class="headerlink" title="2.4 线性表的顺序表示和实现"></a>2.4 线性表的顺序表示和实现</h2><h3 id="2-4-1-线性表的顺序存储表示"><a href="#2-4-1-线性表的顺序存储表示" class="headerlink" title="2.4.1 线性表的顺序存储表示"></a>2.4.1 线性表的顺序存储表示</h3><p>线性表的顺序表示又称为<strong>顺序存储结构</strong>或<strong>顺序映像</strong>。</p>
<p>顺序存储定义：把<strong>逻辑上相邻的数据元素</strong>存储在<strong>物理上相邻的存储单元</strong>中的存储结构。</p>
<p>线形表顺序存储结构占用<strong>一片续的存储空间</strong>。知道某个元素的存储位置就可以计算其他元素的存储位置。</p>
<blockquote>
<p>数组静态分配</p>
</blockquote>
<p>这段代码就相当于一个模板<br>typedef是用来给数据类型起一个新的名字<br>ElemType是数组的数据类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 100  <span class="hljs-comment">//线性表存储空间初始分配量</span></span><br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType data[MaxSize];<br>    <span class="hljs-type">int</span> length;  <span class="hljs-comment">//线性表当前长度</span><br>  &#125; SqList; <span class="hljs-comment">// 顺序表类型</span><br></code></pre></td></tr></table></figure>

<p>数组存放的是第一个元素的地址，因此也可以写成以下动态分配形式，用指针代替第一个元素地址。</p>
<blockquote>
<p>数组动态分配</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_INIT_SIZE 1000  <span class="hljs-comment">//线性表存储空间</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>  ElemType *data;  <span class="hljs-comment">//存储空间的基地址</span><br>  <span class="hljs-type">int</span> length;<br>&#125; SqList; <span class="hljs-comment">// 定义顺序表类型</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">SqList L;  <span class="hljs-comment">//定义变量L，L是SqList这种类型的，L是个线性表</span><br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(ElemType) * MaxSize);<br></code></pre></td></tr></table></figure>
<p>（ElemType*）表示强制类型转换</p>
<p>在头文件stdlib.h中：</p>
<p>malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址。</p>
<p>size of(x)运算，计算变量x的长度</p>
<p>free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量。</p>
<blockquote>
<p>补充：C++的动态存储分配</p>
</blockquote>
<p>new 类型名T （初值列表）<br>    功能：<br>        申请用于存放T类型对象的内存空间，并依初值列表赋以初值结果值<br>    结果值：<br>        成功：T类型的指针，指向新分配的内存<br>        失败：0（NULL)<br>例如：int * p1 &#x3D; new int;或int * p1 &#x3D; new int(10);<br>注意：new出来的空间是一个地址所以只能赋值给指针。</p>
<p>delete 指针p<br>    功能：<br>        释放指针p所指向的内存。p必须是new操作的返回值</p>
<blockquote>
<p>补充：C++的参数传递</p>
</blockquote>
<ul>
<li><p>函数调用时传送给形参表的实参必须与形参三个一致</p>
<ul>
<li>类型、个数、顺序</li>
</ul>
</li>
<li><p>参数传递有两种方式</p>
<ul>
<li>传值方式</li>
<li>传地址<ul>
<li>参数为指针变量</li>
<li>参数为引用类型</li>
<li>参数为数组名</li>
</ul>
</li>
</ul>
</li>
<li><p>传地址方式–引用类型作参数<br>什么是引用？？？<br>引用：它用来给一个对象提供一个替代的名字</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> i=<span class="hljs-number">5</span>;<br>	<span class="hljs-type">int</span> &amp;j=i;<br>	i=<span class="hljs-number">7</span>;<br>	cout&lt;&lt;<span class="hljs-string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;j=&quot;</span>&lt;&lt;j;<br>&#125;  <span class="hljs-comment">//j是一个引用类型，代表i的一个替代名i值改变时，j值也跟着改变，所以会输出i=7 j=7</span><br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210192252376.png" srcset="/img/loading.gif" lazyload></p>
<p>m是对a的引用，n是对b的引用，通过引用变量直接操作实参</p>
<p>可以这样理解：m和a用的是同一个地址，他们共用同一块空间</p>
<ul>
<li>引用类型作形参的三点说明<ul>
<li>传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化</li>
<li>引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作，而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值时实参变量的副本。因此当参数传递的<strong>数据量比较大</strong>时，用引用比用一般变量传递参数的时间和空间效率都好</li>
<li>指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“* 指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用的点出，必须用变量的地址作为实参</li>
</ul>
</li>
</ul>
<h3 id="2-4-2-顺序表基本操作的实现"><a href="#2-4-2-顺序表基本操作的实现" class="headerlink" title="2.4.2 顺序表基本操作的实现"></a>2.4.2 顺序表基本操作的实现</h3><blockquote>
<p>线性表L的初始化</p>
</blockquote>
<p>Status 是函数的类型，其值是函数结果状态代码，在本例中为int的别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitList_Sq</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<span class="hljs-comment">// 构造一个空的顺序表L   </span><br>L.elem=<span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">// 为顺序表分配空间</span><br><span class="hljs-keyword">if</span>(!L.elem) <br>    <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 空表长度为0</span><br><span class="hljs-keyword">return</span> OK；<br></code></pre></td></tr></table></figure>

<blockquote>
<p>销毁线性表L</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestoryList</span><span class="hljs-params">(SqList &amp;L)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(L.elem) <br>      <span class="hljs-keyword">delete</span> L.elem; <span class="hljs-comment">// 释放存储空间</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>清空线性表L</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  L.length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 将线性表的长度置为0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>求线性表的长度</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> L.length;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>判断线性表是否为空</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>顺序表的取值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 取物理位置第i个元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt;= L.length) <span class="hljs-keyword">return</span> ERROR;<br><br>  e = L.elem[i<span class="hljs-number">-1</span>];<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里是在主函数定义了变量e，并且通过引用的方式把值已经传给e了，所以不用return e，这样写代码是为了获取状态代码，判断此操作中传入的i值是否可在线性表中取到</p>
<blockquote>
<p>顺序表按值查找(顺序查找)</p>
</blockquote>
<ul>
<li><p>在线性表L中查找与指定值e相同的数据元素的位置</p>
</li>
<li><p>从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，返回0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//顺序表的查找（按值查找）</span><br><span class="hljs-comment">//暂且先用最简单的查找方法，从表的一端开始，逐个进行记录的关键字和给定值比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在线性表L中查找值为e的元素，返回其序号（是第几个元素）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;  <span class="hljs-comment">//查找成功，返回序号</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//查找失败，返回0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>平均查找长度ASL(Average Search Length):</p>
<ul>
<li><p>为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的<strong>平均查找长度</strong>。</p>
</li>
<li><p><strong>数学期望&#x3D;平均查找长度</strong></p>
</li>
</ul>
<blockquote>
<p>顺序表插入</p>
</blockquote>
<p>插入不同位置的算法演示：插入位置在最后、插入位置在中间、插入位置在最前面</p>
<p>算法思想：</p>
<ol>
<li><p>判断插入位置i是否合理</p>
</li>
<li><p>判断顺序表的存储空间是否已满，若已满返回ERROR</p>
</li>
<li><p>将第n至第i位的元素一次向后移动一个位置，空出第i个位置</p>
</li>
<li><p>将要插入的新元素e放入第i个位置</p>
</li>
<li><p>表长加1，返回插入成功。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ListInsert_Sq</span>(SqList&amp; L, <span class="hljs-type">int</span> i, ElemType e)<br>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// i值不合法</span><br>  <span class="hljs-keyword">if</span>(L.length == MAXSIZE) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 当前存储已满</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = L.length<span class="hljs-number">-1</span>; j &gt;= i; j--)&#123;<br>    L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<br>  &#125;  <span class="hljs-comment">//把位置i后的元素都后移一个位置</span><br>  L.elem[i<span class="hljs-number">-1</span>] = e;<br>  L.length++;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>顺序表插入算法的平均时间复杂度为O(n)。</p>
<blockquote>
<p>顺序表的删除算法</p>
</blockquote>
<p>算法思想：</p>
<ol>
<li><p>判断删除位置i是否合法</p>
</li>
<li><p>将欲删除的元素保留在e中</p>
</li>
<li><p>将第i+1至第n位的元素依次向前移动一个位置</p>
</li>
<li><p>表长减1，删除成功返回OK</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ListInsert_Sq</span>(SqList&amp; L, <span class="hljs-type">int</span> i)<br>&#123;<br>  <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// i值不合法</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt;= L.length<span class="hljs-number">-1</span>; j++)&#123;<br>    L.elem[j<span class="hljs-number">-1</span>] = L.elem[j];<br>  &#125;<br>  L.length--;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125; <br><span class="hljs-comment">//注意算法里面的i是位置不是数组下标</span><br></code></pre></td></tr></table></figure>

<p>顺序表删除算法的平均时间复杂度为O(n)。</p>
<h3 id="2-4-3-顺序表小结"><a href="#2-4-3-顺序表小结" class="headerlink" title="2.4.3 顺序表小结"></a>2.4.3 顺序表小结</h3><ol>
<li><p>利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致</p>
</li>
<li><p>在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等</p>
<ul>
<li>这种存取元素的方法被称为<strong>随机存取法</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>顺序表的操作算法分析</p>
</blockquote>
<ul>
<li><p>时间复杂度</p>
<ul>
<li>查找、插入、删除算法的平均时间复杂度为O(n)</li>
</ul>
</li>
<li><p>空间复杂度</p>
<ul>
<li>顺序表操作算法的空间复杂度S(n) &#x3D; O(1)，没有占用辅助空间</li>
</ul>
</li>
</ul>
<blockquote>
<p>顺序表的优缺点</p>
</blockquote>
<ol>
<li><p>优点</p>
<ul>
<li><p>存储密度大（结点本身所占存储量&#x2F;结点结构所占存储量）</p>
</li>
<li><p>可以随机存取表中任一元素</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>在插入、删除某一元素时，需要移动大量元素</p>
</li>
<li><p>浪费存储空间</p>
</li>
<li><p>属于静态存储形式，数据元素的个数不能自由扩充</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-5-线性表的链式表示和实现"><a href="#2-5-线性表的链式表示和实现" class="headerlink" title="2.5 线性表的链式表示和实现"></a>2.5 线性表的链式表示和实现</h2><ul>
<li><p>链式存储结构</p>
<ul>
<li>节点在存储器中的位置是任意的，即逻辑上相邻的数据在物理上不一定相邻</li>
</ul>
</li>
<li><p>线性表的链式表示又称为非顺序映像或链式映像。</p>
</li>
<li><p>用一组<strong>物理位置任意的存储单元</strong>来存放线性表的数据元素。</p>
</li>
</ul>
<p>单链表由头指针惟一确定，因此单链表可以用头指针的名字来命名。</p>
<p>各结点由两个域组成：</p>
<ul>
<li><p>数据域：存储元素数值数据</p>
</li>
<li><p>指针域：存储直接后继结点的存储位置</p>
</li>
</ul>
<blockquote>
<p>链式存储有关的术语</p>
</blockquote>
<ol>
<li><p>结点：数据元素的存储映像。由数据域和指针域两部分组成</p>
</li>
<li><p>链表：n个结点由<strong>指针链</strong>链接而成的一个链表</p>
</li>
<li><p>链表类型</p>
<p> 单链表：结点只有一个指针域的链表；</p>
<p> 双链表：结点有两个指针域的链表；</p>
<p> 循环链表：首尾相接的链表；</p>
</li>
<li><p>头指针、头结点和首元结点：</p>
<p> 头指针：是指向链表中第一个结点的指针，即指向头结点</p>
<p> 首元结点：是指链表中存储第一个数据元素a1的结点</p>
<p> 头结点：是在链表的首元结点之前附设的一个结点，一个附加结点。</p>
</li>
</ol>
<p><strong>以上三个概念一定要区分好</strong></p>
<blockquote>
<p>讨论1：如何表示空表</p>
</blockquote>
<ul>
<li><p>若无头结点时，头指针为空时表示空表</p>
</li>
<li><p>有头结点时，当头结点的指针域位空时表示空表</p>
</li>
</ul>
<blockquote>
<p>讨论2：在链表中设置头结点有什么好处？</p>
</blockquote>
<ol>
<li><p>便于首元结点的处理</p>
<p> 首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需进行特殊处理</p>
</li>
<li><p>便于空表和非空表的统一处理</p>
<p> 无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了</p>
</li>
</ol>
<blockquote>
<p>讨论3：头结点的数据域内装的是什么？</p>
</blockquote>
<p>头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。</p>
<blockquote>
<p>链表的特点：</p>
</blockquote>
<ol>
<li><p>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻</p>
</li>
<li><p>访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间<strong>不相同</strong></p>
</li>
<li><p><strong>链表是顺序存取的，顺序表是随机存取的</strong></p>
</li>
</ol>
<h3 id="2-5-1-单链表的定义和表示"><a href="#2-5-1-单链表的定义和表示" class="headerlink" title="2.5.1 单链表的定义和表示"></a>2.5.1 单链表的定义和表示</h3><blockquote>
<p>带头结点的单链表</p>
</blockquote>
<p>单链表是由<strong>表头</strong>唯一确定，因此单链表可以用头指针的名字来命名若头指针名是L，则把链表称为表L</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123; <span class="hljs-comment">// 声明结点的类型和指向结点的指针类型</span><br>  ElemType data;  <span class="hljs-comment">// 结点的数据域</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next;    <span class="hljs-comment">// 结点的指针域</span><br>&#125; Lnode, *LinkList; <span class="hljs-comment">// LinkList为指向结构体Lnode的指针类型，LinkList也就是别名</span><br></code></pre></td></tr></table></figure>

<p>定义链表L：LinkList L;  （指向头结点）</p>
<p>定义结点指针p：LNode * p等价于LinkList p;（指向中间结点，也就是结点的指针域）</p>
<h3 id="2-5-2-单链表基本操作的实现"><a href="#2-5-2-单链表基本操作的实现" class="headerlink" title="2.5.2 单链表基本操作的实现"></a>2.5.2 单链表基本操作的实现</h3><blockquote>
<p>算法2.6——单链表的初始化(带头结点的单链表)</p>
</blockquote>
<p>单链表的初始化即构造一个空表。</p>
<p>算法步骤：</p>
<ol>
<li><p>生成新结点作为头结点，用头指针L指向头结点</p>
</li>
<li><p>将头结点的指针域置空</p>
</li>
</ol>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InitList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>补充算法1：判断链表是否为空</p>
</blockquote>
<p>空表：链表中无元素，称为空链表(头指针和头结点仍然在)</p>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123; <span class="hljs-comment">// 若L为空表，则返回1，否则返回0</span><br>  <span class="hljs-keyword">if</span>(L-&gt;next)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>补充算法2：单链表的销毁：链表销毁后不存在</p>
</blockquote>
<p>算法思路：从头指针开始，依次释放所有结点</p>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">DestoryList_L</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<span class="hljs-comment">// 销毁单链表L</span><br>  Lnode *p;<br>  <span class="hljs-keyword">while</span>(L)&#123; <span class="hljs-comment">// 直至L为空</span><br>    p = L;<br>    L = L-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>  &#125;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>补充算法3：清空链表</p>
</blockquote>
<p>链表仍存在，但链表中无元素，成为空链表(头指针和头结点仍然在)</p>
<p>算法思路：依次释放所有结点，并将头结点指针域设置为空</p>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">// 将L重置为空表</span><br>  Lnode *p, *q<br>  p = L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p)&#123;<br>    q = p-&gt;next;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = q;<br>  &#125;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 头结点指针域为空</span><br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>补充算法3：求单链表的表长</p>
</blockquote>
<p>算法思路：从首元结点开始，依次计数所有结点</p>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength_L</span><span class="hljs-params">(LinkList L)</span></span>&#123; <span class="hljs-comment">// 返回L中数据元素个数</span><br>  LinkList p;<br>  p = L-&gt;next;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(p)&#123; <span class="hljs-comment">// 遍历单链表，统计结点数</span><br>    i++;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>算法2.7——取值(取单链表中第i个元素的内容)</p>
</blockquote>
<p>算法思路：从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止。因此，<strong>链表不是随机存取结构</strong>。</p>
<p>算法步骤：</p>
<ol>
<li><p>从第一个结点(L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p &#x3D; L-&gt;next;</p>
</li>
<li><p>j做计数器，累计当前扫描过的结点数，j初值为1；</p>
</li>
<li><p>当p指向扫描到的下一个结点时，计数器j加1；</p>
</li>
<li><p>当j &#x3D;&#x3D; i时，p所指的结点就是要找的第i个结点。</p>
</li>
</ol>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">GetElem_L</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-comment">// 获取线性表L中的某个数据元素的内容，通过变量e返回</span><br>  p = L-&gt;next; j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(!p || j &gt; i) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">// 第i个元素不存在</span><br>  e = p-&gt;data;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>查找：</p>
<ul>
<li><p>按值查找：根据指定数据获取该数据所在的位置（该数据的地址）；</p>
</li>
<li><p>按值查找：根据指定数据获取该数据所在位置序号（是第几个元素）</p>
</li>
</ul>
<blockquote>
<p>算法2.8——按值查找：根据指定数据获取该数据所在的位置（地址）</p>
</blockquote>
<p>算法步骤：</p>
<ol>
<li><p>从第一个结点起，依次和e相比较</p>
</li>
<li><p>如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址；</p>
</li>
<li><p>如果查遍整个链表都没有找到其值和e相等的元素，则返回0或NULL。</p>
</li>
</ol>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Lnode* <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 在线性表L中查找值e的数据元素</span><br>  <span class="hljs-comment">// 找到，则返回L中值为e的数据元素的地址，查找失败返回NULL</span><br>  p = L-&gt;next;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>    p = p-&gt;next;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>算法2.8 变化——按值查找：根据指定数据获取该数据所在的位置序号</p>
</blockquote>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem_L</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 返回L中值为e的数据元素的位置序号，查找失败返回0</span><br>  p = L-&gt;next; j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;<br>    p = p-&gt;next;<br>    j++;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(p) <span class="hljs-keyword">return</span> j;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>算法2.9 插入——在第i个结点前插入值为e的新结点</p>
</blockquote>
<p>算法步骤：</p>
<ol>
<li><p>首先找到ai-1的存储位置p</p>
</li>
<li><p>生成一个数据域为e的新结点s</p>
</li>
<li><p>插入新结点：</p>
<ol>
<li><p>新结点的指针域指向结点ai</p>
</li>
<li><p>结点ai-1的指针域指向新结点</p>
</li>
</ol>
</li>
</ol>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;<br>  p = L; j = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 寻找第i-1个结点，p指向i-1结点</span><br>  <span class="hljs-keyword">while</span>(p &amp;&amp; j &lt; i - <span class="hljs-number">1</span>)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-comment">// /i大于表长+1或者小于1，插入位置非法</span><br>  <span class="hljs-keyword">if</span>(!p || j &gt; i - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR; <br>  <span class="hljs-comment">// 生成新结点s，将结点s的数据域置为e</span><br>  s = <span class="hljs-keyword">new</span> LNode;<br>  s-&gt;data = e;<br>  <span class="hljs-comment">// 将结点s插入L中</span><br>  s-&gt;next = p-&gt;next;<span class="hljs-comment">//把p的指针域的指针（原本指向p后面一个结点的指针）赋值给s的指针域里的指针</span><br>  p-&gt;next = s;<span class="hljs-comment">//把指向s结点的指针赋值给p的指针域里的指针</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>算法2.10 删除——删除第i个结点</p>
</blockquote>
<p>算法步骤：</p>
<ol>
<li><p>首先找到ai-1的存储位置p，保存要删除的ai的值</p>
</li>
<li><p>令p-&gt;next指向ai+1</p>
</li>
<li><p>释放结点ai的空间</p>
</li>
</ol>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">  <span class="hljs-comment">// 将线性表L中第i个数据元素删除</span><br>  <span class="hljs-function">Status <span class="hljs-title">ListDelete_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType&amp;e)</span></span>&#123;<br>  p = L; j = <span class="hljs-number">0</span>; <br>  <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j &lt; i<span class="hljs-number">-1</span>)&#123;<br>    p = p-&gt;next;<br>    ++j;<br>  &#125;<br>  <span class="hljs-comment">// 寻找第i个结点，并令p指向其前驱</span><br>  <span class="hljs-keyword">if</span>(!(p-&gt;next) || j &gt; i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR；<span class="hljs-comment">//删除位置不合理</span><br>  q = p-&gt;next;  <span class="hljs-comment">// 临时保存被删结点的地址以备释放</span><br>  <span class="hljs-comment">//让q指向p后面的一个结点</span><br>  p-&gt;next = q-&gt;next; <span class="hljs-comment">// 改变删除结点前驱结点的指针域</span><br>  <span class="hljs-comment">//让p指向q后面的一个结点，此时q变成了原来要删除的结点，而p跳过了q，指向q后面的一个结点</span><br>  e = q-&gt;data;  <span class="hljs-comment">// 保存删除结点的数据域</span><br>  <span class="hljs-keyword">delete</span> q;     <span class="hljs-comment">// 释放删除结点的空间</span><br>  <span class="hljs-keyword">return</span> OK;<br>&#125; <span class="hljs-comment">// ListDelete_L</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>算法2.11 建立单链表——头插法（倒位序）</p>
</blockquote>
<p>头插法：元素插入在链表头部，也叫前插法</p>
<p>算法步骤：</p>
<ol>
<li><p>从一个空表开始，重复读入数据；</p>
</li>
<li><p>生成新结点，将读入数据存放到新结点的数据域中</p>
</li>
<li><p><strong>从最后一个结点开始</strong>，依次将各结点插入到链表的前端</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142235433.png" srcset="/img/loading.gif" lazyload></p>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_H</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先建立一个带头结点的单链表</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; --i)&#123;<br>    p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点p</span><br>    cin &gt;&gt; p-&gt;data; <span class="hljs-comment">// 输入元素值</span><br>    p-&gt;next = L-&gt;next;  <span class="hljs-comment">// 插入到表头</span><br>    L-&gt;next = p;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>算法2.11 建立单链表——尾插法（正位序）</p>
</blockquote>
<p>尾查法：元素插入在链表尾部，也叫后插法</p>
<p>算法步骤：</p>
<ol>
<li><p>从一个空表开始，正位序将新结点逐个插入到链表的尾部，尾指针r始终指向链表的尾结点。</p>
</li>
<li><p>初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301142255418.png" srcset="/img/loading.gif" lazyload></p>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 正位序输入n个元素的值，建立带表头结点的单链表L</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList&amp; L, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  L = <span class="hljs-keyword">new</span> LNode;<br>  L-&gt;next = <span class="hljs-literal">NULL</span>;<br>  r = L;  <span class="hljs-comment">// 尾指针r指向头结点</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>    p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点，输入元素值</span><br>    cin &gt;&gt; p-&gt;data;<br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//新结点指针域先赋值为空</span><br>    r-&gt;next = p;<span class="hljs-comment">//把新的结点插入到链表尾部</span><br>    r = p;<span class="hljs-comment">//更新尾指针</span><br>  &#125;<br>&#125; <span class="hljs-comment">// CreateList_R</span><br></code></pre></td></tr></table></figure>

<h3 id="2-5-3-单链表的查找、插入、删除算法时间效率分析"><a href="#2-5-3-单链表的查找、插入、删除算法时间效率分析" class="headerlink" title="2.5.3 单链表的查找、插入、删除算法时间效率分析"></a>2.5.3 单链表的查找、插入、删除算法时间效率分析</h3><ol>
<li><p>因线性链表只能顺序存取，即在查找时要从头指针找起，查找的时间复杂度为O(n)</p>
</li>
<li><p>插入和删除：</p>
<p> 因线性链表不需要移动元素，只要修改指针，一般情况下时间复杂度为O(1)。</p>
<p> 但是，如果要在单链表中进行前插或删除操作，由于要从头查找前驱结点，所耗时间复杂度为O(n)</p>
</li>
<li><p>头插法的时间复杂度是O(n)</p>
</li>
<li><p>尾插法的时间复杂度是O(n)</p>
</li>
</ol>
<h3 id="2-5-4-循环链表"><a href="#2-5-4-循环链表" class="headerlink" title="2.5.4 循环链表"></a>2.5.4 循环链表</h3><p>循环链表：是一种头尾相接的链表（即：表中最后一个结点的指针域指向头结点，整个链表形成一个环）。</p>
<p>优点：<strong>从表中任一结点出发均可找到表中其他结点</strong>。</p>
<p>循环链表的空表表示：头指针的指针域指向自己。</p>
<blockquote>
<p>注意：</p>
</blockquote>
<p>由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p-&gt;next是否为空，而是判断它们<strong>是否等于头指针</strong>。<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151549155.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>头指针表示单循环链表</p>
</blockquote>
<p>找a1的时间复杂度：O(1)</p>
<p>找an的时间复杂度：O(n)</p>
<p>但考虑到表的操作常常是在表的首尾位置上进行，因此更过的是考虑用<strong>尾指针表示单循环链表</strong></p>
<blockquote>
<p>尾指针表示单循环链表</p>
</blockquote>
<p>设尾指针为R：</p>
<p>找a1的时间复杂度：O(1)，a1的存储位置是：R-&gt;next-&gt;next</p>
<p>找an的时间复杂度：O(1)，an的存储位置是：R</p>
<blockquote>
<p>带尾指针循环链表的合并（将Tb合并在Ta之后）</p>
</blockquote>
<p>操作步骤：</p>
<ol>
<li><p>p存表头结点：p &#x3D; Ta-&gt;next;</p>
</li>
<li><p>Tb表头连接到Ta表尾:Ta-&gt;next &#x3D; Tb-&gt;next-&gt;next;</p>
</li>
<li><p>释放Tb表头结点:delete Tb-&gt;next;</p>
</li>
<li><p>修改指针:Tb-&gt;next &#x3D; p;</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202301151601055.png" srcset="/img/loading.gif" lazyload></p>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span></span>&#123;<br>  <span class="hljs-comment">// 假设Ta、Tb都是非空的单循环链表</span><br>  p = Ta-&gt;next;     <span class="hljs-comment">// 1. p存表头结点</span><br>  Ta-&gt;next = Tb-&gt;next-&gt;next;  <span class="hljs-comment">// Tb表头连接到Ta表尾</span><br>  <span class="hljs-keyword">delete</span> Tb-&gt;next;         <span class="hljs-comment">// 释放Tb表头结点</span><br>  Tb-&gt;next = p;           <span class="hljs-comment">// 修改指针</span><br>  <span class="hljs-keyword">return</span> Tb;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度为O(1)</p>
<h3 id="2-5-5-双向链表"><a href="#2-5-5-双向链表" class="headerlink" title="2.5.5 双向链表"></a>2.5.5 双向链表</h3><p>双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指针域prior，这样链表中就形成了有两个方向不同的链，故称为双向链表。</p>
<p>双向链表结构定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>&#123;<br>  Elemtype data;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *prior, *next;<br>&#125;DuLNode, *DuLinkList;<br></code></pre></td></tr></table></figure>

<p>双向循环链表:</p>
<p>和单链的循环表类似，双向链表也可以有循环表</p>
<ul>
<li><p>让头结点的前驱指针指向链表的最后一个结点</p>
</li>
<li><p>让最后一个结点的后继指针指向头结点。</p>
</li>
</ul>
<p>在双向链表中有些操作（如：ListLength、GetElem等），因仅涉及一个方向的指针，故它们的算法与线性链表的相同。但在插入、删除时，则需同时修改两个方向上的指针，两者的操作的时间复杂度均为O(n)。</p>
<blockquote>
<p>算法2.13 双向链表的插入</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;<br>  <span class="hljs-comment">// 在带头结点的双向循环链表L中第i个位置之前插入元素e</span><br>  <span class="hljs-keyword">if</span>(!(p = <span class="hljs-built_in">GetElemP_DuL</span>(L, i))) <span class="hljs-keyword">return</span> ERROR;<br>  s = <span class="hljs-keyword">new</span> DuLNode;<br>  s-&gt;data = e;<br>  s-&gt;prior = p-&gt;prior;<br>  p-&gt;prior-&gt;next = s;<br>  s-&gt;next = p;<br>  p-&gt;prior = s;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>算法2.14 双向链表的删除</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListDelete_DuL</span><span class="hljs-params">(DuLinkList&amp; L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>  <span class="hljs-comment">// 删除带头结点的双向循环链表L的第i个元素，并用e返回。</span><br>  <span class="hljs-keyword">if</span>(!(p = <span class="hljs-built_in">GetElemP_DuL</span>(L, i))) <span class="hljs-keyword">return</span> ERROR;<br>  e = p-&gt;data;<br>  p-&gt;prior-&gt;next = p-&gt;next;<br>  p-&gt;next-&gt;prior = p-&gt;prior;<br>  <span class="hljs-keyword">delete</span> p;<br>  <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>单链表、循环链表和双向链表的时间效率比较</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131139437.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-6-顺序表和链式表的比较"><a href="#2-6-顺序表和链式表的比较" class="headerlink" title="2.6 顺序表和链式表的比较"></a>2.6 顺序表和链式表的比较</h2><blockquote>
<p>链式存储结构的优点：</p>
</blockquote>
<ul>
<li><p>结点空间可以动态申请和释放；</p>
</li>
<li><p>数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素。</p>
</li>
</ul>
<blockquote>
<p>链式存储结构的缺点</p>
</blockquote>
<ul>
<li><p>存储密度小：每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大。</p>
</li>
<li><p>链式存储结构是非随机存取结构。对任一结点的操作都需要从头指针依指针链查找到该结点，这增加了算法的复杂度。</p>
</li>
</ul>
<blockquote>
<p>顺序表和链式表的比较</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131138707.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="2-7-线性表的应用"><a href="#2-7-线性表的应用" class="headerlink" title="2.7 线性表的应用"></a>2.7 线性表的应用</h2><p>主要介绍线性表的合并和有序表的合并。</p>
<blockquote>
<p>线性表的合并 </p>
</blockquote>
<ul>
<li><p>问题描述：</p>
<p>假设利用两个线性表La和Lb分别表示两个集合A和B，现要求合一个新的集合A &#x3D; A∪B</p>
</li>
<li><p>算法步骤：</p>
<p>依次取出Lb中的每个元素，执行以下操作：</p>
<ol>
<li><p>在La中查找该元素</p>
</li>
<li><p>如果找不到，则将其插入La的最后</p>
</li>
</ol>
</li>
<li><p>算法描述：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(List &amp;La, List Lb)</span></span>&#123;<br>  La_len = <span class="hljs-built_in">ListLength</span>(La);<br>  Lb_len = <span class="hljs-built_in">ListLength</span>(Lb);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; Lb_len; i++)&#123;<br>    <span class="hljs-built_in">GetElem</span>(Lb, i, e);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">LocateElem</span>(La, e))&#123;<br>      <span class="hljs-built_in">ListInsert</span>(&amp;La, ++La_len, e);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述算法时间复杂度为O(La_len*Lb_len)。</p>
<blockquote>
<p>有序表的合并</p>
</blockquote>
<ul>
<li><p>问题描述：</p>
<p>已知线性表La和Lb的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素仍按值非递减有序排列。</p>
</li>
<li><p>算法步骤：</p>
<ol>
<li><p>创建一个空表Lc</p>
</li>
<li><p>依次从La或Lb中“摘取”元素值较小的结点插入到Lc表的最后，直至其中一个表变空为止</p>
</li>
<li><p>继续将La或Lb其中一个表的剩余结点插入在Lc表的最后</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>算法2.16 有序表合并——用顺序表实现</p>
</blockquote>
<ul>
<li>用顺序表实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_sq</span><span class="hljs-params">(SqList LA, SqList LB, SqList&amp; LC)</span></span>&#123;<br>  <span class="hljs-comment">// 指针pa和pb的初值分别指向两个表的第一个元素</span><br>  pa = LA.elem;<br>  pb = LB.elem;<br><br>  <span class="hljs-comment">// 新表长度为待合并两表的长度和</span><br>  LC.length = LA.length + LB.length;<br>  <span class="hljs-comment">// 为新表分配空间</span><br>  LC.elem = <span class="hljs-keyword">new</span> ElemType[LC.length];<br>  pc = LC.elem;<br><br>  <span class="hljs-comment">// 找到LA和LB的最后一个元素</span><br>  pa_last = LA.elem + LA.length - <span class="hljs-number">1</span>;<br>  pb_last = LB.elem + LB.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 两个表都非空</span><br>  <span class="hljs-keyword">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)&#123;<br>    <span class="hljs-keyword">if</span>(*pa &lt;= *pb)&#123;<br>      *pc++ = *pa++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      *pc++ = *pb++;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// LB已到达表尾，将LA中剩余元素加入LC</span><br>  <span class="hljs-keyword">while</span>(pa &lt;= pa_last) *pc++ = *pa++;<br><br>  <span class="hljs-comment">// LA已到达表尾，将LB中剩余元素加入LC</span><br>  <span class="hljs-keyword">while</span>(pb &lt;= pb_last) *pc++ = *pb++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度为：O(ListLength(LA)+ListLength(LB))</p>
<p>空间复杂度为：O(ListLength(LA)+ListLength(LB))</p>
<blockquote>
<p>算法2.17 有序表合并——用链表实现</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeList_L</span><span class="hljs-params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;<br>  pa = La-&gt;next;<br>  pb = Lb-&gt;next;<br>  <span class="hljs-comment">// pc指针指向头结点</span><br>  pc = Lc = La; <span class="hljs-comment">// 用La的头结点作为Lc的头结点</span><br>  <span class="hljs-keyword">while</span>(pa &amp;&amp; pb)&#123;<br>    <span class="hljs-keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;<br>      pc-&gt;next = pa;<br>      pc = pa;<br>      pa = pa-&gt;next;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      pc-&gt;next = pb;<br>      pc = pb;<br>      pb = pb-&gt;next;<br>    &#125;<br>  &#125;<br>  pc-&gt;next = pa ? pa : pb;  <span class="hljs-comment">// 插入剩余段</span><br>  <span class="hljs-keyword">delete</span> Lb;  <span class="hljs-comment">// 删除Lb的头结点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度为：O(ListLength(La)+ListLength(Lb))</p>
<p>空间复杂度为：O(1)</p>
<h2 id="2-8-案例分析与实现"><a href="#2-8-案例分析与实现" class="headerlink" title="2.8 案例分析与实现"></a>2.8 案例分析与实现</h2><blockquote>
<p>案例2.1：一元多项式的运算，实现两个多项式的加、减、乘运算</p>
</blockquote>
<p>可用顺序表实现。</p>
<blockquote>
<p>案例2.2：稀疏多项式的运算</p>
</blockquote>
<p>对于稀疏多项式，可考虑创建一个新的结构体，分别保存指数和系数。</p>
<p>利用顺序表实现时存在<strong>存储空间分配不灵活、运算得空间复杂度高</strong>等缺点。可考虑利用链式存储结构实现。</p>
<p>定义新的链表结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span>&#123;<br>  <span class="hljs-type">float</span> coeff;  <span class="hljs-comment">// 系数</span><br>  <span class="hljs-type">int</span> expn;     <span class="hljs-comment">// 指数</span><br>  PNode *next;  <span class="hljs-comment">// 指针域</span><br>&#125;PNode， *Polynomial;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>多项式相加</p>
<ul>
<li><p>多项式创建——算法步骤</p>
<ol>
<li><p>创建一个只有头结点的空链表；</p>
</li>
<li><p>根据多项式的项的个数n，循环n次执行以下操作：</p>
<ul>
<li><p>生成一个新结点*s；</p>
</li>
<li><p>输入多项式当前项的系数和指数赋给新结点*s的数据域；</p>
</li>
<li><p>设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点；</p>
</li>
<li><p>指针q初始化，指向首元结点；</p>
</li>
<li><p>循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点*q；</p>
</li>
<li><p>将输入项结点*s插入到结点q之前。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>多项式创建——算法描述(头插法)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatePolyn</span><span class="hljs-params">(Polynomial &amp;P, <span class="hljs-type">int</span> n)</span></span>&#123;<br>  <span class="hljs-comment">// 输入m项的系数和指数，建立表示多项式的有序链表P</span><br>  P = <span class="hljs-keyword">new</span> PNode;<br>  P-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 先建立一个带头结点的单链表</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;  <span class="hljs-comment">// 依次输入n个非零项</span><br>    s = <span class="hljs-keyword">new</span> PNode;  <span class="hljs-comment">// 生成新结点</span><br>    cin &gt;&gt; s-&gt;coef &gt;&gt; s-&gt;expn;<br>    pre = p;      <span class="hljs-comment">// pre用于保存q的前驱，初值为头结点</span><br>    q = p-&gt;next;  <span class="hljs-comment">// q初始化，指向首元结点</span><br>    <span class="hljs-keyword">while</span>(q &amp;&amp; q-&gt;expn &lt; s-&gt;expn)&#123;  <span class="hljs-comment">// 找到第一个大于输入项指数的项*q</span><br>      pre = q;<br>      q = p-&gt;next;<br>    &#125;<br>    s-&gt;next = q;  <span class="hljs-comment">// 将输入项s插入到q和其前驱结点pre之间</span><br>    pre-&gt;next = s;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>多项式相加——算法步骤</p>
<ol>
<li><p>指针p1和p2初始化，分别指向Pa和Pb的首元结点。</p>
</li>
<li><p>p3指向和多项式的当前结点，初值为Pa的头结点。</p>
</li>
<li><p>当指针p1和p2均未到达相应表尾时，则循环比较p1和p2所指结点对应的指值(p1-&gt;expn与p2-&gt;expn)，有下列三种情况：</p>
<ul>
<li><p>当p1-&gt;expn &#x3D;&#x3D; p2-&gt;expn时，则将两个结点中的系数相加</p>
<ul>
<li><p>若和不为零，则修改p1所指结点的系数值，同时删除p2所指结点</p>
</li>
<li><p>若和为零，则删除p1和p2所指结点</p>
</li>
</ul>
</li>
<li><p>当p1-&gt;expn &lt; p2-&gt;expn时，则应摘取p1所指结点插入到“和多项式”链表中表；</p>
</li>
<li><p>当p1-&gt;expn &gt; p2-&gt;expn时，则应摘取p2所指结点插入到“和多项式”链表中表；</p>
</li>
</ul>
</li>
<li><p>将非空多项式的剩余段浦入到p3所指结点之后</p>
</li>
<li><p>释放Pb的头结点。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>案例2.3 图书信息管理系统</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%8E%8B%E5%8D%93/" class="category-chain-item">数据结构王卓</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://example.com/2022/10/13/线性表——王卓/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ChengKhen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月13日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/13/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/" title="栈和队列——王卓">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">栈和队列——王卓</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/" title="数据结构绪论——王卓">
                        <span class="hidden-mobile">数据结构绪论——王卓</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
