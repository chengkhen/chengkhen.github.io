

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ChengKhen">
  <meta name="keywords" content="">
  
    <meta name="description" content="第5章 树和二叉树5.1 树与二叉树的定义5.1.1 树的定义树(非线性结构)是以分支关系定义的层次结构：结点之间有分支、具有层次关系。  树的定义  树(Tree)是n(n≥0)个结点的有限集。  若n&#x3D;0，称为空树；  若n&gt;0，则它满足如下两个条件：   有且仅有一个特定的称为根(Root)的结点；  其余结点可分m(m≥0)个互不相交的有限集T1，T2，T3…Tm，其中每一">
<meta property="og:type" content="article">
<meta property="og:title" content="树和二叉树——王卓">
<meta property="og:url" content="http://example.com/2022/10/13/%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/index.html">
<meta property="og:site_name" content="Blog of ChengKhen">
<meta property="og:description" content="第5章 树和二叉树5.1 树与二叉树的定义5.1.1 树的定义树(非线性结构)是以分支关系定义的层次结构：结点之间有分支、具有层次关系。  树的定义  树(Tree)是n(n≥0)个结点的有限集。  若n&#x3D;0，称为空树；  若n&gt;0，则它满足如下两个条件：   有且仅有一个特定的称为根(Root)的结点；  其余结点可分m(m≥0)个互不相交的有限集T1，T2，T3…Tm，其中每一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121460.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131122180.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123376.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123841.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131124877.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131125028.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131126344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127045.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127885.png">
<meta property="article:published_time" content="2022-10-13T02:57:03.000Z">
<meta property="article:modified_time" content="2022-10-13T03:32:38.375Z">
<meta property="article:author" content="ChengKhen">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121460.png">
  
  
  
  <title>树和二叉树——王卓 - Blog of ChengKhen</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>ChengKhen</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="树和二叉树——王卓"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-13 10:57" pubdate>
          2022年10月13日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          126 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">树和二叉树——王卓</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第5章-树和二叉树"><a href="#第5章-树和二叉树" class="headerlink" title="第5章 树和二叉树"></a>第5章 树和二叉树</h1><h2 id="5-1-树与二叉树的定义"><a href="#5-1-树与二叉树的定义" class="headerlink" title="5.1 树与二叉树的定义"></a>5.1 树与二叉树的定义</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><p>树(非线性结构)是以分支关系定义的层次结构：结点之间有分支、具有层次关系。</p>
<blockquote>
<p>树的定义</p>
</blockquote>
<p>树(Tree)是n(n≥0)个结点的<strong>有限集</strong>。</p>
<ul>
<li><p>若n&#x3D;0，称为空树；</p>
<ul>
<li>若n&gt;0，则它满足如下两个条件：</li>
</ul>
<ol>
<li><p><strong>有且仅有一个</strong>特定的称为根(Root)的结点；</p>
</li>
<li><p><strong>其余结点</strong>可分m(m≥0)个互不相交的有限集T1，T2，T3…Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)。</p>
</li>
</ol>
</li>
</ul>
<p>树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还可有其他的表示形式：嵌套集合表示<br>（即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）；广义表的形式表示，根作为由子树森林组成的表的名字写在表的左边；凹入表示法（类似书的编目）。</p>
<h3 id="5-1-2-树的基本术语"><a href="#5-1-2-树的基本术语" class="headerlink" title="5.1.2 树的基本术语"></a>5.1.2 树的基本术语</h3><p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131121460.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><p><strong>根节点</strong>：非空树中无前驱结点的结点；</p>
</li>
<li><p><strong>结点</strong>：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支，如图中的A 、B 、C 、D等。</p>
</li>
<li><p><strong>结点的度</strong>：结点拥有的子树数称为结点的度。例如，A的度为3，C的度为1，F的度为0。</p>
</li>
<li><p><strong>树的度</strong>：树的度是树内各结点度的最大值。图中所示的树的度为3。</p>
</li>
<li><p><strong>叶子</strong>：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。</p>
</li>
<li><p><strong>非终端结点</strong>：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。</p>
</li>
<li><p><strong>双亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B的双亲为A，B的孩子有E和F。</p>
</li>
<li><p><strong>兄弟</strong>：同一个双亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。</p>
</li>
<li><p><strong>祖先</strong>：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。</p>
</li>
<li><p><strong>子孙</strong>：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。</p>
</li>
<li><p><strong>层次</strong>：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。</p>
</li>
<li><p><strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。</p>
</li>
<li><p><strong>树的深度</strong>：树中结点的最大层次称为<strong>树的深度或高度</strong>。图中所示的树的深度为4。</p>
</li>
<li><p><strong>有序树和无序树</strong>：如果将树中结点的各子树从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</p>
</li>
<li><p><strong>森林</strong>：是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。</p>
</li>
</ol>
<blockquote>
<p>树结构和线性结构的比较</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131122180.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="5-1-3-二叉树的定义"><a href="#5-1-3-二叉树的定义" class="headerlink" title="5.1.3 二叉树的定义"></a>5.1.3 二叉树的定义</h3><p>引入二叉树的原因：</p>
<ul>
<li><p>二又树的结构最简单，规律性最强；</p>
</li>
<li><p>可以证明，所有树都能转为唯一对应的二叉树，不失一般性。</p>
</li>
</ul>
<p>二叉树是n(n≥0)个结点的有限集，它或者是空集(n&#x3D;0)，或者由一个根结点及<strong>两棵互不相交</strong>的分别称作这个根的左子树和右子树的二又树组成。</p>
<ol>
<li><p>每个结点最多有俩孩子，二叉树中不存在度大于2的结点。</p>
</li>
<li><p>子树有左右之分，其次序不能颠倒。</p>
</li>
<li><p>二叉树可以是空集合，根可以有空的左子树或空的右子树。</p>
</li>
</ol>
<p>二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。</p>
<p>需要注意的是：<strong>二叉树不是树的特殊情况，与树是两个概念</strong>。</p>
<p>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要区分，说明它是左子树，还是右子树。</p>
<p>树中当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。</p>
<p>因此，考虑到二叉树的特点，思考：具有三个结点的二叉树可能有几种不同形态？普通树有几种不同形态？</p>
<p>二叉树有五种形态；树有两种形态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123376.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131123841.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>二叉树的5种基本形态</p>
</blockquote>
<p>二叉树的5种基本形态包括有：空二叉树、根和空的左右子树、根和左子树、根和右子树、根和左右子树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131124877.png" srcset="/img/loading.gif" lazyload></p>
<p>似于二叉树，因此可以利用二叉树来表示表达式。</p>
<h2 id="5-3-树和二叉树的抽象数据类型定义"><a href="#5-3-树和二叉树的抽象数据类型定义" class="headerlink" title="5.3 树和二叉树的抽象数据类型定义"></a>5.3 树和二叉树的抽象数据类型定义</h2><p>根据树的结构定义，加上树的一组基本操作就构成了树的抽象数据类型定义。</p>
<pre><code class="hljs">ADT BinaryTree&#123;
    // 数据对象D：
    // 数据关系R：
    // 基本操作P：
&#125;ADT BinaryTree;
</code></pre>
<h2 id="5-4-二叉树的性质和存储结构"><a href="#5-4-二叉树的性质和存储结构" class="headerlink" title="5.4 二叉树的性质和存储结构"></a>5.4 二叉树的性质和存储结构</h2><h3 id="5-4-1-二叉树的性质"><a href="#5-4-1-二叉树的性质" class="headerlink" title="5.4.1 二叉树的性质"></a>5.4.1 二叉树的性质</h3><p>性质1：在二叉树的第i层上至多有2^(i-1)个结点(i≥1)</p>
<p>性质2：深度为k的二叉树一共至多有2^k-1 个结点(k≥1)</p>
<p>性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 &#x3D; n2+1。即叶子结点的数目等于度为2的结点数为n2，再加1。</p>
<blockquote>
<p>两种特殊形式的二叉树</p>
</blockquote>
<ol>
<li><p>满二叉树</p>
<p> 满二叉树：深度为k且含有2^k-1个结点的二叉树。</p>
<p> 特点：</p>
<ul>
<li><p>每一层上的结点数都是最大结点数（即每层都满）</p>
</li>
<li><p>叶子节点全部在最底层。</p>
</li>
</ul>
<p> 对满二叉树结点位置进行编号，按照从根结点开始，自<strong>上而下，自左而右</strong>进行编号，可以发现每一结点位置都有元素。</p>
<p> 满二叉树在同样深度的二叉树中<strong>结点个数最多</strong>。</p>
<p> 满二叉树在同样深度的二叉树中<strong>叶子结点个数最多</strong>。</p>
</li>
<li><p>完全二叉树</p>
<p> 完全二叉树：深度为k的，有n个结点的二叉树，当且仅当其<strong>每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时</strong>，称之为完全二叉树。</p>
<p> 同理，在满二叉树中，从最后一个结点开始，<strong>连续去掉任意</strong>个结点，即是一棵完全二叉树。</p>
<p> 完全二叉树的特点是：</p>
<ul>
<li><p>叶子结点只可能在层次最大的两层上出现；</p>
</li>
<li><p>对任一结点，若其右分支下的子孙(即右子树)的最大层次为i，则其左分支下的子孙(左子树)的最大层次必为i或i+1。</p>
</li>
</ul>
</li>
</ol>
<p>性质4：具有n个结点的完全二叉树的深度为⌊log2n⌋ + 1。</p>
<p>性质5：如果对一棵有n个结点的完全二叉树(其深度为⌊log2n⌋+ 1)的结点按层序编号(从第1层到第⌊log2n⌋+1层，每层从左到右)，则对任一结点i(1≤i≤n)，有：</p>
<ol>
<li><p>如果i&#x3D;1，则结点1是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点⌊i&#x2F;2⌋。</p>
</li>
<li><p>如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i。</p>
</li>
<li><p>如果2i+1&gt;n，则结点无右孩子；否则其右孩子是结点2i+1。</p>
</li>
</ol>
<p>性质5表明了完全二叉树中<strong>双亲结点编号与孩子结点编号</strong>之间的关系。</p>
<h3 id="5-4-2-二叉树的存储结构"><a href="#5-4-2-二叉树的存储结构" class="headerlink" title="5.4.2 二叉树的存储结构"></a>5.4.2 二叉树的存储结构</h3><p>二叉树的存储结构主要有顺序存储结构和链式存储结构，其中链式存储结构又分为二叉链表和三叉链表。</p>
<p>二叉树的顺序存储实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树顺序存储表示</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br>Typedef TElemType SqBiTree[MAXSIZE];<br>SqBiTree bt;<br></code></pre></td></tr></table></figure>

<p>二叉树的顺序存储缺点：存储密度低，适合存储满二叉树和完全二叉树。</p>
<blockquote>
<p>二叉树的链式存储结构</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span>&#123;<br>    TElemType data;<br>    BiNode *lchild, *rchild;<br>&#125;BiNode, *BiTree;<br></code></pre></td></tr></table></figure>

<p>在n个结点的二叉表中，有n+1个空指针域。</p>
<p>三叉链表即在二叉链表的基础上增加一个指向父节点的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriNode</span>&#123;<br>    TElemType data;<br>    TriNode *lchild, *parent, *rchild;<br>&#125;TriNode, *TriTree;<br></code></pre></td></tr></table></figure>

<h2 id="5-5-遍历二叉树和线索二叉树"><a href="#5-5-遍历二叉树和线索二叉树" class="headerlink" title="5.5 遍历二叉树和线索二叉树"></a>5.5 遍历二叉树和线索二叉树</h2><h3 id="5-5-1-遍历二叉树"><a href="#5-5-1-遍历二叉树" class="headerlink" title="5.5.1 遍历二叉树"></a>5.5.1 遍历二叉树</h3><ul>
<li><p>遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。</p>
</li>
<li><p>遍历目的：得到树中所有结点的一个线性排列。</p>
</li>
<li><p>遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p>
</li>
<li><p>遍历方法：规定在先左后右的情况下，主要遍历方法有三种：先序遍历、中序遍历、后续遍历。</p>
</li>
</ul>
<ol>
<li>三种遍历方法描述如下：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131125028.png" srcset="/img/loading.gif" lazyload></p>
<ol>
<li><p>先序遍历</p>
<p>  访问步骤，若二叉树为空，则空操作；否则：</p>
<ol>
<li><p>访问根节点；</p>
</li>
<li><p>先续遍历左子树；</p>
</li>
<li><p>先续遍历右子树。</p>
</li>
</ol>
</li>
<li><p>中序遍历</p>
<p>  访问步骤，若二叉树为空，则空操作；否则：</p>
<ol>
<li><p>中序遍历左子树；</p>
</li>
<li><p>访问根结点；</p>
</li>
<li><p>中序遍历右子树。</p>
</li>
</ol>
</li>
<li><p>后续遍历</p>
<p>  访问步骤，若二叉树为空，则空操作；否则：</p>
<ol>
<li><p>后续遍历左子树；</p>
</li>
<li><p>后续遍历右子树；</p>
</li>
<li><p>访问根结点。</p>
</li>
</ol>
</li>
<li><p>根据遍历顺序确定二叉树</p>
<ul>
<li><p>若二叉树中各结点的值均不同，则二叉树结点的先序序列、中序序列、后序列都是唯一的。</p>
</li>
<li><p>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树</p>
</li>
</ul>
<p> 例题：已知二叉树的先序和中序序列，构造出相应的二叉树：<strong>可以先由先序序列确定根，由中序确定左右子树</strong>。</p>
<p> 已知中序序列和后序序列，<strong>由后序遍历可知，根结点必在后续序列尾部</strong>。</p>
</li>
<li><p>遍历的算法实现——先序遍历</p>
<p> 二叉树先续遍历算法（递归）</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>遍历算法实现——中序遍历</p>
<p> 二叉树中序遍历算法（递归）</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="5">
<li><p>遍历算法实现——后序遍历</p>
<p> 二叉树后序遍历算法（递归）</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;    <span class="hljs-comment">// 空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild);    <span class="hljs-comment">// 递归遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">// 递归遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T);<span class="hljs-comment">// 访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="6">
<li><p>遍历算法分析</p>
<ul>
<li><p>如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。</p>
</li>
<li><p>时间效率：O(n)；每个结点只访问一次</p>
</li>
<li><p>空间效率：O(n)；栈占用的最大辅助空间</p>
</li>
</ul>
</li>
<li><p>遍历二叉树的非递归算法</p>
<p> 中序遍历非递归算法：二叉树中序遍历的非递归算法的关键在于：<strong>在中序遍历过某节点的整个左子树后，如何找到该接点的根以及右子树</strong>。</p>
<p> 基本思想：</p>
<ul>
<li><p>建立一个空栈S，指针p指向根结点</p>
</li>
<li><p>申请一个结点空间q，用来存放栈顶弹出的元素。</p>
</li>
<li><p>当p非空或者栈S非空时，循环执行以下操作：</p>
<ul>
<li><p>如果p非空，则将p进栈，p指向该结点的左孩子；</p>
</li>
<li><p>如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。</p>
</li>
</ul>
</li>
</ul>
<p> 中序遍历非递归算法实现：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    BiTree p; <span class="hljs-built_in">InitStack</span>(S); p = T;<br>    <span class="hljs-keyword">while</span>(p || !<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123; <span class="hljs-comment">// 不为空</span><br>            <span class="hljs-built_in">Push</span>(S, p);<br>            p = p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">Pop</span>(S, q);<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%c&quot;</span>, q-&gt;data);<br>            p = q-&gt;rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。
</code></pre>
<ol start="8">
<li><p>二叉树的层次遍历</p>
<p> 对于一颗二叉树，从根结点开始，按<strong>从上到下、从左到右</strong>的顺序访问每一个结点。每一个结点仅仅访问一次。</p>
<p> 算法思路：</p>
<ul>
<li><p>将根结点入队；</p>
</li>
<li><p>队不为空时循环：从队列中出列一个结点*p，访问它：</p>
<ul>
<li><p>若它右左孩子结点，将左孩子结点入队；</p>
</li>
<li><p>若它有右孩子结点，将右孩子结点入队。</p>
</li>
</ul>
</li>
</ul>
<p> 二叉树层次遍历算法实现：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    BTNode data[MaxSize];   <span class="hljs-comment">// 存放队中元素</span><br>    <span class="hljs-type">int</span> front, rear;        <span class="hljs-comment">// 队头和队尾指针</span><br>&#125;SqQueue;   <span class="hljs-comment">// 顺序循环队列类型</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BTNode *b)</span></span>&#123;<br>    BTNode* p;<br>    SqQueue* qu;<br>    <span class="hljs-built_in">InitQueue</span>(sqQueue); <span class="hljs-comment">// 初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(qu, b);     <span class="hljs-comment">// 根结点指针入队</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;<br>        <span class="hljs-comment">// 队不为空，则循环</span><br>        <span class="hljs-built_in">deQueue</span>(qu, p); <span class="hljs-comment">// 出队结点p</span><br>        cout &lt;&lt; p-&gt;data;<br>        <span class="hljs-keyword">if</span>(p-&gt;lchild != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 有左孩子时将其入队</span><br>            <span class="hljs-built_in">enQueue</span>(qu, p-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(p-&gt;rchild != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-comment">// 有右孩子时将其入队</span><br>            <span class="hljs-built_in">enQueue</span>(qi, p-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="9">
<li><p>二叉树遍历算法的应用——二叉树的建立(算法5.3)</p>
<p> 按照先续遍历序列建立二叉树的二叉链表</p>
<p> 算法步骤：</p>
<ul>
<li><p>扫描字符序列，读入字符，建立二叉树的存储结构；</p>
</li>
<li><p>如果ch是一个”#”字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：在建立二叉树的过程中按照二叉树先序方式建立：</p>
<ul>
<li><p>申请一个结点空间T；</p>
</li>
<li><p>将ch赋给T-&gt;data；</p>
</li>
<li><p>递归创建T的左子树</p>
</li>
<li><p>递归创建T的右子树</p>
</li>
</ul>
</li>
</ul>
<p> 算法实现：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree&amp; T)</span></span>&#123;<br>    <span class="hljs-comment">// 按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T</span><br>    cin &gt;&gt; ch;<br>    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&quot;#&quot;</span>) T = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 递归结束，建空树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 递归创建二叉树</span><br>        T = <span class="hljs-keyword">new</span> BiTree; <span class="hljs-comment">// 生成根结点</span><br>        T-&gt;data = ch;   <span class="hljs-comment">// 根结点数据域置为ch</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<span class="hljs-comment">// 递归创建左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<span class="hljs-comment">// 递归创建右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>二叉树遍历算法的应用——复制二叉树(算法5.4)</p>
<p>算法步骤：</p>
<p>如果是空树，递归结束，否则执行以下操作：</p>
<ul>
<li><p>申请一个新结点空间， 复制根结点；</p>
</li>
<li><p>递归复制左子树；</p>
</li>
<li><p>递归复制右子树。</p>
</li>
</ul>
<p>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Copy</span><span class="hljs-params">(BiTree T, BiTree&amp; NewT)</span></span>&#123;<br>    <span class="hljs-comment">// 复制一棵和T完全相同的二叉树</span><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 如果是空树，递归结束</span><br>        newT = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        newT = <span class="hljs-keyword">new</span> BoTree;<br>        newT-&gt;data = T-&gt;data;<span class="hljs-comment">// 复制根结点</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;lchild, newT-&gt;lchild);<span class="hljs-comment">// 递归复制左子树</span><br>        <span class="hljs-built_in">Copy</span>(T-&gt;rchild, newT-&gt;rchild);<span class="hljs-comment">// 递归复制左子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>二叉树遍历算法的应用——计算二叉树的深度(算法5.5)</p>
<p>如果是空树，递归结束，深度为0，否则执行以下操作：</p>
<ul>
<li><p>递归计算左子树的深度记为m；</p>
</li>
<li><p>递归计算右子树的深度记为n;</p>
</li>
<li><p>如果m大于n，二叉树的深度为m+1，否则为n+1。</p>
</li>
</ul>
<p>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Depth</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-comment">// 计算二叉树T的深度</span><br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m = <span class="hljs-built_in">Depth</span>(T-&gt;lchild);   <span class="hljs-comment">// 递归计算左子树的深度记为m</span><br>        n = <span class="hljs-built_in">Depth</span>(T-&gt;rchild);   <span class="hljs-comment">// 递归计算右子树的深度记为n</span><br>        <span class="hljs-keyword">if</span>(m &gt; n) <span class="hljs-keyword">return</span>(m+<span class="hljs-number">1</span>);  <span class="hljs-comment">// 二叉树深度为m与n的较大者加1</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">return</span> (n+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。</p>
</li>
<li><p>二叉树遍历算法的应用——统计二叉树结点的个数(算法5.6)</p>
<p>如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上1。</p>
<p>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NodeCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NodeCount</span>(T-&gt;lchild) + <span class="hljs-built_in">NodeCount</span>(T-&gt;rchild) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>二叉树遍历算法的应用——统计二叉树叶子结点的个数(补充算法)</p>
<p>如果是空树，则结点个数为0；否则，结点个数为左子树的叶子结点个数加上右子树的叶子结点个数再加上1。</p>
<p>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeafCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-comment">// 如果是叶子节点返回1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCount</span>(T-&gt;lchild) + <span class="hljs-built_in">LeafCount</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-5-2-线索二叉树"><a href="#5-5-2-线索二叉树" class="headerlink" title="5.5.2 线索二叉树"></a>5.5.2 线索二叉树</h3><ol>
<li><p>线索二叉树的基本概念</p>
<p> 遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。</p>
<p> 但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点<strong>在任一序列中的前驱和后继信息</strong>，这种信息只有在遍历的动态过程中才能得到，为此<strong>引入线索二叉树来保存这些在动态过程中得到的（任一序列中的）有关前驱和后继的信息</strong>。</p>
<p> 由于有n个结点的二叉链表中必定存在n+1个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息。可做如下规定：若结点有左子树，则其lchild域指示其左孩子，<strong>否则令lchild域指示其前驱</strong>；若结点有右子树，则其rchild域指示其右孩子，<strong>否则令rchild域指示其后继</strong>。同时，为了避免混淆，尚需改变结点结构，增加两个标志域：LTag和RTag，其中标志位为0表示存储的为左&#x2F;右孩子，为1表示存储的为前驱&#x2F;后继。</p>
<p> 这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树(Threaded Binary Tree)，对二叉树按某种遍历次序使其变为线索二叉树的过程叫<strong>线索化</strong>。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 二叉树的二叉线索存储表示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span><br>&#123;<br>    TElemType data;<br>    BiThrNode *lchild, *rchild;<br>    <span class="hljs-type">int</span> LTag, RTag;<br>&#125;BiThrNode, *BiThrTree;<br></code></pre></td></tr></table></figure>

<p> 以下为先序线索二叉树、中序线索二叉树、后序线索二叉树示意图。</p>
</li>
</ol>
<ul>
<li><p>先序线索二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131126344.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>中序线索二叉树</p>
</li>
<li><p>后序线索二叉树<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127045.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p>为了方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其<strong>lchild域的指针指向二叉树的根结点</strong>，其<strong>rchild域的指针指向遍历遍历时访问的最后一个结点</strong>；同时，<strong>令二叉树遍历序列中第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点</strong>。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。</p>
<pre><code class="hljs">即其中LTag = 0，lchild指向根结点；RTag = 1，rchild指向遍历序列中最后一个结点。
</code></pre>
<ol start="2">
<li><p>构造线索二叉树</p>
<p> TODO</p>
</li>
</ol>
<h2 id="5-6-树和森林"><a href="#5-6-树和森林" class="headerlink" title="5.6 树和森林"></a>5.6 树和森林</h2><p>树(Tree)是n(n≥0)个结点的有限集。若n&#x3D;0，称为空树。</p>
<p>若n&gt;0，当有且仅有一个特定的称为根(root)的结点；其余结点可分为m(m≥0)个互不相交的有限集T1，T2，T3，…，Tm</p>
<p>森林是m(m≥0)个互不相交的树的集合。</p>
<h3 id="5-6-1-树的存储结构"><a href="#5-6-1-树的存储结构" class="headerlink" title="5.6.1 树的存储结构"></a>5.6.1 树的存储结构</h3><ol>
<li><p>双亲表示法</p>
<p> 这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。</p>
</li>
</ol>
<ul>
<li>树的双亲表示法<br><img src="https://cdn.jsdelivr.net/gh/chengkhen/picture_via_picco/202210131127885.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<p>双亲表示法特点：找双亲结点容易，找孩子结点难。</p>
<p>类型描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTNode</span>&#123;<br>    TElemType data;<br>    <span class="hljs-type">int</span> parent; <span class="hljs-comment">// parent结点位置</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PTree</span>&#123;<br>    PTNode nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> r, n;   <span class="hljs-comment">// 根结点的位置和节点个数</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>孩子表示法</p>
<p> 把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。</p>
<p> 特点：找孩子容易，找双亲难。</p>
<p> 类型描述：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 孩子结点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123;<br>    <span class="hljs-type">int</span> child;<br>    CTNode* next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> CTNode *ChildPtr;<br><span class="hljs-comment">// 双亲结点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTBox</span>&#123;<br>    TElemType data;<br>    ChildPtr firstChild;    <span class="hljs-comment">// 孩子链表头指针</span><br>&#125;<br><span class="hljs-comment">// 树结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTree</span>&#123;<br>    CTBox nodes[MAX_TREE_SIZE];<br>    <span class="hljs-type">int</span> n, r;<br>&#125;;<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">可以把双亲表示法和孩子表示法结合起来，即将双亲表示和孩子链表合在一起，称为带双亲的孩子链表。
</code></pre>
<ol start="3">
<li><p>孩子兄弟表示法(二叉树表示法、二叉链表表示法)</p>
<p> 又称二叉树表示法，或<strong>二叉链表表示法</strong>，即以二叉链表做树的存储结构。链表中结点的两个链域分别指向该结点的<strong>第一个孩子结点</strong>和<strong>下一个兄弟结点</strong>，分别命名为firstchild域和nextsibling域。</p>
<p>  类型描述：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>&#123;<br>    ElemType data;<br>    CSNode *firstChild, *nextsibling;<br>&#125;;<br><span class="hljs-keyword">typedef</span> CSNode *CSTree;<br></code></pre></td></tr></table></figure>

<p> 这种存储结构的优点是它和二叉树的二叉链表表示完全一样，便于将一般的树结构转换为二叉树进行处理，利用二叉树的算法来实现对树的操作。因此孩子兄弟表示法是应用较为普遍的一种树的存储表示方法。</p>
</li>
</ol>
<h3 id="5-6-2-森林与二叉树的转换"><a href="#5-6-2-森林与二叉树的转换" class="headerlink" title="5.6.2 森林与二叉树的转换"></a>5.6.2 森林与二叉树的转换</h3><ul>
<li><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操T。</p>
</li>
<li><p>由于树和二叉树都可以用二叉链表作存储结构，则<strong>以二叉链表作媒介</strong>可以导出树与二叉树之间的一个对应关系。</p>
</li>
</ul>
<p>给定一棵树，可以找到唯一的以可二叉树与之对应。这个一一对应的关系说明<strong>森林或树与二叉树可以相互转换</strong>。</p>
<ol>
<li><p>将树转换为二叉树</p>
<ol>
<li><p>加线：在兄弟之间加一连线；</p>
</li>
<li><p>抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系；</p>
</li>
<li><p>旋转：以树的根结点为轴心，将整树顺时针转45°</p>
</li>
</ol>
<p> 树变二叉树：<strong>兄弟相连留长子</strong></p>
</li>
<li><p>将二叉树转换为树</p>
<ol>
<li><p>加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子……沿分支找到的所有右孩子，都p的双亲用线连起来；</p>
</li>
<li><p>抹线：抹掉原二叉树中双亲与右孩子之间的连线；</p>
</li>
<li><p>调整：将结点按层次排列，形成树结构</p>
</li>
</ol>
<p> 二叉树变树：<strong>左孩右右连双亲，去掉原来右孩线</strong></p>
</li>
<li><p>森林转换称二叉树</p>
<ol>
<li><p>将各棵树分别转换成二叉树</p>
</li>
<li><p>将每棵树的根结点用线相连</p>
</li>
<li><p>以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构</p>
</li>
</ol>
<p> 森林变二叉树：<strong>树变二叉根相连</strong></p>
</li>
<li><p>二叉树转换成森林</p>
<ol>
<li><p>抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树；</p>
</li>
<li><p>还原：将孤立的二叉树还原成树</p>
</li>
</ol>
<p> 二叉树变森林：<strong>去掉全部右孩线，孤立二叉再还原</strong>。</p>
</li>
</ol>
<h3 id="5-6-3-树和森林的遍历"><a href="#5-6-3-树和森林的遍历" class="headerlink" title="5.6.3 树和森林的遍历"></a>5.6.3 树和森林的遍历</h3><ol>
<li><p>树的遍历（三种方式）</p>
<ol>
<li><p>先根(次序)遍历：若树不空，则先访问根结点，然后依次先根遍历各棵子树。</p>
</li>
<li><p>后根(次序)遍历：若树不空，则先依次后根遍历各棵子树，然后再访问根结点。</p>
</li>
<li><p>层次遍历：若树不空，则自上而下自左至右访问树中每个结点。</p>
</li>
</ol>
</li>
<li><p>森林的遍历</p>
<p> 将森林看作由三部分构成：1、森林中第一棵树的根结点；2.森林中第一棵树的子树森林；3.森林中其它树构成的森林。</p>
<ol>
<li><p>先序遍历</p>
<p> 若森林不为空，则</p>
<ol>
<li><p><strong>访问森林中第一棵树的根结点</strong>；</p>
</li>
<li><p>先序遍历森林中第一棵树的子树森林；</p>
</li>
<li><p>先序遍历森林中（除第一棵树之外）其余树构成的森林。</p>
</li>
</ol>
</li>
<li><p>中序遍历</p>
<p> 若森林不为空，则</p>
<ol>
<li><p>中序遍历森林中第一棵树的子树森林；</p>
</li>
<li><p>访问森林中第一棵树的根结点；</p>
</li>
<li><p>中序遍历森林中（除第一棵树之外）其余树构成的森林。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="5-7-哈夫曼树及其应用"><a href="#5-7-哈夫曼树及其应用" class="headerlink" title="5.7 哈夫曼树及其应用"></a>5.7 哈夫曼树及其应用</h2><h3 id="5-7-1-哈夫曼树的基本概念"><a href="#5-7-1-哈夫曼树的基本概念" class="headerlink" title="5.7.1 哈夫曼树的基本概念"></a>5.7.1 哈夫曼树的基本概念</h3><p>哈夫曼(Huffman)树又称<strong>最优树，是一类带权路径长度最短的树</strong>，哈夫曼树的定义，涉及路径、路径长度、权等概念。</p>
<ul>
<li><p><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。</p>
</li>
<li><p><strong>路径长度</strong>：路径上的<strong>分支数目</strong>称作路径长度。</p>
</li>
<li><p><strong>树的路径长度</strong>：从树根到每一结点的路径长度之和。</p>
<p>  在结点数目相同的二叉树中，<strong>完全二叉树的路径长度最短的二叉树</strong>。但路径长度最短的二叉树不一定就是完全二叉树。</p>
</li>
<li><p><strong>权</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。赋予某个实体的一个量，是对实体的某个或某些属性的数值化描述。在数据结构中，实体有结点（元素）和边（关系）两大类，所以对应有<strong>结点权和边权</strong>。结点权或边权具体代表什么意义，由具体情况决定。如果在一棵树中的结点上带有权值，则对应的就有带权树等概念。</p>
</li>
<li><p><strong>结点的带权路径长度</strong>：从该结点到树根之间的<strong>路径长度与结点上权的乘积</strong>。</p>
</li>
<li><p><strong>树的带权路径长度</strong>：树中所有<strong>叶子结点</strong>的带权路径长度之和，通常记作WPL。</p>
</li>
<li><p><strong>哈夫曼树</strong>：假设有m个权值{w1, W2,…,Wm}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为W；则其中<strong>带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树</strong>。</p>
</li>
</ul>
<p>带权路径最短的树，比较的前提是所有树的度相同，即树的各结点度的最大值，即结点拥有的子树数。</p>
<p><strong>满二叉树不一定是曼哈夫树</strong>，哈夫曼树中权越大的叶子离根越近，具有相同带权结点的哈夫曼树不唯一。</p>
<h3 id="5-7-2-哈夫曼树的构造算法"><a href="#5-7-2-哈夫曼树的构造算法" class="headerlink" title="5.7.2 哈夫曼树的构造算法"></a>5.7.2 哈夫曼树的构造算法</h3><ol>
<li><p>哈夫曼树的构造过程</p>
<p> 在构造哈夫曼树时，<strong>首先选择权小的</strong>，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的<strong>贪心法</strong>。</p>
<ol>
<li><p>根据给定的n个权值{W1, W2, …, Wn}，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。<strong>构造森林全是根</strong>。</p>
</li>
<li><p>在森林F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。<strong>选用两小造新树</strong>。</p>
</li>
<li><p>在森林F中删除这两棵树，同时将新得到的二叉树加入F中。<strong>删除两小添新人</strong>。</p>
</li>
<li><p>重复（2）和（3），直到F只含一棵树为止。这棵树便是哈夫曼树。<strong>重复2、3剩单根</strong>。</p>
</li>
</ol>
<p> 特点：</p>
<p> 包含n棵树的森林要经过n-1次合并才能形成哈去曼树，共产生n-1新结点，且这n-1个新结点都是具有两个孩子的分支结点。。</p>
<ul>
<li><p><strong>包含n个叶子结点的哈夫曼树中共有2n-1个结点</strong>。</p>
</li>
<li><p><strong>哈夫曼树的结点的度数为0或2，没有度为1的结点</strong>。</p>
</li>
</ul>
</li>
<li><p>哈夫曼算法的实现</p>
<p> 哈夫曼树是一种二叉树，由于哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n-1个结点，可以存储在一个大小为2n-1的一维数组中。树中每个结点还要包含其<strong>双亲信息</strong>和<strong>孩子结点的信息</strong>。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> parent, lch, rch;<br>&#125;HTNode, *HuffmanTree;<br></code></pre></td></tr></table></figure>

<p> 哈夫曼树中共有2n-1个结点不使用0下标，数组大小为2n。将叶子结点集中存储在前面部分1~n个位置，而后面的n-1个位置存储其余非叶子结点。</p>
<blockquote>
<p>构造哈夫曼树——算法5.10</p>
</blockquote>
<p> 构造哈夫曼树算法的实现可以分成两大部分。</p>
<ol>
<li><p>初始化：首先动态申请2n个单元；然后循环2n-1次，从1号单元开始，依次将1至2n-1所有单元中的双亲、左孩子、右孩子的下标都初始化为0；最后再循环n次，输入前n个单元中叶子结点的权值。</p>
</li>
<li><p>创建树：循环n-1次，通过n-1次的选择、删除与合并来创建哈夫曼树。</p>
<ul>
<li><p>选择是从当前森林中选择双亲为0且权值最小的两个树根结点s1和s2；</p>
</li>
<li><p>删除是指将结点s1和s2的双亲改为非0；</p>
</li>
<li><p>合并就是将s1和s2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中，同时记录这个新结点左孩子的下标为s1，右孩子的下标为s2。</p>
</li>
</ul>
</li>
</ol>
<p> 算法实现：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanTree</span><span class="hljs-params">(HuffmanTree HT, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;<br>    HT = <span class="hljs-keyword">new</span> HTNode[m+<span class="hljs-number">1</span>];   <span class="hljs-comment">// 0号单元未用，</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-comment">// 将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0</span><br>        HT[i].lch = <span class="hljs-number">0</span>;<br>        HT[i].rch = <span class="hljs-number">0</span>;<br>        HT[i].parent = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-comment">// 输入前n个元素的weight值</span><br>        cin &gt;&gt; HT[i].weight;<br>    &#125;<br>    <span class="hljs-comment">/*－初始化工作结束，下面开始创建哈夫曼树－*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n+<span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        <span class="hljs-built_in">Select</span>(HT, i<span class="hljs-number">-1</span>, s1, s2);<br>        <span class="hljs-comment">// 在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点，并返回它们在HT中的序号s1和s2</span><br>        HT[s1].parent = i;<br>        HT[s2].parent = i;<br>        <span class="hljs-comment">// 得到新结点i，从森林中删除s1和s2，将s1和s2的双亲域由0改为i</span><br>        HT[i].lch = s1;<br>        HT[i].rch = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-7-3-哈夫曼编码"><a href="#5-7-3-哈夫曼编码" class="headerlink" title="5.7.3 哈夫曼编码"></a>5.7.3 哈夫曼编码</h3><p>在进行数据压缩时，为了使压缩后的数据文件尽可能短，可采用不定长编码。其基本思想是：为出现次数较多的字符编以较短的编码。为确保对数据文件进行有效的压缩和对压缩文件进行正确的解码，可以利用哈夫曼树来设计二进制编码。</p>
<p>关键：要设计长度不等的编码，则必须使<strong>任一字符的编码都不是另一个字符的编码的前缀</strong>。上述编码方式又称为前缀编码。</p>
<p>前缀编码：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀（最左子串），则称编码是前缀编码。</p>
<p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p>
<p>哈夫曼编码的性质：</p>
<ol>
<li><p><strong>哈夫曼编码是前缀编码</strong>。</p>
</li>
<li><p><strong>哈夫曼编码是最优前缀编码</strong>。</p>
</li>
</ol>
<p>哈夫曼编码实现方法：</p>
<ol>
<li><p>统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）。</p>
</li>
<li><p>利用哈夫曼树的特点：权越大的叶子离根越近；<strong>将每个字符的概率值作为权值，构造哈夫曼树</strong>。则概率越大的结点，路径越短。</p>
</li>
<li><p>在哈夫曼树的每个分支上标上0或1：</p>
<ul>
<li><p>结点的左分支标0，右分支标1</p>
</li>
<li><p>把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。</p>
</li>
</ul>
</li>
</ol>
<p>两个问题：</p>
<ol>
<li><p>为什么哈夫曼编码能够保证是前缀编码？。</p>
<p> 因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀</p>
</li>
<li><p>为什么哈夫曼编码能够保证字符编码总长最短？</p>
<p> 因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</p>
</li>
</ol>
<blockquote>
<p>哈夫曼编码的算法实现</p>
</blockquote>
<p>在构造哈夫曼树之后，求哈夫曼编码的主要思想是：<strong>依次以叶子为出发点，向上回溯至根结点为止</strong>。回溯时走左分支则生成代码0，走右分支则生成代码1。</p>
<p>算法步骤：</p>
<ol>
<li><p>分配存储n个字符编码的编码表空间HC，长度为n+1；分配临时存储每个字符编码的动态数组空间cd，cd[n-1]置为’\0’。</p>
</li>
<li><p>逐个求解n个字符的编码，循环n次，执行以下操作：</p>
<ul>
<li><p>设置变量start用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置n-1;</p>
</li>
<li><p>设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f用于记录i的双亲结点的下标；</p>
</li>
<li><p>从叶子结点向上回溯至根结点，求得字符i的编码，当f没有到达根结点时，循环执行以下操作：</p>
<ul>
<li><p>回溯一次start向前指一个位置，即–start;</p>
</li>
<li><p>若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在cd[start]中；</p>
</li>
<li><p>继续向上回溯，改变c和f的值。</p>
</li>
</ul>
</li>
<li><p>根据数组cd的字符串长度为第i个字符编码分配空间HC[i]，然后将数组cd中的编码复制到HC[i]中。</p>
</li>
</ul>
</li>
<li><p>释放临时空间cd。</p>
</li>
</ol>
<p>算法描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHuffmanCode</span><span class="hljs-params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span><br>    HC = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>*[n+<span class="hljs-number">1</span>];        <span class="hljs-comment">// 分配存储n个字符编码的编码表空间</span><br>    cd = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];           <span class="hljs-comment">// 分配临时存放每个字符编码的动态数组空间</span><br>    cd[n<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;             <span class="hljs-comment">// 编码结束符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">// 逐个字符求哈夫曼编码</span><br>    &#123;<br>        start = n<span class="hljs-number">-1</span>;            <span class="hljs-comment">// start开始时指向最后，即编码结束符位置</span><br>        c = i;<br>        f = HT[i].parent;       <span class="hljs-comment">// f指向结点c的双亲结点</span><br>        <span class="hljs-keyword">while</span>(f != <span class="hljs-number">0</span>)           <span class="hljs-comment">// 从叶子节点开始向上回溯，知道根结点</span><br>        &#123;<br>            --start;            <span class="hljs-comment">// 回溯一次start位置向前指一个位置</span><br>            <span class="hljs-keyword">if</span>(HT[f].lch == c)  <span class="hljs-comment">// 结点c是f的左孩子，则生成代码0</span><br>            &#123;<br>                cd[start] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>                <span class="hljs-comment">// 结点c是f的右孩子，则生成代码1</span><br>            &#123;<br>                cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            &#125;<br>            c = f;<br>            f = HT[f].parent;   <span class="hljs-comment">// 继续向上回溯</span><br>        &#125;                       <span class="hljs-comment">// 求出第i个字符的编码</span><br>        HC[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n-start];  <span class="hljs-comment">// 为第i个字符编码分配空间</span><br>        <span class="hljs-built_in">strcpy</span>(HC[i], &amp;cd[start]);<br>    &#125;<br>    <span class="hljs-keyword">delete</span> cd;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>文件的编码和译码</p>
</blockquote>
<ol>
<li><p>编码</p>
<p> 有了字符集的哈夫曼编码表之后，对数据文件的编码过程是：依次读入文件中的字符c，在哈夫曼编码表HC中找到此字符，将字符c转换为编码表中存放的编码串。</p>
</li>
<li><p>译码</p>
<p> 对编码后的文件进行译码的过程必须借助于哈夫曼树。具体过程是：依次读入文件的二进制码，从哈夫曼树的根结点（即HT[m])出发，若当前读入0，则走向左孩子，否则走向右孩子。一旦到达某一叶子HT[i]时便译出相应的字符编码HC[i]。然后重新从根出发继续译码，直至文件结束。</p>
</li>
</ol>
<h2 id="5-8-案例分析与实现"><a href="#5-8-案例分析与实现" class="headerlink" title="5.8 案例分析与实现"></a>5.8 案例分析与实现</h2><h2 id="5-9-习题"><a href="#5-9-习题" class="headerlink" title="5.9 习题"></a>5.9 习题</h2><ol>
<li><p>利用二叉链表存储树， 则根结点的右指针()。</p>
<p> A. 指向最左孩子 B. 指向最右孩子 C. 为空 D. 非空</p>
<p> 解答：C，利用二叉链表存储树时，右指针指向兄弟结点，因为根节点没有兄弟结点，故根结点的右指针为空</p>
</li>
<li><p>一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足()。</p>
<p> A. 所有的结点均无左孩子 B. 所有的结点均无右孩子 C. 只有一个叶子结点 D. 是任意一棵二叉树</p>
<p> 解答：因为先序遍历结果是“中左右”， 序遍历结果是“左右中”，当没有左子树时，就是“中右”和“右中”；当没有右子树时，就是“中左”和“左中”。则所有的结点均无左孩子或所有的结点均无右孩子均可，所以A、B不能选，又所有的结点均无左孩子与所有的结点均无右孩子时，均只有一个叶子结点，故选C。</p>
</li>
<li><p>在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是( )</p>
<p> A．41 B．82 C．113 D．122</p>
<p> 解答：考查树结点数的特性。设树中度为i(i&#x3D;0，1，2，3，4)的结点数分别为Ni，树中结点总数为N，则树中各结点的度之和等于N-1，即N&#x3D;1+N1+2N2+3N3+4N4&#x3D;N0+N1+N2+N3+N4。根据题设中的数据，即可得到N0&#x3D;82，即树T的叶结点的个数是82。</p>
</li>
</ol>
<p>算法设计题：</p>
<ol>
<li><p>统计二叉树的叶结点个数。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe1.cpp">算法设计题1</a></p>
</li>
<li><p>判别两棵树是否相等。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe2.cpp">算法设计题2</a></p>
</li>
<li><p>交换二叉树每个结点的左孩子和右孩子。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe3.cpp">算法设计题3</a></p>
</li>
<li><p>设计二叉树的双序遍历算法（双序遍历是指对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树）。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe4.cpp">算法设计题4</a></p>
</li>
<li><p>计算二叉树最大的宽度（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe5.cpp">算法设计题5</a></p>
</li>
<li><p>用按层次顺序遍历二叉树的方法，统计树中度为1的结点数目。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe6.cpp">算法设计题6</a></p>
</li>
<li><p>求任意二叉树中第一条最长的路径长度，并输出此路径上各结点的值。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe7.cpp">算法设计题7</a></p>
</li>
<li><p>输出二叉树中从每个叶子结点到根结点的路径。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/Chapter5Exe/AlgoDesignExe8.cpp">算法设计题8</a></p>
</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%8E%8B%E5%8D%93/" class="category-chain-item">数据结构王卓</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>树和二叉树——王卓</div>
      <div>http://example.com/2022/10/13/树和二叉树——王卓/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ChengKhen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月13日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/10/13/%E5%9B%BE%E2%80%94%E2%80%94%E7%8E%8B%E5%8D%93/" title="图——王卓">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">图——王卓</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/13/%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" title="串、数组和广义表">
                        <span class="hidden-mobile">串、数组和广义表</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
